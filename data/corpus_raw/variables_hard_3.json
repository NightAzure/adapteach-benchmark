{
  "title": "Closures and late binding: loop variable capture and dependable ways to freeze values",
  "content": "Python uses lexical scoping: inner functions can reference names from enclosing scopes. However, closure variables are often **late-bound**, meaning the name is looked up when the inner function runs, not when it is created.\n\n---\n## 1) The classic pitfall: closures created in a loop\n\n```python\nfuncs = []\nfor i in range(5):\n    funcs.append(lambda: i)\n\nprint([f() for f in funcs])  # often [4, 4, 4, 4, 4]\n```\n\nAll lambdas refer to the same name `i`, which ends at 4 after the loop.\n\n---\n## 2) Fix pattern A: default argument capture (simple and popular)\nDefault arguments are evaluated when the function is defined.\n\n```python\nfuncs = []\nfor i in range(5):\n    funcs.append(lambda i=i: i)\n\nprint([f() for f in funcs])  # [0, 1, 2, 3, 4]\n```\n\n---\n## 3) Fix pattern B: helper factory function\n\n```python\ndef make_func(i):\n    def f():\n        return i\n    return f\n\nfuncs = [make_func(i) for i in range(5)]\nprint([f() for f in funcs])  # [0, 1, 2, 3, 4]\n```\n\n---\n## 4) Fix pattern C: functools.partial\n\n```python\nfrom functools import partial\n\ndef identity(x):\n    return x\n\nfuncs = [partial(identity, i) for i in range(5)]\nprint([f() for f in funcs])  # [0, 1, 2, 3, 4]\n```\n\n---\n## 5) A chunking-friendly “real use” example\nMake a set of functions that add different offsets.\n\n```python\nadders = []\nfor offset in (0, 10, 100):\n    adders.append(lambda x, offset=offset: x + offset)\n\nprint([f(5) for f in adders])  # [5, 15, 105]\n```\n\n---\n## 6) Extra: closures with multiple captured names\n\n```python\ndef factory(mult):\n    funcs = []\n    for i in range(3):\n        funcs.append(lambda x, i=i, mult=mult: (x + i) * mult)\n    return funcs\n\nfs = factory(10)\nprint([f(1) for f in fs])  # [10, 20, 30]\n```\n\n---\n## 7) Practical takeaways\n- If you build lambdas in loops, **assume late binding** unless you capture values explicitly.\n- Default arguments are the shortest “freeze this value now” technique.\n",
  "type": "tutorial",
  "concept_tags": ["variables", "scope", "closures", "late-binding", "lambdas", "loops"],
  "difficulty": "hard",
  "metadata": {
    "language": "en",
    "domain": "programming/python",
    "retrieved_at": "2026-02-09",
    "intended_use": "educational corpus",
    "chunking_hints": ["loop+lambda pitfall", "three fix patterns", "many short runnable blocks", "dense multi-capture example"]
  },
  "provenance": {
    "url": "https://stackoverflow.com/questions/2295290/what-do-lambda-function-closures-capture",
    "license": "CC BY-SA (Stack Overflow; version depends on post date)",
    "attribution": "Stack Overflow contributors (see post timeline)",
    "retrieved_at": "2026-02-09"
  },
  "ai_generated": false
}
