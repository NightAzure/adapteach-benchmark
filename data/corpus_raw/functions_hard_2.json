{
  "title": "Higher-order function tools (hard): functools.wraps, lru_cache/cache, and partial",
  "content": "Hard-level function work often means building function wrappers (decorators), caching results, or creating specialized callables. The `functools` module supports these patterns.\n\n---\n## 1) functools.wraps: preserve metadata when wrapping\nWithout care, wrappers hide the original functionâ€™s name/docstring.\n\n```python\ndef deco(func):\n    def wrapper(*args, **kwargs):\n        return func(*args, **kwargs)\n    return wrapper\n\n@deco\ndef f():\n    \"\"\"example doc\"\"\"\n    return 1\n\nprint(f.__name__)  # wrapper\nprint(f.__doc__)   # None\n```\n\nUsing `functools.wraps` fixes that:\n\n```python\nimport functools\n\ndef deco(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        return func(*args, **kwargs)\n    return wrapper\n\n@deco\ndef f():\n    \"\"\"example doc\"\"\"\n    return 1\n\nprint(f.__name__)  # f\nprint(f.__doc__)   # example doc\n```\n\n---\n## 2) lru_cache/cache: memoize function results\nCaching is useful when the function is pure-ish and called repeatedly with the same inputs.\n\n```python\nimport functools\n\n@functools.lru_cache(maxsize=128)\ndef fib(n):\n    if n < 2:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\nprint(fib(30))\nprint(fib.cache_info())\n```\n\nUnbounded caching is available via `cache` (or `lru_cache(maxsize=None)`):\n\n```python\nimport functools\n\n@functools.cache\ndef f(n):\n    return n * n\n\nprint(f(10))\n```\n\n---\n## 3) partial: create specialized callables\n`partial` pre-fills arguments.\n\n```python\nimport functools\n\ndef power(base, exp):\n    return base ** exp\n\nsquare = functools.partial(power, exp=2)\ncube = functools.partial(power, exp=3)\n\nprint(square(10))\nprint(cube(10))\n```\n\n---\n## 4) A larger example: decorator + wraps + caching together\n\n```python\nimport functools\n\ndef log_calls(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        print(\"call\", func.__name__, args, kwargs)\n        return func(*args, **kwargs)\n    return wrapper\n\n@log_calls\n@functools.lru_cache(maxsize=64)\ndef compute(x, y):\n    return (x * x) + (y * y)\n\nprint(compute(3, 4))\nprint(compute(3, 4))  # cached\n```\n",
  "type": "reference",
  "concept_tags": ["functions", "functools", "wraps", "decorators", "lru_cache", "cache", "partial", "memoization"],
  "difficulty": "hard",
  "metadata": {
    "language": "en",
    "domain": "programming/python",
    "retrieved_at": "2026-02-09",
    "intended_use": "educational corpus",
    "chunking_hints": ["wraps vs metadata loss", "lru_cache + cache_info", "partial examples", "stacked decorators with cache"]
  },
  "provenance": {
    "url": "https://docs.python.org/3/library/functools.html",
    "license": "PSF Documentation License (Python docs)",
    "attribution": "Python Software Foundation / Python Documentation Contributors",
    "retrieved_at": "2026-02-09"
  },
  "ai_generated": false
}
