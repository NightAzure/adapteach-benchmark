{
  "title": "Chapter 11  Dictionaries",
  "content": "Buy this book at Amazon.com Chapter 11  Dictionaries This chapter presents another built-in type called a dictionary.\nDictionaries are one of Python’s best features; they are the\nbuilding blocks of many efficient and elegant algorithms. 11.1  A dictionary is a mapping A dictionary is like a list, but more general. In a list,\nthe indices have to be integers; in a dictionary they can\nbe (almost) any type. A dictionary contains a collection of indices, which are called keys , and a collection of values. Each key is associated with a\nsingle value. The association of a key and a value is called a key-value pair or sometimes an item . In mathematical language, a dictionary represents a mapping from keys to values, so you can also say that each key\n“maps to” a value.\nAs an example, we’ll build a dictionary that maps from English\nto Spanish words, so the keys and the values are all strings. The function dict creates a new dictionary with no items.\nBecause dict is the name of a built-in function, you\nshould avoid using it as a variable name. >>> eng2sp = dict()\n>>> eng2sp\n{} The squiggly-brackets, {} , represent an empty dictionary.\nTo add items to the dictionary, you can use square brackets: >>> eng2sp['one'] = 'uno' This line creates an item that maps from the key 'one' to the value 'uno' . If we print the\ndictionary again, we see a key-value pair with a colon\nbetween the key and value: >>> eng2sp\n{'one': 'uno'} This output format is also an input format. For example,\nyou can create a new dictionary with three items: >>> eng2sp = {'one': 'uno', 'two': 'dos', 'three': 'tres'} But if you print eng2sp , you might be surprised: >>> eng2sp\n{'one': 'uno', 'three': 'tres', 'two': 'dos'} The order of the key-value pairs might not be the same. If\nyou type the same example on your computer, you might get a\ndifferent result. In general, the order of items in\na dictionary is unpredictable. But that’s not a problem because\nthe elements of a dictionary are never indexed with integer indices.\nInstead, you use the keys to look up the corresponding values: >>> eng2sp['two']\n'dos' The key 'two' always maps to the value 'dos' so the order\nof the items doesn’t matter. If the key isn’t in the dictionary, you get an exception: >>> eng2sp['four']\nKeyError: 'four' The len function works on dictionaries; it returns the\nnumber of key-value pairs: >>> len(eng2sp)\n3 The in operator works on dictionaries, too; it tells you whether\nsomething appears as a key in the dictionary (appearing\nas a value is not good enough). >>> 'one' in eng2sp\nTrue\n>>> 'uno' in eng2sp\nFalse To see whether something appears as a value in a dictionary, you\ncan use the method values , which returns a collection of\nvalues, and then use the in operator: >>> vals = eng2sp.values()\n>>> 'uno' in vals\nTrue The in operator uses different algorithms for lists and\ndictionaries. For lists, it searches the elements of the list in\norder, as in Section 8.6 . As the list gets longer, the search\ntime gets longer in direct proportion. Python dictionaries use a data structure\ncalled a hashtable that has a remarkable property: the in operator takes about the same amount of time no matter how\nmany items are in the dictionary. I explain how that’s possible\nin Section B.4 , but the explanation might not make\nsense until you’ve read a few more chapters. 11.2  Dictionary as a collection of counters Suppose you are given a string and you want to count how many\ntimes each letter appears. There are several ways you could do it: You could create 26 variables, one for each letter of the\nalphabet. Then you could traverse the string and, for each\ncharacter, increment the corresponding counter, probably using\na chained conditional. You could create a list with 26 elements. Then you could\nconvert each character to a number (using the built-in function ord ), use the number as an index into the list, and increment\nthe appropriate counter. You could create a dictionary with characters as keys\nand counters as the corresponding values. The first time you\nsee a character, you would add an item to the dictionary. After\nthat you would increment the value of an existing item. Each of these options performs the same computation, but each\nof them implements that computation in a different way. An implementation is a way of performing a computation;\nsome implementations are better than others. For example,\nan advantage of the dictionary implementation is that we don’t\nhave to know ahead of time which letters appear in the string\nand we only have to make room for the letters that do appear. Here is what the code might look like: def histogram(s):\n    d = dict()\n    for c in s:\n        if c not in d:\n            d[c] = 1\n        else:\n            d[c] += 1\n    return d The name of the function is histogram , which is a statistical\nterm for a collection of counters (or frequencies). The first line of the\nfunction creates an empty dictionary. The for loop traverses\nthe string. Each time through the loop, if the character c is\nnot in the dictionary, we create a new item with key c and the\ninitial value 1 (since we have seen this letter once). If c is\nalready in the dictionary we increment d[c] . Here’s how it works: >>> h = histogram('brontosaurus')\n>>> h\n{'a': 1, 'b': 1, 'o': 2, 'n': 1, 's': 2, 'r': 2, 'u': 2, 't': 1} The histogram indicates that the letters 'a' and 'b' appear once; 'o' appears twice, and so on. Dictionaries have a method called get that takes a key\nand a default value. If the key appears in the dictionary, get returns the corresponding value; otherwise it returns\nthe default value. For example: >>> h = histogram('a')\n>>> h\n{'a': 1}\n>>> h.get('a', 0)\n1\n>>> h.get('c', 0)\n0 As an exercise, use get to write histogram more concisely. You\nshould be able to eliminate the if statement. 11.3  Looping and dictionaries If you use a dictionary in a for statement, it traverses\nthe keys of the dictionary. For example, print_hist prints each key and the corresponding value: def print_hist(h):\n    for c in h:\n        print(c, h[c]) Here’s what the output looks like: >>> h = histogram('parrot')\n>>> print_hist(h)\na 1\np 1\nr 2\nt 1\no 1 Again, the keys are in no particular order. To traverse the keys\nin sorted order, you can use the built-in function sorted : >>> for key in sorted(h):\n...     print(key, h[key])\na 1\no 1\np 1\nr 2\nt 1 11.4  Reverse lookup Given a dictionary d and a key k , it is easy to\nfind the corresponding value v = d[k] . This operation\nis called a lookup . But what if you have v and you want to find k ?\nYou have two problems: first, there might be more than one\nkey that maps to the value v . Depending on the application,\nyou might be able to pick one, or you might have to make\na list that contains all of them. Second, there is no\nsimple syntax to do a reverse lookup ; you have to search. Here is a function that takes a value and returns the first\nkey that maps to that value: def reverse_lookup(d, v):\n    for k in d:\n        if d[k] == v:\n            return k\n    raise LookupError() This function is yet another example of the search pattern, but it\nuses a feature we haven’t seen before, raise . The raise statement causes an exception; in this case it causes a LookupError , which is a built-in exception used to indicate\nthat a lookup operation failed. If we get to the end of the loop, that means v doesn’t appear in the dictionary as a value, so we raise an\nexception. Here is an example of a successful reverse lookup: >>> h = histogram('parrot')\n>>> key = reverse_lookup(h, 2)\n>>> key\n'r' And an unsuccessful one: >>> key = reverse_lookup(h, 3)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"<stdin>\", line 5, in reverse_lookup\nLookupError The effect when you raise an exception is the same as when\nPython raises one: it prints a traceback and an error message. When you raise an exception, you can provide a detailed error message as an optional argument. For example: >>> raise LookupError('value does not appear in the dictionary')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in ?\nLookupError: value does not appear in the dictionary A reverse lookup is much slower than a forward lookup; if you\nhave to do it often, or if the dictionary gets big, the performance\nof your program will suffer. 11.5  Dictionaries and lists Lists can appear as values in a dictionary. For example, if you\nare given a dictionary that maps from letters to frequencies, you\nmight want to invert it; that is, create a dictionary that maps\nfrom frequencies to letters. Since there might be several letters\nwith the same frequency, each value in the inverted dictionary\nshould be a list of letters. Here is a function that inverts a dictionary: def invert_dict(d):\n    inverse = dict()\n    for key in d:\n        val = d[key]\n        if val not in inverse:\n            inverse[val] = [key]\n        else:\n            inverse[val].append(key)\n    return inverse Each time through the loop, key gets a key from d and val gets the corresponding value. If val is not in inverse , that means we haven’t seen it before, so we create a new\nitem and initialize it with a singleton (a list that contains a\nsingle element). Otherwise we have seen this value before, so we\nappend the corresponding key to the list. Here is an example: >>> hist = histogram('parrot')\n>>> hist\n{'a': 1, 'p': 1, 'r': 2, 't': 1, 'o': 1}\n>>> inverse = invert_dict(hist)\n>>> inverse\n{1: ['a', 'p', 't', 'o'], 2: ['r']} Figure 11.1: State diagram. Figure 11.1 is a state diagram showing hist and inverse .\nA dictionary is represented as a box with the type dict above it\nand the key-value pairs inside. If the values are integers, floats or\nstrings, I draw them inside the box, but I usually draw lists\noutside the box, just to keep the diagram simple. Lists can be values in a dictionary, as this example shows, but they\ncannot be keys. Here’s what happens if you try: >>> t = [1, 2, 3]\n>>> d = dict()\n>>> d[t] = 'oops'\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in ?\nTypeError: list objects are unhashable I mentioned earlier that a dictionary is implemented using\na hashtable and that means that the keys have to be hashable . A hash is a function that takes a value (of any kind)\nand returns an integer. Dictionaries use these integers,\ncalled hash values, to store and look up key-value pairs. This system works fine if the keys are immutable. But if the\nkeys are mutable, like lists, bad things happen. For example,\nwhen you create a key-value pair, Python hashes the key and \nstores it in the corresponding location. If you modify the\nkey and then hash it again, it would go to a different location.\nIn that case you might have two entries for the same key,\nor you might not be able to find a key. Either way, the\ndictionary wouldn’t work correctly. That’s why keys have to be hashable, and why mutable types like\nlists aren’t. The simplest way to get around this limitation is to\nuse tuples, which we will see in the next chapter. Since dictionaries are mutable, they can’t be used as keys,\nbut they can be used as values. 11.6  Memos If you played with the fibonacci function from\nSection 6.7 , you might have noticed that the bigger\nthe argument you provide, the longer the function takes to run.\nFurthermore, the run time increases quickly. To understand why, consider Figure 11.2 , which shows\nthe call graph for fibonacci with n=4 : Figure 11.2: Call graph. A call graph shows a set of function frames, with lines connecting each\nframe to the frames of the functions it calls. At the top of the\ngraph, fibonacci with n=4 calls fibonacci with n=3 and n=2 . In turn, fibonacci with n=3 calls fibonacci with n=2 and n=1 . And so on. Count how many times fibonacci(0) and fibonacci(1) are\ncalled. This is an inefficient solution to the problem, and it gets\nworse as the argument gets bigger. One solution is to keep track of values that have already been\ncomputed by storing them in a dictionary. A previously computed value\nthat is stored for later use is called a memo . Here is a\n“memoized” version of fibonacci : known = {0:0, 1:1}\n\ndef fibonacci(n):\n    if n in known:\n        return known[n]\n\n    res = fibonacci(n-1) + fibonacci(n-2)\n    known[n] = res\n    return res known is a dictionary that keeps track of the Fibonacci\nnumbers we already know. It starts with\ntwo items: 0 maps to 0 and 1 maps to 1. Whenever fibonacci is called, it checks known .\nIf the result is already there, it can return\nimmediately. Otherwise it has to \ncompute the new value, add it to the dictionary, and return it. If you run this version of fibonacci and compare it with\nthe original, you will find that it is much faster. 11.7  Global variables In the previous example, known is created outside the function,\nso it belongs to the special frame called __main__ .\nVariables in __main__ are sometimes called global because they can be accessed from any function. Unlike local\nvariables, which disappear when their function ends, global variables\npersist from one function call to the next. It is common to use global variables for flags ; that is, \nboolean variables that indicate (“flag”) whether a condition\nis true. For example, some programs use\na flag named verbose to control the level of detail in the\noutput: verbose = True\n\ndef example1():\n    if verbose:\n        print('Running example1') If you try to reassign a global variable, you might be surprised.\nThe following example is supposed to keep track of whether the\nfunction has been called: been_called = False\n\ndef example2():\n    been_called = True         # WRONG But if you run it you will see that the value of been_called doesn’t change. The problem is that example2 creates a new local\nvariable named been_called . The local variable goes away when\nthe function ends, and has no effect on the global variable. To reassign a global variable inside a function you have to declare the global variable before you use it: been_called = False\n\ndef example2():\n    global been_called \n    been_called = True The global statement tells the interpreter\nsomething like, “In this function, when I say been_called , I\nmean the global variable; don’t create a local one.” Here’s an example that tries to update a global variable: count = 0\n\ndef example3():\n    count = count + 1          # WRONG If you run it you get: UnboundLocalError: local variable 'count' referenced before assignment Python assumes that count is local, and under that assumption\nyou are reading it before writing it. The solution, again,\nis to declare count global. def example3():\n    global count\n    count += 1 If a global variable refers to a mutable value, you can modify\nthe value without declaring the variable: known = {0:0, 1:1}\n\ndef example4():\n    known[2] = 1 So you can add, remove and replace elements of a global list or\ndictionary, but if you want to reassign the variable, you\nhave to declare it: def example5():\n    global known\n    known = dict() Global variables can be useful, but if you have a lot of them,\nand you modify them frequently, they can make programs\nhard to debug. 11.8  Debugging As you work with bigger datasets it can become unwieldy to\ndebug by printing and checking the output by hand. Here are some\nsuggestions for debugging large datasets: Scale down the input: If possible, reduce the size of the\ndataset. For example if the program reads a text file, start with\njust the first 10 lines, or with the smallest example you can find.\nYou can either edit the files themselves, or (better) modify the\nprogram so it reads only the first n lines. If there is an error, you can reduce n to the smallest\nvalue that manifests the error, and then increase it gradually\nas you find and correct errors. Check summaries and types: Instead of printing and checking the\nentire dataset, consider printing summaries of the data: for example,\nthe number of items in a dictionary or the total of a list of numbers. A common cause of runtime errors is a value that is not the right\ntype. For debugging this kind of error, it is often enough to print\nthe type of a value. Write self-checks: Sometimes you can write code to check\nfor errors automatically. For example, if you are computing the\naverage of a list of numbers, you could check that the result is\nnot greater than the largest element in the list or less than\nthe smallest. This is called a “sanity check” because it detects\nresults that are “insane”. Another kind of check compares the results of two different\ncomputations to see if they are consistent. This is called a\n“consistency check”. Format the output: Formatting debugging output\ncan make it easier to spot an error. We saw an example in\nSection 6.9 . Another tool you might find useful is the pprint module, which provides\na pprint function that displays built-in types in\na more human-readable format ( pprint stands for\n“pretty print”). Again, time you spend building scaffolding can reduce\nthe time you spend debugging. 11.9  Glossary mapping: A relationship in which each element of one set\ncorresponds to an element of another set. dictionary: A mapping from keys to their\ncorresponding values. key-value pair: The representation of the mapping from\na key to a value. item: In a dictionary, another name for a key-value\npair. key: An object that appears in a dictionary as the\nfirst part of a key-value pair. value: An object that appears in a dictionary as the\nsecond part of a key-value pair. This is more specific than\nour previous use of the word “value”. implementation: A way of performing a computation. hashtable: The algorithm used to implement Python\ndictionaries. hash function: A function used by a hashtable to compute the\nlocation for a key. hashable: A type that has a hash function. Immutable\ntypes like integers,\nfloats and strings are hashable; mutable types like lists and\ndictionaries are not. lookup: A dictionary operation that takes a key and finds\nthe corresponding value. reverse lookup: A dictionary operation that takes a value and finds\none or more keys that map to it. raise statement: A statement that (deliberately) raises an exception. singleton: A list (or other sequence) with a single element. call graph: A diagram that shows every frame created during\nthe execution of a program, with an arrow from each caller to\neach callee. memo: A computed value stored to avoid unnecessary future \ncomputation. global variable: A variable defined outside a function. Global\nvariables can be accessed from any function. global statement: A statement that declares a variable name\nglobal. flag: A boolean variable used to indicate whether a condition\nis true. declaration: A statement like global that tells the\ninterpreter something about a variable. 11.10  Exercises Exercise 1 Write a function that reads the words in words.txt and\nstores them as keys in a dictionary. It doesn’t matter what the\nvalues are. Then you can use the in operator\nas a fast way to check whether a string is in\nthe dictionary. If you did Exercise 10 , you can compare the speed\nof this implementation with the list in operator and the\nbisection search. Exercise 2 Read the documentation of the dictionary method setdefault and use it to write a more concise version of invert_dict .\nSolution: https://thinkpython.com/code/invert_dict.py . Exercise 3 Memoize the Ackermann function from Exercise 2 and see if\nmemoization makes it possible to evaluate the function with bigger\narguments. Hint: no.\nSolution: https://thinkpython.com/code/ackermann_memo.py . Exercise 4 If you did Exercise 7 , you already have\na function named has_duplicates that takes a list\nas a parameter and returns True if there is any object\nthat appears more than once in the list. Use a dictionary to write a faster, simpler version of has_duplicates . \nSolution: https://thinkpython.com/code/has_duplicates.py . Exercise 5 Two words are “rotate pairs” if you can rotate one of them\nand get the other (see rotate_word in Exercise 5 ). Write a program that reads a wordlist and finds all the rotate\npairs. Solution: https://thinkpython.com/code/rotate_pairs.py . Exercise 6 Here’s another Puzzler from Car Talk ( http://www.cartalk.com/content/puzzlers ): This was sent in by a fellow named Dan O’Leary. He came upon a common\none-syllable, five-letter word recently that has the following unique\nproperty. When you remove the first letter, the remaining letters form\na homophone of the original word, that is a word that sounds exactly\nthe same. Replace the first letter, that is, put it back and remove\nthe second letter and the result is yet another homophone of the\noriginal word. And the question is, what’s the word? Now I’m going to give you an example that doesn’t work. Let’s look at\nthe five-letter word, ‘wrack.’ W-R-A-C-K, you know like to ‘wrack with\npain.’ If I remove the first letter, I am left with a four-letter\nword, ’R-A-C-K.’ As in, ‘Holy cow, did you see the rack on that buck!\nIt must have been a nine-pointer!’ It’s a perfect homophone. If you\nput the ‘w’ back, and remove the ‘r,’ instead, you’re left with the\nword, ‘wack,’ which is a real word, it’s just not a homophone of the\nother two words. But there is, however, at least one word that Dan and we know of,\nwhich will yield two homophones if you remove either of the first two\nletters to make two, new four-letter words. The question is, what’s\nthe word? You can use the dictionary from Exercise 1 to check\nwhether a string is in the word list. To check whether two words are homophones, you can use the CMU\nPronouncing Dictionary. You can download it from http://www.speech.cs.cmu.edu/cgi-bin/cmudict or from https://thinkpython.com/code/c06d and you can also download https://thinkpython.com/code/pronounce.py , which provides a function\nnamed read_dictionary that reads the pronouncing dictionary and\nreturns a Python dictionary that maps from each word to a string that\ndescribes its primary pronunciation. Write a program that lists all the words that solve the Puzzler.\nSolution: https://thinkpython.com/code/homophone.py . Buy this book at Amazon.com\n\n#### Contribute\n\nIf you would like to make a contribution to support my books,\nyou can use the button below and pay with PayPal.  Thank you!\nPay what you want:\nSmall $1.00 USD\nMedium $5.00 USD\nLarge $10.00 USD\nX-Large $20.00 USD\nXX-Large $50.00 USD\nAre you using one of our books in a class? We'd like to know\nabout it.  Please consider filling out this short survey . Think DSP Think Java Think Bayes Think Python 2e Think Stats 2e Think Complexity",
  "type": "tutorial",
  "concept_tags": [
    "OOP",
    "classes",
    "objects"
  ],
  "difficulty": "intermediate",
  "metadata": {
    "language": "en",
    "domain": "programming/python",
    "retrieved_at": "2026-02-24",
    "intended_use": "educational corpus",
    "source": "think_python"
  },
  "provenance": {
    "url": "https://greenteapress.com/thinkpython2/html/thinkpython2012.html",
    "license": "CC BY-NC 3.0",
    "attribution": "Allen B. Downey, greenteapress.com",
    "retrieved_at": "2026-02-24"
  },
  "ai_generated": false,
  "doc_id": "scraped-https-greenteapress-com-thinkpython2-html-thinkpython2012-ht-5873bdc9"
}