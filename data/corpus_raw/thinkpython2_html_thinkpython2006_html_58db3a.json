{
  "title": "Chapter 5  Conditionals and recursion",
  "content": "Buy this book at Amazon.com Chapter 5  Conditionals and recursion The main topic of this chapter is the if statement, which\nexecutes different code depending on the state of the program.\nBut first I want to introduce two new operators: floor division\nand modulus. 5.1  Floor division and modulus The floor division operator, // , divides\ntwo numbers and rounds down to an integer. For example, suppose the\nrun time of a movie is 105 minutes. You might want to know how\nlong that is in hours. Conventional division\nreturns a floating-point number: >>> minutes = 105\n>>> minutes / 60\n1.75 But we don’t normally write hours with decimal points. Floor\ndivision returns the integer number of hours, rounding down: >>> minutes = 105\n>>> hours = minutes // 60\n>>> hours\n1 To get the remainder, you could subtract off one hour in minutes: >>> remainder = minutes - hours * 60\n>>> remainder\n45 An alternative is to use the modulus operator , % , which\ndivides two numbers and returns the remainder. >>> remainder = minutes % 60\n>>> remainder\n45 The modulus operator is more useful than it seems. For\nexample, you can check whether one number is divisible by another—if x % y is zero, then x is divisible by y . Also, you can extract the right-most digit\nor digits from a number. For example, x % 10 yields the\nright-most digit of x (in base 10). Similarly x % 100 yields the last two digits. If you are using Python 2, division works differently. The\ndivision operator, / , performs floor division if both\noperands are integers, and floating-point division if either\noperand is a float . 5.2  Boolean expressions A boolean expression is an expression that is either true\nor false. The following examples use the \noperator == , which compares two operands and produces True if they are equal and False otherwise: >>> 5 == 5\nTrue\n>>> 5 == 6\nFalse True and False are special\nvalues that belong to the type bool ; they are not strings: >>> type(True)\n<class 'bool'>\n>>> type(False)\n<class 'bool'> The == operator is one of the relational operators ; the\nothers are: x != y               # x is not equal to y\n      x > y                # x is greater than y\n      x < y                # x is less than y\n      x >= y               # x is greater than or equal to y\n      x <= y               # x is less than or equal to y Although these operations are probably familiar to you, the Python\nsymbols are different from the mathematical symbols. A common error\nis to use a single equal sign ( = ) instead of a double equal sign\n( == ). Remember that = is an assignment operator and == is a relational operator. There is no such thing as =< or => . 5.3  Logical operators There are three logical operators : and , or , and not . The semantics (meaning) of these operators is\nsimilar to their meaning in English. For example, x > 0 and x < 10 is true only if x is greater than 0 and less than 10. n%2 == 0 or n%3 == 0 is true if either or both of the\nconditions is true, that is, if the number is divisible by 2 or 3. Finally, the not operator negates a boolean\nexpression, so not (x > y) is true if x > y is false,\nthat is, if x is less than or equal to y . Strictly speaking, the operands of the logical operators should be\nboolean expressions, but Python is not very strict.\nAny nonzero number is interpreted as True : >>> 42 and True\nTrue This flexibility can be useful, but there are some subtleties to\nit that might be confusing. You might want to avoid it (unless\nyou know what you are doing). 5.4  Conditional execution In order to write useful programs, we almost always need the ability\nto check conditions and change the behavior of the program\naccordingly. Conditional statements give us this ability. The\nsimplest form is the if statement: if x > 0:\n    print('x is positive') The boolean expression after if is\ncalled the condition . If it is true, the indented\nstatement runs. If not, nothing happens. if statements have the same structure as function definitions:\na header followed by an indented body. Statements like this are\ncalled compound statements . There is no limit on the number of statements that can appear in\nthe body, but there has to be at least one.\nOccasionally, it is useful to have a body with no statements (usually\nas a place keeper for code you haven’t written yet). In that\ncase, you can use the pass statement, which does nothing. if x < 0:\n    pass          # TODO: need to handle negative values! 5.5  Alternative execution A second form of the if statement is “alternative execution”,\nin which there are two possibilities and the condition determines\nwhich one runs. The syntax looks like this: if x % 2 == 0:\n    print('x is even')\nelse:\n    print('x is odd') If the remainder when x is divided by 2 is 0, then we know that x is even, and the program displays an appropriate message. If\nthe condition is false, the second set of statements runs.\nSince the condition must be true or false, exactly one of the\nalternatives will run. The alternatives are called branches , because they are branches in the flow of execution. 5.6  Chained conditionals Sometimes there are more than two possibilities and we need more than\ntwo branches. One way to express a computation like that is a chained conditional : if x < y:\n    print('x is less than y')\nelif x > y:\n    print('x is greater than y')\nelse:\n    print('x and y are equal') elif is an abbreviation of “else if”. Again, exactly one\nbranch will run. There is no limit on the number of elif statements. If there is an else clause, it has to be\nat the end, but there doesn’t have to be one. if choice == 'a':\n    draw_a()\nelif choice == 'b':\n    draw_b()\nelif choice == 'c':\n    draw_c() Each condition is checked in order. If the first is false,\nthe next is checked, and so on. If one of them is\ntrue, the corresponding branch runs and the statement\nends. Even if more than one condition is true, only the\nfirst true branch runs. 5.7  Nested conditionals One conditional can also be nested within another. We could have\nwritten the example in the previous section like this: if x == y:\n    print('x and y are equal')\nelse:\n    if x < y:\n        print('x is less than y')\n    else:\n        print('x is greater than y') The outer conditional contains two branches. The\nfirst branch contains a simple statement. The second branch\ncontains another if statement, which has two branches of its\nown. Those two branches are both simple statements,\nalthough they could have been conditional statements as well. Although the indentation of the statements makes the structure\napparent, nested conditionals become difficult to read very\nquickly. It is a good idea to avoid them when you can. Logical operators often provide a way to simplify nested conditional\nstatements. For example, we can rewrite the following code using a\nsingle conditional: if 0 < x:\n    if x < 10:\n        print('x is a positive single-digit number.') The print statement runs only if we make it past both\nconditionals, so we can get the same effect with the and operator: if 0 < x and x < 10:\n    print('x is a positive single-digit number.') For this kind of condition, Python provides a more concise option: if 0 < x < 10:\n    print('x is a positive single-digit number.') 5.8  Recursion It is legal for one function to call another;\nit is also legal for a function to call itself. It may not be obvious\nwhy that is a good thing, but it turns out to be one of the most\nmagical things a program can do.\nFor example, look at the following function: def countdown(n):\n    if n <= 0:\n        print('Blastoff!')\n    else:\n        print(n)\n        countdown(n-1) If n is 0 or negative, it outputs the word, “Blastoff!”\nOtherwise, it outputs n and then calls a function named countdown —itself—passing n-1 as an argument. What happens if we call this function like this? >>> countdown(3) The execution of countdown begins with n=3 , and since n is greater than 0, it outputs the value 3, and then calls itself... The execution of countdown begins with n=2 , and since n is greater than 0, it outputs the value 2, and then calls itself... The execution of countdown begins with n=1 , and since n is greater than 0, it outputs the value 1, and then calls itself... The execution of countdown begins with n=0 , and since n is not greater than 0, it outputs the word, “Blastoff!” and then\nreturns. The countdown that got n=1 returns. The countdown that got n=2 returns. The countdown that got n=3 returns. And then you’re back in __main__ . So, the\ntotal output looks like this: 3\n2\n1\nBlastoff! A function that calls itself is recursive ; the process of\nexecuting it is called recursion . As another example, we can write a function that prints a\nstring n times. def print_n(s, n):\n    if n <= 0:\n        return\n    print(s)\n    print_n(s, n-1) If n <= 0 the return statement exits the function. The\nflow of execution immediately returns to the caller, and the remaining\nlines of the function don’t run. The rest of the function is similar to countdown : it displays s and then calls itself to display s n −1 additional\ntimes. So the number of lines of output is 1 + (n - 1) , which\nadds up to n . For simple examples like this, it is probably easier to use a for loop. But we will see examples later that are hard to write\nwith a for loop and easy to write with recursion, so it is\ngood to start early. 5.9  Stack diagrams for recursive functions In Section 3.9 , we used a stack diagram to represent\nthe state of a program during a function call. The same kind of\ndiagram can help interpret a recursive function. Every time a function gets called, Python creates a\nframe to contain the function’s local variables and parameters.\nFor a recursive function, there might be more than one frame on the\nstack at the same time. Figure 5.1 shows a stack diagram for countdown called with n = 3 . Figure 5.1: Stack diagram. As usual, the top of the stack is the frame for __main__ .\nIt is empty because we did not create any variables in __main__ or pass any arguments to it. The four countdown frames have different values for the\nparameter n . The bottom of the stack, where n=0 , is\ncalled the base case . It does not make a recursive call, so\nthere are no more frames. As an exercise, draw a stack diagram for print_n called with s = 'Hello' and n=2 .\nThen write a function called do_n that takes a function\nobject and a number, n , as arguments, and that calls\nthe given function n times. 5.10  Infinite recursion If a recursion never reaches a base case, it goes on making\nrecursive calls forever, and the program never terminates. This is\nknown as infinite recursion , and it is generally not\na good idea. Here is a minimal program with an infinite recursion: def recurse():\n    recurse() In most programming environments, a program with infinite recursion\ndoes not really run forever. Python reports an error\nmessage when the maximum recursion depth is reached: File \"<stdin>\", line 2, in recurse\n  File \"<stdin>\", line 2, in recurse\n  File \"<stdin>\", line 2, in recurse\n                  .   \n                  .\n                  .\n  File \"<stdin>\", line 2, in recurse\nRuntimeError: Maximum recursion depth exceeded This traceback is a little bigger than the one we saw in the\nprevious chapter. When the error occurs, there are 1000 recurse frames on the stack! If you encounter an infinite recursion by accident, review\nyour function to confirm that there is a base case that does not\nmake a recursive call. And if there is a base case, check whether\nyou are guaranteed to reach it. 5.11  Keyboard input The programs we have written so far accept no input from the user.\nThey just do the same thing every time. Python provides a built-in function called input that\nstops the program and\nwaits for the user to type something. When the user presses Return or Enter , the program resumes and input returns what the user typed as a string. In Python 2, the same\nfunction is called raw_input . >>> text = input()\nWhat are you waiting for?\n>>> text\n'What are you waiting for?' Before getting input from the user, it is a good idea to print a\nprompt telling the user what to type. input can take a\nprompt as an argument: >>> name = input('What...is your name?\\n')\nWhat...is your name?\nArthur, King of the Britons!\n>>> name\n'Arthur, King of the Britons!' The sequence \\n at the end of the prompt represents a newline , which is a special character that causes a line break.\nThat’s why the user’s input appears below the prompt. If you expect the user to type an integer, you can try to convert\nthe return value to int : >>> prompt = 'What...is the airspeed velocity of an unladen swallow?\\n'\n>>> speed = input(prompt)\nWhat...is the airspeed velocity of an unladen swallow?\n42\n>>> int(speed)\n42 But if the user types something other than a string of digits,\nyou get an error: >>> speed = input(prompt)\nWhat...is the airspeed velocity of an unladen swallow?\nWhat do you mean, an African or a European swallow?\n>>> int(speed)\nValueError: invalid literal for int() with base 10 We will see how to handle this kind of error later. 5.12  Debugging When a syntax or runtime error occurs, the error message contains\na lot of information, but it can be overwhelming. The most\nuseful parts are usually: What kind of error it was, and Where it occurred. Syntax errors are usually easy to find, but there are a few\ngotchas. Whitespace errors can be tricky because spaces and\ntabs are invisible and we are used to ignoring them. >>> x = 5\n>>>  y = 6\n  File \"<stdin>\", line 1\n    y = 6\n    ^\nIndentationError: unexpected indent In this example, the problem is that the second line is indented by\none space. But the error message points to y , which is\nmisleading. In general, error messages indicate where the problem was\ndiscovered, but the actual error might be earlier in the code,\nsometimes on a previous line. The same is true of runtime errors. Suppose you are trying\nto compute a signal-to-noise ratio in decibels. The formula\nis SNR db = 10 log 10 ( P signal / P noise ). In Python,\nyou might write something like this: import math\nsignal_power = 9\nnoise_power = 10\nratio = signal_power // noise_power\ndecibels = 10 * math.log10(ratio)\nprint(decibels) When you run this program, you get an exception: Traceback (most recent call last):\n  File \"snr.py\", line 5, in ?\n    decibels = 10 * math.log10(ratio)\nValueError: math domain error The error message indicates line 5, but there is nothing\nwrong with that line. To find the real error, it might be\nuseful to print the value of ratio , which turns out to\nbe 0. The problem is in line 4, which uses floor division\ninstead of floating-point division. You should take the time to read error messages carefully, but don’t\nassume that everything they say is correct. 5.13  Glossary floor division: An operator, denoted // , that divides two\nnumbers and rounds down (toward negative infinity) to an integer. modulus operator: An operator, denoted with a percent sign\n( % ), that works on integers and returns the remainder when one\nnumber is divided by another. boolean expression: An expression whose value is either True or False . relational operator: One of the operators that compares\nits operands: == , != , > , < , >= , and <= . logical operator: One of the operators that combines boolean\nexpressions: and , or , and not . conditional statement: A statement that controls the flow of\nexecution depending on some condition. condition: The boolean expression in a conditional statement\nthat determines which branch runs. compound statement: A statement that consists of a header\nand a body. The header ends with a colon (:). The body is indented\nrelative to the header. branch: One of the alternative sequences of statements in\na conditional statement. chained conditional: A conditional statement with a series\nof alternative branches. nested conditional: A conditional statement that appears\nin one of the branches of another conditional statement. return statement: A statement that causes a function to\nend immediately and return to the caller. recursion: The process of calling the function that is\ncurrently executing. base case: A conditional branch in a\nrecursive function that does not make a recursive call. infinite recursion: A recursion that doesn’t have a\nbase case, or never reaches it. Eventually, an infinite recursion\ncauses a runtime error. 5.14  Exercises Exercise 1 The time module provides a function, also named time , that\nreturns the current Greenwich Mean Time in “the epoch”, which is\nan arbitrary time used as a reference point. On UNIX systems, the\nepoch is 1 January 1970. >>> import time\n>>> time.time()\n1437746094.5735958 Write a script that reads the current time and converts it to\na time of day in hours, minutes, and seconds, plus the number of\ndays since the epoch. Exercise 2 Fermat’s Last Theorem says that there are no positive integers a , b , and c such that a n + b n = c n for any values of n greater than 2. Write a function named check_fermat that takes four\nparameters— a , b , c and n —and\nchecks to see if Fermat’s theorem holds. If n is greater than 2 and a n + b n = c n the program should print, “Holy smokes, Fermat was wrong!”\nOtherwise the program should print, “No, that doesn’t work.” Write a function that prompts the user to input values\nfor a , b , c and n , converts them to\nintegers, and uses check_fermat to check whether they\nviolate Fermat’s theorem. Exercise 3 If you are given three sticks, you may or may not be able to arrange\nthem in a triangle. For example, if one of the sticks is 12 inches\nlong and the other two are one inch long, you will\nnot be able to get the short sticks to meet in the middle. For any\nthree lengths, there is a simple test to see if it is possible to form\na triangle: If any of the three lengths is greater than the sum of the other\ntwo, then you cannot form a triangle. Otherwise, you\ncan. (If the sum of two lengths equals the third, they form\nwhat is called a “degenerate” triangle.) Write a function named is_triangle that takes three\nintegers as arguments, and that prints either “Yes” or “No”, depending\non whether you can or cannot form a triangle from sticks with the\ngiven lengths. Write a function that prompts the user to input three stick\nlengths, converts them to integers, and uses is_triangle to\ncheck whether sticks with the given lengths can form a triangle. Exercise 4 What is the output of the following program?\nDraw a stack diagram that shows the state of the program\nwhen it prints the result. def recurse(n, s):\n    if n == 0:\n        print(s)\n    else:\n        recurse(n-1, n+s)\n\nrecurse(3, 0) What would happen if you called this function like this: recurse(-1, 0) ? Write a docstring that explains everything someone would need to\nknow in order to use this function (and nothing else). The following exercises use the turtle module, described in\nChapter 4 : Exercise 5 Read the following function and see if you can figure out\nwhat it does (see the examples in Chapter 4 ). Then run it \nand see if you got it right. def draw(t, length, n):\n    if n == 0:\n        return\n    angle = 50\n    t.fd(length*n)\n    t.lt(angle)\n    draw(t, length, n-1)\n    t.rt(2*angle)\n    draw(t, length, n-1)\n    t.lt(angle)\n    t.bk(length*n) Figure 5.2: A Koch curve. Exercise 6 The Koch curve is a fractal that looks something like\nFigure 5.2 . To draw a Koch curve with length x , all you\nhave to do is Draw a Koch curve with length x /3 . Turn left 60 degrees. Draw a Koch curve with length x /3 . Turn right 120 degrees. Draw a Koch curve with length x /3 . Turn left 60 degrees. Draw a Koch curve with length x /3 . The exception is if x is less than 3: in that case,\nyou can just draw a straight line with length x . Write a function called koch that takes a turtle and\na length as parameters, and that uses the turtle to draw a Koch\ncurve with the given length. Write a function called snowflake that draws three\nKoch curves to make the outline of a snowflake. Solution: https://thinkpython.com/code/koch.py . The Koch curve can be generalized in several ways. See http://en.wikipedia.org/wiki/Koch_snowflake for examples and\nimplement your favorite. Buy this book at Amazon.com\n\n#### Contribute\n\nIf you would like to make a contribution to support my books,\nyou can use the button below and pay with PayPal.  Thank you!\nPay what you want:\nSmall $1.00 USD\nMedium $5.00 USD\nLarge $10.00 USD\nX-Large $20.00 USD\nXX-Large $50.00 USD\nAre you using one of our books in a class? We'd like to know\nabout it.  Please consider filling out this short survey . Think DSP Think Java Think Bayes Think Python 2e Think Stats 2e Think Complexity",
  "type": "tutorial",
  "concept_tags": [
    "loops",
    "iteration",
    "strings"
  ],
  "difficulty": "intro",
  "metadata": {
    "language": "en",
    "domain": "programming/python",
    "retrieved_at": "2026-02-24",
    "intended_use": "educational corpus",
    "source": "think_python"
  },
  "provenance": {
    "url": "https://greenteapress.com/thinkpython2/html/thinkpython2006.html",
    "license": "CC BY-NC 3.0",
    "attribution": "Allen B. Downey, greenteapress.com",
    "retrieved_at": "2026-02-24"
  },
  "ai_generated": false,
  "doc_id": "scraped-https-greenteapress-com-thinkpython2-html-thinkpython2006-ht-58db3a7e"
}