{
  "title": "Chapter 1  The way of the program",
  "content": "Buy this book at Amazon.com Chapter 1  The way of the program The goal of this book is to teach you to think like a computer\nscientist. This way of thinking combines some of the best features of\nmathematics, engineering, and natural science. Like mathematicians,\ncomputer scientists use formal languages to denote ideas (specifically\ncomputations). Like engineers, they design things, assembling\ncomponents into systems and evaluating tradeoffs among alternatives.\nLike scientists, they observe the behavior of complex systems, form\nhypotheses, and test predictions. The single most important skill for a computer scientist is problem solving . Problem solving means the ability to formulate\nproblems, think creatively about solutions, and express a solution\nclearly and accurately. As it turns out, the process of learning to\nprogram is an excellent opportunity to practice problem-solving\nskills. That’s why this chapter is called, “The way of the\nprogram”. On one level, you will be learning to program, a useful skill by\nitself. On another level, you will use programming as a means to an\nend. As we go along, that end will become clearer. 1.1  What is a program? A program is a sequence of instructions that specifies how to\nperform a computation. The computation might be something\nmathematical, such as solving a system of equations or finding the\nroots of a polynomial, but it can also be a symbolic computation, such\nas searching and replacing text in a document or something\ngraphical, like processing an image or playing a video. The details look different in different languages, but a few basic\ninstructions appear in just about every language: input: Get data from the keyboard, a file, the network, or some\nother device. output: Display data on the screen, save it in a\nfile, send it over the network, etc. math: Perform basic mathematical operations like addition and\nmultiplication. conditional execution: Check for certain conditions and\nrun the appropriate code. repetition: Perform some action repeatedly, usually with\nsome variation. Believe it or not, that’s pretty much all there is to it. Every\nprogram you’ve ever used, no matter how complicated, is made up of\ninstructions that look pretty much like these. So you can think of\nprogramming as the process of breaking a large, complex task\ninto smaller and smaller subtasks until the subtasks are\nsimple enough to be performed with one of these basic instructions. 1.2  Running Python One of the challenges of getting started with Python is that you\nmight have to install Python and related software on your computer.\nIf you are familiar with your operating system, and especially\nif you are comfortable with the command-line interface, you will\nhave no trouble installing Python. But for beginners, it can be\npainful to learn about system administration and programming at the\nsame time. To avoid that problem, I recommend that you start out running Python\nin a browser. Later, when you are comfortable with Python, I’ll\nmake suggestions for installing Python on your computer. There are a number of web pages you can use to run Python. If you\nalready have a favorite, go ahead and use it. Otherwise I recommend\nPythonAnywhere. I provide detailed instructions for getting started\nat http://tinyurl.com/thinkpython2e . There are two versions of Python, called Python 2 and Python 3.\nThey are very similar, so if you learn one, it is easy to switch\nto the other. In fact, there are only a few differences you will\nencounter as a beginner.\nThis book is written for Python 3, but I include some notes\nabout Python 2. The Python interpreter is a program that reads and executes\nPython code. Depending on your environment, you might start the\ninterpreter by clicking on an icon, or by typing python on\na command line. \nWhen it starts, you should see output like this: Python 3.4.0 (default, Jun 19 2015, 14:20:21) \n[GCC 4.8.2] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> The first three lines contain information about the interpreter\nand the operating system it’s running on, so it might be different for\nyou. But you should check that the version number, which is 3.4.0 in this example, begins with 3, which indicates that\nyou are running Python 3. If it begins with 2, you are running\n(you guessed it) Python 2. The last line is a prompt that indicates that the interpreter is\nready for you to enter code.\nIf you type a line of code and hit Enter, the interpreter displays the\nresult: >>> 1 + 1\n2 Now you’re ready to get started.\nFrom here on, I assume that you know how to start the Python\ninterpreter and run code. 1.3  The first program Traditionally, the first program you write in a new language\nis called “Hello, World!” because all it does is display the\nwords “Hello, World!”. In Python, it looks like this: >>> print('Hello, World!') This is an example of a print statement , although it\ndoesn’t actually print anything on paper. It displays a result on the\nscreen. In this case, the result is the words Hello, World! The quotation marks in the program mark the beginning and end\nof the text to be displayed; they don’t appear in the result. The parentheses indicate that print is a function. We’ll get\nto functions in Chapter 3 . In Python 2, the print statement is slightly different; it is not\na function, so it doesn’t use parentheses. >>> print 'Hello, World!' This distinction will make more sense soon, but that’s enough to\nget started. 1.4  Arithmetic operators After “Hello, World”, the next step is arithmetic. Python provides operators , which are special symbols that represent computations\nlike addition and multiplication. The operators + , - , and * perform addition,\nsubtraction, and multiplication, as in the following examples: >>> 40 + 2\n42\n>>> 43 - 1\n42\n>>> 6 * 7\n42 The operator / performs division: >>> 84 / 2\n42.0 You might wonder why the result is 42.0 instead of 42 .\nI’ll explain in the next section. Finally, the operator ** performs exponentiation; that is,\nit raises a number to a power: >>> 6**2 + 6\n42 In some other languages, ^ is used for exponentiation, but\nin Python it is a bitwise operator called XOR. If you are not\nfamiliar with bitwise operators, the result will surprise you: >>> 6 ^ 2\n4 I won’t cover\nbitwise operators in this book, but you can read about\nthem at http://wiki.python.org/moin/BitwiseOperators . 1.5  Values and types A value is one of the basic things a program works with, like a\nletter or a number. Some values we have seen so far are 2 , 42.0 , and 'Hello, World!' . These values belong to different types : 2 is an integer , 42.0 is a floating-point number ,\nand 'Hello, World!' is a string ,\nso-called because the letters it contains are strung together. If you are not sure what type a value has, the interpreter can\ntell you: >>> type(2)\n<class 'int'>\n>>> type(42.0)\n<class 'float'>\n>>> type('Hello, World!')\n<class 'str'> In these results, the word “class” is used in the sense of\na category; a type is a category of values. Not surprisingly, integers belong to the type int ,\nstrings belong to str and floating-point\nnumbers belong to float . What about values like '2' and '42.0' ?\nThey look like numbers, but they are in quotation marks like\nstrings. >>> type('2')\n<class 'str'>\n>>> type('42.0')\n<class 'str'> They’re strings. When you type a large integer, you might be tempted to use commas\nbetween groups of digits, as in 1,000,000 . This is not a\nlegal integer in Python, but it is legal: >>> 1,000,000\n(1, 0, 0) That’s not what we expected at all! Python interprets 1,000,000 as a comma-separated sequence of integers. We’ll learn\nmore about this kind of sequence later. 1.6  Formal and natural languages Natural languages are the languages people speak,\nsuch as English, Spanish, and French. They were not designed\nby people (although people try to impose some order on them);\nthey evolved naturally. Formal languages are languages that are designed by people for\nspecific applications. For example, the notation that mathematicians\nuse is a formal language that is particularly good at denoting\nrelationships among numbers and symbols. Chemists use a formal\nlanguage to represent the chemical structure of molecules. And\nmost importantly: Programming languages are formal languages that have been\ndesigned to express computations. Formal languages tend to have strict syntax rules that\ngovern the structure of statements.\nFor example, in mathematics the statement\n3 + 3 = 6 has correct syntax, but\n3 + = 3 $ 6 does not. In chemistry H 2 O is a syntactically correct formula, but 2 Zz is not. Syntax rules come in two flavors, pertaining to tokens and\nstructure. Tokens are the basic elements of the language, such as\nwords, numbers, and chemical elements. One of the problems with\n3 += 3 $ 6 is that  $  is not a legal token in mathematics\n(at least as far as I know). Similarly, 2 Zz is not legal because\nthere is no element with the abbreviation Zz . The second type of syntax rule pertains to the way tokens are\ncombined. The equation 3 +/ 3 is illegal because even though +\nand / are legal tokens, you can’t have one right after the other.\nSimilarly, in a chemical formula the subscript comes after the element\nname, not before. This is @ well-structured Engli$h\nsentence with invalid t*kens in it. This sentence all valid tokens\nhas, but invalid structure with. When you read a sentence in English or a statement in a formal\nlanguage, you have to figure out the structure\n(although in a natural language you do this subconsciously). This\nprocess is called parsing . Although formal and natural languages have many features in\ncommon—tokens, structure, and syntax—there are some\ndifferences: ambiguity: Natural languages are full of ambiguity, which\npeople deal with by using contextual clues and other information.\nFormal languages are designed to be nearly or completely unambiguous,\nwhich means that any statement has exactly one meaning,\nregardless of context. redundancy: In order to make up for ambiguity and reduce\nmisunderstandings, natural languages employ lots of\nredundancy. As a result, they are often verbose. Formal languages\nare less redundant and more concise. literalness: Natural languages are full of idiom and metaphor.\nIf I say, “The penny dropped”, there is probably no penny and\nnothing dropping (this idiom means that someone understood something\nafter a period of confusion). Formal languages\nmean exactly what they say. Because we all grow up speaking natural languages, it is sometimes\nhard to adjust to formal languages. The difference between formal and\nnatural language is like the difference between poetry and prose, but\nmore so: Poetry: Words are used for their sounds as well as for\ntheir meaning, and the whole poem together creates an effect or\nemotional response. Ambiguity is not only common but often\ndeliberate. Prose: The literal meaning of words is more important,\nand the structure contributes more meaning. Prose is more amenable to\nanalysis than poetry but still often ambiguous. Programs: The meaning of a computer program is unambiguous\nand literal, and can be understood entirely by analysis of the\ntokens and structure. Formal languages are more dense\nthan natural languages, so it takes longer to read them. Also, the\nstructure is important, so it is not always best to read\nfrom top to bottom, left to right. Instead, learn to parse the\nprogram in your head, identifying the tokens and interpreting the\nstructure. Finally, the details matter. Small errors in\nspelling and punctuation, which you can get away\nwith in natural languages, can make a big difference in a formal\nlanguage. 1.7  Debugging Programmers make mistakes. For whimsical reasons, programming errors\nare called bugs and the process of tracking them down is called debugging . Programming, and especially debugging, sometimes brings out strong\nemotions. If you are struggling with a difficult bug, you might \nfeel angry, despondent, or embarrassed. There is evidence that people naturally respond to computers as if\nthey were people. When they work well, we think\nof them as teammates, and when they are obstinate or rude, we\nrespond to them the same way we respond to rude,\nobstinate people (Reeves and Nass, The Media\nEquation: How People Treat Computers, Television, and New Media\nLike Real People and Places ). Preparing for these reactions might help you deal with them.\nOne approach is to think of the computer as an employee with\ncertain strengths, like speed and precision, and\nparticular weaknesses, like lack of empathy and inability\nto grasp the big picture. Your job is to be a good manager: find ways to take advantage\nof the strengths and mitigate the weaknesses. And find ways\nto use your emotions to engage with the problem,\nwithout letting your reactions interfere with your ability\nto work effectively. Learning to debug can be frustrating, but it is a valuable skill\nthat is useful for many activities beyond programming. At the\nend of each chapter there is a section, like this one,\nwith my suggestions for debugging. I hope they help! 1.8  Glossary problem solving: The process of formulating a problem, finding\na solution, and expressing it. high-level language: A programming language like Python that\nis designed to be easy for humans to read and write. low-level language: A programming language that is designed\nto be easy for a computer to run; also called “machine language” or\n“assembly language”. portability: A property of a program that can run on more\nthan one kind of computer. interpreter: A program that reads another program and executes\nit prompt: Characters displayed by the interpreter to indicate\nthat it is ready to take input from the user. program: A set of instructions that specifies a computation. print statement: An instruction that causes the Python\ninterpreter to display a value on the screen. operator: A special symbol that represents a simple computation like\naddition, multiplication, or string concatenation. value: One of the basic units of data, like a number or string, \nthat a program manipulates. type: A category of values. The types we have seen so far\nare integers (type int ), floating-point numbers (type float ), and strings (type str ). integer: A type that represents whole numbers. floating-point: A type that represents numbers with fractional\nparts. string: A type that represents sequences of characters. natural language: Any one of the languages that people speak that\nevolved naturally. formal language: Any one of the languages that people have designed\nfor specific purposes, such as representing mathematical ideas or\ncomputer programs; all programming languages are formal languages. token: One of the basic elements of the syntactic structure of\na program, analogous to a word in a natural language. syntax: The rules that govern the structure of a program. parse: To examine a program and analyze the syntactic structure. bug: An error in a program. debugging: The process of finding and correcting bugs. 1.9  Exercises Exercise 1 It is a good idea to read this book in front of a computer so you can\ntry out the examples as you go. Whenever you are experimenting with a new feature, you should try\nto make mistakes. For example, in the “Hello, world!” program,\nwhat happens if you leave out one of the quotation marks? What\nif you leave out both? What if you spell print wrong? This kind of experiment helps you remember what you read; it also\nhelps when you are programming, because you get to know what the error\nmessages mean. It is better to make mistakes now and on purpose than\nlater and accidentally. In a print statement, what happens if you leave out one\nof the parentheses, or both? If you are trying to print a string, what happens if you\nleave out one of the quotation marks, or both? You can use a minus sign to make a negative number like -2 . What happens if you put a plus sign before a number?\nWhat about 2++2 ? In math notation, leading zeros are ok, as in 09 .\nWhat happens if you try this in Python? What about 011 ? What happens if you have two values with no operator\nbetween them? Exercise 2 Start the Python interpreter and use it as a calculator. How many seconds are there in 42 minutes 42 seconds? How many miles are there in 10 kilometers? Hint: there are 1.61\nkilometers in a mile. If you run a 10 kilometer race in 42 minutes 42 seconds, what is\nyour average pace (time per mile in minutes and seconds)? What is\nyour average speed in miles per hour? Buy this book at Amazon.com\n\n#### Contribute\n\nIf you would like to make a contribution to support my books,\nyou can use the button below and pay with PayPal.  Thank you!\nPay what you want:\nSmall $1.00 USD\nMedium $5.00 USD\nLarge $10.00 USD\nX-Large $20.00 USD\nXX-Large $50.00 USD\nAre you using one of our books in a class? We'd like to know\nabout it.  Please consider filling out this short survey . Think DSP Think Java Think Bayes Think Python 2e Think Stats 2e Think Complexity",
  "type": "tutorial",
  "concept_tags": [
    "variables",
    "data_types",
    "operators",
    "expressions"
  ],
  "difficulty": "intro",
  "metadata": {
    "language": "en",
    "domain": "programming/python",
    "retrieved_at": "2026-02-24",
    "intended_use": "educational corpus",
    "source": "think_python"
  },
  "provenance": {
    "url": "https://greenteapress.com/thinkpython2/html/thinkpython2002.html",
    "license": "CC BY-NC 3.0",
    "attribution": "Allen B. Downey, greenteapress.com",
    "retrieved_at": "2026-02-24"
  },
  "ai_generated": false,
  "doc_id": "scraped-https-greenteapress-com-thinkpython2-html-thinkpython2002-ht-00aa1a50"
}