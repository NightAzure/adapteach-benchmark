{
  "title": "8.Errors and ExceptionsÂ¶",
  "content": "# 8.Errors and ExceptionsÂ¶\n\nUntil now error messages havenât been more than mentioned, but if you have tried\nout the examples you have probably seen some.  There are (at least) two\ndistinguishable kinds of errors: syntax errors and exceptions .\n\n## 8.1.Syntax ErrorsÂ¶\n\nSyntax errors, also known as parsing errors, are perhaps the most common kind of\ncomplaint you get while you are still learning Python:\n\n```python\n>>> while True print('Hello world')\n  File \"<stdin>\", line 1\n    while True print('Hello world')\n               ^^^^^\nSyntaxError: invalid syntax\n```\n\nThe parser repeats the offending line and displays little arrows pointing\nat the place where the error was detected.  Note that this is not always the\nplace that needs to be fixed.  In the example, the error is detected at the\nfunction print() , since a colon ( ':' ) is missing just before it.\n\nThe file name ( <stdin> in our example) and line number are printed so you\nknow where to look in case the input came from a file.\n\n## 8.2.ExceptionsÂ¶\n\nEven if a statement or expression is syntactically correct, it may cause an\nerror when an attempt is made to execute it. Errors detected during execution\nare called exceptions and are not unconditionally fatal: you will soon learn\nhow to handle them in Python programs.  Most exceptions are not handled by\nprograms, however, and result in error messages as shown here:\n\n```python\n>>> 10 * (1/0)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n    10 * (1/0)\n          ~^~\nZeroDivisionError: division by zero\n>>> 4 + spam*3\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n    4 + spam*3\n        ^^^^\nNameError: name 'spam' is not defined\n>>> '2' + 2\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n    '2' + 2\n    ~~~~^~~\nTypeError: can only concatenate str (not \"int\") to str\n```\n\nThe last line of the error message indicates what happened. Exceptions come in\ndifferent types, and the type is printed as part of the message: the types in\nthe example are ZeroDivisionError , NameError and TypeError .\nThe string printed as the exception type is the name of the built-in exception\nthat occurred.  This is true for all built-in exceptions, but need not be true\nfor user-defined exceptions (although it is a useful convention). Standard\nexception names are built-in identifiers (not reserved keywords).\n\nThe rest of the line provides detail based on the type of exception and what\ncaused it.\n\nThe preceding part of the error message shows the context where the exception\noccurred, in the form of a stack traceback. In general it contains a stack\ntraceback listing source lines; however, it will not display lines read from\nstandard input.\n\nBuilt-in Exceptions lists the built-in exceptions and their meanings.\n\n## 8.3.Handling ExceptionsÂ¶\n\nIt is possible to write programs that handle selected exceptions. Look at the\nfollowing example, which asks the user for input until a valid integer has been\nentered, but allows the user to interrupt the program (using Control - C or\nwhatever the operating system supports); note that a user-generated interruption\nis signalled by raising the KeyboardInterrupt exception.\n\n```python\n>>> while True:\n...     try:\n...         x = int(input(\"Please enter a number: \"))\n...         break\n...     except ValueError:\n...         print(\"Oops!  That was no valid number.  Try again...\")\n...\n```\n\nThe try statement works as follows.\n\n- First, the try clause (the statement(s) between the try and except keywords) is executed.\n- If no exception occurs, the except clause is skipped and execution of the try statement is finished.\n- If an exception occurs during execution of the try clause, the rest of the\nclause is skipped.  Then, if its type matches the exception named after the except keyword, the except clause is executed, and then execution\ncontinues after the try/except block.\n- If an exception occurs which does not match the exception named in the except\nclause , it is passed on to outer try statements; if no handler is\nfound, it is an unhandled exception and execution stops with an error message.\n\nA try statement may have more than one except clause , to specify\nhandlers for different exceptions.  At most one handler will be executed.\nHandlers only handle exceptions that occur in the corresponding try clause ,\nnot in other handlers of the same try statement.  An except clause may name multiple exceptions as a parenthesized tuple, for example:\n\n```python\n... except (RuntimeError, TypeError, NameError):\n...     pass\n```\n\nA class in an except clause matches exceptions which are instances of the\nclass itself or one of its derived classes (but not the other way around â an except clause listing a derived class does not match instances of its base classes).\nFor example, the following code will print B, C, D in that order:\n\n```python\nclass B(Exception):\n    pass\n\nclass C(B):\n    pass\n\nclass D(C):\n    pass\n\nfor cls in [B, C, D]:\n    try:\n        raise cls()\n    except D:\n        print(\"D\")\n    except C:\n        print(\"C\")\n    except B:\n        print(\"B\")\n```\n\nNote that if the except clauses were reversed (with except B first), it\nwould have printed B, B, B â the first matching except clause is triggered.\n\nWhen an exception occurs, it may have associated values, also known as the\nexceptionâs arguments . The presence and types of the arguments depend on the\nexception type.\n\nThe except clause may specify a variable after the exception name.  The\nvariable is bound to the exception instance which typically has an args attribute that stores the arguments. For convenience, builtin exception\ntypes define __str__() to print all the arguments without explicitly\naccessing .args .\n\n```python\n>>> try:\n...     raise Exception('spam', 'eggs')\n... except Exception as inst:\n...     print(type(inst))    # the exception type\n...     print(inst.args)     # arguments stored in .args\n...     print(inst)          # __str__ allows args to be printed directly,\n...                          # but may be overridden in exception subclasses\n...     x, y = inst.args     # unpack args\n...     print('x =', x)\n...     print('y =', y)\n...\n<class 'Exception'>\n('spam', 'eggs')\n('spam', 'eggs')\nx = spam\ny = eggs\n```\n\nThe exceptionâs __str__() output is printed as the last part (âdetailâ)\nof the message for unhandled exceptions.\n\nBaseException is the common base class of all exceptions. One of its\nsubclasses, Exception , is the base class of all the non-fatal exceptions.\nExceptions which are not subclasses of Exception are not typically\nhandled, because they are used to indicate that the program should terminate.\nThey include SystemExit which is raised by sys.exit() and KeyboardInterrupt which is raised when a user wishes to interrupt\nthe program.\n\nException can be used as a wildcard that catches (almost) everything.\nHowever, it is good practice to be as specific as possible with the types\nof exceptions that we intend to handle, and to allow any unexpected\nexceptions to propagate on.\n\nThe most common pattern for handling Exception is to print or log\nthe exception and then re-raise it (allowing a caller to handle the\nexception as well):\n\n```python\nimport sys\n\ntry:\n    f = open('myfile.txt')\n    s = f.readline()\n    i = int(s.strip())\nexcept OSError as err:\n    print(\"OS error:\", err)\nexcept ValueError:\n    print(\"Could not convert data to an integer.\")\nexcept Exception as err:\n    print(f\"Unexpected {err=}, {type(err)=}\")\n    raise\n```\n\nThe try â¦ except statement has an optional else\nclause , which, when present, must follow all except clauses .  It is useful\nfor code that must be executed if the try clause does not raise an exception.\nFor example:\n\n```python\nfor arg in sys.argv[1:]:\n    try:\n        f = open(arg, 'r')\n    except OSError:\n        print('cannot open', arg)\n    else:\n        print(arg, 'has', len(f.readlines()), 'lines')\n        f.close()\n```\n\nThe use of the else clause is better than adding additional code to\nthe try clause because it avoids accidentally catching an exception\nthat wasnât raised by the code being protected by the try â¦ except statement.\n\nException handlers do not handle only exceptions that occur immediately in the try clause , but also those that occur inside functions that are called (even\nindirectly) in the try clause . For example:\n\n```python\n>>> def this_fails():\n...     x = 1/0\n...\n>>> try:\n...     this_fails()\n... except ZeroDivisionError as err:\n...     print('Handling run-time error:', err)\n...\nHandling run-time error: division by zero\n```\n\n## 8.4.Raising ExceptionsÂ¶\n\nThe raise statement allows the programmer to force a specified\nexception to occur. For example:\n\n```python\n>>> raise NameError('HiThere')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n    raise NameError('HiThere')\nNameError: HiThere\n```\n\nThe sole argument to raise indicates the exception to be raised.\nThis must be either an exception instance or an exception class (a class that\nderives from BaseException , such as Exception or one of its\nsubclasses).  If an exception class is passed, it will be implicitly\ninstantiated by calling its constructor with no arguments:\n\n```python\nraise ValueError  # shorthand for 'raise ValueError()'\n```\n\nIf you need to determine whether an exception was raised but donât intend to\nhandle it, a simpler form of the raise statement allows you to\nre-raise the exception:\n\n```python\n>>> try:\n...     raise NameError('HiThere')\n... except NameError:\n...     print('An exception flew by!')\n...     raise\n...\nAn exception flew by!\nTraceback (most recent call last):\n  File \"<stdin>\", line 2, in <module>\n    raise NameError('HiThere')\nNameError: HiThere\n```\n\n## 8.5.Exception ChainingÂ¶\n\nIf an unhandled exception occurs inside an except section, it will\nhave the exception being handled attached to it and included in the error\nmessage:\n\n```python\n>>> try:\n...     open(\"database.sqlite\")\n... except OSError:\n...     raise RuntimeError(\"unable to handle error\")\n...\nTraceback (most recent call last):\n  File \"<stdin>\", line 2, in <module>\n    open(\"database.sqlite\")\n    ~~~~^^^^^^^^^^^^^^^^^^^\nFileNotFoundError: [Errno 2] No such file or directory: 'database.sqlite'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<stdin>\", line 4, in <module>\n    raise RuntimeError(\"unable to handle error\")\nRuntimeError: unable to handle error\n```\n\nTo indicate that an exception is a direct consequence of another, the raise statement allows an optional from clause:\n\n```python\n# exc must be exception instance or None.\nraise RuntimeError from exc\n```\n\nThis can be useful when you are transforming exceptions. For example:\n\n```python\n>>> def func():\n...     raise ConnectionError\n...\n>>> try:\n...     func()\n... except ConnectionError as exc:\n...     raise RuntimeError('Failed to open database') from exc\n...\nTraceback (most recent call last):\n  File \"<stdin>\", line 2, in <module>\n    func()\n    ~~~~^^\n  File \"<stdin>\", line 2, in func\nConnectionError\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"<stdin>\", line 4, in <module>\n    raise RuntimeError('Failed to open database') from exc\nRuntimeError: Failed to open database\n```\n\nIt also allows disabling automatic exception chaining using the from None idiom:\n\n```python\n>>> try:\n...     open('database.sqlite')\n... except OSError:\n...     raise RuntimeError from None\n...\nTraceback (most recent call last):\n  File \"<stdin>\", line 4, in <module>\n    raise RuntimeError from None\nRuntimeError\n```\n\nFor more information about chaining mechanics, see Built-in Exceptions .\n\n## 8.6.User-defined ExceptionsÂ¶\n\nPrograms may name their own exceptions by creating a new exception class (see Classes for more about Python classes).  Exceptions should typically\nbe derived from the Exception class, either directly or indirectly.\n\nException classes can be defined which do anything any other class can do, but\nare usually kept simple, often only offering a number of attributes that allow\ninformation about the error to be extracted by handlers for the exception.\n\nMost exceptions are defined with names that end in âErrorâ, similar to the\nnaming of the standard exceptions.\n\nMany standard modules define their own exceptions to report errors that may\noccur in functions they define.\n\n## 8.7.Defining Clean-up ActionsÂ¶\n\nThe try statement has another optional clause which is intended to\ndefine clean-up actions that must be executed under all circumstances.  For\nexample:\n\n```python\n>>> try:\n...     raise KeyboardInterrupt\n... finally:\n...     print('Goodbye, world!')\n...\nGoodbye, world!\nTraceback (most recent call last):\n  File \"<stdin>\", line 2, in <module>\n    raise KeyboardInterrupt\nKeyboardInterrupt\n```\n\nIf a finally clause is present, the finally clause will execute as the last task before the try statement completes. The finally clause runs whether or\nnot the try statement produces an exception. The following\npoints discuss more complex cases when an exception occurs:\n\n- If an exception occurs during execution of the try clause, the exception may be handled by an except clause. If the exception is not handled by an except clause, the exception is re-raised after the finally clause has been executed.\n- An exception could occur during execution of an except or else clause. Again, the exception is re-raised after\nthe finally clause has been executed.\n- If the finally clause executes a break , continue or return statement, exceptions are not\nre-raised. This can be confusing and is therefore discouraged. From\nversion 3.14 the compiler emits a SyntaxWarning for it\n(see PEP 765 ).\n- If the try statement reaches a break , continue or return statement, the finally clause will execute just prior to the break , continue or return statementâs execution.\n- If a finally clause includes a return statement, the returned value will be the one from the finally clauseâs return statement, not the\nvalue from the try clauseâs return statement. This can be confusing and is therefore discouraged. From\nversion 3.14 the compiler emits a SyntaxWarning for it\n(see PEP 765 ).\n\nFor example:\n\n```python\n>>> def bool_return():\n...     try:\n...         return True\n...     finally:\n...         return False\n...\n>>> bool_return()\nFalse\n```\n\nA more complicated example:\n\n```python\n>>> def divide(x, y):\n...     try:\n...         result = x / y\n...     except ZeroDivisionError:\n...         print(\"division by zero!\")\n...     else:\n...         print(\"result is\", result)\n...     finally:\n...         print(\"executing finally clause\")\n...\n>>> divide(2, 1)\nresult is 2.0\nexecuting finally clause\n>>> divide(2, 0)\ndivision by zero!\nexecuting finally clause\n>>> divide(\"2\", \"1\")\nexecuting finally clause\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n    divide(\"2\", \"1\")\n    ~~~~~~^^^^^^^^^^\n  File \"<stdin>\", line 3, in divide\n    result = x / y\n             ~~^~~\nTypeError: unsupported operand type(s) for /: 'str' and 'str'\n```\n\nAs you can see, the finally clause is executed in any event.  The TypeError raised by dividing two strings is not handled by the except clause and therefore re-raised after the finally clause has been executed.\n\nIn real world applications, the finally clause is useful for\nreleasing external resources (such as files or network connections), regardless\nof whether the use of the resource was successful.\n\n## 8.8.Predefined Clean-up ActionsÂ¶\n\nSome objects define standard clean-up actions to be undertaken when the object\nis no longer needed, regardless of whether or not the operation using the object\nsucceeded or failed. Look at the following example, which tries to open a file\nand print its contents to the screen.\n\n```python\nfor line in open(\"myfile.txt\"):\n    print(line, end=\"\")\n```\n\nThe problem with this code is that it leaves the file open for an indeterminate\namount of time after this part of the code has finished executing.\nThis is not an issue in simple scripts, but can be a problem for larger\napplications. The with statement allows objects like files to be\nused in a way that ensures they are always cleaned up promptly and correctly.\n\n```python\nwith open(\"myfile.txt\") as f:\n    for line in f:\n        print(line, end=\"\")\n```\n\nAfter the statement is executed, the file f is always closed, even if a\nproblem was encountered while processing the lines. Objects which, like files,\nprovide predefined clean-up actions will indicate this in their documentation.\n\n## 8.9.Raising and Handling Multiple Unrelated ExceptionsÂ¶\n\nThere are situations where it is necessary to report several exceptions that\nhave occurred. This is often the case in concurrency frameworks, when several\ntasks may have failed in parallel, but there are also other use cases where\nit is desirable to continue execution and collect multiple errors rather than\nraise the first exception.\n\nThe builtin ExceptionGroup wraps a list of exception instances so\nthat they can be raised together. It is an exception itself, so it can be\ncaught like any other exception.\n\n```python\n>>> def f():\n...     excs = [OSError('error 1'), SystemError('error 2')]\n...     raise ExceptionGroup('there were problems', excs)\n...\n>>> f()\n  + Exception Group Traceback (most recent call last):\n  |   File \"<stdin>\", line 1, in <module>\n  |     f()\n  |     ~^^\n  |   File \"<stdin>\", line 3, in f\n  |     raise ExceptionGroup('there were problems', excs)\n  | ExceptionGroup: there were problems (2 sub-exceptions)\n  +-+---------------- 1 ----------------\n    | OSError: error 1\n    +---------------- 2 ----------------\n    | SystemError: error 2\n    +------------------------------------\n>>> try:\n...     f()\n... except Exception as e:\n...     print(f'caught {type(e)}: e')\n...\ncaught <class 'ExceptionGroup'>: e\n>>>\n```\n\nBy using except* instead of except , we can selectively\nhandle only the exceptions in the group that match a certain\ntype. In the following example, which shows a nested exception\ngroup, each except* clause extracts from the group exceptions\nof a certain type while letting all other exceptions propagate to\nother clauses and eventually to be reraised.\n\n```python\n>>> def f():\n...     raise ExceptionGroup(\n...         \"group1\",\n...         [\n...             OSError(1),\n...             SystemError(2),\n...             ExceptionGroup(\n...                 \"group2\",\n...                 [\n...                     OSError(3),\n...                     RecursionError(4)\n...                 ]\n...             )\n...         ]\n...     )\n...\n>>> try:\n...     f()\n... except* OSError as e:\n...     print(\"There were OSErrors\")\n... except* SystemError as e:\n...     print(\"There were SystemErrors\")\n...\nThere were OSErrors\nThere were SystemErrors\n  + Exception Group Traceback (most recent call last):\n  |   File \"<stdin>\", line 2, in <module>\n  |     f()\n  |     ~^^\n  |   File \"<stdin>\", line 2, in f\n  |     raise ExceptionGroup(\n  |     ...<12 lines>...\n  |     )\n  | ExceptionGroup: group1 (1 sub-exception)\n  +-+---------------- 1 ----------------\n    | ExceptionGroup: group2 (1 sub-exception)\n    +-+---------------- 1 ----------------\n      | RecursionError: 4\n      +------------------------------------\n>>>\n```\n\nNote that the exceptions nested in an exception group must be instances,\nnot types. This is because in practice the exceptions would typically\nbe ones that have already been raised and caught by the program, along\nthe following pattern:\n\n```python\n>>> excs = []\n... for test in tests:\n...     try:\n...         test.run()\n...     except Exception as e:\n...         excs.append(e)\n...\n>>> if excs:\n...    raise ExceptionGroup(\"Test Failures\", excs)\n...\n```\n\n## 8.10.Enriching Exceptions with NotesÂ¶\n\nWhen an exception is created in order to be raised, it is usually initialized\nwith information that describes the error that has occurred. There are cases\nwhere it is useful to add information after the exception was caught. For this\npurpose, exceptions have a method add_note(note) that accepts a string and\nadds it to the exceptionâs notes list. The standard traceback rendering\nincludes all notes, in the order they were added, after the exception.\n\n```python\n>>> try:\n...     raise TypeError('bad type')\n... except Exception as e:\n...     e.add_note('Add some information')\n...     e.add_note('Add some more information')\n...     raise\n...\nTraceback (most recent call last):\n  File \"<stdin>\", line 2, in <module>\n    raise TypeError('bad type')\nTypeError: bad type\nAdd some information\nAdd some more information\n>>>\n```\n\nFor example, when collecting exceptions into an exception group, we may want\nto add context information for the individual errors. In the following each\nexception in the group has a note indicating when this error has occurred.\n\n```python\n>>> def f():\n...     raise OSError('operation failed')\n...\n>>> excs = []\n>>> for i in range(3):\n...     try:\n...         f()\n...     except Exception as e:\n...         e.add_note(f'Happened in Iteration {i+1}')\n...         excs.append(e)\n...\n>>> raise ExceptionGroup('We have some problems', excs)\n  + Exception Group Traceback (most recent call last):\n  |   File \"<stdin>\", line 1, in <module>\n  |     raise ExceptionGroup('We have some problems', excs)\n  | ExceptionGroup: We have some problems (3 sub-exceptions)\n  +-+---------------- 1 ----------------\n    | Traceback (most recent call last):\n    |   File \"<stdin>\", line 3, in <module>\n    |     f()\n    |     ~^^\n    |   File \"<stdin>\", line 2, in f\n    |     raise OSError('operation failed')\n    | OSError: operation failed\n    | Happened in Iteration 1\n    +---------------- 2 ----------------\n    | Traceback (most recent call last):\n    |   File \"<stdin>\", line 3, in <module>\n    |     f()\n    |     ~^^\n    |   File \"<stdin>\", line 2, in f\n    |     raise OSError('operation failed')\n    | OSError: operation failed\n    | Happened in Iteration 2\n    +---------------- 3 ----------------\n    | Traceback (most recent call last):\n    |   File \"<stdin>\", line 3, in <module>\n    |     f()\n    |     ~^^\n    |   File \"<stdin>\", line 2, in f\n    |     raise OSError('operation failed')\n    | OSError: operation failed\n    | Happened in Iteration 3\n    +------------------------------------\n>>>\n```",
  "type": "tutorial",
  "concept_tags": [
    "exceptions",
    "debugging",
    "error_handling"
  ],
  "difficulty": "intro",
  "metadata": {
    "language": "en",
    "domain": "programming/python",
    "retrieved_at": "2026-02-24",
    "intended_use": "educational corpus",
    "source": "python_docs"
  },
  "provenance": {
    "url": "https://docs.python.org/3/tutorial/errors.html",
    "license": "PSF Documentation License",
    "attribution": "Python Software Foundation",
    "retrieved_at": "2026-02-24"
  },
  "ai_generated": false,
  "doc_id": "scraped-https-docs-python-org-3-tutorial-errors-html-418c6ed6"
}