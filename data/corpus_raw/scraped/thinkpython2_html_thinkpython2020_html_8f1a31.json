{
  "title": "Chapter 19  The Goodies",
  "content": "Buy this book at Amazon.com Chapter 19  The Goodies One of my goals for this book has been to teach you as little Python\nas possible. When there were two ways to do something, I picked \none and avoided mentioning the other. Or sometimes I put the second\none into an exercise. Now I want to go back for some of the good bits that got left behind.\nPython provides a number of features that are not really necessary—you\ncan write good code without them—but with them you can sometimes\nwrite code that’s more concise, readable or efficient, and sometimes\nall three. 19.1  Conditional expressions We saw conditional statements in Section 5.4 .\nConditional statements are often used to choose one of two values;\nfor example: if x > 0:\n    y = math.log(x)\nelse:\n    y = float('nan') This statement checks whether x is positive. If so, it computes math.log . If not, math.log would raise a ValueError. To\navoid stopping the program, we generate a “NaN”, which is a special\nfloating-point value that represents “Not a Number”. We can write this statement more concisely using a conditional\nexpression : y = math.log(x) if x > 0 else float('nan') You can almost read this line like English: “ y gets log- x if x is greater than 0; otherwise it gets NaN”. Recursive functions can sometimes be rewritten using conditional\nexpressions. For example, here is a recursive version of factorial : def factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1) We can rewrite it like this: def factorial(n):\n    return 1 if n == 0 else n * factorial(n-1) Another use of conditional expressions is handling optional\narguments. For example, here is the init method from GoodKangaroo (see Exercise 2 ): def __init__(self, name, contents=None):\n        self.name = name\n        if contents == None:\n            contents = []\n        self.pouch_contents = contents We can rewrite this one like this: def __init__(self, name, contents=None):\n        self.name = name\n        self.pouch_contents = [] if contents == None else contents In general, you can replace a conditional statement with a conditional\nexpression if both branches contain simple expressions that are\neither returned or assigned to the same variable. 19.2  List comprehensions In Section 10.7 we saw the map and filter patterns. For\nexample, this function takes a list of strings, maps the string method capitalize to the elements, and returns a new list of strings: def capitalize_all(t):\n    res = []\n    for s in t:\n        res.append(s.capitalize())\n    return res We can write this more concisely using a list comprehension : def capitalize_all(t):\n    return [s.capitalize() for s in t] The bracket operators indicate that we are constructing a new\nlist. The expression inside the brackets specifies the elements\nof the list, and the for clause indicates what sequence\nwe are traversing. The syntax of a list comprehension is a little awkward because\nthe loop variable, s in this example, appears in the expression\nbefore we get to the definition. List comprehensions can also be used for filtering. For example,\nthis function selects only the elements of t that are\nupper case, and returns a new list: def only_upper(t):\n    res = []\n    for s in t:\n        if s.isupper():\n            res.append(s)\n    return res We can rewrite it using a list comprehension def only_upper(t):\n    return [s for s in t if s.isupper()] List comprehensions are concise and easy to read, at least for simple\nexpressions. And they are usually faster than the equivalent for\nloops, sometimes much faster. So if you are mad at me for not\nmentioning them earlier, I understand. But, in my defense, list comprehensions are harder to debug because\nyou can’t put a print statement inside the loop. I suggest that you\nuse them only if the computation is simple enough that you are likely\nto get it right the first time. And for beginners that means never. 19.3  Generator expressions Generator expressions are similar to list comprehensions, but\nwith parentheses instead of square brackets: >>> g = (x**2 for x in range(5))\n>>> g\n<generator object <genexpr> at 0x7f4c45a786c0> The result is a generator object that knows how to iterate through\na sequence of values. But unlike a list comprehension, it does not\ncompute the values all at once; it waits to be asked. The built-in\nfunction next gets the next value from the generator: >>> next(g)\n0\n>>> next(g)\n1 When you get to the end of the sequence, next raises a \nStopIteration exception. You can also use a for loop to iterate\nthrough the values: >>> for val in g:\n...     print(val)\n4\n9\n16 The generator object keeps track of where it is in the sequence,\nso the for loop picks up where next left off. Once the\ngenerator is exhausted, it continues to raise StopIteration : >>> next(g)\nStopIteration Generator expressions are often used with functions like sum , max , and min : >>> sum(x**2 for x in range(5))\n30 19.4 any and all Python provides a built-in function, any , that takes a sequence\nof boolean values and returns True if any of the values are True . It works on lists: >>> any([False, False, True])\nTrue But it is often used with generator expressions: >>> any(letter == 't' for letter in 'monty')\nTrue That example isn’t very useful because it does the same thing\nas the in operator. But we could use any to rewrite\nsome of the search functions we wrote in Section 9.3 . For\nexample, we could write avoids like this: def avoids(word, forbidden):\n    return not any(letter in forbidden for letter in word) The function almost reads like English, “ word avoids forbidden if there are not any forbidden letters in word .” Using any with a generator expression is efficient because\nit stops immediately if it finds a True value,\nso it doesn’t have to evaluate the whole sequence. Python provides another built-in function, all , that returns True if every element of the sequence is True . As\nan exercise, use all to re-write uses_all from\nSection 9.3 . 19.5  Sets In Section 13.6 I use dictionaries to find the words\nthat appear in a document but not in a word list. The function\nI wrote takes d1 , which contains the words from the document\nas keys, and d2 , which contains the list of words. It\nreturns a dictionary that contains the keys from d1 that\nare not in d2 . def subtract(d1, d2):\n    res = dict()\n    for key in d1:\n        if key not in d2:\n            res[key] = None\n    return res In all of these dictionaries, the values are None because\nwe never use them. As a result, we waste some storage space. Python provides another built-in type, called a set , that\nbehaves like a collection of dictionary keys with no values. Adding\nelements to a set is fast; so is checking membership. And sets\nprovide methods and operators to compute common set operations. For example, set subtraction is available as a method called difference or as an operator, - . So we can rewrite subtract like this: def subtract(d1, d2):\n    return set(d1) - set(d2) The result is a set instead of a dictionary, but for operations like\niteration, the behavior is the same. Some of the exercises in this book can be done concisely and\nefficiently with sets. For example, here is a solution to has_duplicates , from\nExercise 7 , that uses a dictionary: def has_duplicates(t):\n    d = {}\n    for x in t:\n        if x in d:\n            return True\n        d[x] = True\n    return False When an element appears for the first time, it is added to the\ndictionary. If the same element appears again, the function returns True . Using sets, we can write the same function like this: def has_duplicates(t):\n    return len(set(t)) < len(t) An element can only appear in a set once, so if an element in t appears more than once, the set will be smaller than t . If there\nare no duplicates, the set will be the same size as t . We can also use sets to do some of the exercises in\nChapter 9 . For example, here’s a version of uses_only with a loop: def uses_only(word, available):\n    for letter in word: \n        if letter not in available:\n            return False\n    return True uses_only checks whether all letters in word are\nin available . We can rewrite it like this: def uses_only(word, available):\n    return set(word) <= set(available) The <= operator checks whether one set is a subset of another,\nincluding the possibility that they are equal, which is true if all\nthe letters in word appear in available . As an exercise, rewrite avoids using sets. 19.6  Counters A Counter is like a set, except that if an element appears more\nthan once, the Counter keeps track of how many times it appears.\nIf you are familiar with the mathematical idea of a multiset ,\na Counter is a natural way to represent a multiset. Counter is defined in a standard module called collections ,\nso you have to import it. You can initialize a Counter with a string,\nlist, or anything else that supports iteration: >>> from collections import Counter\n>>> count = Counter('parrot')\n>>> count\nCounter({'r': 2, 't': 1, 'o': 1, 'p': 1, 'a': 1}) Counters behave like dictionaries in many ways; they map from each\nkey to the number of times it appears. As in dictionaries,\nthe keys have to be hashable. Unlike dictionaries, Counters don’t raise an exception if you access\nan element that doesn’t appear. Instead, they return 0: >>> count['d']\n0 We can use Counters to rewrite is_anagram from\nExercise 6 : def is_anagram(word1, word2):\n    return Counter(word1) == Counter(word2) If two words are anagrams, they contain the same letters with the same\ncounts, so their Counters are equivalent. Counters provide methods and operators to perform set-like operations,\nincluding addition, subtraction, union and intersection. And\nthey provide an often-useful method, most_common , which\nreturns a list of value-frequency pairs, sorted from most common to\nleast: >>> count = Counter('parrot')\n>>> for val, freq in count.most_common(3):\n...     print(val, freq)\nr 2\np 1\na 1 19.7  defaultdict The collections module also provides defaultdict , which is\nlike a dictionary except that if you access a key that doesn’t exist,\nit can generate a new value on the fly. When you create a defaultdict, you provide a function that’s used to\ncreate new values. A function used to create objects is sometimes\ncalled a factory . The built-in functions that create lists, sets,\nand other types can be used as factories: >>> from collections import defaultdict\n>>> d = defaultdict(list) Notice that the argument is list , which is a class object,\nnot list() , which is a new list. The function you provide\ndoesn’t get called unless you access a key that doesn’t exist. >>> t = d['new key']\n>>> t\n[] The new list, which we’re calling t , is also added to the\ndictionary. So if we modify t , the change appears in d : >>> t.append('new value')\n>>> d\ndefaultdict(<class 'list'>, {'new key': ['new value']}) If you are making a dictionary of lists, you can often write simpler\ncode using defaultdict . In my solution to\nExercise 2 , which you can get from https://thinkpython.com/code/anagram_sets.py , I make a\ndictionary that maps from a sorted string of letters to the list of\nwords that can be spelled with those letters. For example, ’opst’ maps to the list [’opts’, ’post’, ’pots’, ’spot’,\n’stop’, ’tops’] . Here’s the original code: def all_anagrams(filename):\n    d = {}\n    for line in open(filename):\n        word = line.strip().lower()\n        t = signature(word)\n        if t not in d:\n            d[t] = [word]\n        else:\n            d[t].append(word)\n    return d This can be simplified using setdefault , which you might\nhave used in Exercise 2 : def all_anagrams(filename):\n    d = {}\n    for line in open(filename):\n        word = line.strip().lower()\n        t = signature(word)\n        d.setdefault(t, []).append(word)\n    return d This solution has the drawback that it makes a new list\nevery time, regardless of whether it is needed. For lists,\nthat’s no big deal, but if the factory\nfunction is complicated, it might be. We can avoid this problem and \nsimplify the code using a defaultdict : def all_anagrams(filename):\n    d = defaultdict(list)\n    for line in open(filename):\n        word = line.strip().lower()\n        t = signature(word)\n        d[t].append(word)\n    return d My solution to Exercise 3 , which you can download from https://thinkpython.com/code/PokerHandSoln.py ,\nuses setdefault in the function has_straightflush . This solution has the drawback\nof creating a Hand object every time through the loop, whether\nit is needed or not. As an exercise, rewrite it using\na defaultdict. 19.8  Named tuples Many simple objects are basically collections of related values.\nFor example, the Point object defined in Chapter 15 contains\ntwo numbers, x and y . When you define a class like\nthis, you usually start with an init method and a str method: class Point:\n\n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n\n    def __str__(self):\n        return '(%g, %g)' % (self.x, self.y) This is a lot of code to convey a small amount of information.\nPython provides a more concise way to say the same thing: from collections import namedtuple\nPoint = namedtuple('Point', ['x', 'y']) The first argument is the name of the class you want to create.\nThe second is a list of the attributes Point objects should have,\nas strings. The return value from namedtuple is a class object: >>> Point\n<class '__main__.Point'> Point automatically provides methods like __init__ and __str__ so you don’t have to write them. To create a Point object, you use the Point class as a function: >>> p = Point(1, 2)\n>>> p\nPoint(x=1, y=2) The init method assigns the arguments to attributes using the names\nyou provided. The str method prints a representation of the Point\nobject and its attributes. You can access the elements of the named tuple by name: >>> p.x, p.y\n(1, 2) But you can also treat a named tuple as a tuple: >>> p[0], p[1]\n(1, 2)\n\n>>> x, y = p\n>>> x, y\n(1, 2) Named tuples provide a quick way to define simple classes.\nThe drawback is that simple classes don’t always stay simple.\nYou might decide later that you want to add methods to a named tuple.\nIn that case, you could define a new class that inherits from\nthe named tuple: class Pointier(Point):\n    # add more methods here Or you could switch to a conventional class definition. 19.9  Gathering keyword args In Section 12.4 , we saw how to write a function that\ngathers its arguments into a tuple: def printall(*args):\n    print(args) You can call this function with any number of positional arguments\n(that is, arguments that don’t have keywords): >>> printall(1, 2.0, '3')\n(1, 2.0, '3') But the * operator doesn’t gather keyword arguments: >>> printall(1, 2.0, third='3')\nTypeError: printall() got an unexpected keyword argument 'third' To gather keyword arguments, you can use the ** operator: def printall(*args, **kwargs):\n    print(args, kwargs) You can call the keyword gathering parameter anything you want, but kwargs is a common choice. The result is a dictionary that maps\nfrom keywords to values: >>> printall(1, 2.0, third='3')\n(1, 2.0) {'third': '3'} If you have a dictionary of keywords and values, you can use the\nscatter operator, ** to call a function: >>> d = dict(x=1, y=2)\n>>> Point(**d)\nPoint(x=1, y=2) Without the scatter operator, the function would treat d as\na single positional argument, so it would assign d to x and complain because there’s nothing to assign to y : >>> d = dict(x=1, y=2)\n>>> Point(d)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: __new__() missing 1 required positional argument: 'y' When you are working with functions that have a large number of\nparameters, it is often useful to create and pass around dictionaries\nthat specify frequently used options. 19.10  Glossary conditional expression: An expression that has one of two\nvalues, depending on a condition. list comprehension: An expression with a for loop in square\nbrackets that yields a new list. generator expression: An expression with a for loop in parentheses\nthat yields a generator object. multiset: A mathematical entity that represents a mapping\nbetween the elements of a set and the number of times they appear. factory: A function, usually passed as a parameter, used to\ncreate objects. 19.11  Exercises Exercise 1 The following is a function that computes the binomial\ncoefficient recursively. def binomial_coeff(n, k):\n    \"\"\"Compute the binomial coefficient \"n choose k\".\n\n    n: number of trials\n    k: number of successes\n\n    returns: int\n    \"\"\"\n    if k == 0:\n        return 1\n    if n == 0:\n        return 0\n\n    res = binomial_coeff(n-1, k) + binomial_coeff(n-1, k-1)\n    return res Rewrite the body of the function using nested conditional\nexpressions. One note: this function is not very efficient because it ends up computing\nthe same values over and over. You could make it more efficient by\nmemoizing (see Section 11.6 ). But you will find that it’s harder to\nmemoize if you write it using conditional expressions. Buy this book at Amazon.com\n\n#### Contribute\n\nIf you would like to make a contribution to support my books,\nyou can use the button below and pay with PayPal.  Thank you!\nPay what you want:\nSmall $1.00 USD\nMedium $5.00 USD\nLarge $10.00 USD\nX-Large $20.00 USD\nXX-Large $50.00 USD\nAre you using one of our books in a class? We'd like to know\nabout it.  Please consider filling out this short survey . Think DSP Think Java Think Bayes Think Python 2e Think Stats 2e Think Complexity",
  "type": "tutorial",
  "concept_tags": [
    "debugging",
    "error_handling",
    "common_errors"
  ],
  "difficulty": "intro",
  "metadata": {
    "language": "en",
    "domain": "programming/python",
    "retrieved_at": "2026-02-24",
    "intended_use": "educational corpus",
    "source": "think_python"
  },
  "provenance": {
    "url": "https://greenteapress.com/thinkpython2/html/thinkpython2020.html",
    "license": "CC BY-NC 3.0",
    "attribution": "Allen B. Downey, greenteapress.com",
    "retrieved_at": "2026-02-24"
  },
  "ai_generated": false,
  "doc_id": "scraped-https-greenteapress-com-thinkpython2-html-thinkpython2020-ht-8f1a3121"
}