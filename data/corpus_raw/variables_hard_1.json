{
  "title": "Python variable binding and scope: blocks, locals, free variables, globals, and nonlocal",
  "content": "This section builds a solid mental model for *where variable names live* and *how Python decides what a name refers to*. This is one of the most important “hard” topics because the rules are determined by the **structure of the code block**, not by types or declarations.\n\n---\n## 1) Names, objects, and binding\nA **name** (variable) refers to an **object**. A **binding operation** creates or updates that relationship.\n\nTypical binding operations include:\n- assignment (`x = ...`)\n- function definitions (`def f(...): ...` binds `f`)\n- imports (`import math` binds `math`)\n- loop targets (`for i in ...` binds `i`)\n- exception targets (`except Exception as e` binds `e`)\n\n```python\nx = 10\n\ndef demo_bindings():\n    y = 1\n    for i in range(3):\n        pass\n    try:\n        1 / 0\n    except Exception as e:\n        pass\n    import math\n    return y, i, e, math\n\nprint(x)\nprint(demo_bindings())\n```\n\n---\n## 2) Blocks and scope boundaries\nA **block** is code executed as a unit. The most common blocks are:\n- a module (top-level of a file)\n- a function body\n- a class body\n\nEach block has rules about where bindings go.\n\n### Module (global) scope\nNames assigned at top-level become module globals.\n\n```python\n# module scope\nA = 1\nB = 2\nprint(A + B)\n```\n\n### Function (local) scope\nNames bound inside a function are local to that function (unless declared otherwise).\n\n```python\nX = \"global\"\n\ndef f():\n    X_local = \"local\"\n    return X, X_local\n\nprint(f())\n```\n\n---\n## 3) Free variables and closures\nNested functions can *read* names from enclosing scopes. When an inner function uses a name that is not local to it, that name is a **free variable**.\n\n```python\ndef make_adder(n):\n    # n is in the enclosing scope of add()\n    def add(x):\n        return x + n\n    return add\n\nadd5 = make_adder(5)\nprint(add5(10))  # 15\n```\n\n---\n## 4) Rebinding outer names: global vs nonlocal\nReading an outer variable is typically fine. **Rebinding** (assigning) is where you need explicit declarations.\n\n### 4a) global: rebind a module-level name\n\n```python\ncounter = 0\n\ndef bump():\n    global counter\n    counter += 1\n\nbump(); bump(); bump()\nprint(counter)  # 3\n```\n\n### 4b) nonlocal: rebind an enclosing function’s name\n\n```python\ndef make_counter():\n    count = 0\n\n    def inc():\n        nonlocal count\n        count += 1\n        return count\n\n    return inc\n\nc = make_counter()\nprint(c(), c(), c())  # 1 2 3\n```\n\n---\n## 5) A dense example: multiple scopes interacting\nThis example mixes global reads, enclosing reads, and nonlocal rebinding.\n\n```python\nGLOBAL = 100\n\ndef factory(scale):\n    base = 10\n\n    def compute(x):\n        # GLOBAL is read from module scope\n        # base is read from enclosing scope\n        return (GLOBAL + base + x) * scale\n\n    def tweak(delta):\n        nonlocal base\n        base += delta\n        return base\n\n    return compute, tweak\n\ncompute, tweak = factory(2)\nprint(compute(1))  # (100+10+1)*2 = 222\nprint(tweak(5))    # base becomes 15\nprint(compute(1))  # (100+15+1)*2 = 232\n```\n\n---\n## 6) Practical tips\n- Prefer **return values** over globals for most application code.\n- Use `nonlocal` sparingly (it’s powerful, but can make flows harder to follow).\n- When debugging scope issues, try printing values from each scope or refactor into smaller pure functions.\n",
  "type": "reference",
  "concept_tags": ["variables", "scope", "binding", "blocks", "free-variables", "closures", "global", "nonlocal"],
  "difficulty": "hard",
  "metadata": {
    "language": "en",
    "domain": "programming/python",
    "retrieved_at": "2026-02-09",
    "intended_use": "educational corpus",
    "chunking_hints": ["many medium code blocks", "multiple binding constructs", "closure + nonlocal example", "dense multi-scope script"]
  },
  "provenance": {
    "url": "https://docs.python.org/3/reference/executionmodel.html",
    "license": "PSF Documentation License (Python docs)",
    "attribution": "Python Software Foundation / Python Documentation Contributors",
    "retrieved_at": "2026-02-09"
  },
  "ai_generated": false
}
