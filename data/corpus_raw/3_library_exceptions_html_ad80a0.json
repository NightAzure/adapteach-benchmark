{
  "title": "Built-in ExceptionsÂ¶",
  "content": "# Built-in ExceptionsÂ¶\n\nIn Python, all exceptions must be instances of a class that derives from BaseException .  In a try statement with an except clause that mentions a particular class, that clause also handles any exception\nclasses derived from that class (but not exception classes from which it is\nderived).  Two exception classes that are not related via subclassing are never\nequivalent, even if they have the same name.\n\nThe built-in exceptions listed in this chapter can be generated by the interpreter or\nbuilt-in functions.  Except where mentioned, they have an âassociated valueâ\nindicating the detailed cause of the error.  This may be a string or a tuple of\nseveral items of information (e.g., an error code and a string explaining the\ncode).  The associated value is usually passed as arguments to the exception\nclassâs constructor.\n\nUser code can raise built-in exceptions.  This can be used to test an exception\nhandler or to report an error condition âjust likeâ the situation in which the\ninterpreter raises the same exception; but beware that there is nothing to\nprevent user code from raising an inappropriate error.\n\nThe built-in exception classes can be subclassed to define new exceptions;\nprogrammers are encouraged to derive new exceptions from the Exception class or one of its subclasses, and not from BaseException .  More\ninformation on defining exceptions is available in the Python Tutorial under User-defined Exceptions .\n\n## Exception contextÂ¶\n\nThree attributes on exception objects provide information about the context in\nwhich the exception was raised:\n\nBaseException.\n__context__\nÂ¶\nBaseException.\n__cause__\nÂ¶\nBaseException.\n__suppress_context__\nÂ¶\nWhen raising a new exception while another exception\nis already being handled, the new exceptionâs __context__ attribute is automatically set to the handled\nexception.  An exception may be handled when an except or finally clause, or a with statement, is used.\n\nThis implicit exception context can be\nsupplemented with an explicit cause by using from with raise :\n\n```python\nraise new_exc from original_exc\n```\n\nThe expression following from must be an exception or None . It\nwill be set as __cause__ on the raised exception. Setting __cause__ also implicitly sets the __suppress_context__ attribute to True , so that using raise new_exc from None effectively replaces the old exception with the new one for display\npurposes (e.g. converting KeyError to AttributeError ), while\nleaving the old exception available in __context__ for introspection\nwhen debugging.\n\nThe default traceback display code shows these chained exceptions in\naddition to the traceback for the exception itself. An explicitly chained\nexception in __cause__ is always shown when present. An implicitly\nchained exception in __context__ is shown only if __cause__ is None and __suppress_context__ is false.\n\nIn either case, the exception itself is always shown after any chained\nexceptions so that the final line of the traceback always shows the last\nexception that was raised.\n\n## Inheriting from built-in exceptionsÂ¶\n\nUser code can create subclasses that inherit from an exception type.\nItâs recommended to only subclass one exception type at a time to avoid\nany possible conflicts between how the bases handle the args attribute, as well as due to possible memory layout incompatibilities.\n\nCPython implementation detail: Most built-in exceptions are implemented in C for efficiency, see: Objects/exceptions.c .  Some have custom memory layouts\nwhich makes it impossible to create a subclass that inherits from\nmultiple exception types. The memory layout of a type is an implementation\ndetail and might change between Python versions, leading to new\nconflicts in the future.  Therefore, itâs recommended to avoid\nsubclassing multiple exception types altogether.\n\n## Base classesÂ¶\n\nThe following exceptions are used mostly as base classes for other exceptions.\n\nexception\nBaseException\nÂ¶\nThe base class for all built-in exceptions.  It is not meant to be directly\ninherited by user-defined classes (for that, use Exception ).  If str() is called on an instance of this class, the representation of\nthe argument(s) to the instance are returned, or the empty string when\nthere were no arguments.\n\nargs\nÂ¶\nThe tuple of arguments given to the exception constructor.  Some built-in\nexceptions (like OSError ) expect a certain number of arguments and\nassign a special meaning to the elements of this tuple, while others are\nusually called only with a single string giving an error message.\n\nwith_traceback\n(\ntb\n)\nÂ¶\nThis method sets tb as the new traceback for the exception and returns\nthe exception object.  It was more commonly used before the exception\nchaining features of PEP 3134 became available.  The following example\nshows how we can convert an instance of SomeException into an\ninstance of OtherException while preserving the traceback.  Once\nraised, the current frame is pushed onto the traceback of the OtherException , as would have happened to the traceback of the\noriginal SomeException had we allowed it to propagate to the caller.\n\n```python\ntry:\n    ...\nexcept SomeException:\n    tb = sys.exception().__traceback__\n    raise OtherException(...).with_traceback(tb)\n```\n\n__traceback__\nÂ¶\nA writable field that holds the traceback object associated with this\nexception. See also: The raise statement .\n\nadd_note\n(\nnote\n)\nÂ¶\nAdd the string note to the exceptionâs notes which appear in the standard\ntraceback after the exception string. A TypeError is raised if note is not a string.\n\nAdded in version 3.11.\n\n__notes__\nÂ¶\nA list of the notes of this exception, which were added with add_note() .\nThis attribute is created when add_note() is called.\n\nAdded in version 3.11.\n\nexception\nException\nÂ¶\nAll built-in, non-system-exiting exceptions are derived from this class.  All\nuser-defined exceptions should also be derived from this class.\n\nexception\nArithmeticError\nÂ¶\nThe base class for those built-in exceptions that are raised for various\narithmetic errors: OverflowError , ZeroDivisionError , FloatingPointError .\n\nexception\nBufferError\nÂ¶\nRaised when a buffer related operation cannot be\nperformed.\n\nexception\nLookupError\nÂ¶\nThe base class for the exceptions that are raised when a key or index used on\na mapping or sequence is invalid: IndexError , KeyError .  This\ncan be raised directly by codecs.lookup() .\n\n## Concrete exceptionsÂ¶\n\nThe following exceptions are the exceptions that are usually raised.\n\nexception\nAssertionError\nÂ¶\nRaised when an assert statement fails.\n\nexception\nAttributeError\nÂ¶\nRaised when an attribute reference (see Attribute references ) or\nassignment fails.  (When an object does not support attribute references or\nattribute assignments at all, TypeError is raised.)\n\nThe optional name and obj keyword-only arguments\nset the corresponding attributes:\n\nname\nÂ¶\nThe name of the attribute that was attempted to be accessed.\n\nobj\nÂ¶\nThe object that was accessed for the named attribute.\n\nChanged in version 3.10: Added the name and obj attributes.\n\nexception\nEOFError\nÂ¶\nRaised when the input() function hits an end-of-file condition (EOF)\nwithout reading any data. (Note: the io.IOBase.read() and io.IOBase.readline() methods return an empty string when they hit EOF.)\n\nexception\nFloatingPointError\nÂ¶\nNot currently used.\n\nexception\nGeneratorExit\nÂ¶\nRaised when a generator or coroutine is closed;\nsee generator.close() and coroutine.close() .  It\ndirectly inherits from BaseException instead of Exception since\nit is technically not an error.\n\nexception\nImportError\nÂ¶\nRaised when the import statement has troubles trying to\nload a module.  Also raised when the âfrom listâ in from ... import has a name that cannot be found.\n\nThe optional name and path keyword-only arguments\nset the corresponding attributes:\n\nname\nÂ¶\nThe name of the module that was attempted to be imported.\n\npath\nÂ¶\nThe path to any file which triggered the exception.\n\nChanged in version 3.3: Added the name and path attributes.\n\nexception\nModuleNotFoundError\nÂ¶\nA subclass of ImportError which is raised by import when a module could not be located.  It is also raised when None is found in sys.modules .\n\nAdded in version 3.6.\n\nexception\nIndexError\nÂ¶\nRaised when a sequence subscript is out of range.  (Slice indices are\nsilently truncated to fall in the allowed range; if an index is not an\ninteger, TypeError is raised.)\n\nexception\nKeyError\nÂ¶\nRaised when a mapping (dictionary) key is not found in the set of existing keys.\n\nexception\nKeyboardInterrupt\nÂ¶\nRaised when the user hits the interrupt key (normally Control - C or Delete ).  During execution, a check for interrupts is made\nregularly. The exception inherits from BaseException so as to not be\naccidentally caught by code that catches Exception and thus prevent\nthe interpreter from exiting.\n\nNote\n\nCatching a KeyboardInterrupt requires special consideration.\nBecause it can be raised at unpredictable points, it may, in some\ncircumstances, leave the running program in an inconsistent state. It is\ngenerally best to allow KeyboardInterrupt to end the program as\nquickly as possible or avoid raising it entirely. (See Note on Signal Handlers and Exceptions .)\n\nexception\nMemoryError\nÂ¶\nRaised when an operation runs out of memory but the situation may still be\nrescued (by deleting some objects).  The associated value is a string indicating\nwhat kind of (internal) operation ran out of memory. Note that because of the\nunderlying memory management architecture (Câs malloc() function), the\ninterpreter may not always be able to completely recover from this situation; it\nnevertheless raises an exception so that a stack traceback can be printed, in\ncase a run-away program was the cause.\n\nexception\nNameError\nÂ¶\nRaised when a local or global name is not found.  This applies only to\nunqualified names.  The associated value is an error message that includes the\nname that could not be found.\n\nThe optional name keyword-only argument sets the attribute:\n\nname\nÂ¶\nThe name of the variable that was attempted to be accessed.\n\nChanged in version 3.10: Added the name attribute.\n\nexception\nNotImplementedError\nÂ¶\nThis exception is derived from RuntimeError .  In user defined base\nclasses, abstract methods should raise this exception when they require\nderived classes to override the method, or while the class is being\ndeveloped to indicate that the real implementation still needs to be added.\n\nNote\n\nIt should not be used to indicate that an operator or method is not\nmeant to be supported at all â in that case either leave the operator /\nmethod undefined or, if a subclass, set it to None .\n\nCaution\n\nNotImplementedError and NotImplemented are not\ninterchangeable. This exception should only be used as described\nabove; see NotImplemented for details on correct usage of\nthe built-in constant.\n\nexception\nOSError\n(\n[\narg\n]\n)\nÂ¶\nexception\nOSError\n(\nerrno\n,\nstrerror\n[\n,\nfilename\n[\n,\nwinerror\n[\n,\nfilename2\n]\n]\n]\n)\nThis exception is raised when a system function returns a system-related\nerror, including I/O failures such as âfile not foundâ or âdisk fullâ\n(not for illegal argument types or other incidental errors).\n\nThe second form of the constructor sets the corresponding attributes,\ndescribed below.  The attributes default to None if not\nspecified.  For backwards compatibility, if three arguments are passed,\nthe args attribute contains only a 2-tuple\nof the first two constructor arguments.\n\nThe constructor often actually returns a subclass of OSError , as\ndescribed in OS exceptions below.  The particular subclass depends on\nthe final errno value.  This behaviour only occurs when\nconstructing OSError directly or via an alias, and is not\ninherited when subclassing.\n\nerrno\nÂ¶\nA numeric error code from the C variable errno .\n\nwinerror\nÂ¶\nUnder Windows, this gives you the native\nWindows error code.  The errno attribute is then an approximate\ntranslation, in POSIX terms, of that native error code.\n\nUnder Windows, if the winerror constructor argument is an integer,\nthe errno attribute is determined from the Windows error code,\nand the errno argument is ignored.  On other platforms, the winerror argument is ignored, and the winerror attribute\ndoes not exist.\n\nstrerror\nÂ¶\nThe corresponding error message, as provided by\nthe operating system.  It is formatted by the C\nfunctions perror() under POSIX, and FormatMessage() under Windows.\n\nfilename\nÂ¶\nfilename2\nÂ¶\nFor exceptions that involve a file system path (such as open() or os.unlink() ), filename is the file name passed to the function.\nFor functions that involve two file system paths (such as os.rename() ), filename2 corresponds to the second\nfile name passed to the function.\n\nChanged in version 3.3: EnvironmentError , IOError , WindowsError , socket.error , select.error and mmap.error have been merged into OSError , and the\nconstructor may return a subclass.\n\nChanged in version 3.4: The filename attribute is now the original file name passed to\nthe function, instead of the name encoded to or decoded from the filesystem encoding and error handler . Also, the filename2 constructor argument and attribute was added.\n\nexception\nOverflowError\nÂ¶\nRaised when the result of an arithmetic operation is too large to be\nrepresented.  This cannot occur for integers (which would rather raise MemoryError than give up).  However, for historical reasons,\nOverflowError is sometimes raised for integers that are outside a required\nrange.   Because of the lack of standardization of floating-point exception\nhandling in C, most floating-point operations are not checked.\n\nexception\nPythonFinalizationError\nÂ¶\nThis exception is derived from RuntimeError .  It is raised when\nan operation is blocked during interpreter shutdown also known as Python finalization .\n\nExamples of operations which can be blocked with a PythonFinalizationError during the Python finalization:\n\n- Creating a new Python thread.\n- Joining a running daemon thread.\n- os.fork() .\n\nSee also the sys.is_finalizing() function.\n\nAdded in version 3.13: Previously, a plain RuntimeError was raised.\n\nChanged in version 3.14: threading.Thread.join() can now raise this exception.\n\nexception\nRecursionError\nÂ¶\nThis exception is derived from RuntimeError .  It is raised when the\ninterpreter detects that the maximum recursion depth (see sys.getrecursionlimit() ) is exceeded.\n\nAdded in version 3.5: Previously, a plain RuntimeError was raised.\n\nexception\nReferenceError\nÂ¶\nThis exception is raised when a weak reference proxy, created by the weakref.proxy() function, is used to access an attribute of the referent\nafter it has been garbage collected. For more information on weak references,\nsee the weakref module.\n\nexception\nRuntimeError\nÂ¶\nRaised when an error is detected that doesnât fall in any of the other\ncategories.  The associated value is a string indicating what precisely went\nwrong.\n\nexception\nStopIteration\nÂ¶\nRaised by built-in function next() and an iterator 's __next__() method to signal that there are no further\nitems produced by the iterator.\n\nvalue\nÂ¶\nThe exception object has a single attribute value , which is\ngiven as an argument when constructing the exception, and defaults\nto None .\n\nWhen a generator or coroutine function\nreturns, a new StopIteration instance is\nraised, and the value returned by the function is used as the value parameter to the constructor of the exception.\n\nIf a generator code directly or indirectly raises StopIteration ,\nit is converted into a RuntimeError (retaining the StopIteration as the new exceptionâs cause).\n\nChanged in version 3.3: Added value attribute and the ability for generator functions to\nuse it to return a value.\n\nChanged in version 3.5: Introduced the RuntimeError transformation via from __future__ import generator_stop , see PEP 479 .\n\nChanged in version 3.7: Enable PEP 479 for all code by default: a StopIteration error raised in a generator is transformed into a RuntimeError .\n\nexception\nStopAsyncIteration\nÂ¶\nMust be raised by __anext__() method of an asynchronous iterator object to stop the iteration.\n\nAdded in version 3.5.\n\nexception\nSyntaxError\n(\nmessage\n,\ndetails\n)\nÂ¶\nRaised when the parser encounters a syntax error.  This may occur in an import statement, in a call to the built-in functions compile() , exec() ,\nor eval() , or when reading the initial script or standard input\n(also interactively).\n\nThe str() of the exception instance returns only the error message.\nDetails is a tuple whose members are also available as separate attributes.\n\nfilename\nÂ¶\nThe name of the file the syntax error occurred in.\n\nlineno\nÂ¶\nWhich line number in the file the error occurred in. This is\n1-indexed: the first line in the file has a lineno of 1.\n\noffset\nÂ¶\nThe column in the line where the error occurred. This is\n1-indexed: the first character in the line has an offset of 1.\n\ntext\nÂ¶\nThe source code text involved in the error.\n\nend_lineno\nÂ¶\nWhich line number in the file the error occurred ends in. This is\n1-indexed: the first line in the file has a lineno of 1.\n\nend_offset\nÂ¶\nThe column in the end line where the error occurred finishes. This is\n1-indexed: the first character in the line has an offset of 1.\n\nFor errors in f-string fields, the message is prefixed by âf-string: â\nand the offsets are offsets in a text constructed from the replacement\nexpression.  For example, compiling fâBad {a b} fieldâ results in this\nargs attribute: (âf-string: â¦â, (ââ, 1, 2, â(a b)nâ, 1, 5)).\n\nChanged in version 3.10: Added the end_lineno and end_offset attributes.\n\nexception\nIndentationError\nÂ¶\nBase class for syntax errors related to incorrect indentation.  This is a\nsubclass of SyntaxError .\n\nexception\nTabError\nÂ¶\nRaised when indentation contains an inconsistent use of tabs and spaces.\nThis is a subclass of IndentationError .\n\nexception\nSystemError\nÂ¶\nRaised when the interpreter finds an internal error, but the situation does not\nlook so serious to cause it to abandon all hope. The associated value is a\nstring indicating what went wrong (in low-level terms). In CPython ,\nthis could be raised by incorrectly using Pythonâs C API, such as returning\na NULL value without an exception set.\n\nIf youâre confident that this exception wasnât your fault, or the fault of\na package youâre using, you should report this to the author or maintainer\nof your Python interpreter.\nBe sure to report the version of the Python interpreter ( sys.version ; it is\nalso printed at the start of an interactive Python session), the exact error\nmessage (the exceptionâs associated value) and if possible the source of the\nprogram that triggered the error.\n\nexception\nSystemExit\nÂ¶\nThis exception is raised by the sys.exit() function.  It inherits from BaseException instead of Exception so that it is not accidentally\ncaught by code that catches Exception .  This allows the exception to\nproperly propagate up and cause the interpreter to exit.  When it is not\nhandled, the Python interpreter exits; no stack traceback is printed.  The\nconstructor accepts the same optional argument passed to sys.exit() .\nIf the value is an integer, it specifies the system exit status (passed to\nCâs exit() function); if it is None , the exit status is zero; if\nit has another type (such as a string), the objectâs value is printed and\nthe exit status is one.\n\nA call to sys.exit() is translated into an exception so that clean-up\nhandlers ( finally clauses of try statements) can be\nexecuted, and so that a debugger can execute a script without running the risk\nof losing control.  The os._exit() function can be used if it is\nabsolutely positively necessary to exit immediately (for example, in the child\nprocess after a call to os.fork() ).\n\ncode\nÂ¶\nThe exit status or error message that is passed to the constructor.\n(Defaults to None .)\n\nexception\nTypeError\nÂ¶\nRaised when an operation or function is applied to an object of inappropriate\ntype.  The associated value is a string giving details about the type mismatch.\n\nThis exception may be raised by user code to indicate that an attempted\noperation on an object is not supported, and is not meant to be. If an object\nis meant to support a given operation but has not yet provided an\nimplementation, NotImplementedError is the proper exception to raise.\n\nPassing arguments of the wrong type (e.g. passing a list when an int is expected) should result in a TypeError , but passing\narguments with the wrong value (e.g. a number outside expected boundaries)\nshould result in a ValueError .\n\nexception\nUnboundLocalError\nÂ¶\nRaised when a reference is made to a local variable in a function or method, but\nno value has been bound to that variable.  This is a subclass of NameError .\n\nexception\nUnicodeError\nÂ¶\nRaised when a Unicode-related encoding or decoding error occurs.  It is a\nsubclass of ValueError .\n\nUnicodeError has attributes that describe the encoding or decoding\nerror.  For example, err.object[err.start:err.end] gives the particular\ninvalid input that the codec failed on.\n\nencoding\nÂ¶\nThe name of the encoding that raised the error.\n\nreason\nÂ¶\nA string describing the specific codec error.\n\nobject\nÂ¶\nThe object the codec was attempting to encode or decode.\n\nstart\nÂ¶\nThe first index of invalid data in object .\n\nThis value should not be negative as it is interpreted as an\nabsolute offset but this constraint is not enforced at runtime.\n\nend\nÂ¶\nThe index after the last invalid data in object .\n\nThis value should not be negative as it is interpreted as an\nabsolute offset but this constraint is not enforced at runtime.\n\nexception\nUnicodeEncodeError\nÂ¶\nRaised when a Unicode-related error occurs during encoding.  It is a subclass of UnicodeError .\n\nexception\nUnicodeDecodeError\nÂ¶\nRaised when a Unicode-related error occurs during decoding.  It is a subclass of UnicodeError .\n\nexception\nUnicodeTranslateError\nÂ¶\nRaised when a Unicode-related error occurs during translating.  It is a subclass\nof UnicodeError .\n\nexception\nValueError\nÂ¶\nRaised when an operation or function receives an argument that has the\nright type but an inappropriate value, and the situation is not described by a\nmore precise exception such as IndexError .\n\nexception\nZeroDivisionError\nÂ¶\nRaised when the second argument of a division or modulo operation is zero.  The\nassociated value is a string indicating the type of the operands and the\noperation.\n\nThe following exceptions are kept for compatibility with previous versions;\nstarting from Python 3.3, they are aliases of OSError .\n\nexception\nEnvironmentError\nÂ¶\nexception\nIOError\nÂ¶\nexception\nWindowsError\nÂ¶\nOnly available on Windows.\n\n### OS exceptionsÂ¶\n\nThe following exceptions are subclasses of OSError , they get raised\ndepending on the system error code.\n\nexception\nBlockingIOError\nÂ¶\nRaised when an operation would block on an object (e.g. socket) set\nfor non-blocking operation.\nCorresponds to errno EAGAIN , EALREADY , EWOULDBLOCK and EINPROGRESS .\n\nIn addition to those of OSError , BlockingIOError can have\none more attribute:\n\ncharacters_written\nÂ¶\nAn integer containing the number of bytes written to the stream\nbefore it blocked. This attribute is available when using the\nbuffered I/O classes from the io module.\n\nexception\nChildProcessError\nÂ¶\nRaised when an operation on a child process failed.\nCorresponds to errno ECHILD .\n\nexception\nConnectionError\nÂ¶\nA base class for connection-related issues.\n\nSubclasses are BrokenPipeError , ConnectionAbortedError , ConnectionRefusedError and ConnectionResetError .\n\nexception\nBrokenPipeError\nÂ¶\nA subclass of ConnectionError , raised when trying to write on a\npipe while the other end has been closed, or trying to write on a socket\nwhich has been shutdown for writing.\nCorresponds to errno EPIPE and ESHUTDOWN .\n\nexception\nConnectionAbortedError\nÂ¶\nA subclass of ConnectionError , raised when a connection attempt\nis aborted by the peer.\nCorresponds to errno ECONNABORTED .\n\nexception\nConnectionRefusedError\nÂ¶\nA subclass of ConnectionError , raised when a connection attempt\nis refused by the peer.\nCorresponds to errno ECONNREFUSED .\n\nexception\nConnectionResetError\nÂ¶\nA subclass of ConnectionError , raised when a connection is\nreset by the peer.\nCorresponds to errno ECONNRESET .\n\nexception\nFileExistsError\nÂ¶\nRaised when trying to create a file or directory which already exists.\nCorresponds to errno EEXIST .\n\nexception\nFileNotFoundError\nÂ¶\nRaised when a file or directory is requested but doesnât exist.\nCorresponds to errno ENOENT .\n\nexception\nInterruptedError\nÂ¶\nRaised when a system call is interrupted by an incoming signal.\nCorresponds to errno EINTR .\n\nChanged in version 3.5: Python now retries system calls when a syscall is interrupted by a\nsignal, except if the signal handler raises an exception (see PEP 475 for the rationale), instead of raising InterruptedError .\n\nexception\nIsADirectoryError\nÂ¶\nRaised when a file operation (such as os.remove() ) is requested\non a directory.\nCorresponds to errno EISDIR .\n\nexception\nNotADirectoryError\nÂ¶\nRaised when a directory operation (such as os.listdir() ) is requested on\nsomething which is not a directory.  On most POSIX platforms, it may also be\nraised if an operation attempts to open or traverse a non-directory file as if\nit were a directory.\nCorresponds to errno ENOTDIR .\n\nexception\nPermissionError\nÂ¶\nRaised when trying to run an operation without the adequate access\nrights - for example filesystem permissions.\nCorresponds to errno EACCES , EPERM , and ENOTCAPABLE .\n\nChanged in version 3.11.1: WASIâs ENOTCAPABLE is now mapped to PermissionError .\n\nexception\nProcessLookupError\nÂ¶\nRaised when a given process doesnât exist.\nCorresponds to errno ESRCH .\n\nexception\nTimeoutError\nÂ¶\nRaised when a system function timed out at the system level.\nCorresponds to errno ETIMEDOUT .\n\nAdded in version 3.3: All the above OSError subclasses were added.\n\nSee also\n\nPEP 3151 - Reworking the OS and IO exception hierarchy\n\n## WarningsÂ¶\n\nThe following exceptions are used as warning categories; see the Warning Categories documentation for more details.\n\nexception\nWarning\nÂ¶\nBase class for warning categories.\n\nexception\nUserWarning\nÂ¶\nBase class for warnings generated by user code.\n\nexception\nDeprecationWarning\nÂ¶\nBase class for warnings about deprecated features when those warnings are\nintended for other Python developers.\n\nIgnored by the default warning filters, except in the __main__ module\n( PEP 565 ). Enabling the Python Development Mode shows\nthis warning.\n\nThe deprecation policy is described in PEP 387 .\n\nexception\nPendingDeprecationWarning\nÂ¶\nBase class for warnings about features which are obsolete and\nexpected to be deprecated in the future, but are not deprecated\nat the moment.\n\nThis class is rarely used as emitting a warning about a possible\nupcoming deprecation is unusual, and DeprecationWarning is preferred for already active deprecations.\n\nIgnored by the default warning filters. Enabling the Python\nDevelopment Mode shows this warning.\n\nThe deprecation policy is described in PEP 387 .\n\nexception\nSyntaxWarning\nÂ¶\nBase class for warnings about dubious syntax.\n\nThis warning is typically emitted when compiling Python source code, and usually wonât be reported\nwhen running already compiled code.\n\nexception\nRuntimeWarning\nÂ¶\nBase class for warnings about dubious runtime behavior.\n\nexception\nFutureWarning\nÂ¶\nBase class for warnings about deprecated features when those warnings are\nintended for end users of applications that are written in Python.\n\nexception\nImportWarning\nÂ¶\nBase class for warnings about probable mistakes in module imports.\n\nIgnored by the default warning filters. Enabling the Python\nDevelopment Mode shows this warning.\n\nexception\nUnicodeWarning\nÂ¶\nBase class for warnings related to Unicode.\n\nexception\nEncodingWarning\nÂ¶\nBase class for warnings related to encodings.\n\nSee Opt-in EncodingWarning for details.\n\nAdded in version 3.10.\n\nexception\nBytesWarning\nÂ¶\nBase class for warnings related to bytes and bytearray .\n\nexception\nResourceWarning\nÂ¶\nBase class for warnings related to resource usage.\n\nIgnored by the default warning filters. Enabling the Python\nDevelopment Mode shows this warning.\n\nAdded in version 3.2.\n\n## Exception groupsÂ¶\n\nThe following are used when it is necessary to raise multiple unrelated\nexceptions. They are part of the exception hierarchy so they can be\nhandled with except like all other exceptions. In addition,\nthey are recognised by except* , which matches\ntheir subgroups based on the types of the contained exceptions.\n\nexception\nExceptionGroup\n(\nmsg\n,\nexcs\n)\nÂ¶\nexception\nBaseExceptionGroup\n(\nmsg\n,\nexcs\n)\nÂ¶\nBoth of these exception types wrap the exceptions in the sequence excs .\nThe msg parameter must be a string. The difference between the two\nclasses is that BaseExceptionGroup extends BaseException and\nit can wrap any exception, while ExceptionGroup extends Exception and it can only wrap subclasses of Exception . This design is so that except Exception catches an ExceptionGroup but not BaseExceptionGroup .\n\nThe BaseExceptionGroup constructor returns an ExceptionGroup rather than a BaseExceptionGroup if all contained exceptions are Exception instances, so it can be used to make the selection\nautomatic. The ExceptionGroup constructor, on the other hand,\nraises a TypeError if any contained exception is not an Exception subclass.\n\nmessage\nÂ¶\nThe msg argument to the constructor. This is a read-only attribute.\n\nexceptions\nÂ¶\nA tuple of the exceptions in the excs sequence given to the\nconstructor. This is a read-only attribute.\n\nsubgroup\n(\ncondition\n)\nÂ¶\nReturns an exception group that contains only the exceptions from the\ncurrent group that match condition , or None if the result is empty.\n\nThe condition can be an exception type or tuple of exception types, in which\ncase each exception is checked for a match using the same check that is used\nin an except clause.  The condition can also be a callable (other than\na type object) that accepts an exception as its single argument and returns\ntrue for the exceptions that should be in the subgroup.\n\nThe nesting structure of the current exception is preserved in the result,\nas are the values of its message , __traceback__ , __cause__ , __context__ and __notes__ fields.\nEmpty nested groups are omitted from the result.\n\nThe condition is checked for all exceptions in the nested exception group,\nincluding the top-level and any nested exception groups. If the condition is\ntrue for such an exception group, it is included in the result in full.\n\nAdded in version 3.13: condition can be any callable which is not a type object.\n\nsplit\n(\ncondition\n)\nÂ¶\nLike subgroup() , but returns the pair (match, rest) where match is subgroup(condition) and rest is the remaining non-matching\npart.\n\nderive\n(\nexcs\n)\nÂ¶\nReturns an exception group with the same message , but which\nwraps the exceptions in excs .\n\nThis method is used by subgroup() and split() , which\nare used in various contexts to break up an exception group. A\nsubclass needs to override it in order to make subgroup() and split() return instances of the subclass rather\nthan ExceptionGroup .\n\nsubgroup() and split() copy the __traceback__ , __cause__ , __context__ and __notes__ fields from\nthe original exception group to the one returned by derive() , so\nthese fields do not need to be updated by derive() .\n\n```python\n>>> class MyGroup(ExceptionGroup):\n...     def derive(self, excs):\n...         return MyGroup(self.message, excs)\n...\n>>> e = MyGroup(\"eg\", [ValueError(1), TypeError(2)])\n>>> e.add_note(\"a note\")\n>>> e.__context__ = Exception(\"context\")\n>>> e.__cause__ = Exception(\"cause\")\n>>> try:\n...    raise e\n... except Exception as e:\n...    exc = e\n...\n>>> match, rest = exc.split(ValueError)\n>>> exc, exc.__context__, exc.__cause__, exc.__notes__\n(MyGroup('eg', [ValueError(1), TypeError(2)]), Exception('context'), Exception('cause'), ['a note'])\n>>> match, match.__context__, match.__cause__, match.__notes__\n(MyGroup('eg', [ValueError(1)]), Exception('context'), Exception('cause'), ['a note'])\n>>> rest, rest.__context__, rest.__cause__, rest.__notes__\n(MyGroup('eg', [TypeError(2)]), Exception('context'), Exception('cause'), ['a note'])\n>>> exc.__traceback__ is match.__traceback__ is rest.__traceback__\nTrue\n```\n\nNote that BaseExceptionGroup defines __new__() , so\nsubclasses that need a different constructor signature need to\noverride that rather than __init__() . For example, the following\ndefines an exception group subclass which accepts an exit_code and\nconstructs the groupâs message from it.\n\n```python\nclass Errors(ExceptionGroup):\n   def __new__(cls, errors, exit_code):\n      self = super().__new__(Errors, f\"exit code: {exit_code}\", errors)\n      self.exit_code = exit_code\n      return self\n\n   def derive(self, excs):\n      return Errors(excs, self.exit_code)\n```\n\nLike ExceptionGroup , any subclass of BaseExceptionGroup which\nis also a subclass of Exception can only wrap instances of Exception .\n\nAdded in version 3.11.\n\n## Exception hierarchyÂ¶\n\nThe class hierarchy for built-in exceptions is:\n\n```python\nBaseException\n âââ BaseExceptionGroup\n âââ GeneratorExit\n âââ KeyboardInterrupt\n âââ SystemExit\n âââ Exception\n      âââ ArithmeticError\n      â    âââ FloatingPointError\n      â    âââ OverflowError\n      â    âââ ZeroDivisionError\n      âââ AssertionError\n      âââ AttributeError\n      âââ BufferError\n      âââ EOFError\n      âââ ExceptionGroup [BaseExceptionGroup]\n      âââ ImportError\n      â    âââ ModuleNotFoundError\n      âââ LookupError\n      â    âââ IndexError\n      â    âââ KeyError\n      âââ MemoryError\n      âââ NameError\n      â    âââ UnboundLocalError\n      âââ OSError\n      â    âââ BlockingIOError\n      â    âââ ChildProcessError\n      â    âââ ConnectionError\n      â    â    âââ BrokenPipeError\n      â    â    âââ ConnectionAbortedError\n      â    â    âââ ConnectionRefusedError\n      â    â    âââ ConnectionResetError\n      â    âââ FileExistsError\n      â    âââ FileNotFoundError\n      â    âââ InterruptedError\n      â    âââ IsADirectoryError\n      â    âââ NotADirectoryError\n      â    âââ PermissionError\n      â    âââ ProcessLookupError\n      â    âââ TimeoutError\n      âââ ReferenceError\n      âââ RuntimeError\n      â    âââ NotImplementedError\n      â    âââ PythonFinalizationError\n      â    âââ RecursionError\n      âââ StopAsyncIteration\n      âââ StopIteration\n      âââ SyntaxError\n      â    âââ IndentationError\n      â         âââ TabError\n      âââ SystemError\n      âââ TypeError\n      âââ ValueError\n      â    âââ UnicodeError\n      â         âââ UnicodeDecodeError\n      â         âââ UnicodeEncodeError\n      â         âââ UnicodeTranslateError\n      âââ Warning\n           âââ BytesWarning\n           âââ DeprecationWarning\n           âââ EncodingWarning\n           âââ FutureWarning\n           âââ ImportWarning\n           âââ PendingDeprecationWarning\n           âââ ResourceWarning\n           âââ RuntimeWarning\n           âââ SyntaxWarning\n           âââ UnicodeWarning\n           âââ UserWarning\n```",
  "type": "tutorial",
  "concept_tags": [
    "exceptions",
    "error_handling",
    "debugging"
  ],
  "difficulty": "intro",
  "metadata": {
    "language": "en",
    "domain": "programming/python",
    "retrieved_at": "2026-02-24",
    "intended_use": "educational corpus",
    "source": "python_docs"
  },
  "provenance": {
    "url": "https://docs.python.org/3/library/exceptions.html",
    "license": "PSF Documentation License",
    "attribution": "Python Software Foundation",
    "retrieved_at": "2026-02-24"
  },
  "ai_generated": false,
  "doc_id": "scraped-https-docs-python-org-3-library-exceptions-html-ad80a01f"
}