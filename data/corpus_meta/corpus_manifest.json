{
  "documents": [
    {
      "ai_generated": false,
      "concept_tags": [
        "file_io",
        "modules",
        "standard_library"
      ],
      "content": "# 10.Brief Tour of the Standard Library\u00c2\u00b6\n\n## 10.1.Operating System Interface\u00c2\u00b6\n\nThe os module provides dozens of functions for interacting with the\noperating system:\n\n```python\n>>> import os\n>>> os.getcwd()      # Return the current working directory\n'C:\\\\Python314'\n>>> os.chdir('/server/accesslogs')   # Change current working directory\n>>> os.system('mkdir today')   # Run the command mkdir in the system shell\n0\n```python\n\nBe sure to use the import os style instead of from os import * .  This\nwill keep os.open() from shadowing the built-in open() function which\noperates much differently.\n\nThe built-in dir() and help() functions are useful as interactive\naids for working with large modules like os :\n\n```python\n>>> import os\n>>> dir(os)\n<returns a list of all module functions>\n>>> help(os)\n<returns an extensive manual page created from the module's docstrings>\n```python\n\nFor daily file and directory management tasks, the shutil module provides\na higher level interface that is easier to use:\n\n```python\n>>> import shutil\n>>> shutil.copyfile('data.db', 'archive.db')\n'archive.db'\n>>> shutil.move('/build/executables', 'installdir')\n'installdir'\n```python\n\n## 10.2.File Wildcards\u00c2\u00b6\n\nThe glob module provides a function for making file lists from directory\nwildcard searches:\n\n```python\n>>> import glob\n>>> glob.glob('*.py')\n['primes.py', 'random.py', 'quote.py']\n```python\n\n## 10.3.Command Line Arguments\u00c2\u00b6\n\nCommon utility scripts often need to process command line arguments. These\narguments are stored in the sys module\u00e2\u0080\u0099s argv attribute as a list.  For\ninstance, let\u00e2\u0080\u0099s take the following demo.py file:\n\n```python\n# File demo.py\nimport sys\nprint(sys.argv)\n```python\n\nHere is the output from running python demo.py one two three at the command\nline:\n\n```python\n['demo.py', 'one', 'two', 'three']\n```python\n\nThe argparse module provides a more sophisticated mechanism to process\ncommand line arguments.  The following script extracts one or more filenames\nand an optional number of lines to be displayed:\n\n```python\nimport argparse\n\nparser = argparse.ArgumentParser(\n    prog='top',\n    description='Show top lines from each file')\nparser.add_argument('filenames', nargs='+')\nparser.add_argument('-l', '--lines', type=int, default=10)\nargs = parser.parse_args()\nprint(args)\n```python\n\nWhen run at the command line with python top.py --lines=5 alpha.txt beta.txt , the script sets args.lines to 5 and args.filenames to ['alpha.txt', 'beta.txt'] .\n\n## 10.4.Error Output Redirection and Program Termination\u00c2\u00b6\n\nThe sys module also has attributes for stdin , stdout , and stderr .\nThe latter is useful for emitting warnings and error messages to make them\nvisible even when stdout has been redirected:\n\n```python\n>>> sys.stderr.write('Warning, log file not found starting a new one\\n')\nWarning, log file not found starting a new one\n```python\n\nThe most direct way to terminate a script is to use sys.exit() .\n\n## 10.5.String Pattern Matching\u00c2\u00b6\n\nThe re module provides regular expression tools for advanced string\nprocessing. For complex matching and manipulation, regular expressions offer\nsuccinct, optimized solutions:\n\n```python\n>>> import re\n>>> re.findall(r'\\bf[a-z]*', 'which foot or hand fell fastest')\n['foot', 'fell', 'fastest']\n>>> re.sub(r'(\\b[a-z]+) \\1', r'\\1', 'cat in the the hat')\n'cat in the hat'\n```python\n\nWhen only simple capabilities are needed, string methods are preferred because\nthey are easier to read and debug:\n\n```python\n>>> 'tea for too'.replace('too', 'two')\n'tea for two'\n```python\n\n## 10.6.Mathematics\u00c2\u00b6\n\nThe math module gives access to the underlying C library functions for\nfloating-point math:\n\n```python\n>>> import math\n>>> math.cos(math.pi / 4)\n0.70710678118654757\n>>> math.log(1024, 2)\n10.0\n```python\n\nThe random module provides tools for making random selections:\n\n```python\n>>> import random\n>>> random.choice(['apple', 'pear', 'banana'])\n'apple'\n>>> random.sample(range(100), 10)   # sampling without replacement\n[30, 83, 16, 4, 8, 81, 41, 50, 18, 33]\n>>> random.random()    # random float from the interval [0.0, 1.0)\n0.17970987693706186\n>>> random.randrange(6)    # random integer chosen from range(6)\n4\n```python\n\nThe statistics module calculates basic statistical properties\n(the mean, median, variance, etc.) of numeric data:\n\n```python\n>>> import statistics\n>>> data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]\n>>> statistics.mean(data)\n1.6071428571428572\n>>> statistics.median(data)\n1.25\n>>> statistics.variance(data)\n1.3720238095238095\n```python\n\nThe SciPy project < https://scipy.org > has many other modules for numerical\ncomputations.\n\n## 10.7.Internet Access\u00c2\u00b6\n\nThere are a number of modules for accessing the internet and processing internet\nprotocols. Two of the simplest are urllib.request for retrieving data\nfrom URLs and smtplib for sending mail:\n\n```python\n>>> from urllib.request import urlopen\n>>> with urlopen('https://docs.python.org/3/') as response:\n...     for line in response:\n...         line = line.decode()             # Convert bytes to a str\n...         if 'updated' in line:\n...             print(line.rstrip())         # Remove trailing newline\n...\n      Last updated on Nov 11, 2025 (20:11 UTC).\n\n>>> import smtplib\n>>> server = smtplib.SMTP('localhost')\n>>> server.sendmail('soothsayer@example.org', 'jcaesar@example.org',\n... \"\"\"To: jcaesar@example.org\n... From: soothsayer@example.org\n...\n... Beware the Ides of March.\n... \"\"\")\n>>> server.quit()\n```python\n\n(Note that the second example needs a mailserver running on localhost.)\n\n## 10.8.Dates and Times\u00c2\u00b6\n\nThe datetime module supplies classes for manipulating dates and times in\nboth simple and complex ways. While date and time arithmetic is supported, the\nfocus of the implementation is on efficient member extraction for output\nformatting and manipulation.  The module also supports objects that are timezone\naware.\n\n```python\n>>> # dates are easily constructed and formatted\n>>> from datetime import date\n>>> now = date.today()\n>>> now\ndatetime.date(2003, 12, 2)\n>>> now.strftime(\"%m-%d-%y. %d %b %Y is a %A on the %d day of %B.\")\n'12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.'\n\n>>> # dates support calendar arithmetic\n>>> birthday = date(1964, 7, 31)\n>>> age = now - birthday\n>>> age.days\n14368\n```python\n\n## 10.9.Data Compression\u00c2\u00b6\n\nCommon data archiving and compression formats are directly supported by modules\nincluding: zlib , gzip , bz2 , lzma , zipfile and tarfile .\n\n```python\n>>> import zlib\n>>> s = b'witch which has which witches wrist watch'\n>>> len(s)\n41\n>>> t = zlib.compress(s)\n>>> len(t)\n37\n>>> zlib.decompress(t)\nb'witch which has which witches wrist watch'\n>>> zlib.crc32(s)\n226805979\n```python\n\n## 10.10.Performance Measurement\u00c2\u00b6\n\nSome Python users develop a deep interest in knowing the relative performance of\ndifferent approaches to the same problem. Python provides a measurement tool\nthat answers those questions immediately.\n\nFor example, it may be tempting to use the tuple packing and unpacking feature\ninstead of the traditional approach to swapping arguments. The timeit module quickly demonstrates a modest performance advantage:\n\n```python\n>>> from timeit import Timer\n>>> Timer('t=a; a=b; b=t', 'a=1; b=2').timeit()\n0.57535828626024577\n>>> Timer('a,b = b,a', 'a=1; b=2').timeit()\n0.54962537085770791\n```python\n\nIn contrast to timeit \u00e2\u0080\u0099s fine level of granularity, the profile and pstats modules provide tools for identifying time critical sections in\nlarger blocks of code.\n\n## 10.11.Quality Control\u00c2\u00b6\n\nOne approach for developing high quality software is to write tests for each\nfunction as it is developed and to run those tests frequently during the\ndevelopment process.\n\nThe doctest module provides a tool for scanning a module and validating\ntests embedded in a program\u00e2\u0080\u0099s docstrings.  Test construction is as simple as\ncutting-and-pasting a typical call along with its results into the docstring.\nThis improves the documentation by providing the user with an example and it\nallows the doctest module to make sure the code remains true to the\ndocumentation:\n\n```python\ndef average(values):\n    \"\"\"Computes the arithmetic mean of a list of numbers.\n\n    >>> print(average([20, 30, 70]))\n    40.0\n    \"\"\"\n    return sum(values) / len(values)\n\nimport doctest\ndoctest.testmod()   # automatically validate the embedded tests\n```python\n\nThe unittest module is not as effortless as the doctest module,\nbut it allows a more comprehensive set of tests to be maintained in a separate\nfile:\n\n```python\nimport unittest\n\nclass TestStatisticalFunctions(unittest.TestCase):\n\n    def test_average(self):\n        self.assertEqual(average([20, 30, 70]), 40.0)\n        self.assertEqual(round(average([1, 5, 7]), 1), 4.3)\n        with self.assertRaises(ZeroDivisionError):\n            average([])\n        with self.assertRaises(TypeError):\n            average(20, 30, 70)\n\nunittest.main()  # Calling from the command line invokes all tests\n```python\n\n## 10.12.Batteries Included\u00c2\u00b6\n\nPython has a \u00e2\u0080\u009cbatteries included\u00e2\u0080\u009d philosophy.  This is best seen through the\nsophisticated and robust capabilities of its larger packages. For example:\n\n- The xmlrpc.client and xmlrpc.server modules make implementing\nremote procedure calls into an almost trivial task.  Despite the modules\u00e2\u0080\u0099\nnames, no direct knowledge or handling of XML is needed.\n- The email package is a library for managing email messages, including\nMIME and other RFC 5322 -based message documents. Unlike smtplib and poplib which actually send and receive messages, the email package has\na complete toolset for building or decoding complex message structures\n(including attachments) and for implementing internet encoding and header\nprotocols.\n- The json package provides robust support for parsing this\npopular data interchange format.  The csv module supports\ndirect reading and writing of files in Comma-Separated Value format,\ncommonly supported by databases and spreadsheets.  XML processing is\nsupported by the xml.etree.ElementTree , xml.dom and xml.sax packages. Together, these modules and packages\ngreatly simplify data interchange between Python applications and\nother tools.\n- The sqlite3 module is a wrapper for the SQLite database\nlibrary, providing a persistent database that can be updated and\naccessed using slightly nonstandard SQL syntax.\n- Internationalization is supported by a number of modules including gettext , locale , and the codecs package.",
      "difficulty": "intro",
      "doc_id": "doc-10-brief-tour-of-the-standard-library-28f2830678",
      "provenance": {
        "author": "",
        "date": "",
        "license": "PSF Documentation License",
        "source_file": "data/corpus_raw/scraped/3_tutorial_stdlib_html_0b886b.json",
        "url": "https://docs.python.org/3/tutorial/stdlib.html"
      },
      "title": "10.Brief Tour of the Standard Library\u00c2\u00b6",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "debugging",
        "error_handling",
        "exceptions",
        "logging"
      ],
      "content": "## 10ORGANIZING FILES\n\nIn the previous chapter, you learned how to create and write to new files in Python. Your programs can also organize preexisting files on the hard drive. Maybe you\u2019ve had the experience of going through a folder full of dozens, hundreds, or even thousands of files and copying, renaming, moving, or compressing them all by hand. Or consider tasks such as these:\n\n- Making copies of all PDF files (and only the PDF files) in every subfolder of a folder\n- Removing the leading zeros in the filenames for every file in a folder of hundreds of files named spam001.txt , spam002.txt , spam003.txt , and so on\n- Compressing the contents of several folders into one ZIP file (which could be a simple backup system)\n\nAll this boring stuff is just begging to be automated in Python. By programming your computer to do these tasks, you can transform it into a quick-working file clerk who never makes mistakes.\n\nAs you begin working with files, you may find it helpful to be able to quickly see what the extension (. txt , . pdf , . jpg , and so on) of a file is. With macOS and Linux, your file browser most likely shows extensions automatically. With Windows, file extensions may be hidden by default. To show extensions, go to Start \u25b8 Control Panel \u25b8 Appearance and Personalization \u25b8 Folder Options . On the View tab, under Advanced Settings, uncheck the Hide extensions for known file types checkbox.\n\n### The shutil Module\n\nThe shutil (or shell utilities) module has functions to let you copy, move, rename, and delete files in your Python programs. To use the shutil functions, you will first need to use import shutil .\n\n#### Copying Files and Folders\n\nThe shutil module provides functions for copying files, as well as entire folders.\n\nCalling shutil.copy( source , destination ) will copy the file at the path source to the folder at the path destination . (Both source and destination can be strings or Path objects.) If destination is a filename, it will be used as the new name of the copied file. This function returns a string or Path object of the copied file.\n\nEnter the following into the interactive shell to see how shutil.copy() works:\n\n>>> import shutil, os >>> from pathlib import Path >>> p = Path.home() \u278a >>> shutil.copy(p / 'spam.txt', p / 'some_folder') 'C:\\\\Users\\\\Al\\\\some_folder\\\\spam.txt' \u278b >>> shutil.copy(p / 'eggs.txt', p / 'some_folder/eggs2.txt') WindowsPath('C:/Users/Al/some_folder/eggs2.txt')\n\nThe first shutil.copy() call copies the file at C:\\Users\\Al\\spam.txt to the folder C:\\Users\\Al\\some_folder . The return value is the path of the newly copied file. Note that since a folder was specified as the destination \u278a , the original spam.txt filename is used for the new, copied file\u2019s filename. The second shutil.copy() call \u278b also copies the file at C:\\Users\\Al\\eggs.txt to the folder C:\\Users\\Al\\some_folder but gives the copied file the name eggs2.txt .\n\nWhile shutil.copy() will copy a single file, shutil.copytree() will copy an entire folder and every folder and file contained in it. Calling shutil.copytree( source , destination ) will copy the folder at the path source , along with all of its files and subfolders, to the folder at the path destination . The source and destination parameters are both strings. The function returns a string of the path of the copied folder.\n\nEnter the following into the interactive shell:\n\n>>> import shutil, os >>> from pathlib import Path >>> p = Path.home() >>> shutil.copytree(p / 'spam', p / 'spam_backup') WindowsPath('C:/Users/Al/spam_backup')\n\nThe shutil.copytree() call creates a new folder named spam_backup with the same content as the original spam folder. You have now safely backed up your precious, precious spam.\n\n#### Moving and Renaming Files and Folders\n\nCalling shutil.move( source , destination ) will move the file or folder at the path source to the path destination and will return a string of the absolute path of the new location.\n\nIf destination points to a folder, the source file gets moved into destination and keeps its current filename. For example, enter the following into the interactive shell:\n\n>>> import shutil >>> shutil.move('C:\\\\bacon.txt', 'C:\\\\eggs') 'C:\\\\eggs\\\\bacon.txt'\n\nAssuming a folder named eggs already exists in the C:\\ directory, this shutil.move() call says, \u201cMove C:\\bacon.txt into the folder C:\\eggs .\u201d\n\nIf there had been a bacon.txt file already in C:\\eggs , it would have been overwritten. Since it\u2019s easy to accidentally overwrite files in this way, you should take some care when using move() .\n\nThe destination path can also specify a filename. In the following example, the source file is moved and renamed.\n\n>>> shutil.move('C:\\\\bacon.txt', 'C:\\\\eggs\\\\new_bacon.txt') 'C:\\\\eggs\\\\new_bacon.txt'\n\nThis line says, \u201cMove C:\\bacon.txt into the folder C:\\eggs , and while you\u2019re at it, rename that bacon.txt file to new_bacon.txt .\u201d\n\nBoth of the previous examples worked under the assumption that there was a folder eggs in the C:\\ directory. But if there is no eggs folder, then move() will rename bacon.txt to a file named eggs .\n\n>>> shutil.move('C:\\\\bacon.txt', 'C:\\\\eggs') 'C:\\\\eggs'\n\nHere, move() can\u2019t find a folder named eggs in the C:\\ directory and so assumes that destination must be specifying a filename, not a folder. So the bacon.txt text file is renamed to eggs (a text file without the .txt file extension)\u2014probably not what you wanted! This can be a tough-to-spot bug in your programs since the move() call can happily do something that might be quite different from what you were expecting. This is yet another reason to be careful when using move() .\n\nFinally, the folders that make up the destination must already exist, or else Python will throw an exception. Enter the following into the interactive shell:\n\n>>> shutil.move('spam.txt', 'c:\\\\does_not_exist\\\\eggs\\\\ham') Traceback (most recent call last): -- snip -- FileNotFoundError: [Errno 2] No such file or directory: 'c:\\\\does_not_exist\\\\ eggs\\\\ham'\n\nPython looks for eggs and ham inside the directory does_not_exist . It doesn\u2019t find the nonexistent directory, so it can\u2019t move spam.txt to the path you specified.\n\n#### Permanently Deleting Files and Folders\n\nYou can delete a single file or a single empty folder with functions in the os module, whereas to delete a folder and all of its contents, you use the shutil module.\n\n- Calling os.unlink( path ) will delete the file at path .\n- Calling os.rmdir( path ) will delete the folder at path . This folder must be empty of any files or folders.\n- Calling shutil.rmtree( path ) will remove the folder at path , and all files and folders it contains will also be deleted.\n\nBe careful when using these functions in your programs! It\u2019s often a good idea to first run your program with these calls commented out and with print() calls added to show the files that would be deleted. Here is a Python program that was intended to delete files that have the .txt file extension but has a typo (highlighted in bold) that causes it to delete .rxt files instead:\n\nimport os from pathlib import Path for filename in Path.home().glob('*. r xt'): os.unlink(filename)\n\nIf you had any important files ending with .rxt , they would have been accidentally, permanently deleted. Instead, you should have first run the program like this:\n\nimport os from pathlib import Path for filename in Path.home().glob('*.rxt'): #os.unlink(filename) print(filename)\n\nNow the os.unlink() call is commented, so Python ignores it. Instead, you will print the filename of the file that would have been deleted. Running this version of the program first will show you that you\u2019ve accidentally told the program to delete .rxt files instead of .txt files.\n\nOnce you are certain the program works as intended, delete the print(filename) line and uncomment the os.unlink(filename) line. Then run the program again to actually delete the files.\n\n#### Safe Deletes with the send2trash Module\n\nSince Python\u2019s built-in shutil.rmtree() function irreversibly deletes files and folders, it can be dangerous to use. A much better way to delete files and folders is with the third-party send2trash module. You can install this module by running pip install --user send2trash from a Terminal window. (See Appendix A for a more in-depth explanation of how to install third-party modules.)\n\nUsing send2trash is much safer than Python\u2019s regular delete functions, because it will send folders and files to your computer\u2019s trash or recycle bin instead of permanently deleting them. If a bug in your program deletes something with send2trash you didn\u2019t intend to delete, you can later restore it from the recycle bin.\n\nAfter you have installed send2trash , enter the following into the interactive shell:\n\n>>> import send2trash >>> baconFile = open('bacon.txt', 'a')\u00a0\u00a0\u00a0# creates the file >>> baconFile.write('Bacon is not a vegetable.') 25 >>> baconFile.close() >>> send2trash.send2trash('bacon.txt')\n\nIn general, you should always use the send2trash.send2trash() function to delete files and folders. But while sending files to the recycle bin lets you recover them later, it will not free up disk space like permanently deleting them does. If you want your program to free up disk space, use the os and shutil functions for deleting files and folders. Note that the send2trash() function can only send files to the recycle bin; it cannot pull files out of it.\n\n### Walking a Directory Tree\n\nSay you want to rename every file in some folder and also every file in every subfolder of that folder. That is, you want to walk through the directory tree, touching each file as you go. Writing a program to do this could get tricky; fortunately, Python provides a function to handle this process for you.\n\nLet\u2019s look at the C:\\delicious folder with its contents, shown in Figure 10-1.\n\nFigure 10-1: An example folder that contains three folders and four files\n\nHere is an example program that uses the os.walk() function on the directory tree from Figure 10-1:\n\nimport os for folderName, subfolders, filenames in os.walk('C:\\\\delicious'): print('The current folder is ' + folderName) for subfolder in subfolders: print('SUBFOLDER OF ' + folderName + ': ' + subfolder) for filename in filenames: print('FILE INSIDE ' + folderName + ': '+ filename) print('')\n\nThe os.walk() function is passed a single string value: the path of a folder. You can use os.walk() in a for loop statement to walk a directory tree, much like how you can use the range() function to walk over a range of numbers. Unlike range() , the os.walk() function will return three values on each iteration through the loop:\n\n- A string of the current folder\u2019s name\n- A list of strings of the folders in the current folder\n- A list of strings of the files in the current folder\n\n(By current folder, I mean the folder for the current iteration of the for loop. The current working directory of the program is not changed by os.walk() .)\n\nJust like you can choose the variable name i in the code for i in range(10): , you can also choose the variable names for the three values listed earlier. I usually use the names foldername , subfolders , and filenames .\n\nWhen you run this program, it will output the following:\n\nThe current folder is C:\\delicious SUBFOLDER OF C:\\delicious: cats SUBFOLDER OF C:\\delicious: walnut FILE INSIDE C:\\delicious: spam.txt The current folder is C:\\delicious\\cats FILE INSIDE C:\\delicious\\cats: catnames.txt FILE INSIDE C:\\delicious\\cats: zophie.jpg The current folder is C:\\delicious\\walnut SUBFOLDER OF C:\\delicious\\walnut: waffles The current folder is C:\\delicious\\walnut\\waffles FILE INSIDE C:\\delicious\\walnut\\waffles: butter.txt.\n\nSince os.walk() returns lists of strings for the subfolder and filename variables, you can use these lists in their own for loops. Replace the print() function calls with your own custom code. (Or if you don\u2019t need one or both of them, remove the for loops.)\n\n### Compressing Files with the zipfile Module\n\nYou may be familiar with ZIP files (with the .zip file extension), which can hold the compressed contents of many other files. Compressing a file reduces its size, which is useful when transferring it over the internet. And since a ZIP file can also contain multiple files and subfolders, it\u2019s a handy way to package several files into one. This single file, called an archive file , can then be, say, attached to an email.\n\nYour Python programs can create and open (or extract ) ZIP files using functions in the zipfile module. Say you have a ZIP file named example.zip that has the contents shown in Figure 10-2.\n\nFigure 10-2: The contents of example.zip\n\nYou can download this ZIP file from https://nostarch.com/automatestuff2/ or just follow along using a ZIP file already on your computer.\n\n#### Reading ZIP Files\n\nTo read the contents of a ZIP file, first you must create a ZipFile object (note the capital letters Z and F ). ZipFile objects are conceptually similar to the File objects you saw returned by the open() function in the previous chapter: they are values through which the program interacts with the file. To create a ZipFile object, call the zipfile.ZipFile() function, passing it a string of the .ZIP file\u2019s filename. Note that zipfile is the name of the Python module, and ZipFile() is the name of the function.\n\nFor example, enter the following into the interactive shell:\n\n>>> import zipfile, os >>> from pathlib import Path >>> p = Path.home() >>> exampleZip = zipfile.ZipFile(p / 'example.zip') >>> exampleZip.namelist() ['spam.txt', 'cats/', 'cats/catnames.txt', 'cats/zophie.jpg'] >>> spamInfo = exampleZip.getinfo('spam.txt') >>> spamInfo.file_size 13908 >>> spamInfo.compress_size 3828 \u278a >>> f'Compressed file is {round(spamInfo.file_size / spamInfo .compress_size, 2)}x smaller!' ) 'Compressed file is 3.63x smaller!' >>> exampleZip.close()\n\nA ZipFile object has a namelist() method that returns a list of strings for all the files and folders contained in the ZIP file. These strings can be passed to the getinfo() ZipFile method to return a ZipInfo object about that particular file. ZipInfo objects have their own attributes, such as file_size and compress_size in bytes, which hold integers of the original file size and compressed file size, respectively. While a ZipFile object represents an entire archive file, a ZipInfo object holds useful information about a single file in the archive.\n\nThe command at \u278a calculates how efficiently example.zip is compressed by dividing the original file size by the compressed file size and prints this information.\n\n#### Extracting from ZIP Files\n\nThe extractall() method for ZipFile objects extracts all the files and folders from a ZIP file into the current working directory.\n\n>>> import zipfile, os >>> from pathlib import Path >>> p = Path.home() >>> exampleZip = zipfile.ZipFile(p / 'example.zip') \u278a >>> exampleZip.extractall() >>> exampleZip.close()\n\nAfter running this code, the contents of example.zip will be extracted to C:\\ . Optionally, you can pass a folder name to extractall() to have it extract the files into a folder other than the current working directory. If the folder passed to the extractall() method does not exist, it will be created. For instance, if you replaced the call at \u278a with exampleZip.extractall('C:\\\\delicious') , the code would extract the files from example.zip into a newly created C:\\delicious folder.\n\nThe extract() method for ZipFile objects will extract a single file from the ZIP file. Continue the interactive shell example:\n\n>>> exampleZip.extract('spam.txt') 'C:\\\\spam.txt' >>> exampleZip.extract('spam.txt', 'C:\\\\some\\\\new\\\\folders') 'C:\\\\some\\\\new\\\\folders\\\\spam.txt' >>> exampleZip.close()\n\nThe string you pass to extract() must match one of the strings in the list returned by namelist() . Optionally, you can pass a second argument to extract() to extract the file into a folder other than the current working directory. If this second argument is a folder that doesn\u2019t yet exist, Python will create the folder. The value that extract() returns is the absolute path to which the file was extracted.\n\n#### Creating and Adding to ZIP Files\n\nTo create your own compressed ZIP files, you must open the ZipFile object in write mode by passing 'w' as the second argument. (This is similar to opening a text file in write mode by passing 'w' to the open() function.)\n\nWhen you pass a path to the write() method of a ZipFile object, Python will compress the file at that path and add it into the ZIP file. The write() method\u2019s first argument is a string of the filename to add. The second argument is the compression type parameter, which tells the computer what algorithm it should use to compress the files; you can always just set this value to zipfile.ZIP_DEFLATED . (This specifies the deflate compression algorithm, which works well on all types of data.) Enter the following into the interactive shell:\n\n>>> import zipfile >>> newZip = zipfile.ZipFile('new.zip', 'w') >>> newZip.write('spam.txt', compress_type=zipfile.ZIP_DEFLATED) >>> newZip.close()\n\nThis code will create a new ZIP file named new.zip that has the compressed contents of spam.txt .\n\nKeep in mind that, just as with writing to files, write mode will erase all existing contents of a ZIP file. If you want to simply add files to an existing ZIP file, pass 'a' as the second argument to zipfile.ZipFile() to open the ZIP file in append mode .\n\n### Project: Renaming Files with American-Style Dates to European-Style Dates\n\nSay your boss emails you thousands of files with American-style dates (MM-DD-YYYY) in their names and needs them renamed to European-style dates (DD-MM-YYYY). This boring task could take all day to do by hand! Let\u2019s write a program to do it instead.\n\nHere\u2019s what the program does:\n\n- It searches all the filenames in the current working directory for American-style dates.\n- When one is found, it renames the file with the month and day swapped to make it European-style.\n\nThis means the code will need to do the following:\n\n- Create a regex that can identify the text pattern of American-style dates.\n- Call os.listdir() to find all the files in the working directory.\n- Loop over each filename, using the regex to check whether it has a date.\n- If it has a date, rename the file with shutil.move() .\n\nFor this project, open a new file editor window and save your code as renameDates.py .\n\n#### Step 1: Create a Regex for American-Style Dates\n\nThe first part of the program will need to import the necessary modules and create a regex that can identify MM-DD-YYYY dates. The to-do comments will remind you what\u2019s left to write in this program. Typing them as TODO makes them easy to find using Mu editor\u2019s CTRL-F find feature. Make your code look like the following:\n\n#! python3 # renameDates.py - Renames filenames with American MM-DD-YYYY date format # to European DD-MM-YYYY. \u278a import shutil, os, re # Create a regex that matches files with the American date format. \u278b datePattern = re.compile(r\"\"\"^(.*?) # all text before the date ((0|1)?\\d)-\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# one or two digits for the month ((0|1|2|3)?\\d)-\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# one or two digits for the day ((19|20)\\d\\d)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# four digits for the year (.*?)$\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# all text after the date \"\"\", re.VERBOSE \u278c ) # TODO: Loop over the files in the working directory. # TODO: Skip files without a date. # TODO: Get the different parts of the filename. # TODO: Form the European-style filename. # TODO: Get the full, absolute file paths. # TODO: Rename the files.\n\nFrom this chapter, you know the shutil.move() function can be used to rename files: its arguments are the name of the file to rename and the new filename. Because this function exists in the shutil module, you must import that module \u278a .\n\nBut before renaming the files, you need to identify which files you want to rename. Filenames with dates such as spam4-4-1984.txt and 01-03-2014eggs.zip should be renamed, while filenames without dates such as littlebrother.epub can be ignored.\n\nYou can use a regular expression to identify this pattern. After importing the re module at the top, call re.compile() to create a Regex object \u278b . Passing re.VERBOSE for the second argument \u278c will allow whitespace and comments in the regex string to make it more readable.\n\nThe regular expression string begins with ^(.*?) to match any text at the beginning of the filename that might come before the date. The ((0|1)?\\d) group matches the month. The first digit can be either 0 or 1 , so the regex matches 12 for December but also 02 for February. This digit is also optional so that the month can be 04 or 4 for April. The group for the day is ((0|1|2|3)?\\d) and follows similar logic; 3 , 03 , and 31 are all valid numbers for days. (Yes, this regex will accept some invalid dates such as 4-31-2014 , 2-29-2013 , and 0-15-2014 . Dates have a lot of thorny special cases that can be easy to miss. But for simplicity, the regex in this program works well enough.)\n\nWhile 1885 is a valid year, you can just look for years in the 20th or 21st century. This will keep your program from accidentally matching nondate filenames with a date-like format, such as 10-10-1000.txt .\n\nThe (.*?)$ part of the regex will match any text that comes after the date.\n\n#### Step 2: Identify the Date Parts from the Filenames\n\nNext, the program will have to loop over the list of filename strings returned from os.listdir() and match them against the regex. Any files that do not have a date in them should be skipped. For filenames that have a date, the matched text will be stored in several variables. Fill in the first three TODO s in your program with the following code:\n\n#! python3 # renameDates.py - Renames filenames with American MM-DD-YYYY date format # to European DD-MM-YYYY. -- snip -- # Loop over the files in the working directory. for amerFilename in os.listdir('.'): mo = datePattern.search(amerFilename) # Skip files without a date. \u278a if mo == None: \u278b continue \u278c # Get the different parts of the filename. beforePart = mo.group(1) monthPart\u00a0\u00a0= mo.group(2) dayPart\u00a0\u00a0\u00a0\u00a0= mo.group(4) yearPart\u00a0\u00a0\u00a0= mo.group(6) afterPart\u00a0\u00a0= mo.group(8) -- snip --\n\nIf the Match object returned from the search() method is None \u278a , then the filename in amerFilename does not match the regular expression. The continue statement \u278b will skip the rest of the loop and move on to the next filename.\n\nOtherwise, the various strings matched in the regular expression groups are stored in variables named beforePart , monthPart , dayPart , yearPart , and afterPart \u278c . The strings in these variables will be used to form the European-style filename in the next step.\n\nTo keep the group numbers straight, try reading the regex from the beginning, and count up each time you encounter an opening parenthesis. Without thinking about the code, just write an outline of the regular expression. This can help you visualize the groups. Here\u2019s an example:\n\ndatePattern = re.compile(r\"\"\"^( 1 ) # all text before the date ( 2 ( 3 ) )-\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# one or two digits for the month ( 4 ( 5 ) )-\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# one or two digits for the day ( 6 ( 7 ) )\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# four digits for the year ( 8 )$\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# all text after the date \"\"\", re.VERBOSE)\n\nHere, the numbers 1 through 8 represent the groups in the regular expression you wrote. Making an outline of the regular expression, with just the parentheses and group numbers, can give you a clearer understanding of your regex before you move on with the rest of the program.\n\n#### Step 3: Form the New Filename and Rename the Files\n\nAs the final step, concatenate the strings in the variables made in the previous step with the European-style date: the date comes before the month. Fill in the three remaining TODO s in your program with the following code:\n\n#! python3 # renameDates.py - Renames filenames with American MM-DD-YYYY date format # to European DD-MM-YYYY. -- snip -- # Form the European-style filename. \u278a euroFilename = beforePart + dayPart + '-' + monthPart + '-' + yearPart + afterPart # Get the full, absolute file paths. absWorkingDir = os.path.abspath('.') amerFilename = os.path.join(absWorkingDir, amerFilename) euroFilename = os.path.join(absWorkingDir, euroFilename) # Rename the files. \u278b print(f'Renaming \"{amerFilename}\" to \"{euroFilename}\"...') \u278c #shutil.move(amerFilename, euroFilename)\u00a0\u00a0\u00a0# uncomment after testing\n\nStore the concatenated string in a variable named euroFilename \u278a . Then, pass the original filename in amerFilename and the new euroFilename variable to the shutil.move() function to rename the file \u278c .\n\nThis program has the shutil.move() call commented out and instead prints the filenames that will be renamed \u278b . Running the program like this first can let you double-check that the files are renamed correctly. Then you can uncomment the shutil.move() call and run the program again to actually rename the files.\n\n#### Ideas for Similar Programs\n\nThere are many other reasons you might want to rename a large number of files.\n\n- To add a prefix to the start of the filename, such as adding spam_ to rename eggs.txt to spam_eggs.txt\n- To change filenames with European-style dates to American-style dates\n- To remove the zeros from files such as spam0042.txt\n\n### Project: Backing Up a Folder into a ZIP File\n\nSay you\u2019re working on a project whose files you keep in a folder named C:\\AlsPythonBook . You\u2019re worried about losing your work, so you\u2019d like to create ZIP file \u201csnapshots\u201d of the entire folder. You\u2019d like to keep different versions, so you want the ZIP file\u2019s filename to increment each time it is made; for example, AlsPythonBook_1.zip , AlsPythonBook_2.zip , AlsPythonBook_3.zip , and so on. You could do this by hand, but it is rather annoying, and you might accidentally misnumber the ZIP files\u2019 names. It would be much simpler to run a program that does this boring task for you.\n\nFor this project, open a new file editor window and save it as backupToZip.py .\n\n#### Step 1: Figure Out the ZIP File\u2019s Name\n\nThe code for this program will be placed into a function named backupToZip() . This will make it easy to copy and paste the function into other Python programs that need this functionality. At the end of the program, the function will be called to perform the backup. Make your program look like this:\n\n#! python3 # backupToZip.py - Copies an entire folder and its contents into # a ZIP file whose filename increments. \u278a import zipfile, os def backupToZip(folder): # Back up the entire contents of \"folder\" into a ZIP file. folder = os.path.abspath(folder)\u00a0\u00a0\u00a0# make sure folder is absolute # Figure out the filename this code should use based on # what files already exist. \u278b number = 1 \u278c while True: zipFilename = os.path.basename(folder) + '_' + str(number) + '.zip' if not os.path.exists(zipFilename): break number = number + 1 \u278d # TODO: Create the ZIP file. # TODO: Walk the entire folder tree and compress the files in each folder. print('Done.') backupToZip('C:\\\\delicious')\n\nDo the basics first: add the shebang ( #! ) line, describe what the program does, and import the zipfile and os modules \u278a .\n\nDefine a backupToZip() function that takes just one parameter, folder . This parameter is a string path to the folder whose contents should be backed up. The function will determine what filename to use for the ZIP file it will create; then the function will create the file, walk the folder folder, and add each of the subfolders and files to the ZIP file. Write TODO comments for these steps in the source code to remind yourself to do them later \u278d .\n\nThe first part, naming the ZIP file, uses the base name of the absolute path of folder . If the folder being backed up is C:\\delicious , the ZIP file\u2019s name should be delicious_N.zip , where N = 1 is the first time you run the program, N = 2 is the second time, and so on.\n\nYou can determine what N should be by checking whether delicious_1.zip already exists, then checking whether delicious_2.zip already exists, and so on. Use a variable named number for N \u278b , and keep incrementing it inside the loop that calls os.path.exists() to check whether the file exists \u278c . The first nonexistent filename found will cause the loop to break , since it will have found the filename of the new zip.\n\n#### Step 2: Create the New ZIP File\n\nNext let\u2019s create the ZIP file. Make your program look like the following:\n\n#! python3 # backupToZip.py - Copies an entire folder and its contents into # a ZIP file whose filename increments. -- snip -- while True: zipFilename = os.path.basename(folder) + '_' + str(number) + '.zip' if not os.path.exists(zipFilename): break number = number + 1 # Create the ZIP file. print(f'Creating {zipFilename}...') \u278a backupZip = zipfile.ZipFile(zipFilename, 'w') # TODO: Walk the entire folder tree and compress the files in each folder. print('Done.') backupToZip('C:\\\\delicious')\n\nNow that the new ZIP file\u2019s name is stored in the zipFilename variable, you can call zipfile.ZipFile() to actually create the ZIP file \u278a . Be sure to pass 'w' as the second argument so that the ZIP file is opened in write mode.\n\n#### Step 3: Walk the Directory Tree and Add to the ZIP File\n\nNow you need to use the os.walk() function to do the work of listing every file in the folder and its subfolders. Make your program look like the following:\n\n#! python3 # backupToZip.py - Copies an entire folder and its contents into # a ZIP file whose filename increments. -- snip -- # Walk the entire folder tree and compress the files in each folder. \u278a for foldername, subfolders, filenames in os.walk(folder): print(f'Adding files in {foldername}...') # Add the current folder to the ZIP file. \u278b backupZip.write(foldername) # Add all the files in this folder to the ZIP file. \u278c for filename in filenames: newBase = os.path.basename(folder) + '_' if filename.startswith(newBase) and filename.endswith('.zip'): continue\u00a0\u00a0\u00a0# don't back up the backup ZIP files backupZip.write(os.path.join(foldername, filename)) backupZip.close() print('Done.') backupToZip('C:\\\\delicious')\n\nYou can use os.walk() in a for loop \u278a , and on each iteration it will return the iteration\u2019s current folder name, the subfolders in that folder, and the filenames in that folder.\n\nIn the for loop, the folder is added to the ZIP file \u278b . The nested for loop can go through each filename in the filenames list \u278c . Each of these is added to the ZIP file, except for previously made backup ZIPs.\n\nWhen you run this program, it will produce output that will look something like this:\n\nCreating delicious_1.zip... Adding files in C:\\delicious... Adding files in C:\\delicious\\cats... Adding files in C:\\delicious\\waffles... Adding files in C:\\delicious\\walnut... Adding files in C:\\delicious\\walnut\\waffles... Done.\n\nThe second time you run it, it will put all the files in C:\\delicious into a ZIP file named delicious_2.zip , and so on.\n\n#### Ideas for Similar Programs\n\nYou can walk a directory tree and add files to compressed ZIP archives in several other programs. For example, you can write programs that do the following:\n\n- Walk a directory tree and archive just files with certain extensions, such as .txt or .py , and nothing else.\n- Walk a directory tree and archive every file except the .txt and .py ones.\n- Find the folder in a directory tree that has the greatest number of files or the folder that uses the most disk space.\n\n### Summary\n\nEven if you are an experienced computer user, you probably handle files manually with the mouse and keyboard. Modern file explorers make it easy to work with a few files. But sometimes you\u2019ll need to perform a task that would take hours using your computer\u2019s file explorer.\n\nThe os and shutil modules offer functions for copying, moving, renaming, and deleting files. When deleting files, you might want to use the send2trash module to move files to the recycle bin or trash rather than permanently deleting them. And when writing programs that handle files, it\u2019s a good idea to comment out the code that does the actual copy/move/rename/delete and add a print() call instead so you can run the program and verify exactly what it will do.\n\nOften you will need to perform these operations not only on files in one folder but also on every folder in that folder, every folder in those folders, and so on. The os.walk() function handles this trek across the folders for you so that you can concentrate on what your program needs to do with the files in them.\n\nThe zipfile module gives you a way of compressing and extracting files in .ZIP archives through Python. Combined with the file-handling functions of os and shutil , zipfile makes it easy to package up several files from anywhere on your hard drive. These .ZIP files are much easier to upload to websites or send as email attachments than many separate files.\n\nPrevious chapters of this book have provided source code for you to copy. But when you write your own programs, they probably won\u2019t come out perfectly the first time. The next chapter focuses on some Python modules that will help you analyze and debug your programs so that you can quickly get them working correctly.\n\n### Practice Questions\n\n1. What is the difference between shutil.copy() and shutil.copytree() ?\n\n2. What function is used to rename files?\n\n3. What is the difference between the delete functions in the send2trash and shutil modules?\n\n4. ZipFile objects have a close() method just like File objects\u2019 close() method. What ZipFile method is equivalent to File objects\u2019 open() method?\n\n### Practice Projects\n\nFor practice, write programs to do the following tasks.\n\n#### Selective Copy\n\nWrite a program that walks through a folder tree and searches for files with a certain file extension (such as .pdf or .jpg ). Copy these files from whatever location they are in to a new folder.\n\n#### Deleting Unneeded Files\n\nIt\u2019s not uncommon for a few unneeded but humongous files or folders to take up the bulk of the space on your hard drive. If you\u2019re trying to free up room on your computer, you\u2019ll get the most bang for your buck by deleting the most massive of the unwanted files. But first you have to find them.\n\nWrite a program that walks through a folder tree and searches for exceptionally large files or folders\u2014say, ones that have a file size of more than 100MB. (Remember that to get a file\u2019s size, you can use os.path.getsize() from the os module.) Print these files with their absolute path to the screen.\n\n#### Filling in the Gaps\n\nWrite a program that finds all files with a given prefix, such as spam001.txt , spam002.txt , and so on, in a single folder and locates any gaps in the numbering (such as if there is a spam001.txt and spam003.txt but no spam002.txt ). Have the program rename all the later files to close this gap.\n\nAs an added challenge, write another program that can insert gaps into numbered files so that a new file can be added.",
      "difficulty": "intro",
      "doc_id": "doc-10organizing-files-8fe90908f0",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-NC-SA 3.0",
        "source_file": "data/corpus_raw/2e_chapter10_91afde.json",
        "url": "https://automatetheboringstuff.com/2e/chapter10/"
      },
      "title": "10ORGANIZING FILES",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "OOP",
        "classes",
        "objects"
      ],
      "content": "## 11DEBUGGING\n\nNow that you know enough to write more complicated programs, you may start finding not-so-simple bugs in them. This chapter covers some tools and techniques for finding the root cause of bugs in your program to help you fix bugs faster and with less effort.\n\nTo paraphrase an old joke among programmers, writing code accounts for 90 percent of programming. Debugging code accounts for the other 90 percent.\n\nYour computer will do only what you tell it to do; it won\u2019t read your mind and do what you intended it to do. Even professional programmers create bugs all the time, so don\u2019t feel discouraged if your program has a problem.\n\nFortunately, there are a few tools and techniques to identify what exactly your code is doing and where it\u2019s going wrong. First, you will look at logging and assertions, two features that can help you detect bugs early. In general, the earlier you catch bugs, the easier they will be to fix.\n\nSecond, you will look at how to use the debugger. The debugger is a feature of Mu that executes a program one instruction at a time, giving you a chance to inspect the values in variables while your code runs, and track how the values change over the course of your program. This is much slower than running the program at full speed, but it is helpful to see the actual values in a program while it runs, rather than deducing what the values might be from the source code.\n\n### Raising Exceptions\n\nPython raises an exception whenever it tries to execute invalid code. In Chapter 3, you read about how to handle Python\u2019s exceptions with try and except statements so that your program can recover from exceptions that you anticipated. But you can also raise your own exceptions in your code. Raising an exception is a way of saying, \u201cStop running the code in this function and move the program execution to the except statement.\u201d\n\nExceptions are raised with a raise statement. In code, a raise statement consists of the following:\n\n- The raise keyword\n- A call to the Exception() function\n- A string with a helpful error message passed to the Exception() function\n\nFor example, enter the following into the interactive shell:\n\n>>> raise Exception('This is the error message.') Traceback (most recent call last): File \"<pyshell#191>\", line 1, in <module> raise Exception('This is the error message.') Exception: This is the error message.\n\nIf there are no try and except statements covering the raise statement that raised the exception, the program simply crashes and displays the exception\u2019s error message.\n\nOften it\u2019s the code that calls the function, rather than the function itself, that knows how to handle an exception. That means you will commonly see a raise statement inside a function and the try and except statements in the code calling the function. For example, open a new file editor tab, enter the following code, and save the program as boxPrint.py :\n\ndef boxPrint(symbol, width, height): if len(symbol) != 1: \u278a raise Exception('Symbol must be a single character string.') if width <= 2: \u278b raise Exception('Width must be greater than 2.') if height <= 2: \u278c raise Exception('Height must be greater than 2.') print(symbol * width) for i in range(height - 2): print(symbol + (' ' * (width - 2)) + symbol) print(symbol * width) for sym, w, h in (('*', 4, 4), ('O', 20, 5), ('x', 1, 3), ('ZZ', 3, 3)): try: boxPrint(sym, w, h) \u278d except Exception as err: \u278e print('An exception happened: ' + str(err))\n\nYou can view the execution of this program at https://autbor.com/boxprint . Here we\u2019ve defined a boxPrint() function that takes a character, a width, and a height, and uses the character to make a little picture of a box with that width and height. This box shape is printed to the screen.\n\nSay we want the character to be a single character, and the width and height to be greater than 2. We add if statements to raise exceptions if these requirements aren\u2019t satisfied. Later, when we call boxPrint() with various arguments, our try / except will handle invalid arguments.\n\nThis program uses the except Exception as err form of the except statement \u278d . If an Exception object is returned from boxPrint() \u278a \u278b \u278c , this except statement will store it in a variable named err . We can then convert the Exception object to a string by passing it to str() to produce a user-friendly error message \u278e . When you run this boxPrint.py , the output will look like this:\n\n**** *\u00a0\u00a0* *\u00a0\u00a0* **** OOOOOOOOOOOOOOOOOOOO O\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0O O\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0O O\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0O OOOOOOOOOOOOOOOOOOOO An exception happened: Width must be greater than 2. An exception happened: Symbol must be a single character string.\n\nUsing the try and except statements, you can handle errors more gracefully instead of letting the entire program crash.\n\n### Getting the Traceback as a String\n\nWhen Python encounters an error, it produces a treasure trove of error information called the traceback . The traceback includes the error message, the line number of the line that caused the error, and the sequence of the function calls that led to the error. This sequence of calls is called the call stack .\n\nOpen a new file editor tab in Mu, enter the following program, and save it as errorExample.py :\n\ndef spam(): bacon() def bacon(): raise Exception('This is the error message.') spam()\n\nWhen you run errorExample.py , the output will look like this:\n\nTraceback (most recent call last): File \"errorExample.py\", line 7, in <module> spam() File \"errorExample.py\", line 2, in spam bacon() File \"errorExample.py\", line 5, in bacon raise Exception('This is the error message.') Exception: This is the error message.\n\nFrom the traceback, you can see that the error happened on line 5, in the bacon() function. This particular call to bacon() came from line 2, in the spam() function, which in turn was called on line 7. In programs where functions can be called from multiple places, the call stack can help you determine which call led to the error.\n\nPython displays the traceback whenever a raised exception goes unhandled. But you can also obtain it as a string by calling traceback.format_exc() . This function is useful if you want the information from an exception\u2019s traceback but also want an except statement to gracefully handle the exception. You will need to import Python\u2019s traceback module before calling this function.\n\nFor example, instead of crashing your program right when an exception occurs, you can write the traceback information to a text file and keep your program running. You can look at the text file later, when you\u2019re ready to debug your program. Enter the following into the interactive shell:\n\n>>> import traceback >>> try: ...\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0raise Exception('This is the error message.') except: ...\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0errorFile = open('errorInfo.txt', 'w') ...\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0errorFile.write(traceback.format_exc()) ...\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0errorFile.close() ...\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print('The traceback info was written to errorInfo.txt.') 111 The traceback info was written to errorInfo.txt.\n\nThe 111 is the return value from the write() method, since 111 characters were written to the file. The traceback text was written to errorInfo.txt .\n\nTraceback (most recent call last): File \"<pyshell#28>\", line 2, in <module> Exception: This is the error message.\n\nIn \u201cLogging\u201d on page 255, you\u2019ll learn how to use the logging module, which is more effective than simply writing this error information to text files.\n\n### Assertions\n\nAn assertion is a sanity check to make sure your code isn\u2019t doing something obviously wrong. These sanity checks are performed by assert statements. If the sanity check fails, then an AssertionError exception is raised. In code, an assert statement consists of the following:\n\n- The assert keyword\n- A condition (that is, an expression that evaluates to True or False )\n- A comma\n- A string to display when the condition is False\n\nIn plain English, an assert statement says, \u201cI assert that the condition holds true, and if not, there is a bug somewhere, so immediately stop the program.\u201d For example, enter the following into the interactive shell:\n\n>>> ages = [26, 57, 92, 54, 22, 15, 17, 80, 47, 73] >>> ages.sort() >>> ages [15, 17, 22, 26, 47, 54, 57, 73, 80, 92] >>> assert ages[0] <= ages[-1] # Assert that the first age is <= the last age.\n\nThe assert statement here asserts that the first item in ages should be less than or equal to the last one. This is a sanity check; if the code in sort() is bug-free and did its job, then the assertion would be true.\n\nBecause the ages[0] <= ages[-1] expression evaluates to True , the assert statement does nothing.\n\nHowever, let\u2019s pretend we had a bug in our code. Say we accidentally called the reverse() list method instead of the sort() list method. When we enter the following in the interactive shell, the assert statement raises an AssertionError :\n\n>>> ages = [26, 57, 92, 54, 22, 15, 17, 80, 47, 73] >>> ages.reverse() >>> ages [73, 47, 80, 17, 15, 22, 54, 92, 57, 26] >>> assert ages[0] <= ages[-1] # Assert that the first age is <= the last age. Traceback (most recent call last): File \"<stdin>\", line 1, in <module> AssertionError\n\nUnlike exceptions, your code should not handle assert statements with try and except ; if an assert fails, your program should crash. By \u201cfailing fast\u201d like this, you shorten the time between the original cause of the bug and when you first notice the bug. This will reduce the amount of code you will have to check before finding the bug\u2019s cause.\n\nAssertions are for programmer errors, not user errors. Assertions should only fail while the program is under development; a user should never see an assertion error in a finished program. For errors that your program can run into as a normal part of its operation (such as a file not being found or the user entering invalid data), raise an exception instead of detecting it with an assert statement. You shouldn\u2019t use assert statements in place of raising exceptions, because users can choose to turn off assertions. If you run a Python script with python -O myscript.py instead of python myscript.py , Python will skip assert statements. Users might disable assertions when they\u2019re developing a program and need to run it in a production setting that requires peak performance. (Though, in many cases, they\u2019ll leave assertions enabled even then.)\n\nAssertions also aren\u2019t a replacement for comprehensive testing. For instance, if the previous ages example was set to [10, 3, 2, 1, 20] , then the assert ages[0] <= ages[-1] assertion wouldn\u2019t notice that the list was unsorted, because it just happened to have a first age that was less than or equal to the last age, which is the only thing the assertion checked for.\n\n#### Using an Assertion in a Traffic Light Simulation\n\nSay you\u2019re building a traffic light simulation program. The data structure representing the stoplights at an intersection is a dictionary with keys 'ns' and 'ew' , for the stoplights facing north-south and east-west, respectively. The values at these keys will be one of the strings 'green' , 'yellow' , or 'red' . The code would look something like this:\n\nmarket_2nd = {'ns': 'green', 'ew': 'red'} mission_16th = {'ns': 'red', 'ew': 'green'}\n\nThese two variables will be for the intersections of Market Street and 2nd Street, and Mission Street and 16th Street. To start the project, you want to write a switchLights() function, which will take an intersection dictionary as an argument and switch the lights.\n\nAt first, you might think that switchLights() should simply switch each light to the next color in the sequence: Any 'green' values should change to 'yellow' , 'yellow' values should change to 'red' , and 'red' values should change to 'green' . The code to implement this idea might look like this:\n\ndef switchLights(stoplight): for key in stoplight.keys(): if stoplight[key] == 'green': stoplight[key] = 'yellow' elif stoplight[key] == 'yellow': stoplight[key] = 'red' elif stoplight[key] == 'red': stoplight[key] = 'green' switchLights(market_2nd)\n\nYou may already see the problem with this code, but let\u2019s pretend you wrote the rest of the simulation code, thousands of lines long, without noticing it. When you finally do run the simulation, the program doesn\u2019t crash\u2014but your virtual cars do!\n\nSince you\u2019ve already written the rest of the program, you have no idea where the bug could be. Maybe it\u2019s in the code simulating the cars or in the code simulating the virtual drivers. It could take hours to trace the bug back to the switchLights() function.\n\nBut if while writing switchLights() you had added an assertion to check that at least one of the lights is always red , you might have included the following at the bottom of the function:\n\nassert 'red' in stoplight.values(), 'Neither light is red! ' + str(stoplight)\n\nWith this assertion in place, your program would crash with this error message:\n\nTraceback (most recent call last): File \"carSim.py\", line 14, in <module> switchLights(market_2nd) File \"carSim.py\", line 13, in switchLights assert 'red' in stoplight.values(), 'Neither light is red! ' + str(stoplight) \u278a AssertionError: Neither light is red! {'ns': 'yellow', 'ew': 'green'}\n\nThe important line here is the AssertionError \u278a . While your program crashing is not ideal, it immediately points out that a sanity check failed: neither direction of traffic has a red light, meaning that traffic could be going both ways. By failing fast early in the program\u2019s execution, you can save yourself a lot of future debugging effort.\n\n### Logging\n\nIf you\u2019ve ever put a print() statement in your code to output some variable\u2019s value while your program is running, you\u2019ve used a form of logging to debug your code. Logging is a great way to understand what\u2019s happening in your program and in what order it\u2019s happening. Python\u2019s logging module makes it easy to create a record of custom messages that you write. These log messages will describe when the program execution has reached the logging function call and list any variables you have specified at that point in time. On the other hand, a missing log message indicates a part of the code was skipped and never executed.\n\n#### Using the logging Module\n\nTo enable the logging module to display log messages on your screen as your program runs, copy the following to the top of your program (but under the #! python shebang line):\n\nimport logging logging.basicConfig(level=logging.DEBUG, format=' %(asctime)s -\u00a0\u00a0%(levelname) s -\u00a0\u00a0%(message)s')\n\nYou don\u2019t need to worry too much about how this works, but basically, when Python logs an event, it creates a LogRecord object that holds information about that event. The logging module\u2019s basicConfig() function lets you specify what details about the LogRecord object you want to see and how you want those details displayed.\n\nSay you wrote a function to calculate the factorial of a number. In mathematics, factorial 4 is 1 \u00d7 2 \u00d7 3 \u00d7 4, or 24. Factorial 7 is 1 \u00d7 2 \u00d7 3 \u00d7 4 \u00d7 5 \u00d7 6 \u00d7 7, or 5,040. Open a new file editor tab and enter the following code. It has a bug in it, but you will also enter several log messages to help yourself figure out what is going wrong. Save the program as factorialLog.py .\n\nimport logging logging.basicConfig(level=logging.DEBUG, format='%(asctime)s -\u00a0\u00a0%(levelname)s -\u00a0\u00a0%(message)s') logging.debug('Start of program') def factorial(n): logging.debug('Start of factorial(%s%%)'\u00a0\u00a0% (n)) total = 1 for i in range(n + 1): total *= i logging.debug('i is ' + str(i) + ', total is ' + str(total)) logging.debug('End of factorial(%s%%)'\u00a0\u00a0% (n)) return total print(factorial(5)) logging.debug('End of program')\n\nHere, we use the logging.debug() function when we want to print log information. This debug() function will call basicConfig() , and a line of information will be printed. This information will be in the format we specified in basicConfig() and will include the messages we passed to debug() . The print(factorial(5)) call is part of the original program, so the result is displayed even if logging messages are disabled.\n\nThe output of this program looks like this:\n\n2019-05-23 16:20:12,664 - DEBUG - Start of program 2019-05-23 16:20:12,664 - DEBUG - Start of factorial(5) 2019-05-23 16:20:12,665 - DEBUG - i is 0, total is 0 2019-05-23 16:20:12,668 - DEBUG - i is 1, total is 0 2019-05-23 16:20:12,670 - DEBUG - i is 2, total is 0 2019-05-23 16:20:12,673 - DEBUG - i is 3, total is 0 2019-05-23 16:20:12,675 - DEBUG - i is 4, total is 0 2019-05-23 16:20:12,678 - DEBUG - i is 5, total is 0 2019-05-23 16:20:12,680 - DEBUG - End of factorial(5) 0 2019-05-23 16:20:12,684 - DEBUG - End of program\n\nThe factorial() function is returning 0 as the factorial of 5 , which isn\u2019t right. The for loop should be multiplying the value in total by the numbers from 1 to 5 . But the log messages displayed by logging.debug() show that the i variable is starting at 0 instead of 1 . Since zero times anything is zero, the rest of the iterations also have the wrong value for total . Logging messages provide a trail of breadcrumbs that can help you figure out when things started to go wrong.\n\nChange the for i in range(n + 1): line to for i in range( 1, n + 1): , and run the program again. The output will look like this:\n\n2019-05-23 17:13:40,650 - DEBUG - Start of program 2019-05-23 17:13:40,651 - DEBUG - Start of factorial(5) 2019-05-23 17:13:40,651 - DEBUG - i is 1, total is 1 2019-05-23 17:13:40,654 - DEBUG - i is 2, total is 2 2019-05-23 17:13:40,656 - DEBUG - i is 3, total is 6 2019-05-23 17:13:40,659 - DEBUG - i is 4, total is 24 2019-05-23 17:13:40,661 - DEBUG - i is 5, total is 120 2019-05-23 17:13:40,661 - DEBUG - End of factorial(5) 120 2019-05-23 17:13:40,666 - DEBUG - End of program\n\nThe factorial(5) call correctly returns 120 . The log messages showed what was going on inside the loop, which led straight to the bug.\n\nYou can see that the logging.debug() calls printed out not just the strings passed to them but also a timestamp and the word DEBUG .\n\n#### Don\u2019t Debug with the print() Function\n\nTyping import logging and logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s') is somewhat unwieldy. You may want to use print() calls instead, but don\u2019t give in to this temptation! Once you\u2019re done debugging, you\u2019ll end up spending a lot of time removing print() calls from your code for each log message. You might even accidentally remove some print() calls that were being used for nonlog messages. The nice thing about log messages is that you\u2019re free to fill your program with as many as you like, and you can always disable them later by adding a single logging.disable(logging.CRITICAL) call. Unlike print() , the logging module makes it easy to switch between showing and hiding log messages.\n\nLog messages are intended for the programmer, not the user. The user won\u2019t care about the contents of some dictionary value you need to see to help with debugging; use a log message for something like that. For messages that the user will want to see, like File not found or Invalid input, please enter a number , you should use a print() call. You don\u2019t want to deprive the user of useful information after you\u2019ve disabled log messages.\n\n#### Logging Levels\n\nLogging levels provide a way to categorize your log messages by importance. There are five logging levels, described in Table 11-1 from least to most important. Messages can be logged at each level using a different logging function.\n\nTable 11-1: Logging Levels in Python\n\nLevel\n\nLogging function\n\nDescription\n\nDEBUG\n\nlogging.debug()\n\nThe lowest level. Used for small details. Usually you care about these messages only when diagnosing problems.\n\nINFO\n\nlogging.info()\n\nUsed to record information on general events in your program or confirm that things are working at their point in the program.\n\nWARNING\n\nlogging.warning()\n\nUsed to indicate a potential problem that doesn\u2019t prevent the program from working but might do so in the future.\n\nERROR\n\nlogging.error()\n\nUsed to record an error that caused the program to fail to do something.\n\nCRITICAL\n\nlogging.critical()\n\nThe highest level. Used to indicate a fatal error that has caused or is about to cause the program to stop running entirely.\n\nYour logging message is passed as a string to these functions. The logging levels are suggestions. Ultimately, it is up to you to decide which category your log message falls into. Enter the following into the interactive shell:\n\n>>> import logging >>> logging.basicConfig(level=logging.DEBUG, format=' %(asctime)s - %(levelname)s -\u00a0\u00a0%(message)s') >>> logging.debug('Some debugging details.') 2019-05-18 19:04:26,901 - DEBUG - Some debugging details. >>> logging.info('The logging module is working.') 2019-05-18 19:04:35,569 - INFO - The logging module is working. >>> logging.warning('An error message is about to be logged.') 2019-05-18 19:04:56,843 - WARNING - An error message is about to be logged. >>> logging.error('An error has occurred.') 2019-05-18 19:05:07,737 - ERROR - An error has occurred. >>> logging.critical('The program is unable to recover!') 2019-05-18 19:05:45,794 - CRITICAL - The program is unable to recover!\n\nThe benefit of logging levels is that you can change what priority of logging message you want to see. Passing logging.DEBUG to the basicConfig() function\u2019s level keyword argument will show messages from all the logging levels (DEBUG being the lowest level). But after developing your program some more, you may be interested only in errors. In that case, you can set basicConfig() \u2019s level argument to logging.ERROR . This will show only ERROR and CRITICAL messages and skip the DEBUG, INFO, and WARNING messages.\n\n#### Disabling Logging\n\nAfter you\u2019ve debugged your program, you probably don\u2019t want all these log messages cluttering the screen. The logging.disable() function disables these so that you don\u2019t have to go into your program and remove all the logging calls by hand. You simply pass logging.disable() a logging level, and it will suppress all log messages at that level or lower. So if you want to disable logging entirely, just add logging.disable(logging.CRITICAL) to your program. For example, enter the following into the interactive shell:\n\n>>> import logging >>> logging.basicConfig(level=logging.INFO, format=' %(asctime)s - %(levelname)s -\u00a0\u00a0%(message)s') >>> logging.critical('Critical error! Critical error!') 2019-05-22 11:10:48,054 - CRITICAL - Critical error! Critical error! >>> logging.disable(logging.CRITICAL) >>> logging.critical('Critical error! Critical error!') >>> logging.error('Error! Error!')\n\nSince logging.disable() will disable all messages after it, you will probably want to add it near the import logging line of code in your program. This way, you can easily find it to comment out or uncomment that call to enable or disable logging messages as needed.\n\n#### Logging to a File\n\nInstead of displaying the log messages to the screen, you can write them to a text file. The logging.basicConfig() function takes a filename keyword argument, like so:\n\nimport logging logging.basicConfig( filename='myProgramLog.txt' , level=logging.DEBUG, format=' %(asctime)s -\u00a0\u00a0%(levelname)s -\u00a0\u00a0%(message)s')\n\nThe log messages will be saved to myProgramLog.txt . While logging messages are helpful, they can clutter your screen and make it hard to read the program\u2019s output. Writing the logging messages to a file will keep your screen clear and store the messages so you can read them after running the program. You can open this text file in any text editor, such as Notepad or TextEdit.\n\n### Mu\u2019s Debugger\n\nThe debugger is a feature of the Mu editor, IDLE, and other editor software that allows you to execute your program one line at a time. The debugger will run a single line of code and then wait for you to tell it to continue. By running your program \u201cunder the debugger\u201d like this, you can take as much time as you want to examine the values in the variables at any given point during the program\u2019s lifetime. This is a valuable tool for tracking down bugs.\n\nTo run a program under Mu\u2019s debugger, click the Debug button in the top row of buttons, next to the Run button. Along with the usual output pane at the bottom, the Debug Inspector pane will open along the right side of the window. This pane lists the current value of variables in your program. In Figure 11-1, the debugger has paused the execution of the program just before it would have run the first line of code. You can see this line highlighted in the file editor.\n\nFigure 11-1: Mu running a program under the debugger\n\nDebugging mode also adds the following new buttons to the top of the editor: Continue, Step Over, Step In, and Step Out. The usual Stop button is also available.\n\n#### Continue\n\nClicking the Continue button will cause the program to execute normally until it terminates or reaches a breakpoint . (I will describe breakpoints later in this chapter.) If you are done debugging and want the program to continue normally, click the Continue button.\n\n#### Step In\n\nClicking the Step In button will cause the debugger to execute the next line of code and then pause again. If the next line of code is a function call, the debugger will \u201cstep into\u201d that function and jump to the first line of code of that function.\n\n#### Step Over\n\nClicking the Step Over button will execute the next line of code, similar to the Step In button. However, if the next line of code is a function call, the Step Over button will \u201cstep over\u201d the code in the function. The function\u2019s code will be executed at full speed, and the debugger will pause as soon as the function call returns. For example, if the next line of code calls a spam() function but you don\u2019t really care about code inside this function, you can click Step Over to execute the code in the function at normal speed, and then pause when the function returns. For this reason, using the Over button is more common than using the Step In button.\n\n#### Step Out\n\nClicking the Step Out button will cause the debugger to execute lines of code at full speed until it returns from the current function. If you have stepped into a function call with the Step In button and now simply want to keep executing instructions until you get back out, click the Out button to \u201cstep out\u201d of the current function call.\n\n#### Stop\n\nIf you want to stop debugging entirely and not bother to continue executing the rest of the program, click the Stop button. The Stop button will immediately terminate the program.\n\n#### Debugging a Number Adding Program\n\nOpen a new file editor tab and enter the following code:\n\nprint('Enter the first number to add:') first = input() print('Enter the second number to add:') second = input() print('Enter the third number to add:') third = input() print('The sum is ' + first + second + third)\n\nSave it as buggyAddingProgram.py and run it first without the debugger enabled. The program will output something like this:\n\nEnter the first number to add: 5 Enter the second number to add: 3 Enter the third number to add: 42 The sum is 5342\n\nThe program hasn\u2019t crashed, but the sum is obviously wrong. Run the program again, this time under the debugger.\n\nWhen you click the Debug button, the program pauses on line 1, which is the line of code it is about to execute. Mu should look like Figure 10-1.\n\nClick the Step Over button once to execute the first print() call. You should use Step Over instead of Step In here, since you don\u2019t want to step into the code for the print() function. (Although Mu should prevent the debugger from entering Python\u2019s built-in functions.) The debugger moves on to line 2, and highlights line 2 in the file editor, as shown in Figure 11-2. This shows you where the program execution currently is.\n\nFigure 11-2: The Mu editor window after clicking Step Over\n\nClick Step Over again to execute the input() function call. The highlighting will go away while Mu waits for you to type something for the input() call into the output pane. Enter 5 and press ENTER . The highlighting will return.\n\nKeep clicking Step Over , and enter 3 and 42 as the next two numbers. When the debugger reaches line 7, the final print() call in the program, the Mu editor window should look like Figure 11-3.\n\nFigure 11-3: The Debug Inspector pane on the right side shows that the variables are set to strings instead of integers, causing the bug.\n\nIn the Debug Inspector pane, you should see that the first , second , and third variables are set to string values '5' , '3' , and '42' instead of integer values 5 , 3 , and 42 . When the last line is executed, Python concatenates these strings instead of adding the numbers together, causing the bug.\n\nStepping through the program with the debugger is helpful but can also be slow. Often you\u2019ll want the program to run normally until it reaches a certain line of code. You can configure the debugger to do this with breakpoints.\n\n#### Breakpoints\n\nA breakpoint can be set on a specific line of code and forces the debugger to pause whenever the program execution reaches that line. Open a new file editor tab and enter the following program, which simulates flipping a coin 1,000 times. Save it as coinFlip.py .\n\nimport random heads = 0 for i in range(1, 1001): \u278a if random.randint(0, 1) == 1: heads = heads + 1 if i == 500: \u278b print('Halfway done!') print('Heads came up ' + str(heads) + ' times.')\n\nThe random.randint(0, 1) call \u278a will return 0 half of the time and 1 the other half of the time. This can be used to simulate a 50/50 coin flip where 1 represents heads. When you run this program without the debugger, it quickly outputs something like the following:\n\nHalfway done! Heads came up 490 times.\n\nIf you ran this program under the debugger, you would have to click the Step Over button thousands of times before the program terminated. If you were interested in the value of heads at the halfway point of the program\u2019s execution, when 500 of 1,000 coin flips have been completed, you could instead just set a breakpoint on the line print('Halfway done!') \u278b . To set a breakpoint, click the line number in the file editor to cause a red dot to appear, marking the breakpoint like in Figure 11-4.\n\nFigure 11-4: Setting a breakpoint causes a red dot (circled) to appear next to the line number.\n\nYou don\u2019t want to set a breakpoint on the if statement line, since the if statement is executed on every single iteration through the loop. When you set the breakpoint on the code in the if statement, the debugger breaks only when the execution enters the if clause.\n\nThe line with the breakpoint will have a red dot next to it. When you run the program under the debugger, it will start in a paused state at the first line, as usual. But if you click Continue, the program will run at full speed until it reaches the line with the breakpoint set on it. You can then click Continue, Step Over, Step In, or Step Out to continue as normal.\n\nIf you want to remove a breakpoint, click the line number again. The red dot will go away, and the debugger will not break on that line in the future.\n\n### Summary\n\nAssertions, exceptions, logging, and the debugger are all valuable tools to find and prevent bugs in your program. Assertions with the Python assert statement are a good way to implement \u201csanity checks\u201d that give you an early warning when a necessary condition doesn\u2019t hold true. Assertions are only for errors that the program shouldn\u2019t try to recover from and should fail fast. Otherwise, you should raise an exception.\n\nAn exception can be caught and handled by the try and except statements. The logging module is a good way to look into your code while it\u2019s running and is much more convenient to use than the print() function because of its different logging levels and ability to log to a text file.\n\nThe debugger lets you step through your program one line at a time. Alternatively, you can run your program at normal speed and have the debugger pause execution whenever it reaches a line with a breakpoint set. Using the debugger, you can see the state of any variable\u2019s value at any point during the program\u2019s lifetime.\n\nThese debugging tools and techniques will help you write programs that work. Accidentally introducing bugs into your code is a fact of life, no matter how many years of coding experience you have.\n\n### Practice Questions\n\n1. Write an assert statement that triggers an AssertionError if the variable spam is an integer less than 10 .\n\n2. Write an assert statement that triggers an AssertionError if the variables eggs and bacon contain strings that are the same as each other, even if their cases are different (that is, 'hello' and 'hello' are considered the same, and 'goodbye' and 'GOODbye' are also considered the same).\n\n3. Write an assert statement that always triggers an AssertionError .\n\n4. What are the two lines that your program must have in order to be able to call logging.debug() ?\n\n5. What are the two lines that your program must have in order to have logging.debug() send a logging message to a file named programLog.txt ?\n\n6. What are the five logging levels?\n\n7. What line of code can you add to disable all logging messages in your program?\n\n8. Why is using logging messages better than using print() to display the same message?\n\n9. What are the differences between the Step Over, Step In, and Step Out buttons in the debugger?\n\n10. After you click Continue, when will the debugger stop?\n\n11. What is a breakpoint?\n\n12. How do you set a breakpoint on a line of code in Mu?\n\n### Practice Project\n\nFor practice, write a program that does the following.\n\n#### Debugging Coin Toss\n\nThe following program is meant to be a simple coin toss guessing game. The player gets two guesses (it\u2019s an easy game). However, the program has several bugs in it. Run through the program a few times to find the bugs that keep the program from working correctly.\n\nimport random guess = '' while guess not in ('heads', 'tails'): print('Guess the coin toss! Enter heads or tails:') guess = input() toss = random.randint(0, 1) # 0 is tails, 1 is heads if toss == guess: print('You got it!') else: print('Nope! Guess again!') guesss = input() if toss == guess: print('You got it!') else: print('Nope. You are really bad at this game.')",
      "difficulty": "intermediate",
      "doc_id": "doc-11debugging-3032b7dc3e",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-NC-SA 3.0",
        "source_file": "data/corpus_raw/2e_chapter11_7cf7f6.json",
        "url": "https://automatetheboringstuff.com/2e/chapter11/"
      },
      "title": "11DEBUGGING",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "data_types",
        "numbers",
        "operators",
        "strings",
        "variables"
      ],
      "content": "## 1PYTHON BASICS\n\nThe Python programming language has a wide range of syntactical constructions, standard library functions, and interactive development environment features. Fortunately, you can ignore most of that; you just need to learn enough to write some handy little programs.\n\nYou will, however, have to learn some basic programming concepts before you can do anything. Like a wizard in training, you might think these concepts seem arcane and tedious, but with some knowledge and practice, you\u2019ll be able to command your computer like a magic wand and perform incredible feats.\n\nThis chapter has a few examples that encourage you to type into the interactive shell , also called the REPL (Read-Evaluate-Print Loop), which lets you run (or execute ) Python instructions one at a time and instantly shows you the results. Using the interactive shell is great for learning what basic Python instructions do, so give it a try as you follow along. You\u2019ll remember the things you do much better than the things you only read.\n\n### Entering Expressions into the Interactive Shell\n\nYou can run the interactive shell by launching the Mu editor, which you should have downloaded when going through the setup instructions in the Preface. On Windows, open the Start menu, type \u201cMu,\u201d and open the Mu app. On macOS, open your Applications folder and double-click Mu . Click the New button and save an empty file as blank.py . When you run this blank file by clicking the Run button or pressing F5 , it will open the interactive shell, which will open as a new pane that opens at the bottom of the Mu editor\u2019s window. You should see a >>> prompt in the interactive shell.\n\nEnter 2 + 2 at the prompt to have Python do some simple math. The Mu window should now look like this:\n\n>>> 2 + 2 4 >>>\n\nIn Python, 2 + 2 is called an expression , which is the most basic kind of programming instruction in the language. Expressions consist of values (such as 2 ) and operators (such as + ), and they can always evaluate (that is, reduce) down to a single value. That means you can use expressions anywhere in Python code that you could also use a value.\n\nIn the previous example, 2 + 2 is evaluated down to a single value, 4 . A single value with no operators is also considered an expression, though it evaluates only to itself, as shown here:\n\n>>> 2 2\n\nERRORS ARE OKAY!\n\nPrograms will crash if they contain code the computer can\u2019t understand, which will cause Python to show an error message. An error message won\u2019t break your computer, though, so don\u2019t be afraid to make mistakes. A crash just means the program stopped running unexpectedly.\n\nIf you want to know more about an error, you can search for the exact error message text online for more information. You can also check out the resources at https://nostarch.com/automatestuff2/ to see a list of common Python error messages and their meanings.\n\nYou can use plenty of other operators in Python expressions, too. For example, Table 1-1 lists all the math operators in Python.\n\nTable 1-1: Math Operators from Highest to Lowest Precedence\n\nOperator\n\nOperation\n\nExample\n\nEvaluates to . . .\n\n**\n\nExponent\n\n2 ** 3\n\n8\n\n%\n\nModulus/remainder\n\n22 % 8\n\n6\n\n//\n\nInteger division/floored quotient\n\n22 // 8\n\n2\n\n/\n\nDivision\n\n22 / 8\n\n2.75\n\n*\n\nMultiplication\n\n3 * 5\n\n15\n\n-\n\nSubtraction\n\n5 - 2\n\n3\n\n+\n\nAddition\n\n2 + 2\n\n4\n\nThe order of operations (also called precedence ) of Python math operators is similar to that of mathematics. The ** operator is evaluated first; the * , / , // , and % operators are evaluated next, from left to right; and the + and - operators are evaluated last (also from left to right). You can use parentheses to override the usual precedence if you need to. Whitespace in between the operators and values doesn\u2019t matter for Python (except for the indentation at the beginning of the line), but a single space is convention. Enter the following expressions into the interactive shell:\n\n>>> 2 + 3 * 6 20 >>> (2 + 3) * 6 30 >>> 48565878 * 578453 28093077826734 >>> 2 ** 8 256 >>> 23 / 7 3.2857142857142856 >>> 23 // 7 3 >>> 23 % 7 2 >>> 2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02 4 >>> (5 - 1) * ((7 + 1) / (3 - 1)) 16.0\n\nIn each case, you as the programmer must enter the expression, but Python does the hard part of evaluating it down to a single value. Python will keep evaluating parts of the expression until it becomes a single value, as shown here:\n\nThese rules for putting operators and values together to form expressions are a fundamental part of Python as a programming language, just like the grammar rules that help us communicate. Here\u2019s an example:\n\nThis is a grammatically correct English sentence.\n\nThis grammatically is sentence not English correct a.\n\nThe second line is difficult to parse because it doesn\u2019t follow the rules of English. Similarly, if you enter a bad Python instruction, Python won\u2019t be able to understand it and will display a SyntaxError error message, as shown here:\n\n>>> 5 + File \"<stdin>\", line 1 5 + ^ SyntaxError: invalid syntax >>> 42 + 5 + * 2 File \"<stdin>\", line 1 42 + 5 + * 2 ^ SyntaxError: invalid syntax\n\nYou can always test to see whether an instruction works by entering it into the interactive shell. Don\u2019t worry about breaking the computer: the worst that could happen is that Python responds with an error message. Professional software developers get error messages while writing code all the time.\n\n### The Integer, Floating-Point, and String Data Types\n\nRemember that expressions are just values combined with operators, and they always evaluate down to a single value. A data type is a category for values, and every value belongs to exactly one data type. The most common data types in Python are listed in Table 1-2. The values -2 and 30 , for example, are said to be integer values. The integer (or int ) data type indicates values that are whole numbers. Numbers with a decimal point, such as 3.14 , are called floating-point numbers (or floats ). Note that even though the value 42 is an integer, the value 42.0 would be a floating-point number.\n\nTable 1-2: Common Data Types\n\nData type\n\nExamples\n\nIntegers\n\n-2 , -1 , 0 , 1 , 2 , 3 , 4 , 5\n\nFloating-point numbers\n\n-1.25 , -1.0 , -0.5 , 0.0 , 0.5 , 1.0 , 1.25\n\nStrings\n\n'a' , 'aa' , 'aaa' , 'Hello!' , '11 cats'\n\nPython programs can also have text values called strings , or strs (pronounced \u201cstirs\u201d). Always surround your string in single quote ( ' ) characters (as in 'Hello' or 'Goodbye cruel world!' ) so Python knows where the string begins and ends. You can even have a string with no characters in it, '' , called a blank string or an empty string . Strings are explained in greater detail in Chapter 4.\n\nIf you ever see the error message SyntaxError: EOL while scanning string literal , you probably forgot the final single quote character at the end of the string, such as in this example:\n\n>>> 'Hello, world! SyntaxError: EOL while scanning string literal\n\n### String Concatenation and Replication\n\nThe meaning of an operator may change based on the data types of the values next to it. For example, + is the addition operator when it operates on two integers or floating-point values. However, when + is used on two string values, it joins the strings as the string concatenation operator. Enter the following into the interactive shell:\n\n>>> 'Alice' + 'Bob' 'AliceBob'\n\nThe expression evaluates down to a single, new string value that combines the text of the two strings. However, if you try to use the + operator on a string and an integer value, Python will not know how to handle this, and it will display an error message.\n\n>>> 'Alice' + 42 Traceback (most recent call last): File \"<pyshell#0>\", line 1, in <module> 'Alice' + 42 TypeError: can only concatenate str (not \"int\") to str\n\nThe error message can only concatenate str (not \"int\") to str means that Python thought you were trying to concatenate an integer to the string 'Alice' . Your code will have to explicitly convert the integer to a string because Python cannot do this automatically. (Converting data types will be explained in \u201cDissecting Your Program\u201d on page 13 when we talk about the str() , int() , and float() functions.)\n\nThe * operator multiplies two integer or floating-point values. But when the * operator is used on one string value and one integer value, it becomes the string replication operator. Enter a string multiplied by a number into the interactive shell to see this in action.\n\n>>> 'Alice' * 5 'AliceAliceAliceAliceAlice'\n\nThe expression evaluates down to a single string value that repeats the original string a number of times equal to the integer value. String replication is a useful trick, but it\u2019s not used as often as string concatenation.\n\nThe * operator can be used with only two numeric values (for multiplication), or one string value and one integer value (for string replication). Otherwise, Python will just display an error message, like the following:\n\n>>> 'Alice' * 'Bob' Traceback (most recent call last): File \"<pyshell#32>\", line 1, in <module> 'Alice' * 'Bob' TypeError: can't multiply sequence by non-int of type 'str' >>> 'Alice' * 5.0 Traceback (most recent call last): File \"<pyshell#33>\", line 1, in <module> 'Alice' * 5.0 TypeError: can't multiply sequence by non-int of type 'float'\n\nIt makes sense that Python wouldn\u2019t understand these expressions: you can\u2019t multiply two words, and it\u2019s hard to replicate an arbitrary string a fractional number of times.\n\n### Storing Values in Variables\n\nA variable is like a box in the computer\u2019s memory where you can store a single value. If you want to use the result of an evaluated expression later in your program, you can save it inside a variable.\n\n#### Assignment Statements\n\nYou\u2019ll store values in variables with an assignment statement . An assignment statement consists of a variable name, an equal sign (called the assignment operator ), and the value to be stored. If you enter the assignment statement spam = 42 , then a variable named spam will have the integer value 42 stored in it.\n\nThink of a variable as a labeled box that a value is placed in, as in Figure 1-1.\n\nFigure 1-1: spam = 42 is like telling the program, \u201cThe variable spam now has the integer value 42 in it.\u201d\n\nFor example, enter the following into the interactive shell:\n\n\u278a >>> spam = 40 >>> spam 40 >>> eggs = 2 \u278b >>> spam + eggs 42 >>> spam + eggs + spam 82 \u278c >>> spam = spam + 2 >>> spam 42\n\nA variable is initialized (or created) the first time a value is stored in it \u278a . After that, you can use it in expressions with other variables and values \u278b . When a variable is assigned a new value \u278c , the old value is forgotten, which is why spam evaluated to 42 instead of 40 at the end of the example. This is called overwriting the variable. Enter the following code into the interactive shell to try overwriting a string:\n\n>>> spam = 'Hello' >>> spam 'Hello' >>> spam = 'Goodbye' >>> spam 'Goodbye'\n\nJust like the box in Figure 1-2, the spam variable in this example stores 'Hello' until you replace the string with 'Goodbye' .\n\nFigure 1-2: When a new value is assigned to a variable, the old one is forgotten.\n\n#### Variable Names\n\nA good variable name describes the data it contains. Imagine that you moved to a new house and labeled all of your moving boxes as Stuff . You\u2019d never find anything! Most of this book\u2019s examples (and Python\u2019s documentation) use generic variable names like spam , eggs , and bacon , which come from the Monty Python \u201cSpam\u201d sketch. But in your programs, a descriptive name will help make your code more readable.\n\nThough you can name your variables almost anything, Python does have some naming restrictions. Table 1-3 has examples of legal variable names. You can name a variable anything as long as it obeys the following three rules:\n\n- It can be only one word with no spaces.\n- It can use only letters, numbers, and the underscore ( _ ) character.\n- It can\u2019t begin with a number.\n\nTable 1-3: Valid and Invalid Variable Names\n\nValid variable names\n\nInvalid variable names\n\ncurrent_balance\n\ncurrent-balance (hyphens are not allowed)\n\ncurrentBalance\n\ncurrent balance (spaces are not allowed)\n\naccount4\n\n4account (can\u2019t begin with a number)\n\n_42\n\n42 (can\u2019t begin with a number)\n\nTOTAL_SUM\n\nTOTAL_$UM (special characters like $ are not allowed)\n\nhello\n\n'hello' (special characters like ' are not allowed)\n\nVariable names are case-sensitive, meaning that spam , SPAM , Spam , and sPaM are four different variables. Though Spam is a valid variable you can use in a program, it is a Python convention to start your variables with a lowercase letter.\n\nThis book uses camelcase for variable names instead of underscores; that is, variables lookLikeThis instead of looking_like_this . Some experienced programmers may point out that the official Python code style, PEP 8, says that underscores should be used. I unapologetically prefer camelcase and point to the \u201cA Foolish Consistency Is the Hobgoblin of Little Minds\u201d section in PEP 8 itself:\n\nConsistency with the style guide is important. But most importantly: know when to be inconsistent\u2014sometimes the style guide just doesn\u2019t apply. When in doubt, use your best judgment.\n\n### Your First Program\n\nWhile the interactive shell is good for running Python instructions one at a time, to write entire Python programs, you\u2019ll type the instructions into the file editor. The file editor is similar to text editors such as Notepad or TextMate, but it has some features specifically for entering source code. To open a new file in Mu, click the New button on the top row.\n\nThe window that appears should contain a cursor awaiting your input, but it\u2019s different from the interactive shell, which runs Python instructions as soon as you press ENTER . The file editor lets you type in many instructions, save the file, and run the program. Here\u2019s how you can tell the difference between the two:\n\n- The interactive shell window will always be the one with the >>> prompt.\n- The file editor window will not have the >>> prompt.\n\nNow it\u2019s time to create your first program! When the file editor window opens, enter the following into it:\n\n\u278a # This program says hello and asks for my name. \u278b print('Hello, world!') print('What is your name?')\u00a0\u00a0\u00a0\u00a0# ask for their name \u278c myName = input() \u278d print('It is good to meet you, ' + myName) \u278e print('The length of your name is:') print(len(myName)) \u278f print('What is your age?')\u00a0\u00a0\u00a0\u00a0# ask for their age myAge = input() print('You will be ' + str(int(myAge) + 1) + ' in a year.')\n\nOnce you\u2019ve entered your source code, save it so that you won\u2019t have to retype it each time you start Mu. Click the Save button, enter hello.py in the File Name field, and then click Save .\n\nYou should save your programs every once in a while as you type them. That way, if the computer crashes or you accidentally exit Mu, you won\u2019t lose the code. As a shortcut, you can press CTRL -S on Windows and Linux or -S on macOS to save your file.\n\nOnce you\u2019ve saved, let\u2019s run our program. Press the F5 key. Your program should run in the interactive shell window. Remember, you have to press F5 from the file editor window, not the interactive shell window. Enter your name when your program asks for it. The program\u2019s output in the interactive shell should look something like this:\n\nWhen there are no more lines of code to execute, the Python program terminates ; that is, it stops running. (You can also say that the Python program exits .)\n\nYou can close the file editor by clicking the X at the top of the window. To reload a saved program, select File \u25b8 Open... from the menu. Do that now, and in the window that appears, choose hello.py and click the Open button. Your previously saved hello.py program should open in the file editor window.\n\nYou can view the execution of a program using the Python Tutor visualization tool at http://pythontutor.com/ . You can see the execution of this particular program at https://autbor.com/hellopy/ . Click the forward button to move through each step of the program\u2019s execution. You\u2019ll be able to see how the variables\u2019 values and the output change.\n\n### Dissecting Your Program\n\nWith your new program open in the file editor, let\u2019s take a quick tour of the Python instructions it uses by looking at what each line of code does.\n\n#### Comments\n\nThe following line is called a comment .\n\n\u278a # This program says hello and asks for my name.\n\nPython ignores comments, and you can use them to write notes or remind yourself what the code is trying to do. Any text for the rest of the line following a hash mark ( # ) is part of a comment.\n\nSometimes, programmers will put a # in front of a line of code to temporarily remove it while testing a program. This is called commenting out code, and it can be useful when you\u2019re trying to figure out why a program isn\u2019t working. You can remove the # later when you are ready to put the line back in.\n\nPython also ignores the blank line after the comment. You can add as many blank lines to your program as you want. This can make your code easier to read, like paragraphs in a book.\n\n#### The print() Function\n\nThe print() function displays the string value inside its parentheses on the screen.\n\n\u278b print('Hello, world!') print('What is your name?') # ask for their name\n\nThe line print('Hello, world!') means \u201cPrint out the text in the string 'Hello, world!' .\u201d When Python executes this line, you say that Python is calling the print() function and the string value is being passed to the function. A value that is passed to a function call is an argument . Notice that the quotes are not printed to the screen. They just mark where the string begins and ends; they are not part of the string value.\n\nNOTE\n\nYou can also use this function to put a blank line on the screen; just call print() with nothing in between the parentheses.\n\nWhen you write a function name, the opening and closing parentheses at the end identify it as the name of a function. This is why in this book, you\u2019ll see print() rather than print . Chapter 3 describes functions in more detail.\n\n#### The input() Function\n\nThe input() function waits for the user to type some text on the keyboard and press ENTER .\n\n\u278c myName = input()\n\nThis function call evaluates to a string equal to the user\u2019s text, and the line of code assigns the myName variable to this string value.\n\nYou can think of the input() function call as an expression that evaluates to whatever string the user typed in. If the user entered 'Al' , then the expression would evaluate to myName = 'Al' .\n\nIf you call input() and see an error message, like NameError: name 'Al' is not defined , the problem is that you\u2019re running the code with Python 2 instead of Python 3.\n\n#### Printing the User\u2019s Name\n\nThe following call to print() actually contains the expression 'It is good to meet you, ' + myName between the parentheses.\n\n\u278d print('It is good to meet you, ' + myName)\n\nRemember that expressions can always evaluate to a single value. If 'Al' is the value stored in myName on line \u278c , then this expression evaluates to 'It is good to meet you, Al' . This single string value is then passed to print() , which prints it on the screen.\n\n#### The len() Function\n\nYou can pass the len() function a string value (or a variable containing a string), and the function evaluates to the integer value of the number of characters in that string.\n\n\u278e print('The length of your name is:') print(len(myName))\n\nEnter the following into the interactive shell to try this:\n\n>>> len('hello') 5 >>> len('My very energetic monster just scarfed nachos.') 46 >>> len('') 0\n\nJust like those examples, len(myName) evaluates to an integer. It is then passed to print() to be displayed on the screen. The print() function allows you to pass it either integer values or string values, but notice the error that shows up when you type the following into the interactive shell:\n\n>>> print('I am ' + 29 + ' years old.') Traceback (most recent call last): File \"<pyshell#6>\", line 1, in <module> print('I am ' + 29 + ' years old.') TypeError: can only concatenate str (not \"int\") to str\n\nThe print() function isn\u2019t causing that error, but rather it\u2019s the expression you tried to pass to print() . You get the same error message if you type the expression into the interactive shell on its own.\n\n>>> 'I am ' + 29 + ' years old.' Traceback (most recent call last): File \"<pyshell#7>\", line 1, in <module> 'I am ' + 29 + ' years old.' TypeError: can only concatenate str (not \"int\") to str\n\nPython gives an error because the + operator can only be used to add two integers together or concatenate two strings. You can\u2019t add an integer to a string, because this is ungrammatical in Python. You can fix this by using a string version of the integer instead, as explained in the next section.\n\n#### The str(), int(), and float() Functions\n\nIf you want to concatenate an integer such as 29 with a string to pass to print() , you\u2019ll need to get the value '29' , which is the string form of 29 . The str() function can be passed an integer value and will evaluate to a string value version of the integer, as follows:\n\n>>> str(29) '29' >>> print('I am ' + str(29) + ' years old.') I am 29 years old.\n\nBecause str(29) evaluates to '29' , the expression 'I am ' + str(29) + ' years old.' evaluates to 'I am ' + '29' + ' years old.' , which in turn evaluates to 'I am 29 years old.' . This is the value that is passed to the print() function.\n\nThe str() , int() , and float() functions will evaluate to the string, integer, and floating-point forms of the value you pass, respectively. Try converting some values in the interactive shell with these functions and watch what happens.\n\n>>> str(0) '0' >>> str(-3.14) '-3.14' >>> int('42') 42 >>> int('-99') -99 >>> int(1.25) 1 >>> int(1.99) 1 >>> float('3.14') 3.14 >>> float(10) 10.0\n\nThe previous examples call the str() , int() , and float() functions and pass them values of the other data types to obtain a string, integer, or floating-point form of those values.\n\nThe str() function is handy when you have an integer or float that you want to concatenate to a string. The int() function is also helpful if you have a number as a string value that you want to use in some mathematics. For example, the input() function always returns a string, even if the user enters a number. Enter spam = input() into the interactive shell and enter 101 when it waits for your text.\n\n>>> spam = input() 101 >>> spam '101'\n\nThe value stored inside spam isn\u2019t the integer 101 but the string '101' . If you want to do math using the value in spam , use the int() function to get the integer form of spam and then store this as the new value in spam .\n\n>>> spam = int(spam) >>> spam 101\n\nNow you should be able to treat the spam variable as an integer instead of a string.\n\n>>> spam * 10 / 5 202.0\n\nNote that if you pass a value to int() that it cannot evaluate as an integer, Python will display an error message.\n\n>>> int('99.99') Traceback (most recent call last): File \"<pyshell#18>\", line 1, in <module> int('99.99') ValueError: invalid literal for int() with base 10: '99.99' >>> int('twelve') Traceback (most recent call last): File \"<pyshell#19>\", line 1, in <module> int('twelve') ValueError: invalid literal for int() with base 10: 'twelve'\n\nThe int() function is also useful if you need to round a floating-point number down.\n\n>>> int(7.7) 7 >>> int(7.7) + 1 8\n\nYou used the int() and str() functions in the last three lines of your program to get a value of the appropriate data type for the code.\n\n\u278f print('What is your age?') # ask for their age myAge = input() print('You will be ' + str(int(myAge) + 1) + ' in a year.')\n\nTEXT AND NUMBER EQUIVALENCE\n\nAlthough the string value of a number is considered a completely different value from the integer or floating-point version, an integer can be equal to a floating point.\n\n>>> 42 == '42' False >>> 42 == 42.0 True >>> 42.0 == 0042.000 True\n\nPython makes this distinction because strings are text, while integers and floats are both numbers.\n\nThe myAge variable contains the value returned from input() . Because the input() function always returns a string (even if the user typed in a number), you can use the int(myAge) code to return an integer value of the string in myAge . This integer value is then added to 1 in the expression int(myAge) + 1 .\n\nThe result of this addition is passed to the str() function: str(int(myAge) + 1) . The string value returned is then concatenated with the strings 'You will be ' and ' in a year.' to evaluate to one large string value. This large string is finally passed to print() to be displayed on the screen.\n\nLet\u2019s say the user enters the string '4' for myAge . The string '4' is converted to an integer, so you can add one to it. The result is 5 . The str() function converts the result back to a string, so you can concatenate it with the second string, 'in a year.' , to create the final message. These evaluation steps would look something like the following:\n\n### Summary\n\nYou can compute expressions with a calculator or enter string concatenations with a word processor. You can even do string replication easily by copying and pasting text. But expressions, and their component values\u2014operators, variables, and function calls\u2014are the basic building blocks that make programs. Once you know how to handle these elements, you will be able to instruct Python to operate on large amounts of data for you.\n\nIt is good to remember the different types of operators ( + , - , * , / , // , % , and ** for math operations, and + and * for string operations) and the three data types (integers, floating-point numbers, and strings) introduced in this chapter.\n\nI introduced a few different functions as well. The print() and input() functions handle simple text output (to the screen) and input (from the keyboard). The len() function takes a string and evaluates to an int of the number of characters in the string. The str() , int() , and float() functions will evaluate to the string, integer, or floating-point number form of the value they are passed.\n\nIn the next chapter, you\u2019ll learn how to tell Python to make intelligent decisions about what code to run, what code to skip, and what code to repeat based on the values it has. This is known as flow control , and it allows you to write programs that make intelligent decisions.\n\n### Practice Questions\n\n1. Which of the following are operators, and which are values?\n\n* 'hello' -88.8 - / + 5\n\n2. Which of the following is a variable, and which is a string?\n\nspam 'spam'\n\n3. Name three data types.\n\n4. What is an expression made up of? What do all expressions do?\n\n5. This chapter introduced assignment statements, like spam = 10 . What is the difference between an expression and a statement?\n\n6. What does the variable bacon contain after the following code runs?\n\nbacon = 20 bacon + 1\n\n7. What should the following two expressions evaluate to?\n\n'spam' + 'spamspam' 'spam' * 3\n\n8. Why is eggs a valid variable name while 100 is invalid?\n\n9. What three functions can be used to get the integer, floating-point number, or string version of a value?\n\n10. Why does this expression cause an error? How can you fix it?\n\n'I have eaten ' + 99 + ' burritos.'\n\nExtra credit: Search online for the Python documentation for the len() function. It will be on a web page titled \u201cBuilt-in Functions.\u201d Skim the list of other functions Python has, look up what the round() function does, and experiment with it in the interactive shell.",
      "difficulty": "intro",
      "doc_id": "doc-1python-basics-c6c24cef47",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-NC-SA 3.0",
        "source_file": "data/corpus_raw/2e_chapter1_6e73d7.json",
        "url": "https://automatetheboringstuff.com/2e/chapter1/"
      },
      "title": "1PYTHON BASICS",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "boolean",
        "conditionals",
        "control_flow",
        "loops"
      ],
      "content": "## 2FLOW CONTROL\n\nSo, you know the basics of individual instructions and that a program is just a series of instructions. But programming\u2019s real strength isn\u2019t just running one instruction after another like a weekend errand list. Based on how expressions evaluate, a program can decide to skip instructions, repeat them, or choose one of several instructions to run. In fact, you almost never want your programs to start from the first line of code and simply execute every line, straight to the end. Flow control statements can decide which Python instructions to execute under which conditions.\n\nThese flow control statements directly correspond to the symbols in a flowchart, so I\u2019ll provide flowchart versions of the code discussed in this chapter. Figure 2-1 shows a flowchart for what to do if it\u2019s raining. Follow the path made by the arrows from Start to End.\n\nFigure 2-1: A flowchart to tell you what to do if it is raining\n\nIn a flowchart, there is usually more than one way to go from the start to the end. The same is true for lines of code in a computer program. Flowcharts represent these branching points with diamonds, while the other steps are represented with rectangles. The starting and ending steps are represented with rounded rectangles.\n\nBut before you learn about flow control statements, you first need to learn how to represent those yes and no options, and you need to understand how to write those branching points as Python code. To that end, let\u2019s explore Boolean values, comparison operators, and Boolean operators.\n\n### Boolean Values\n\nWhile the integer, floating-point, and string data types have an unlimited number of possible values, the Boolean data type has only two values: True and False . (Boolean is capitalized because the data type is named after mathematician George Boole.) When entered as Python code, the Boolean values True and False lack the quotes you place around strings, and they always start with a capital T or F , with the rest of the word in lowercase. Enter the following into the interactive shell. (Some of these instructions are intentionally incorrect, and they\u2019ll cause error messages to appear.)\n\n\u278a >>> spam = True >>> spam True \u278b >>> true Traceback (most recent call last): File \"<pyshell#2>\", line 1, in <module> true NameError: name 'true' is not defined \u278c >>> True = 2 + 2 SyntaxError: can't assign to keyword\n\nLike any other value, Boolean values are used in expressions and can be stored in variables \u278a . If you don\u2019t use the proper case \u278b or you try to use True and False for variable names \u278c , Python will give you an error message.\n\n### Comparison Operators\n\nComparison operators , also called relational operators , compare two values and evaluate down to a single Boolean value. Table 2-1 lists the comparison operators.\n\nTable 2-1: Comparison Operators\n\nOperator\n\nMeaning\n\n==\n\nEqual to\n\n!=\n\nNot equal to\n\n<\n\nLess than\n\n>\n\nGreater than\n\n<=\n\nLess than or equal to\n\n>=\n\nGreater than or equal to\n\nThese operators evaluate to True or False depending on the values you give them. Let\u2019s try some operators now, starting with == and != .\n\n>>> 42 == 42 True >>> 42 == 99 False >>> 2 != 3 True >>> 2 != 2 False\n\nAs you might expect, == (equal to) evaluates to True when the values on both sides are the same, and != (not equal to) evaluates to True when the two values are different. The == and != operators can actually work with values of any data type.\n\n>>> 'hello' == 'hello' True >>> 'hello' == 'Hello' False >>> 'dog' != 'cat' True >>> True == True True >>> True != False True >>> 42 == 42.0 True \u278a >>> 42 == '42' False\n\nNote that an integer or floating-point value will always be unequal to a string value. The expression 42 == '42' \u278a evaluates to False because Python considers the integer 42 to be different from the string '42' .\n\nThe < , > , <= , and >= operators, on the other hand, work properly only with integer and floating-point values.\n\n>>> 42 < 100 True >>> 42 > 100 False >>> 42 < 42 False >>> eggCount = 42 \u278a >>> eggCount <= 42 True >>> myAge = 29 \u278b >>> myAge >= 10 True\n\nTHE DIFFERENCE BETWEEN THE == AND = OPERATORS\n\nYou might have noticed that the == operator (equal to) has two equal signs, while the = operator (assignment) has just one equal sign. It\u2019s easy to confuse these two operators with each other. Just remember these points:\n\n- The == operator (equal to) asks whether two values are the same as each other.\n- The = operator (assignment) puts the value on the right into the variable on the left.\n\nTo help remember which is which, notice that the == operator (equal to) consists of two characters, just like the != operator (not equal to) consists of two characters.\n\nYou\u2019ll often use comparison operators to compare a variable\u2019s value to some other value, like in the eggCount <= 42 \u278a and myAge >= 10 \u278b examples. (After all, instead of entering 'dog' != 'cat' in your code, you could have just entered True .) You\u2019ll see more examples of this later when you learn about flow control statements.\n\n### Boolean Operators\n\nThe three Boolean operators ( and , or , and not ) are used to compare Boolean values. Like comparison operators, they evaluate these expressions down to a Boolean value. Let\u2019s explore these operators in detail, starting with the and operator.\n\n#### Binary Boolean Operators\n\nThe and and or operators always take two Boolean values (or expressions), so they\u2019re considered binary operators. The and operator evaluates an expression to True if both Boolean values are True ; otherwise, it evaluates to False . Enter some expressions using and into the interactive shell to see it in action.\n\n>>> True and True True >>> True and False False\n\nA truth table shows every possible result of a Boolean operator. Table 2-2 is the truth table for the and operator.\n\nTable 2-2: The and Operator\u2019s Truth Table\n\nExpression\n\nEvaluates to . . .\n\nTrue and True\n\nTrue\n\nTrue and False\n\nFalse\n\nFalse and True\n\nFalse\n\nFalse and False\n\nFalse\n\nOn the other hand, the or operator evaluates an expression to True if either of the two Boolean values is True . If both are False , it evaluates to False .\n\n>>> False or True True >>> False or False False\n\nYou can see every possible outcome of the or operator in its truth table, shown in Table 2-3.\n\nTable 2-3: The or Operator\u2019s Truth Table\n\nExpression\n\nEvaluates to . . .\n\nTrue or True\n\nTrue\n\nTrue or False\n\nTrue\n\nFalse or True\n\nTrue\n\nFalse or False\n\nFalse\n\n#### The not Operator\n\nUnlike and and or , the not operator operates on only one Boolean value (or expression). This makes it a unary operator. The not operator simply evaluates to the opposite Boolean value.\n\n>>> not True False \u278a >>> not not not not True True\n\nMuch like using double negatives in speech and writing, you can nest not operators \u278a , though there\u2019s never not no reason to do this in real programs. Table 2-4 shows the truth table for not .\n\nTable 2-4: The not Operator\u2019s Truth Table\n\nExpression\n\nEvaluates to . . .\n\nnot True\n\nFalse\n\nnot False\n\nTrue\n\n### Mixing Boolean and Comparison Operators\n\nSince the comparison operators evaluate to Boolean values, you can use them in expressions with the Boolean operators.\n\nRecall that the and , or , and not operators are called Boolean operators because they always operate on the Boolean values True and False . While expressions like 4 < 5 aren\u2019t Boolean values, they are expressions that evaluate down to Boolean values. Try entering some Boolean expressions that use comparison operators into the interactive shell.\n\n>>> ( 4 < 5) and (5 < 6) True >>> ( 4 < 5) and (9 < 6) False >>> ( 1 == 2) or (2 == 2) True\n\nThe computer will evaluate the left expression first, and then it will evaluate the right expression. When it knows the Boolean value for each, it will then evaluate the whole expression down to one Boolean value. You can think of the computer\u2019s evaluation process for (4 < 5) and (5 < 6) as the following:\n\nYou can also use multiple Boolean operators in an expression, along with the comparison operators:\n\n>>> 2 + 2 == 4 and not 2 + 2 == 5 and 2 * 2 == 2 + 2 True\n\nThe Boolean operators have an order of operations just like the math operators do. After any math and comparison operators evaluate, Python evaluates the not operators first, then the and operators, and then the or operators.\n\n### Elements of Flow Control\n\nFlow control statements often start with a part called the condition and are always followed by a block of code called the clause . Before you learn about Python\u2019s specific flow control statements, I\u2019ll cover what a condition and a block are.\n\n#### Conditions\n\nThe Boolean expressions you\u2019ve seen so far could all be considered conditions, which are the same thing as expressions; condition is just a more specific name in the context of flow control statements. Conditions always evaluate down to a Boolean value, True or False . A flow control statement decides what to do based on whether its condition is True or False , and almost every flow control statement uses a condition.\n\n#### Blocks of Code\n\nLines of Python code can be grouped together in blocks . You can tell when a block begins and ends from the indentation of the lines of code. There are three rules for blocks.\n\n- Blocks begin when the indentation increases.\n- Blocks can contain other blocks.\n- Blocks end when the indentation decreases to zero or to a containing block\u2019s indentation.\n\nBlocks are easier to understand by looking at some indented code, so let\u2019s find the blocks in part of a small game program, shown here:\n\nname = 'Mary' password = 'swordfish' if name == 'Mary': \u278a print('Hello, Mary') if password == 'swordfish': \u278b print('Access granted.') else: \u278c print('Wrong password.')\n\nYou can view the execution of this program at https://autbor.com/blocks/ . The first block of code \u278a starts at the line print('Hello, Mary') and contains all the lines after it. Inside this block is another block \u278b , which has only a single line in it: print('Access Granted.') . The third block \u278c is also one line long: print('Wrong password.') .\n\n### Program Execution\n\nIn the previous chapter\u2019s hello.py program, Python started executing instructions at the top of the program going down, one after another. The program execution (or simply, execution ) is a term for the current instruction being executed. If you print the source code on paper and put your finger on each line as it is executed, you can think of your finger as the program execution.\n\nNot all programs execute by simply going straight down, however. If you use your finger to trace through a program with flow control statements, you\u2019ll likely find yourself jumping around the source code based on conditions, and you\u2019ll probably skip entire clauses.\n\n### Flow Control Statements\n\nNow, let\u2019s explore the most important piece of flow control: the statements themselves. The statements represent the diamonds you saw in the flowchart in Figure 2-1, and they are the actual decisions your programs will make.\n\n#### if Statements\n\nThe most common type of flow control statement is the if statement. An if statement\u2019s clause (that is, the block following the if statement) will execute if the statement\u2019s condition is True . The clause is skipped if the condition is False .\n\nIn plain English, an if statement could be read as, \u201cIf this condition is true, execute the code in the clause.\u201d In Python, an if statement consists of the following:\n\n- The if keyword\n- A condition (that is, an expression that evaluates to True or False )\n- A colon\n- Starting on the next line, an indented block of code (called the if clause)\n\nFor example, let\u2019s say you have some code that checks to see whether someone\u2019s name is Alice. (Pretend name was assigned some value earlier.)\n\nif name == 'Alice': print('Hi, Alice.')\n\nAll flow control statements end with a colon and are followed by a new block of code (the clause). This if statement\u2019s clause is the block with print('Hi, Alice.') . Figure 2-2 shows what a flowchart of this code would look like.\n\nFigure 2-2: The flowchart for an if statement\n\n#### else Statements\n\nAn if clause can optionally be followed by an else statement. The else clause is executed only when the if statement\u2019s condition is False . In plain English, an else statement could be read as, \u201cIf this condition is true, execute this code. Or else, execute that code.\u201d An else statement doesn\u2019t have a condition, and in code, an else statement always consists of the following:\n\n- The else keyword\n- A colon\n- Starting on the next line, an indented block of code (called the else clause)\n\nReturning to the Alice example, let\u2019s look at some code that uses an else statement to offer a different greeting if the person\u2019s name isn\u2019t Alice.\n\nif name == 'Alice': print('Hi, Alice.') else: print('Hello, stranger.')\n\nFigure 2-3 shows what a flowchart of this code would look like.\n\nFigure 2-3: The flowchart for an else statement\n\n#### elif Statements\n\nWhile only one of the if or else clauses will execute, you may have a case where you want one of many possible clauses to execute. The elif statement is an \u201celse if\u201d statement that always follows an if or another elif statement. It provides another condition that is checked only if all of the previous conditions were False . In code, an elif statement always consists of the following:\n\n- The elif keyword\n- A condition (that is, an expression that evaluates to True or False )\n- A colon\n- Starting on the next line, an indented block of code (called the elif clause)\n\nLet\u2019s add an elif to the name checker to see this statement in action.\n\nif name == 'Alice': print('Hi, Alice.') elif age < 12: print('You are not Alice, kiddo.')\n\nThis time, you check the person\u2019s age, and the program will tell them something different if they\u2019re younger than 12. You can see the flowchart for this in Figure 2-4.\n\nFigure 2-4: The flowchart for an elif statement\n\nThe elif clause executes if age < 12 is True and name == 'Alice' is False . However, if both of the conditions are False , then both of the clauses are skipped. It is not guaranteed that at least one of the clauses will be executed. When there is a chain of elif statements, only one or none of the clauses will be executed. Once one of the statements\u2019 conditions is found to be True , the rest of the elif clauses are automatically skipped. For example, open a new file editor window and enter the following code, saving it as vampire.py :\n\nname = 'Carol' age = 3000 if name == 'Alice': print('Hi, Alice.') elif age < 12: print('You are not Alice, kiddo.') elif age > 2000: print('Unlike you, Alice is not an undead, immortal vampire.') elif age > 100: print('You are not Alice, grannie.')\n\nYou can view the execution of this program at https://autbor.com/vampire/ . Here, I\u2019ve added two more elif statements to make the name checker greet a person with different answers based on age . Figure 2-5 shows the flowchart for this.\n\nFigure 2-5: The flowchart for multiple elif statements in the vampire.py program\n\nThe order of the elif statements does matter, however. Let\u2019s rearrange them to introduce a bug. Remember that the rest of the elif clauses are automatically skipped once a True condition has been found, so if you swap around some of the clauses in vampire.py , you run into a problem. Change the code to look like the following, and save it as vampire2.py :\n\nname = 'Carol' age = 3000 if name == 'Alice': print('Hi, Alice.') elif age < 12: print('You are not Alice, kiddo.') \u278a elif age > 100: print('You are not Alice, grannie.') elif age > 2000: print('Unlike you, Alice is not an undead, immortal vampire.')\n\nYou can view the execution of this program at https://autbor.com/vampire2/ . Say the age variable contains the value 3000 before this code is executed. You might expect the code to print the string 'Unlike you, Alice is not an undead, immortal vampire.' . However, because the age > 100 condition is True (after all, 3,000 is greater than 100) \u278a , the string 'You are not Alice, grannie.' is printed, and the rest of the elif statements are automatically skipped. Remember that at most only one of the clauses will be executed, and for elif statements, the order matters!\n\nFigure 2-6 shows the flowchart for the previous code. Notice how the diamonds for age > 100 and age > 2000 are swapped.\n\nOptionally, you can have an else statement after the last elif statement. In that case, it is guaranteed that at least one (and only one) of the clauses will be executed. If the conditions in every if and elif statement are False , then the else clause is executed. For example, let\u2019s re-create the Alice program to use if , elif , and else clauses.\n\nname = 'Carol' age = 3000 if name == 'Alice': print('Hi, Alice.') elif age < 12: print('You are not Alice, kiddo.') else: print('You are neither Alice nor a little kid.')\n\nYou can view the execution of this program at https://autbor.com/littlekid/ . Figure 2-7 shows the flowchart for this new code, which we\u2019ll save as littleKid.py .\n\nIn plain English, this type of flow control structure would be \u201cIf the first condition is true, do this. Else, if the second condition is true, do that. Otherwise, do something else.\u201d When you use if , elif , and else statements together, remember these rules about how to order them to avoid bugs like the one in Figure 2-6. First, there is always exactly one if statement. Any elif statements you need should follow the if statement. Second, if you want to be sure that at least one clause is executed, close the structure with an else statement.\n\nFigure 2-6: The flowchart for the vampire2.py program. The X path will logically never happen, because if age were greater than 2000 , it would have already been greater than 100 .\n\nFigure 2-7: Flowchart for the previous littleKid.py program\n\n#### while Loop Statements\n\nYou can make a block of code execute over and over again using a while statement. The code in a while clause will be executed as long as the while statement\u2019s condition is True . In code, a while statement always consists of the following:\n\n- The while keyword\n- A condition (that is, an expression that evaluates to True or False )\n- A colon\n- Starting on the next line, an indented block of code (called the while clause)\n\nYou can see that a while statement looks similar to an if statement. The difference is in how they behave. At the end of an if clause, the program execution continues after the if statement. But at the end of a while clause, the program execution jumps back to the start of the while statement. The while clause is often called the while loop or just the loop .\n\nLet\u2019s look at an if statement and a while loop that use the same condition and take the same actions based on that condition. Here is the code with an if statement:\n\nspam = 0 if spam < 5: print('Hello, world.') spam = spam + 1\n\nHere is the code with a while statement:\n\nspam = 0 while spam < 5: print('Hello, world.') spam = spam + 1\n\nThese statements are similar\u2014both if and while check the value of spam , and if it\u2019s less than 5, they print a message. But when you run these two code snippets, something very different happens for each one. For the if statement, the output is simply \"Hello, world.\" . But for the while statement, it\u2019s \"Hello, world.\" repeated five times! Take a look at the flowcharts for these two pieces of code, Figures 2-8 and 2-9, to see why this happens.\n\nFigure 2-8: The flowchart for the if statement code\n\nFigure 2-9: The flowchart for the while statement code\n\nThe code with the if statement checks the condition, and it prints Hello, world. only once if that condition is true. The code with the while loop, on the other hand, will print it five times. The loop stops after five prints because the integer in spam increases by one at the end of each loop iteration, which means that the loop will execute five times before spam < 5 is False .\n\nIn the while loop, the condition is always checked at the start of each iteration (that is, each time the loop is executed). If the condition is True , then the clause is executed, and afterward, the condition is checked again. The first time the condition is found to be False , the while clause is skipped.\n\n#### An Annoying while Loop\n\nHere\u2019s a small example program that will keep asking you to type, literally, your name . Select File \u25b8 New to open a new file editor window, enter the following code, and save the file as yourName.py :\n\n\u278a name = '' \u278b while name != 'your name': print('Please type your name.') \u278c name = input() \u278d print('Thank you!')\n\nYou can view the execution of this program at https://autbor.com/yourname/ . First, the program sets the name variable \u278a to an empty string. This is so that the name != 'your name' condition will evaluate to True and the program execution will enter the while loop\u2019s clause \u278b .\n\nThe code inside this clause asks the user to type their name, which is assigned to the name variable \u278c . Since this is the last line of the block, the execution moves back to the start of the while loop and reevaluates the condition. If the value in name is not equal to the string 'your name' , then the condition is True , and the execution enters the while clause again.\n\nBut once the user types your name , the condition of the while loop will be 'your name' != 'your name' , which evaluates to False . The condition is now False , and instead of the program execution reentering the while loop\u2019s clause, Python skips past it and continues running the rest of the program \u278d . Figure 2-10 shows a flowchart for the yourName.py program.\n\nFigure 2-10: A flowchart of the yourName.py program\n\nNow, let\u2019s see yourName.py in action. Press F5 to run it, and enter something other than your name a few times before you give the program what it wants.\n\nPlease type your name. Al Please type your name. Albert Please type your name. %#@#%*(^&!!! Please type your name. your name Thank you!\n\nIf you never enter your name , then the while loop\u2019s condition will never be False , and the program will just keep asking forever. Here, the input() call lets the user enter the right string to make the program move on. In other programs, the condition might never actually change, and that can be a problem. Let\u2019s look at how you can break out of a while loop.\n\n#### break Statements\n\nThere is a shortcut to getting the program execution to break out of a while loop\u2019s clause early. If the execution reaches a break statement, it immediately exits the while loop\u2019s clause. In code, a break statement simply contains the break keyword.\n\nPretty simple, right? Here\u2019s a program that does the same thing as the previous program, but it uses a break statement to escape the loop. Enter the following code, and save the file as yourName2.py :\n\n\u278a while True: print('Please type your name.') \u278b name = input() \u278c if name == 'your name': \u278d break \u278e print('Thank you!')\n\nYou can view the execution of this program at https://autbor.com/yourname2/ . The first line \u278a creates an infinite loop ; it is a while loop whose condition is always True . (The expression True , after all, always evaluates down to the value True .) After the program execution enters this loop, it will exit the loop only when a break statement is executed. (An infinite loop that never exits is a common programming bug.)\n\nJust like before, this program asks the user to enter your name \u278b . Now, however, while the execution is still inside the while loop, an if statement checks \u278c whether name is equal to 'your name' . If this condition is True , the break statement is run \u278d , and the execution moves out of the loop to print('Thank you!') \u278e . Otherwise, the if statement\u2019s clause that contains the break statement is skipped, which puts the execution at the end of the while loop. At this point, the program execution jumps back to the start of the while statement \u278a to recheck the condition. Since this condition is merely the True Boolean value, the execution enters the loop to ask the user to type your name again. See Figure 2-11 for this program\u2019s flowchart.\n\nRun yourName2.py , and enter the same text you entered for yourName.py . The rewritten program should respond in the same way as the original.\n\nFigure 2-11: The flowchart for the yourName2.py program with an infinite loop. Note that the X path will logically never happen, because the loop condition is always True .\n\n#### continue Statements\n\nLike break statements, continue statements are used inside loops. When the program execution reaches a continue statement, the program execution immediately jumps back to the start of the loop and reevaluates the loop\u2019s condition. (This is also what happens when the execution reaches the end of the loop.)\n\nLet\u2019s use continue to write a program that asks for a name and password. Enter the following code into a new file editor window and save the program as swordfish.py .\n\nTRAPPED IN AN INFINITE LOOP?\n\nIf you ever run a program that has a bug causing it to get stuck in an infinite loop, press CTRL -C or select Shell \u25b8 Restart Shell from IDLE\u2019s menu. This will send a KeyboardInterrupt error to your program and cause it to stop immediately. Try stopping a program by creating a simple infinite loop in the file editor, and save the program as infiniteLoop.py .\n\nwhile True: print('Hello, world!')\n\nWhen you run this program, it will print Hello, world! to the screen forever because the while statement\u2019s condition is always True . CTRL -C is also handy if you want to simply terminate your program immediately, even if it\u2019s not stuck in an infinite loop.\n\nwhile True: print('Who are you?') name = input() \u278a if name != 'Joe': \u278b continue print('Hello, Joe. What is the password? (It is a fish.)') \u278c password = input() if password == 'swordfish': \u278d break \u278e print('Access granted.')\n\nIf the user enters any name besides Joe \u278a , the continue statement \u278b causes the program execution to jump back to the start of the loop. When the program reevaluates the condition, the execution will always enter the loop, since the condition is simply the value True . Once the user makes it past that if statement, they are asked for a password \u278c . If the password entered is swordfish , then the break statement \u278d is run, and the execution jumps out of the while loop to print Access granted \u278e . Otherwise, the execution continues to the end of the while loop, where it then jumps back to the start of the loop. See Figure 2-12 for this program\u2019s flowchart.\n\nFigure 2-12: A flowchart for swordfish.py. The X path will logically never happen, because the loop condition is always True .\n\n\u201cTRUTHY\u201d AND \u201cFALSEY\u201d VALUES\n\nConditions will consider some values in other data types equivalent to True and False . When used in conditions, 0 , 0.0 , and '' (the empty string) are considered False , while all other values are considered True . For example, look at the following program:\n\nname = '' \u278a while not name: print('Enter your name:') name = input() print('How many guests will you have?') numOfGuests = int(input()) \u278b if numOfGuests: \u278c print('Be sure to have enough room for all your guests.') print('Done')\n\nYou can view the execution of this program at https://autbor.com/howmanyguests/ . If the user enters a blank string for name , then the while statement\u2019s condition will be True \u278a , and the program continues to ask for a name. If the value for numOfGuests is not 0 \u278b , then the condition is considered to be True , and the program will print a reminder for the user \u278c .\n\nYou could have entered not name != '' instead of not name , and numOfGuests != 0 instead of numOfGuests , but using the truthy and falsey values can make your code easier to read.\n\nRun this program and give it some input. Until you claim to be Joe, the program shouldn\u2019t ask for a password, and once you enter the correct password, it should exit.\n\nWho are you? I'm fine, thanks. Who are you? Who are you? Joe Hello, Joe. What is the password? (It is a fish.) Mary Who are you? Joe Hello, Joe. What is the password? (It is a fish.) swordfish Access granted.\n\nYou can view the execution of this program at https://autbor.com/hellojoe/ .\n\n#### for Loops and the range() Function\n\nThe while loop keeps looping while its condition is True (which is the reason for its name), but what if you want to execute a block of code only a certain number of times? You can do this with a for loop statement and the range() function.\n\nIn code, a for statement looks something like for i in range(5): and includes the following:\n\n- The for keyword\n- A variable name\n- The in keyword\n- A call to the range() method with up to three integers passed to it\n- A colon\n- Starting on the next line, an indented block of code (called the for clause)\n\nLet\u2019s create a new program called fiveTimes.py to help you see a for loop in action.\n\nprint('My name is') for i in range(5): print('Jimmy Five Times (' + str(i) + ')')\n\nYou can view the execution of this program at https://autbor.com/fivetimesfor/ . The code in the for loop\u2019s clause is run five times. The first time it is run, the variable i is set to 0 . The print() call in the clause will print Jimmy Five Times (0) . After Python finishes an iteration through all the code inside the for loop\u2019s clause, the execution goes back to the top of the loop, and the for statement increments i by one. This is why range(5) results in five iterations through the clause, with i being set to 0 , then 1 , then 2 , then 3 , and then 4 . The variable i will go up to, but will not include, the integer passed to range() . Figure 2-13 shows a flowchart for the fiveTimes.py program.\n\nWhen you run this program, it should print Jimmy Five Times followed by the value of i five times before leaving the for loop.\n\nMy name is Jimmy Five Times (0) Jimmy Five Times (1) Jimmy Five Times (2) Jimmy Five Times (3) Jimmy Five Times (4)\n\nNOTE\n\nYou can use break and continue statements inside for loops as well. The continue statement will continue to the next value of the for loop\u2019s counter, as if the program execution had reached the end of the loop and returned to the start. In fact, you can use continue and break statements only inside while and for loops. If you try to use these statements elsewhere, Python will give you an error.\n\nFigure 2-13: The flowchart for fiveTimes.py\n\nAs another for loop example, consider this story about the mathematician Carl Friedrich Gauss. When Gauss was a boy, a teacher wanted to give the class some busywork. The teacher told them to add up all the numbers from 0 to 100. Young Gauss came up with a clever trick to figure out the answer in a few seconds, but you can write a Python program with a for loop to do this calculation for you.\n\n\u278a total = 0 \u278b for num in range(101): \u278c total = total + num \u278d print(total)\n\nThe result should be 5,050. When the program first starts, the total variable is set to 0 \u278a . The for loop \u278b then executes total = total + num \u278c 100 times. By the time the loop has finished all of its 100 iterations, every integer from 0 to 100 will have been added to total . At this point, total is printed to the screen \u278d . Even on the slowest computers, this program takes less than a second to complete.\n\n(Young Gauss figured out a way to solve the problem in seconds. There are 50 pairs of numbers that add up to 101: 1 + 100, 2 + 99, 3 + 98, and so on, until 50 + 51. Since 50 \u00d7 101 is 5,050, the sum of all the numbers from 0 to 100 is 5,050. Clever kid!)\n\n#### An Equivalent while Loop\n\nYou can actually use a while loop to do the same thing as a for loop; for loops are just more concise. Let\u2019s rewrite fiveTimes.py to use a while loop equivalent of a for loop.\n\nprint('My name is') i = 0 while i < 5: print('Jimmy Five Times (' + str(i) + ')') i = i + 1\n\nYou can view the execution of this program at https://autbor.com/fivetimeswhile/ . If you run this program, the output should look the same as the fiveTimes.py program, which uses a for loop.\n\n#### The Starting, Stopping, and Stepping Arguments to range()\n\nSome functions can be called with multiple arguments separated by a comma, and range() is one of them. This lets you change the integer passed to range() to follow any sequence of integers, including starting at a number other than zero.\n\nfor i in range(12, 16): print(i)\n\nThe first argument will be where the for loop\u2019s variable starts, and the second argument will be up to, but not including, the number to stop at.\n\n12 13 14 15\n\nThe range() function can also be called with three arguments. The first two arguments will be the start and stop values, and the third will be the step argument . The step is the amount that the variable is increased by after each iteration.\n\nfor i in range(0, 10, 2): print(i)\n\nSo calling range(0, 10, 2) will count from zero to eight by intervals of two.\n\n0 2 4 6 8\n\nThe range() function is flexible in the sequence of numbers it produces for for loops. For example (I never apologize for my puns), you can even use a negative number for the step argument to make the for loop count down instead of up.\n\nfor i in range(5, -1, -1): print(i)\n\nThis for loop would have the following output:\n\n5 4 3 2 1 0\n\nRunning a for loop to print i with range(5, -1, -1) should print from five down to zero.\n\n### Importing Modules\n\nAll Python programs can call a basic set of functions called built-in functions , including the print() , input() , and len() functions you\u2019ve seen before. Python also comes with a set of modules called the standard library . Each module is a Python program that contains a related group of functions that can be embedded in your programs. For example, the math module has mathematics-related functions, the random module has random number-related functions, and so on.\n\nBefore you can use the functions in a module, you must import the module with an import statement. In code, an import statement consists of the following:\n\n- The import keyword\n- The name of the module\n- Optionally, more module names, as long as they are separated by commas\n\nOnce you import a module, you can use all the cool functions of that module. Let\u2019s give it a try with the random module, which will give us access to the random.randint() function.\n\nEnter this code into the file editor, and save it as printRandom.py :\n\nimport random for i in range(5): print(random.randint(1, 10))\n\nDON\u2019T OVERWRITE MODULE NAMES\n\nWhen you save your Python scripts, take care not to give them a name that is used by one of Python\u2019s modules, such as random.py , sys.py , os.py , or math.py . If you accidentally name one of your programs, say, random.py , and use an import random statement in another program, your program would import your random.py file instead of Python\u2019s random module. This can lead to errors such as AttributeError: module 'random' has no attribute 'randint' , since your random.py doesn\u2019t have the functions that the real random module has. Don\u2019t use the names of any built-in Python functions either, such as print() or input() .\n\nProblems like these are uncommon, but can be tricky to solve. As you gain more programming experience, you\u2019ll become more aware of the standard names used by Python\u2019s modules and functions, and will run into these problems less frequently.\n\nWhen you run this program, the output will look something like this:\n\n4 1 8 4 1\n\nYou can view the execution of this program at https://autbor.com/printrandom/ . The random.randint() function call evaluates to a random integer value between the two integers that you pass it. Since randint() is in the random module, you must first type random. in front of the function name to tell Python to look for this function inside the random module.\n\nHere\u2019s an example of an import statement that imports four different modules:\n\nimport random, sys, os, math\n\nNow we can use any of the functions in these four modules. We\u2019ll learn more about them later in the book.\n\n#### from import Statements\n\nAn alternative form of the import statement is composed of the from keyword, followed by the module name, the import keyword, and a star; for example, from random import * .\n\nWith this form of import statement, calls to functions in random will not need the random. prefix. However, using the full name makes for more readable code, so it is better to use the import random form of the statement.\n\n### Ending a Program Early with the sys.exit() Function\n\nThe last flow control concept to cover is how to terminate the program. Programs always terminate if the program execution reaches the bottom of the instructions. However, you can cause the program to terminate, or exit, before the last instruction by calling the sys.exit() function. Since this function is in the sys module, you have to import sys before your program can use it.\n\nOpen a file editor window and enter the following code, saving it as exitExample.py :\n\nimport sys while True: print('Type exit to exit.') response = input() if response == 'exit': sys.exit() print('You typed ' + response + '.')\n\nRun this program in IDLE. This program has an infinite loop with no break statement inside. The only way this program will end is if the execution reaches the sys.exit() call. When response is equal to exit , the line containing the sys.exit() call is executed. Since the response variable is set by the input() function, the user must enter exit in order to stop the program.\n\n### A Short Program: Guess the Number\n\nThe examples I\u2019ve shown you so far are useful for introducing basic concepts, but now let\u2019s see how everything you\u2019ve learned comes together in a more complete program. In this section, I\u2019ll show you a simple \u201cguess the number\u201d game. When you run this program, the output will look something like this:\n\nI am thinking of a number between 1 and 20. Take a guess. 10 Your guess is too low. Take a guess. 15 Your guess is too low. Take a guess. 17 Your guess is too high. Take a guess. 16 Good job! You guessed my number in 4 guesses!\n\nEnter the following source code into the file editor, and save the file as guessTheNumber.py :\n\n# This is a guess the number game. import random secretNumber = random.randint(1, 20) print('I am thinking of a number between 1 and 20.') # Ask the player to guess 6 times. for guessesTaken in range(1, 7): print('Take a guess.') guess = int(input()) if guess < secretNumber: print('Your guess is too low.') elif guess > secretNumber: print('Your guess is too high.') else: break\u00a0\u00a0\u00a0\u00a0# This condition is the correct guess! if guess == secretNumber: print('Good job! You guessed my number in ' + str(guessesTaken) + ' guesses!') else: print('Nope. The number I was thinking of was ' + str(secretNumber))\n\nYou can view the execution of this program at https://autbor.com/guessthenumber/ . Let\u2019s look at this code line by line, starting at the top.\n\n# This is a guess the number game. import random secretNumber = random.randint(1, 20)\n\nFirst, a comment at the top of the code explains what the program does. Then, the program imports the random module so that it can use the random.randint() function to generate a number for the user to guess. The return value, a random integer between 1 and 20, is stored in the variable secretNumber .\n\nprint('I am thinking of a number between 1 and 20.') # Ask the player to guess 6 times. for guessesTaken in range(1, 7): print('Take a guess.') guess = int(input())\n\nThe program tells the player that it has come up with a secret number and will give the player six chances to guess it. The code that lets the player enter a guess and checks that guess is in a for loop that will loop at most six times. The first thing that happens in the loop is that the player types in a guess. Since input() returns a string, its return value is passed straight into int() , which translates the string into an integer value. This gets stored in a variable named guess .\n\nif guess < secretNumber: print('Your guess is too low.') elif guess > secretNumber: print('Your guess is too high.')\n\nThese few lines of code check to see whether the guess is less than or greater than the secret number. In either case, a hint is printed to the screen.\n\nelse: break\u00a0\u00a0\u00a0\u00a0# This condition is the correct guess!\n\nIf the guess is neither higher nor lower than the secret number, then it must be equal to the secret number\u2014in which case, you want the program execution to break out of the for loop.\n\nif guess == secretNumber: print('Good job! You guessed my number in ' + str(guessesTaken) + ' guesses!') else: print('Nope. The number I was thinking of was ' + str(secretNumber))\n\nAfter the for loop, the previous if...else statement checks whether the player has correctly guessed the number and then prints an appropriate message to the screen. In both cases, the program displays a variable that contains an integer value ( guessesTaken and secretNumber ). Since it must concatenate these integer values to strings, it passes these variables to the str() function, which returns the string value form of these integers. Now these strings can be concatenated with the + operators before finally being passed to the print() function call.\n\n### A Short Program: Rock, Paper, Scissors\n\nLet\u2019s use the programming concepts we\u2019ve learned so far to create a simple rock, paper, scissors game. The output will look like this:\n\nROCK, PAPER, SCISSORS 0 Wins, 0 Losses, 0 Ties Enter your move: (r)ock (p)aper (s)cissors or (q)uit p PAPER versus... PAPER It is a tie! 0 Wins, 1 Losses, 1 Ties Enter your move: (r)ock (p)aper (s)cissors or (q)uit s SCISSORS versus... PAPER You win! 1 Wins, 1 Losses, 1 Ties Enter your move: (r)ock (p)aper (s)cissors or (q)uit q\n\nType the following source code into the file editor, and save the file as rpsGame.py :\n\nimport random, sys print('ROCK, PAPER, SCISSORS') # These variables keep track of the number of wins, losses, and ties. wins = 0 losses = 0 ties = 0 while True: # The main game loop. print('%s Wins, %s Losses, %s Ties' % (wins, losses, ties)) while True: # The player input loop. print('Enter your move: (r)ock (p)aper (s)cissors or (q)uit') playerMove = input() if playerMove == 'q': sys.exit() # Quit the program. if playerMove == 'r' or playerMove == 'p' or playerMove == 's': break # Break out of the player input loop. print('Type one of r, p, s, or q.') # Display what the player chose: if playerMove == 'r': print('ROCK versus...') elif playerMove == 'p': print('PAPER versus...') elif playerMove == 's': print('SCISSORS versus...') # Display what the computer chose: randomNumber = random.randint(1, 3) if randomNumber == 1: computerMove = 'r' print('ROCK') elif randomNumber == 2: computerMove = 'p' print('PAPER') elif randomNumber == 3: computerMove = 's' print('SCISSORS') # Display and record the win/loss/tie: if playerMove == computerMove: print('It is a tie!') ties = ties + 1 elif playerMove == 'r' and computerMove == 's': print('You win!') wins = wins + 1 elif playerMove == 'p' and computerMove == 'r': print('You win!') wins = wins + 1 elif playerMove == 's' and computerMove == 'p': print('You win!') wins = wins + 1 elif playerMove == 'r' and computerMove == 'p': print('You lose!') losses = losses + 1 elif playerMove == 'p' and computerMove == 's': print('You lose!') losses = losses + 1 elif playerMove == 's' and computerMove == 'r': print('You lose!') losses = losses + 1\n\nLet\u2019s look at this code line by line, starting at the top.\n\nimport random, sys print('ROCK, PAPER, SCISSORS') # These variables keep track of the number of wins, losses, and ties. wins = 0 losses = 0 ties = 0\n\nFirst, we import the random and sys module so that our program can call the random.randint() and sys.exit() functions. We also set up three variables to keep track of how many wins, losses, and ties the player has had.\n\nwhile True: # The main game loop. print('%s Wins, %s Losses, %s Ties' % (wins, losses, ties)) while True: # The player input loop. print('Enter your move: (r)ock (p)aper (s)cissors or (q)uit') playerMove = input() if playerMove == 'q': sys.exit() # Quit the program. if playerMove == 'r' or playerMove == 'p' or playerMove == 's': break # Break out of the player input loop. print('Type one of r, p, s, or q.')\n\nThis program uses a while loop inside of another while loop. The first loop is the main game loop, and a single game of rock, paper, scissors is played on each iteration through this loop. The second loop asks for input from the player, and keeps looping until the player has entered an r , p , s , or q for their move. The r , p , and s correspond to rock, paper, and scissors, respectively, while the q means the player intends to quit. In that case, sys.exit() is called and the program exits. If the player has entered r , p , or s , the execution breaks out of the loop. Otherwise, the program reminds the player to enter r , p , s , or q and goes back to the start of the loop.\n\n# Display what the player chose: if playerMove == 'r': print('ROCK versus...') elif playerMove == 'p': print('PAPER versus...') elif playerMove == 's': print('SCISSORS versus...')\n\nThe player\u2019s move is displayed on the screen.\n\n# Display what the computer chose: randomNumber = random.randint(1, 3) if randomNumber == 1: computerMove = 'r' print('ROCK') elif randomNumber == 2: computerMove = 'p' print('PAPER') elif randomNumber == 3: computerMove = 's' print('SCISSORS')\n\nNext, the computer\u2019s move is randomly selected. Since random.randint() can only return a random number, the 1 , 2 , or 3 integer value it returns is stored in a variable named randomNumber . The program stores a 'r' , 'p' , or 's' string in computerMove based on the integer in randomNumber , as well as displays the computer\u2019s move.\n\n# Display and record the win/loss/tie: if playerMove == computerMove: print('It is a tie!') ties = ties + 1 elif playerMove == 'r' and computerMove == 's': print('You win!') wins = wins + 1 elif playerMove == 'p' and computerMove == 'r': print('You win!') wins = wins + 1 elif playerMove == 's' and computerMove == 'p': print('You win!') wins = wins + 1 elif playerMove == 'r' and computerMove == 'p': print('You lose!') losses = losses + 1 elif playerMove == 'p' and computerMove == 's': print('You lose!') losses = losses + 1 elif playerMove == 's' and computerMove == 'r': print('You lose!') losses = losses + 1\n\nFinally, the program compares the strings in playerMove and computerMove , and displays the results on the screen. It also increments the wins , losses , or ties variable appropriately. Once the execution reaches the end, it jumps back to the start of the main program loop to begin another game.\n\n### Summary\n\nBy using expressions that evaluate to True or False (also called conditions), you can write programs that make decisions on what code to execute and what code to skip. You can also execute code over and over again in a loop while a certain condition evaluates to True . The break and continue statements are useful if you need to exit a loop or jump back to the loop\u2019s start.\n\nThese flow control statements will let you write more intelligent programs. You can also use another type of flow control by writing your own functions, which is the topic of the next chapter.\n\n### Practice Questions\n\n1. What are the two values of the Boolean data type? How do you write them?\n\n2. What are the three Boolean operators?\n\n3. Write out the truth tables of each Boolean operator (that is, every possible combination of Boolean values for the operator and what they evaluate to).\n\n4. What do the following expressions evaluate to?\n\n(5 > 4) and (3 == 5) not (5 > 4) (5 > 4) or (3 == 5) not ((5 > 4) or (3 == 5)) (True and True) and (True == False) (not False) or (not True)\n\n5. What are the six comparison operators?\n\n6. What is the difference between the equal to operator and the assignment operator?\n\n7. Explain what a condition is and where you would use one.\n\n8. Identify the three blocks in this code:\n\nspam = 0 if spam == 10: print('eggs') if spam > 5: print('bacon') else: print('ham') print('spam') print('spam')\n\n9. Write code that prints Hello if 1 is stored in spam , prints Howdy if 2 is stored in spam , and prints Greetings! if anything else is stored in spam .\n\n10. What keys can you press if your program is stuck in an infinite loop?\n\n11. What is the difference between break and continue ?\n\n12. What is the difference between range(10) , range(0, 10) , and range(0, 10, 1) in a for loop?\n\n13. Write a short program that prints the numbers 1 to 10 using a for loop. Then write an equivalent program that prints the numbers 1 to 10 using a while loop.\n\n14. If you had a function named bacon() inside a module named spam , how would you call it after importing spam ?\n\nExtra credit: Look up the round() and abs() functions on the internet, and find out what they do. Experiment with them in the interactive shell.",
      "difficulty": "intro",
      "doc_id": "doc-2flow-control-c08fec5c50",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-NC-SA 3.0",
        "source_file": "data/corpus_raw/scraped/2e_chapter2_b2ea3c.json",
        "url": "https://automatetheboringstuff.com/2e/chapter2/"
      },
      "title": "2FLOW CONTROL",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "data_types",
        "numbers",
        "operators",
        "strings",
        "variables"
      ],
      "content": "# 3.An Informal Introduction to Python\u00c2\u00b6\n\nIn the following examples, input and output are distinguished by the presence or\nabsence of prompts ( >>> and \u00e2\u0080\u00a6 ): to repeat the example, you must type\neverything after the prompt, when the prompt appears; lines that do not begin\nwith a prompt are output from the interpreter. Note that a secondary prompt on a\nline by itself in an example means you must type a blank line; this is used to\nend a multi-line command.\n\nYou can use the \u00e2\u0080\u009cCopy\u00e2\u0080\u009d button (it appears in the upper-right corner\nwhen hovering over or tapping a code example), which strips prompts\nand omits output, to copy and paste the input lines into your interpreter.\n\nMany of the examples in this manual, even those entered at the interactive\nprompt, include comments.  Comments in Python start with the hash character, # , and extend to the end of the physical line.  A comment may appear at the\nstart of a line or following whitespace or code, but not within a string\nliteral.  A hash character within a string literal is just a hash character.\nSince comments are to clarify code and are not interpreted by Python, they may\nbe omitted when typing in examples.\n\nSome examples:\n\n```python\n# this is the first comment\nspam = 1  # and this is the second comment\n          # ... and now a third!\ntext = \"# This is not a comment because it's inside quotes.\"\n```python\n\n## 3.1.Using Python as a Calculator\u00c2\u00b6\n\nLet\u00e2\u0080\u0099s try some simple Python commands.  Start the interpreter and wait for the\nprimary prompt, >>> .  (It shouldn\u00e2\u0080\u0099t take long.)\n\n### 3.1.1.Numbers\u00c2\u00b6\n\nThe interpreter acts as a simple calculator: you can type an expression into it\nand it will write the value.  Expression syntax is straightforward: the\noperators + , - , * and / can be used to perform\narithmetic; parentheses ( () ) can be used for grouping.\nFor example:\n\n```python\n>>> 2 + 2\n4\n>>> 50 - 5*6\n20\n>>> (50 - 5*6) / 4\n5.0\n>>> 8 / 5  # division always returns a floating-point number\n1.6\n```python\n\nThe integer numbers (e.g. 2 , 4 , 20 ) have type int ,\nthe ones with a fractional part (e.g. 5.0 , 1.6 ) have type float .  We will see more about numeric types later in the tutorial.\n\nDivision ( / ) always returns a float.  To do floor division and\nget an integer result you can use the // operator; to calculate\nthe remainder you can use % :\n\n```python\n>>> 17 / 3  # classic division returns a float\n5.666666666666667\n>>>\n>>> 17 // 3  # floor division discards the fractional part\n5\n>>> 17 % 3  # the % operator returns the remainder of the division\n2\n>>> 5 * 3 + 2  # floored quotient * divisor + remainder\n17\n```python\n\nWith Python, it is possible to use the ** operator to calculate powers [ 1 ] :\n\n```python\n>>> 5 ** 2  # 5 squared\n25\n>>> 2 ** 7  # 2 to the power of 7\n128\n```python\n\nThe equal sign ( = ) is used to assign a value to a variable. Afterwards, no\nresult is displayed before the next interactive prompt:\n\n```python\n>>> width = 20\n>>> height = 5 * 9\n>>> width * height\n900\n```python\n\nIf a variable is not \u00e2\u0080\u009cdefined\u00e2\u0080\u009d (assigned a value), trying to use it will\ngive you an error:\n\n```python\n>>> n  # try to access an undefined variable\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nNameError: name 'n' is not defined\n```python\n\nThere is full support for floating point; operators with mixed type operands\nconvert the integer operand to floating point:\n\n```python\n>>> 4 * 3.75 - 1\n14.0\n```python\n\nIn interactive mode, the last printed expression is assigned to the variable _ .  This means that when you are using Python as a desk calculator, it is\nsomewhat easier to continue calculations, for example:\n\n```python\n>>> tax = 12.5 / 100\n>>> price = 100.50\n>>> price * tax\n12.5625\n>>> price + _\n113.0625\n>>> round(_, 2)\n113.06\n```python\n\nThis variable should be treated as read-only by the user.  Don\u00e2\u0080\u0099t explicitly\nassign a value to it \u00e2\u0080\u0094 you would create an independent local variable with the\nsame name masking the built-in variable with its magic behavior.\n\nIn addition to int and float , Python supports other types of\nnumbers, such as Decimal and Fraction .\nPython also has built-in support for complex numbers ,\nand uses the j or J suffix to indicate the imaginary part\n(e.g. 3+5j ).\n\n### 3.1.2.Text\u00c2\u00b6\n\nPython can manipulate text (represented by type str , so-called\n\u00e2\u0080\u009cstrings\u00e2\u0080\u009d) as well as numbers.  This includes characters \u00e2\u0080\u009c ! \u00e2\u0080\u009d, words\n\u00e2\u0080\u009c rabbit \u00e2\u0080\u009d, names \u00e2\u0080\u009c Paris \u00e2\u0080\u009d, sentences \u00e2\u0080\u009c Got your back. \u00e2\u0080\u009d, etc.\n\u00e2\u0080\u009c Yay! :) \u00e2\u0080\u009d. They can be enclosed in single quotes ( '...' ) or double\nquotes ( \"...\" ) with the same result [ 2 ] .\n\n```python\n>>> 'spam eggs'  # single quotes\n'spam eggs'\n>>> \"Paris rabbit got your back :)! Yay!\"  # double quotes\n'Paris rabbit got your back :)! Yay!'\n>>> '1975'  # digits and numerals enclosed in quotes are also strings\n'1975'\n```python\n\nTo quote a quote, we need to \u00e2\u0080\u009cescape\u00e2\u0080\u009d it, by preceding it with \\ .\nAlternatively, we can use the other type of quotation marks:\n\n```python\n>>> 'doesn\\'t'  # use \\' to escape the single quote...\n\"doesn't\"\n>>> \"doesn't\"  # ...or use double quotes instead\n\"doesn't\"\n>>> '\"Yes,\" they said.'\n'\"Yes,\" they said.'\n>>> \"\\\"Yes,\\\" they said.\"\n'\"Yes,\" they said.'\n>>> '\"Isn\\'t,\" they said.'\n'\"Isn\\'t,\" they said.'\n```python\n\nIn the Python shell, the string definition and output string can look\ndifferent.  The print() function produces a more readable output, by\nomitting the enclosing quotes and by printing escaped and special characters:\n\n```python\n>>> s = 'First line.\\nSecond line.'  # \\n means newline\n>>> s  # without print(), special characters are included in the string\n'First line.\\nSecond line.'\n>>> print(s)  # with print(), special characters are interpreted, so \\n produces new line\nFirst line.\nSecond line.\n```python\n\nIf you don\u00e2\u0080\u0099t want characters prefaced by \\ to be interpreted as\nspecial characters, you can use raw strings by adding an r before\nthe first quote:\n\n```python\n>>> print('C:\\some\\name')  # here \\n means newline!\nC:\\some\name\n>>> print(r'C:\\some\\name')  # note the r before the quote\nC:\\some\\name\n```python\n\nThere is one subtle aspect to raw strings: a raw string may not end in\nan odd number of \\ characters; see the FAQ entry for more information\nand workarounds.\n\nString literals can span multiple lines.  One way is using triple-quotes: \"\"\"...\"\"\" or '''...''' .  End-of-line characters are automatically\nincluded in the string, but it\u00e2\u0080\u0099s possible to prevent this by adding a \\ at\nthe end of the line.  In the following example, the initial newline is not\nincluded:\n\n```python\n>>> print(\"\"\"\\\n... Usage: thingy [OPTIONS]\n...      -h                        Display this usage message\n...      -H hostname               Hostname to connect to\n... \"\"\")\nUsage: thingy [OPTIONS]\n     -h                        Display this usage message\n     -H hostname               Hostname to connect to\n\n>>>\n```python\n\nStrings can be concatenated (glued together) with the + operator, and\nrepeated with * :\n\n```python\n>>> # 3 times 'un', followed by 'ium'\n>>> 3 * 'un' + 'ium'\n'unununium'\n```python\n\nTwo or more string literals (i.e. the ones enclosed between quotes) next\nto each other are automatically concatenated.\n\n```python\n>>> 'Py' 'thon'\n'Python'\n```python\n\nThis feature is particularly useful when you want to break long strings:\n\n```python\n>>> text = ('Put several strings within parentheses '\n...         'to have them joined together.')\n>>> text\n'Put several strings within parentheses to have them joined together.'\n```python\n\nThis only works with two literals though, not with variables or expressions:\n\n```python\n>>> prefix = 'Py'\n>>> prefix 'thon'  # can't concatenate a variable and a string literal\n  File \"<stdin>\", line 1\n    prefix 'thon'\n           ^^^^^^\nSyntaxError: invalid syntax\n>>> ('un' * 3) 'ium'\n  File \"<stdin>\", line 1\n    ('un' * 3) 'ium'\n               ^^^^^\nSyntaxError: invalid syntax\n```python\n\nIf you want to concatenate variables or a variable and a literal, use + :\n\n```python\n>>> prefix + 'thon'\n'Python'\n```python\n\nStrings can be indexed (subscripted), with the first character having index 0.\nThere is no separate character type; a character is simply a string of size\none:\n\n```python\n>>> word = 'Python'\n>>> word[0]  # character in position 0\n'P'\n>>> word[5]  # character in position 5\n'n'\n```python\n\nIndices may also be negative numbers, to start counting from the right:\n\n```python\n>>> word[-1]  # last character\n'n'\n>>> word[-2]  # second-last character\n'o'\n>>> word[-6]\n'P'\n```python\n\nNote that since -0 is the same as 0, negative indices start from -1.\n\nIn addition to indexing, slicing is also supported.  While indexing is used\nto obtain individual characters, slicing allows you to obtain a substring:\n\n```python\n>>> word[0:2]  # characters from position 0 (included) to 2 (excluded)\n'Py'\n>>> word[2:5]  # characters from position 2 (included) to 5 (excluded)\n'tho'\n```python\n\nSlice indices have useful defaults; an omitted first index defaults to zero, an\nomitted second index defaults to the size of the string being sliced.\n\n```python\n>>> word[:2]   # character from the beginning to position 2 (excluded)\n'Py'\n>>> word[4:]   # characters from position 4 (included) to the end\n'on'\n>>> word[-2:]  # characters from the second-last (included) to the end\n'on'\n```python\n\nNote how the start is always included, and the end always excluded.  This\nmakes sure that s[:i] + s[i:] is always equal to s :\n\n```python\n>>> word[:2] + word[2:]\n'Python'\n>>> word[:4] + word[4:]\n'Python'\n```python\n\nOne way to remember how slices work is to think of the indices as pointing between characters, with the left edge of the first character numbered 0.\nThen the right edge of the last character of a string of n characters has\nindex n , for example:\n\n```python\n +---+---+---+---+---+---+\n | P | y | t | h | o | n |\n +---+---+---+---+---+---+\n 0   1   2   3   4   5   6\n-6  -5  -4  -3  -2  -1\n```python\n\nThe first row of numbers gives the position of the indices 0\u00e2\u0080\u00a66 in the string;\nthe second row gives the corresponding negative indices. The slice from i to j consists of all characters between the edges labeled i and j ,\nrespectively.\n\nFor non-negative indices, the length of a slice is the difference of the\nindices, if both are within bounds.  For example, the length of word[1:3] is\n2.\n\nAttempting to use an index that is too large will result in an error:\n\n```python\n>>> word[42]  # the word only has 6 characters\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nIndexError: string index out of range\n```python\n\nHowever, out of range slice indexes are handled gracefully when used for\nslicing:\n\n```python\n>>> word[4:42]\n'on'\n>>> word[42:]\n''\n```python\n\nPython strings cannot be changed \u00e2\u0080\u0094 they are immutable .\nTherefore, assigning to an indexed position in the string results in an error:\n\n```python\n>>> word[0] = 'J'\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: 'str' object does not support item assignment\n>>> word[2:] = 'py'\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: 'str' object does not support item assignment\n```python\n\nIf you need a different string, you should create a new one:\n\n```python\n>>> 'J' + word[1:]\n'Jython'\n>>> word[:2] + 'py'\n'Pypy'\n```python\n\nThe built-in function len() returns the length of a string:\n\n```python\n>>> s = 'supercalifragilisticexpialidocious'\n>>> len(s)\n34\n```python\n\nSee also\n\nText Sequence Type \u00e2\u0080\u0094 str\nStrings are examples of sequence types , and support the common\noperations supported by such types.\n\nString Methods\nStrings support a large number of methods for\nbasic transformations and searching.\n\nf-strings\nString literals that have embedded expressions.\n\nFormat String Syntax\nInformation about string formatting with str.format() .\n\nprintf-style String Formatting\nThe old formatting operations invoked when strings are\nthe left operand of the % operator are described in more detail here.\n\n### 3.1.3.Lists\u00c2\u00b6\n\nPython knows a number of compound data types, used to group together other\nvalues.  The most versatile is the list , which can be written as a list of\ncomma-separated values (items) between square brackets.  Lists might contain\nitems of different types, but usually the items all have the same type.\n\n```python\n>>> squares = [1, 4, 9, 16, 25]\n>>> squares\n[1, 4, 9, 16, 25]\n```python\n\nLike strings (and all other built-in sequence types), lists can be\nindexed and sliced:\n\n```python\n>>> squares[0]  # indexing returns the item\n1\n>>> squares[-1]\n25\n>>> squares[-3:]  # slicing returns a new list\n[9, 16, 25]\n```python\n\nLists also support operations like concatenation:\n\n```python\n>>> squares + [36, 49, 64, 81, 100]\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n```python\n\nUnlike strings, which are immutable , lists are a mutable type, i.e. it is possible to change their content:\n\n```python\n>>> cubes = [1, 8, 27, 65, 125]  # something's wrong here\n>>> 4 ** 3  # the cube of 4 is 64, not 65!\n64\n>>> cubes[3] = 64  # replace the wrong value\n>>> cubes\n[1, 8, 27, 64, 125]\n```python\n\nYou can also add new items at the end of the list, by using\nthe list.append() method (we will see more about methods later):\n\n```python\n>>> cubes.append(216)  # add the cube of 6\n>>> cubes.append(7 ** 3)  # and the cube of 7\n>>> cubes\n[1, 8, 27, 64, 125, 216, 343]\n```python\n\nSimple assignment in Python never copies data. When you assign a list\nto a variable, the variable refers to the existing list .\nAny changes you make to the list through one variable will be seen\nthrough all other variables that refer to it.:\n\n```python\n>>> rgb = [\"Red\", \"Green\", \"Blue\"]\n>>> rgba = rgb\n>>> id(rgb) == id(rgba)  # they reference the same object\nTrue\n>>> rgba.append(\"Alph\")\n>>> rgb\n[\"Red\", \"Green\", \"Blue\", \"Alph\"]\n```python\n\nAll slice operations return a new list containing the requested elements.  This\nmeans that the following slice returns a shallow copy of the list:\n\n```python\n>>> correct_rgba = rgba[:]\n>>> correct_rgba[-1] = \"Alpha\"\n>>> correct_rgba\n[\"Red\", \"Green\", \"Blue\", \"Alpha\"]\n>>> rgba\n[\"Red\", \"Green\", \"Blue\", \"Alph\"]\n```python\n\nAssignment to slices is also possible, and this can even change the size of the\nlist or clear it entirely:\n\n```python\n>>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']\n>>> letters\n['a', 'b', 'c', 'd', 'e', 'f', 'g']\n>>> # replace some values\n>>> letters[2:5] = ['C', 'D', 'E']\n>>> letters\n['a', 'b', 'C', 'D', 'E', 'f', 'g']\n>>> # now remove them\n>>> letters[2:5] = []\n>>> letters\n['a', 'b', 'f', 'g']\n>>> # clear the list by replacing all the elements with an empty list\n>>> letters[:] = []\n>>> letters\n[]\n```python\n\nThe built-in function len() also applies to lists:\n\n```python\n>>> letters = ['a', 'b', 'c', 'd']\n>>> len(letters)\n4\n```python\n\nIt is possible to nest lists (create lists containing other lists), for\nexample:\n\n```python\n>>> a = ['a', 'b', 'c']\n>>> n = [1, 2, 3]\n>>> x = [a, n]\n>>> x\n[['a', 'b', 'c'], [1, 2, 3]]\n>>> x[0]\n['a', 'b', 'c']\n>>> x[0][1]\n'b'\n```python\n\n## 3.2.First Steps Towards Programming\u00c2\u00b6\n\nOf course, we can use Python for more complicated tasks than adding two and two\ntogether.  For instance, we can write an initial sub-sequence of the Fibonacci series as follows:\n\n```python\n>>> # Fibonacci series:\n>>> # the sum of two elements defines the next\n>>> a, b = 0, 1\n>>> while a < 10:\n...     print(a)\n...     a, b = b, a+b\n...\n0\n1\n1\n2\n3\n5\n8\n```python\n\nThis example introduces several new features.\n\n- The first line contains a multiple assignment : the variables a and b simultaneously get the new values 0 and 1.  On the last line this is used again,\ndemonstrating that the expressions on the right-hand side are all evaluated\nfirst before any of the assignments take place.  The right-hand side expressions\nare evaluated  from the left to the right.\n- The while loop executes as long as the condition (here: a < 10 )\nremains true.  In Python, like in C, any non-zero integer value is true; zero is\nfalse.  The condition may also be a string or list value, in fact any sequence;\nanything with a non-zero length is true, empty sequences are false.  The test\nused in the example is a simple comparison.  The standard comparison operators\nare written the same as in C: < (less than), > (greater than), == (equal to), <= (less than or equal to), >= (greater than or equal to)\nand != (not equal to).\n- The body of the loop is indented : indentation is Python\u00e2\u0080\u0099s way of grouping\nstatements.  At the interactive prompt, you have to type a tab or space(s) for\neach indented line.  In practice you will prepare more complicated input\nfor Python with a text editor; all decent text editors have an auto-indent\nfacility.  When a compound statement is entered interactively, it must be\nfollowed by a blank line to indicate completion (since the parser cannot\nguess when you have typed the last line).  Note that each line within a basic\nblock must be indented by the same amount.\n- The print() function writes the value of the argument(s) it is given.\nIt differs from just writing the expression you want to write (as we did\nearlier in the calculator examples) in the way it handles multiple arguments,\nfloating-point quantities, and strings.  Strings are printed without quotes,\nand a space is inserted between items, so you can format things nicely, like\nthis: >>> i = 256 * 256 >>> print ( 'The value of i is' , i ) The value of i is 65536 The keyword argument end can be used to avoid the newline after the output,\nor end the output with a different string: >>> a , b = 0 , 1 >>> while a < 1000 : ... print ( a , end = ',' ) ... a , b = b , a + b ... 0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,\n\nFootnotes",
      "difficulty": "intro",
      "doc_id": "doc-3-an-informal-introduction-to-python-b84ef065ad",
      "provenance": {
        "author": "",
        "date": "",
        "license": "PSF Documentation License",
        "source_file": "data/corpus_raw/scraped/3_tutorial_introduction_html_104659.json",
        "url": "https://docs.python.org/3/tutorial/introduction.html"
      },
      "title": "3.An Informal Introduction to Python\u00c2\u00b6",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "arguments",
        "functions",
        "return_values",
        "scope"
      ],
      "content": "## 3FUNCTIONS\n\nYou\u2019re already familiar with the print() , input() , and len() functions from the previous chapters. Python provides several built-in functions like these, but you can also write your own functions. A function is like a miniprogram within a program.\n\nTo better understand how functions work, let\u2019s create one. Enter this program into the file editor and save it as helloFunc.py :\n\n\u278a def hello(): \u278b print('Howdy!') print('Howdy!!!') print('Hello there.') \u278c hello() hello() hello()\n\nYou can view the execution of this program at https://autbor.com/hellofunc/ . The first line is a def statement \u278a , which defines a function named hello() . The code in the block that follows the def statement \u278b is the body of the function. This code is executed when the function is called, not when the function is first defined.\n\nThe hello() lines after the function \u278c are function calls. In code, a function call is just the function\u2019s name followed by parentheses, possibly with some number of arguments in between the parentheses. When the program execution reaches these calls, it will jump to the top line in the function and begin executing the code there. When it reaches the end of the function, the execution returns to the line that called the function and continues moving through the code as before.\n\nSince this program calls hello() three times, the code in the hello() function is executed three times. When you run this program, the output looks like this:\n\nHowdy! Howdy!!! Hello there. Howdy! Howdy!!! Hello there. Howdy! Howdy!!! Hello there.\n\nA major purpose of functions is to group code that gets executed multiple times. Without a function defined, you would have to copy and paste this code each time, and the program would look like this:\n\nprint('Howdy!') print('Howdy!!!') print('Hello there.') print('Howdy!') print('Howdy!!!') print('Hello there.') print('Howdy!') print('Howdy!!!') print('Hello there.')\n\nIn general, you always want to avoid duplicating code because if you ever decide to update the code\u2014if, for example, you find a bug you need to fix\u2014you\u2019ll have to remember to change the code everywhere you copied it.\n\nAs you get more programming experience, you\u2019ll often find yourself deduplicating code, which means getting rid of duplicated or copy-and-pasted code. Deduplication makes your programs shorter, easier to read, and easier to update.\n\n### def Statements with Parameters\n\nWhen you call the print() or len() function, you pass them values, called arguments , by typing them between the parentheses. You can also define your own functions that accept arguments. Type this example into the file editor and save it as helloFunc2.py :\n\n\u278a def hello(name): \u278b print('Hello, ' + name) \u278c hello('Alice') hello('Bob')\n\nWhen you run this program, the output looks like this:\n\nHello, Alice Hello, Bob\n\nYou can view the execution of this program at https://autbor.com/hellofunc2/ . The definition of the hello() function in this program has a parameter called name \u278a . Parameters are variables that contain arguments. When a function is called with arguments, the arguments are stored in the parameters. The first time the hello() function is called, it is passed the argument 'Alice' \u278c . The program execution enters the function, and the parameter name is automatically set to 'Alice' , which is what gets printed by the print() statement \u278b .\n\nOne special thing to note about parameters is that the value stored in a parameter is forgotten when the function returns. For example, if you added print(name) after hello('Bob') in the previous program, the program would give you a NameError because there is no variable named name . This variable is destroyed after the function call hello('Bob') returns, so print(name) would refer to a name variable that does not exist.\n\nThis is similar to how a program\u2019s variables are forgotten when the program terminates. I\u2019ll talk more about why that happens later in the chapter, when I discuss what a function\u2019s local scope is.\n\n#### Define, Call, Pass, Argument, Parameter\n\nThe terms define , call , pass , argument , and parameter can be confusing. Let\u2019s look at a code example to review these terms:\n\n\u278a def sayHello(name): print('Hello, ' + name) \u278b sayHello('Al')\n\nTo define a function is to create it, just like an assignment statement like spam = 42 creates the spam variable. The def statement defines the sayHello() function \u278a . The sayHello('Al') line \u278b calls the now-created function, sending the execution to the top of the function\u2019s code. This function call is also known as passing the string value 'Al' to the function. A value being passed to a function in a function call is an argument . The argument 'Al' is assigned to a local variable named name . Variables that have arguments assigned to them are parameters .\n\nIt\u2019s easy to mix up these terms, but keeping them straight will ensure that you know precisely what the text in this chapter means.\n\n### Return Values and return Statements\n\nWhen you call the len() function and pass it an argument such as 'Hello' , the function call evaluates to the integer value 5 , which is the length of the string you passed it. In general, the value that a function call evaluates to is called the return value of the function.\n\nWhen creating a function using the def statement, you can specify what the return value should be with a return statement. A return statement consists of the following:\n\n- The return keyword\n- The value or expression that the function should return\n\nWhen an expression is used with a return statement, the return value is what this expression evaluates to. For example, the following program defines a function that returns a different string depending on what number it is passed as an argument. Enter this code into the file editor and save it as magic8Ball.py :\n\n\u278a import random \u278b def getAnswer(answerNumber): \u278c if answerNumber == 1: return 'It is certain' elif answerNumber == 2: return 'It is decidedly so' elif answerNumber == 3: return 'Yes' elif answerNumber == 4: return 'Reply hazy try again' elif answerNumber == 5: return 'Ask again later' elif answerNumber == 6: return 'Concentrate and ask again' elif answerNumber == 7: return 'My reply is no' elif answerNumber == 8: return 'Outlook not so good' elif answerNumber == 9: return 'Very doubtful' \u278d r = random.randint(1, 9) \u278e fortune = getAnswer(r) \u278f print(fortune)\n\nYou can view the execution of this program at https://autbor.com/magic8ball/ . When this program starts, Python first imports the random module \u278a . Then the getAnswer() function is defined \u278b . Because the function is being defined (and not called), the execution skips over the code in it. Next, the random.randint() function is called with two arguments: 1 and 9 \u278d . It evaluates to a random integer between 1 and 9 (including 1 and 9 themselves), and this value is stored in a variable named r .\n\nThe getAnswer() function is called with r as the argument \u278e . The program execution moves to the top of the getAnswer() function \u278c , and the value r is stored in a parameter named answerNumber . Then, depending on the value in answerNumber , the function returns one of many possible string values. The program execution returns to the line at the bottom of the program that originally called getAnswer() \u278e . The returned string is assigned to a variable named fortune , which then gets passed to a print() call \u278f and is printed to the screen.\n\nNote that since you can pass return values as an argument to another function call, you could shorten these three lines:\n\nr = random.randint(1, 9) fortune = getAnswer(r) print(fortune)\n\nto this single equivalent line:\n\nprint(getAnswer(random.randint(1, 9)))\n\nRemember, expressions are composed of values and operators. A function call can be used in an expression because the call evaluates to its return value.\n\n### The None Value\n\nIn Python, there is a value called None , which represents the absence of a value. The None value is the only value of the NoneType data type. (Other programming languages might call this value null , nil , or undefined .) Just like the Boolean True and False values, None must be typed with a capital N .\n\nThis value-without-a-value can be helpful when you need to store something that won\u2019t be confused for a real value in a variable. One place where None is used is as the return value of print() . The print() function displays text on the screen, but it doesn\u2019t need to return anything in the same way len() or input() does. But since all function calls need to evaluate to a return value, print() returns None . To see this in action, enter the following into the interactive shell:\n\n>>> spam = print('Hello!') Hello! >>> None == spam True\n\nBehind the scenes, Python adds return None to the end of any function definition with no return statement. This is similar to how a while or for loop implicitly ends with a continue statement. Also, if you use a return statement without a value (that is, just the return keyword by itself), then None is returned.\n\n### Keyword Arguments and the print() Function\n\nMost arguments are identified by their position in the function call. For example, random.randint(1, 10) is different from random.randint(10, 1) . The function call random.randint(1, 10) will return a random integer between 1 and 10 because the first argument is the low end of the range and the second argument is the high end (while random.randint(10, 1) causes an error).\n\nHowever, rather than through their position, keyword arguments are identified by the keyword put before them in the function call. Keyword arguments are often used for optional parameters . For example, the print() function has the optional parameters end and sep to specify what should be printed at the end of its arguments and between its arguments (separating them), respectively.\n\nIf you ran a program with the following code:\n\nprint('Hello') print('World')\n\nthe output would look like this:\n\nHello World\n\nThe two outputted strings appear on separate lines because the print() function automatically adds a newline character to the end of the string it is passed. However, you can set the end keyword argument to change the newline character to a different string. For example, if the code were this:\n\nprint('Hello', end='') print('World')\n\nthe output would look like this:\n\nHelloWorld\n\nThe output is printed on a single line because there is no longer a newline printed after 'Hello' . Instead, the blank string is printed. This is useful if you need to disable the newline that gets added to the end of every print() function call.\n\nSimilarly, when you pass multiple string values to print() , the function will automatically separate them with a single space. Enter the following into the interactive shell:\n\n>>> print('cats', 'dogs', 'mice') cats dogs mice\n\nBut you could replace the default separating string by passing the sep keyword argument a different string. Enter the following into the interactive shell:\n\n>>> print('cats', 'dogs', 'mice', sep=',') cats,dogs,mice\n\nYou can add keyword arguments to the functions you write as well, but first you\u2019ll have to learn about the list and dictionary data types in the next two chapters. For now, just know that some functions have optional keyword arguments that can be specified when the function is called.\n\n### The Call Stack\n\nImagine that you have a meandering conversation with someone. You talk about your friend Alice, which then reminds you of a story about your coworker Bob, but first you have to explain something about your cousin Carol. You finish you story about Carol and go back to talking about Bob, and when you finish your story about Bob, you go back to talking about Alice. But then you are reminded about your brother David, so you tell a story about him, and then get back to finishing your original story about Alice. Your conversation followed a stack -like structure, like in Figure 3-1. The conversation is stack-like because the current topic is always at the top of the stack.\n\nFigure 3-1: Your meandering conversation stack\n\nSimilar to our meandering conversation, calling a function doesn\u2019t send the execution on a one-way trip to the top of a function. Python will remember which line of code called the function so that the execution can return there when it encounters a return statement. If that original function called other functions, the execution would return to those function calls first, before returning from the original function call.\n\nOpen a file editor window and enter the following code, saving it as abcdCallStack.py :\n\ndef a(): print('a() starts') \u278a b() \u278b d() print('a() returns') def b(): print('b() starts') \u278c c() print('b() returns') def c(): \u278d print('c() starts') print('c() returns') def d(): print('d() starts') print('d() returns') \u278e a()\n\nIf you run this program, the output will look like this:\n\na() starts b() starts c() starts c() returns b() returns d() starts d() returns a() returns\n\nYou can view the execution of this program at https://autbor.com/abcdcallstack/ . When a() is called \u278e , it calls b() \u278a , which in turn calls c() \u278c . The c() function doesn\u2019t call anything; it just displays c() starts \u278d and c() returns before returning to the line in b() that called it \u278c . Once execution returns to the code in b() that called c() , it returns to the line in a() that called b() \u278a . The execution continues to the next line in the b() function \u278b , which is a call to d() . Like the c() function, the d() function also doesn\u2019t call anything. It just displays d() starts and d() returns before returning to the line in b() that called it. Since b() contains no other code, the execution returns to the line in a() that called b() \u278b . The last line in a() displays a() returns before returning to the original a() call at the end of the program \u278e .\n\nThe call stack is how Python remembers where to return the execution after each function call. The call stack isn\u2019t stored in a variable in your program; rather, Python handles it behind the scenes. When your program calls a function, Python creates a frame object on the top of the call stack. Frame objects store the line number of the original function call so that Python can remember where to return. If another function call is made, Python puts another frame object on the call stack above the other one.\n\nWhen a function call returns, Python removes a frame object from the top of the stack and moves the execution to the line number stored in it. Note that frame objects are always added and removed from the top of the stack and not from any other place. Figure 3-2 illustrates the state of the call stack in abcdCallStack.py as each function is called and returns.\n\nFigure 3-2: The frame objects of the call stack as abcdCallStack.py calls and returns from functions\n\nThe top of the call stack is which function the execution is currently in. When the call stack is empty, the execution is on a line outside of all functions.\n\nThe call stack is a technical detail that you don\u2019t strictly need to know about to write programs. It\u2019s enough to understand that function calls return to the line number they were called from. However, understanding call stacks makes it easier to understand local and global scopes, described in the next section.\n\n### Local and Global Scope\n\nParameters and variables that are assigned in a called function are said to exist in that function\u2019s local scope . Variables that are assigned outside all functions are said to exist in the global scope . A variable that exists in a local scope is called a local variable , while a variable that exists in the global scope is called a global variable . A variable must be one or the other; it cannot be both local and global.\n\nThink of a scope as a container for variables. When a scope is destroyed, all the values stored in the scope\u2019s variables are forgotten. There is only one global scope, and it is created when your program begins. When your program terminates, the global scope is destroyed, and all its variables are forgotten. Otherwise, the next time you ran a program, the variables would remember their values from the last time you ran it.\n\nA local scope is created whenever a function is called. Any variables assigned in the function exist within the function\u2019s local scope. When the function returns, the local scope is destroyed, and these variables are forgotten. The next time you call the function, the local variables will not remember the values stored in them from the last time the function was called. Local variables are also stored in frame objects on the call stack.\n\nScopes matter for several reasons:\n\n- Code in the global scope, outside of all functions, cannot use any local variables.\n- However, code in a local scope can access global variables.\n- Code in a function\u2019s local scope cannot use variables in any other local scope.\n- You can use the same name for different variables if they are in different scopes. That is, there can be a local variable named spam and a global variable also named spam .\n\nThe reason Python has different scopes instead of just making everything a global variable is so that when variables are modified by the code in a particular call to a function, the function interacts with the rest of the program only through its parameters and the return value. This narrows down the number of lines of code that may be causing a bug. If your program contained nothing but global variables and had a bug because of a variable being set to a bad value, then it would be hard to track down where this bad value was set. It could have been set from anywhere in the program, and your program could be hundreds or thousands of lines long! But if the bug is caused by a local variable with a bad value, you know that only the code in that one function could have set it incorrectly.\n\nWhile using global variables in small programs is fine, it is a bad habit to rely on global variables as your programs get larger and larger.\n\n#### Local Variables Cannot Be Used in the Global Scope\n\nConsider this program, which will cause an error when you run it:\n\ndef spam(): \u278a eggs = 31337 spam() print(eggs)\n\nIf you run this program, the output will look like this:\n\nTraceback (most recent call last): File \"C:/test1.py\", line 4, in <module> print(eggs) NameError: name 'eggs' is not defined\n\nThe error happens because the eggs variable exists only in the local scope created when spam() is called \u278a . Once the program execution returns from spam , that local scope is destroyed, and there is no longer a variable named eggs . So when your program tries to run print(eggs) , Python gives you an error saying that eggs is not defined. This makes sense if you think about it; when the program execution is in the global scope, no local scopes exist, so there can\u2019t be any local variables. This is why only global variables can be used in the global scope.\n\n#### Local Scopes Cannot Use Variables in Other Local Scopes\n\nA new local scope is created whenever a function is called, including when a function is called from another function. Consider this program:\n\ndef spam(): \u278a eggs = 99 \u278b bacon() \u278c print(eggs) def bacon(): ham = 101 \u278d eggs = 0 \u278e spam()\n\nYou can view the execution of this program at https://autbor.com/otherlocalscopes/ . When the program starts, the spam() function is called \u278e , and a local scope is created. The local variable eggs \u278a is set to 99 . Then the bacon() function is called \u278b , and a second local scope is created. Multiple local scopes can exist at the same time. In this new local scope, the local variable ham is set to 101 , and a local variable eggs \u2014which is different from the one in spam() \u2019s local scope\u2014is also created \u278d and set to 0 .\n\nWhen bacon() returns, the local scope for that call is destroyed, including its eggs variable. The program execution continues in the spam() function to print the value of eggs \u278c . Since the local scope for the call to spam() still exists, the only eggs variable is the spam() function\u2019s eggs variable, which was set to 99 . This is what the program prints.\n\nThe upshot is that local variables in one function are completely separate from the local variables in another function.\n\n#### Global Variables Can Be Read from a Local Scope\n\nConsider the following program:\n\ndef spam(): print(eggs) eggs = 42 spam() print(eggs)\n\nYou can view the execution of this program at https://autbor.com/readglobal/ . Since there is no parameter named eggs or any code that assigns eggs a value in the spam() function, when eggs is used in spam() , Python considers it a reference to the global variable eggs . This is why 42 is printed when the previous program is run.\n\n#### Local and Global Variables with the Same Name\n\nTechnically, it\u2019s perfectly acceptable to use the same variable name for a global variable and local variables in different scopes in Python. But, to simplify your life, avoid doing this. To see what happens, enter the following code into the file editor and save it as localGlobalSameName.py :\n\ndef spam(): \u278a eggs = 'spam local' print(eggs)\u00a0\u00a0\u00a0\u00a0# prints 'spam local' def bacon(): \u278b eggs = 'bacon local' print(eggs)\u00a0\u00a0\u00a0\u00a0# prints 'bacon local' spam() print(eggs)\u00a0\u00a0\u00a0\u00a0# prints 'bacon local' \u278c eggs = 'global' bacon() print(eggs)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# prints 'global'\n\nWhen you run this program, it outputs the following:\n\nbacon local spam local bacon local global\n\nYou can view the execution of this program at https://autbor.com/localglobalsamename/ . There are actually three different variables in this program, but confusingly they are all named eggs . The variables are as follows:\n\n\u278a A variable named eggs that exists in a local scope when spam() is called.\n\n\u278b A variable named eggs that exists in a local scope when bacon() is called.\n\n\u278c A variable named eggs that exists in the global scope.\n\nSince these three separate variables all have the same name, it can be confusing to keep track of which one is being used at any given time. This is why you should avoid using the same variable name in different scopes.\n\n### The global Statement\n\nIf you need to modify a global variable from within a function, use the global statement. If you have a line such as global eggs at the top of a function, it tells Python, \u201cIn this function, eggs refers to the global variable, so don\u2019t create a local variable with this name.\u201d For example, enter the following code into the file editor and save it as globalStatement.py :\n\ndef spam(): \u278a global eggs \u278b eggs = 'spam' eggs = 'global' spam() print(eggs)\n\nWhen you run this program, the final print() call will output this:\n\nspam\n\nYou can view the execution of this program at https://autbor.com/globalstatement/ . Because eggs is declared global at the top of spam() \u278a , when eggs is set to 'spam' \u278b , this assignment is done to the globally scoped eggs . No local eggs variable is created.\n\nThere are four rules to tell whether a variable is in a local scope or global scope:\n\n- If a variable is being used in the global scope (that is, outside of all functions), then it is always a global variable.\n- If there is a global statement for that variable in a function, it is a global variable.\n- Otherwise, if the variable is used in an assignment statement in the function, it is a local variable.\n- But if the variable is not used in an assignment statement, it is a global variable.\n\nTo get a better feel for these rules, here\u2019s an example program. Enter the following code into the file editor and save it as sameNameLocalGlobal.py :\n\ndef spam(): \u278a global eggs eggs = 'spam' # this is the global def bacon(): \u278b eggs = 'bacon' # this is a local def ham(): \u278c print(eggs) # this is the global eggs = 42 # this is the global spam() print(eggs)\n\nIn the spam() function, eggs is the global eggs variable because there\u2019s a global statement for eggs at the beginning of the function \u278a . In bacon() , eggs is a local variable because there\u2019s an assignment statement for it in that function \u278b . In ham() \u278c , eggs is the global variable because there is no assignment statement or global statement for it in that function. If you run sameNameLocalGlobal.py , the output will look like this:\n\nspam\n\nYou can view the execution of this program at https://autbor.com/sameNameLocalGlobal/ . In a function, a variable will either always be global or always be local. The code in a function can\u2019t use a local variable named eggs and then use the global eggs variable later in that same function.\n\nNOTE\n\nIf you ever want to modify the value stored in a global variable from in a function, you must use a global statement on that variable.\n\nIf you try to use a local variable in a function before you assign a value to it, as in the following program, Python will give you an error. To see this, enter the following into the file editor and save it as sameNameError.py :\n\ndef spam(): print(eggs) # ERROR! \u278a eggs = 'spam local' \u278b eggs = 'global' spam()\n\nIf you run the previous program, it produces an error message.\n\nTraceback (most recent call last): File \"C:/sameNameError.py\", line 6, in <module> spam() File \"C:/sameNameError.py\", line 2, in spam print(eggs) # ERROR! UnboundLocalError: local variable 'eggs' referenced before assignment\n\nYou can view the execution of this program at https://autbor.com/sameNameError/ . This error happens because Python sees that there is an assignment statement for eggs in the spam() function \u278a and, therefore, considers eggs to be local. But because print(eggs) is executed before eggs is assigned anything, the local variable eggs doesn\u2019t exist. Python will not fall back to using the global eggs variable \u278b .\n\nFUNCTIONS AS \u201cBLACK BOXES\u201d\n\nOften, all you need to know about a function are its inputs (the parameters) and output value; you don\u2019t always have to burden yourself with how the function\u2019s code actually works. When you think about functions in this high-level way, it\u2019s common to say that you\u2019re treating a function as a \u201cblack box.\u201d\n\nThis idea is fundamental to modern programming. Later chapters in this book will show you several modules with functions that were written by other people. While you can take a peek at the source code if you\u2019re curious, you don\u2019t need to know how these functions work in order to use them. And because writing functions without global variables is encouraged, you usually don\u2019t have to worry about the function\u2019s code interacting with the rest of your program.\n\n### Exception Handling\n\nRight now, getting an error, or exception , in your Python program means the entire program will crash. You don\u2019t want this to happen in real-world programs. Instead, you want the program to detect errors, handle them, and then continue to run.\n\nFor example, consider the following program, which has a divide-by-zero error. Open a file editor window and enter the following code, saving it as zeroDivide.py :\n\ndef spam(divideBy): return 42 / divideBy print(spam(2)) print(spam(12)) print(spam(0)) print(spam(1))\n\nWe\u2019ve defined a function called spam , given it a parameter, and then printed the value of that function with various parameters to see what happens. This is the output you get when you run the previous code:\n\n21.0 3.5 Traceback (most recent call last): File \"C:/zeroDivide.py\", line 6, in <module> print(spam(0)) File \"C:/zeroDivide.py\", line 2, in spam return 42 / divideBy ZeroDivisionError: division by zero\n\nYou can view the execution of this program at https://autbor.com/zerodivide/ . A ZeroDivisionError happens whenever you try to divide a number by zero. From the line number given in the error message, you know that the return statement in spam() is causing an error.\n\nErrors can be handled with try and except statements. The code that could potentially have an error is put in a try clause. The program execution moves to the start of a following except clause if an error happens.\n\nYou can put the previous divide-by-zero code in a try clause and have an except clause contain code to handle what happens when this error occurs.\n\ndef spam(divideBy): try: return 42 / divideBy except ZeroDivisionError: print('Error: Invalid argument.') print(spam(2)) print(spam(12)) print(spam(0)) print(spam(1))\n\nWhen code in a try clause causes an error, the program execution immediately moves to the code in the except clause. After running that code, the execution continues as normal. The output of the previous program is as follows:\n\n21.0 3.5 Error: Invalid argument. None 42.0\n\nYou can view the execution of this program at https://autbor.com/tryexceptzerodivide/ . Note that any errors that occur in function calls in a try block will also be caught. Consider the following program, which instead has the spam() calls in the try block:\n\ndef spam(divideBy): return 42 / divideBy try: print(spam(2)) print(spam(12)) print(spam(0)) print(spam(1)) except ZeroDivisionError: print('Error: Invalid argument.')\n\nWhen this program is run, the output looks like this:\n\n21.0 3.5 Error: Invalid argument.\n\nYou can view the execution of this program at https://autbor.com/spamintry/ . The reason print(spam(1)) is never executed is because once the execution jumps to the code in the except clause, it does not return to the try clause. Instead, it just continues moving down the program as normal.\n\n### A Short Program: Zigzag\n\nLet\u2019s use the programming concepts you\u2019ve learned so far to create a small animation program. This program will create a back-and-forth, zigzag pattern until the user stops it by pressing the Mu editor\u2019s Stop button or by pressing CTRL-C . When you run this program, the output will look something like this:\n\n******** ******** ******** ******** ******** ******** ******** ******** ********\n\nType the following source code into the file editor, and save the file as zigzag.py :\n\nimport time, sys indent = 0 # How many spaces to indent. indentIncreasing = True # Whether the indentation is increasing or not. try: while True: # The main program loop. print(' ' * indent, end='') print('********') time.sleep(0.1) # Pause for 1/10 of a second. if indentIncreasing: # Increase the number of spaces: indent = indent + 1 if indent == 20: # Change direction: indentIncreasing = False else: # Decrease the number of spaces: indent = indent - 1 if indent == 0: # Change direction: indentIncreasing = True except KeyboardInterrupt: sys.exit()\n\nLet\u2019s look at this code line by line, starting at the top.\n\nimport time, sys indent = 0 # How many spaces to indent. indentIncreasing = True # Whether the indentation is increasing or not.\n\nFirst, we\u2019ll import the time and sys modules. Our program uses two variables: the indent variable keeps track of how many spaces of indentation are before the band of eight asterisks and indentIncreasing contains a Boolean value to determine if the amount of indentation is increasing or decreasing.\n\ntry: while True: # The main program loop. print(' ' * indent, end='') print('********') time.sleep(0.1) # Pause for 1/10 of a second.\n\nNext, we place the rest of the program inside a try statement. When the user presses CTRL-C while a Python program is running, Python raises the KeyboardInterrupt exception. If there is no try - except statement to catch this exception, the program crashes with an ugly error message. However, for our program, we want it to cleanly handle the KeyboardInterrupt exception by calling sys.exit() . (The code for this is in the except statement at the end of the program.)\n\nThe while True: infinite loop will repeat the instructions in our program forever. This involves using ' ' * indent to print the correct amount of spaces of indentation. We don\u2019t want to automatically print a newline after these spaces, so we also pass end='' to the first print() call. A second print() call prints the band of asterisks. The time.sleep() function hasn\u2019t been covered yet, but suffice it to say that it introduces a one-tenth-second pause in our program at this point.\n\nif indentIncreasing: # Increase the number of spaces: indent = indent + 1 if indent == 20: indentIncreasing = False # Change direction.\n\nNext, we want to adjust the amount of indentation for the next time we print asterisks. If indentIncreasing is True , then we want to add one to indent . But once indent reaches 20 , we want the indentation to decrease.\n\nelse: # Decrease the number of spaces: indent = indent - 1 if indent == 0: indentIncreasing = True # Change direction.\n\nMeanwhile, if indentIncreasing was False , we want to subtract one from indent . Once indent reaches 0 , we want the indentation to increase once again. Either way, the program execution will jump back to the start of the main program loop to print the asterisks again.\n\nexcept KeyboardInterrupt: sys.exit()\n\nIf the user presses CTRL-C at any point that the program execution is in the try block, the KeyboardInterrrupt exception is raised and handled by this except statement. The program execution moves inside the except block, which runs sys.exit() and quits the program. This way, even though the main program loop is an infinite loop, the user has a way to shut down the program.\n\n### Summary\n\nFunctions are the primary way to compartmentalize your code into logical groups. Since the variables in functions exist in their own local scopes, the code in one function cannot directly affect the values of variables in other functions. This limits what code could be changing the values of your variables, which can be helpful when it comes to debugging your code.\n\nFunctions are a great tool to help you organize your code. You can think of them as black boxes: they have inputs in the form of parameters and outputs in the form of return values, and the code in them doesn\u2019t affect variables in other functions.\n\nIn previous chapters, a single error could cause your programs to crash. In this chapter, you learned about try and except statements, which can run code when an error has been detected. This can make your programs more resilient to common error cases.\n\n### Practice Questions\n\n1. Why are functions advantageous to have in your programs?\n\n2. When does the code in a function execute: when the function is defined or when the function is called?\n\n3. What statement creates a function?\n\n4. What is the difference between a function and a function call?\n\n5. How many global scopes are there in a Python program? How many local scopes?\n\n6. What happens to variables in a local scope when the function call returns?\n\n7. What is a return value? Can a return value be part of an expression?\n\n8. If a function does not have a return statement, what is the return value of a call to that function?\n\n9. How can you force a variable in a function to refer to the global variable?\n\n10. What is the data type of None ?\n\n11. What does the import areallyourpetsnamederic statement do?\n\n12. If you had a function named bacon() in a module named spam , how would you call it after importing spam ?\n\n13. How can you prevent a program from crashing when it gets an error?\n\n14. What goes in the try clause? What goes in the except clause?\n\n### Practice Projects\n\nFor practice, write programs to do the following tasks.\n\n#### The Collatz Sequence\n\nWrite a function named collatz() that has one parameter named number . If number is even, then collatz() should print number // 2 and return this value. If number is odd, then collatz() should print and return 3 * number + 1 .\n\nThen write a program that lets the user type in an integer and that keeps calling collatz() on that number until the function returns the value 1 . (Amazingly enough, this sequence actually works for any integer\u2014sooner or later, using this sequence, you\u2019ll arrive at 1! Even mathematicians aren\u2019t sure why. Your program is exploring what\u2019s called the Collatz sequence , sometimes called \u201cthe simplest impossible math problem.\u201d)\n\nRemember to convert the return value from input() to an integer with the int() function; otherwise, it will be a string value.\n\nHint: An integer number is even if number % 2 == 0 , and it\u2019s odd if number % 2 == 1 .\n\nThe output of this program could look something like this:\n\nEnter number: 3 10 5 16 8 4 2 1\n\n#### Input Validation\n\nAdd try and except statements to the previous project to detect whether the user types in a noninteger string. Normally, the int() function will raise a ValueError error if it is passed a noninteger string, as in int('puppy') . In the except clause, print a message to the user saying they must enter an integer.",
      "difficulty": "intro",
      "doc_id": "doc-3functions-ab49f2a8a9",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-NC-SA 3.0",
        "source_file": "data/corpus_raw/2e_chapter3_13880b.json",
        "url": "https://automatetheboringstuff.com/2e/chapter3/"
      },
      "title": "3FUNCTIONS",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "conditionals",
        "control_flow",
        "functions",
        "loops",
        "scope"
      ],
      "content": "# 4.More Control Flow Tools\u00c2\u00b6\n\nAs well as the while statement just introduced, Python uses a few more\nthat we will encounter in this chapter.\n\n## 4.1.ifStatements\u00c2\u00b6\n\nPerhaps the most well-known statement type is the if statement.  For\nexample:\n\n```python\n>>> x = int(input(\"Please enter an integer: \"))\nPlease enter an integer: 42\n>>> if x < 0:\n...     x = 0\n...     print('Negative changed to zero')\n... elif x == 0:\n...     print('Zero')\n... elif x == 1:\n...     print('Single')\n... else:\n...     print('More')\n...\nMore\n```python\n\nThere can be zero or more elif parts, and the else part is\noptional.  The keyword \u00e2\u0080\u0098 elif \u00e2\u0080\u0099 is short for \u00e2\u0080\u0098else if\u00e2\u0080\u0099, and is useful\nto avoid excessive indentation.  An if \u00e2\u0080\u00a6 elif \u00e2\u0080\u00a6 elif \u00e2\u0080\u00a6 sequence is a substitute for the switch or case statements found in other languages.\n\nIf you\u00e2\u0080\u0099re comparing the same value to several constants, or checking for specific types or\nattributes, you may also find the match statement useful. For more\ndetails see match Statements .\n\n## 4.2.forStatements\u00c2\u00b6\n\nThe for statement in Python differs a bit from what you may be used\nto in C or Pascal.  Rather than always iterating over an arithmetic progression\nof numbers (like in Pascal), or giving the user the ability to define both the\niteration step and halting condition (as C), Python\u00e2\u0080\u0099s for statement\niterates over the items of any sequence (a list or a string), in the order that\nthey appear in the sequence.  For example (no pun intended):\n\n```python\n>>> # Measure some strings:\n>>> words = ['cat', 'window', 'defenestrate']\n>>> for w in words:\n...     print(w, len(w))\n...\ncat 3\nwindow 6\ndefenestrate 12\n```python\n\nCode that modifies a collection while iterating over that same collection can\nbe tricky to get right.  Instead, it is usually more straight-forward to loop\nover a copy of the collection or to create a new collection:\n\n```python\n# Create a sample collection\nusers = {'Hans': 'active', '\u00c3\u0089l\u00c3\u00a9onore': 'inactive', '\u00e6\u0099\u00af\u00e5\u00a4\u00aa\u00e9\u0083\u008e': 'active'}\n\n# Strategy:  Iterate over a copy\nfor user, status in users.copy().items():\n    if status == 'inactive':\n        del users[user]\n\n# Strategy:  Create a new collection\nactive_users = {}\nfor user, status in users.items():\n    if status == 'active':\n        active_users[user] = status\n```python\n\n## 4.3.Therange()Function\u00c2\u00b6\n\nIf you do need to iterate over a sequence of numbers, the built-in function range() comes in handy.  It generates arithmetic progressions:\n\n```python\n>>> for i in range(5):\n...     print(i)\n...\n0\n1\n2\n3\n4\n```python\n\nThe given end point is never part of the generated sequence; range(10) generates\n10 values, the legal indices for items of a sequence of length 10.  It\nis possible to let the range start at another number, or to specify a different\nincrement (even negative; sometimes this is called the \u00e2\u0080\u0098step\u00e2\u0080\u0099):\n\n```python\n>>> list(range(5, 10))\n[5, 6, 7, 8, 9]\n\n>>> list(range(0, 10, 3))\n[0, 3, 6, 9]\n\n>>> list(range(-10, -100, -30))\n[-10, -40, -70]\n```python\n\nTo iterate over the indices of a sequence, you can combine range() and len() as follows:\n\n```python\n>>> a = ['Mary', 'had', 'a', 'little', 'lamb']\n>>> for i in range(len(a)):\n...     print(i, a[i])\n...\n0 Mary\n1 had\n2 a\n3 little\n4 lamb\n```python\n\nIn most such cases, however, it is convenient to use the enumerate() function, see Looping Techniques .\n\nA strange thing happens if you just print a range:\n\n```python\n>>> range(10)\nrange(0, 10)\n```python\n\nIn many ways the object returned by range() behaves as if it is a list,\nbut in fact it isn\u00e2\u0080\u0099t. It is an object which returns the successive items of\nthe desired sequence when you iterate over it, but it doesn\u00e2\u0080\u0099t really make\nthe list, thus saving space.\n\nWe say such an object is iterable , that is, suitable as a target for\nfunctions and constructs that expect something from which they can\nobtain successive items until the supply is exhausted.  We have seen that\nthe for statement is such a construct, while an example of a function\nthat takes an iterable is sum() :\n\n```python\n>>> sum(range(4))  # 0 + 1 + 2 + 3\n6\n```python\n\nLater we will see more functions that return iterables and take iterables as\narguments.  In chapter Data Structures , we will discuss list() in more\ndetail.\n\n## 4.4.breakandcontinueStatements\u00c2\u00b6\n\nThe break statement breaks out of the innermost enclosing for or while loop:\n\n```python\n>>> for n in range(2, 10):\n...     for x in range(2, n):\n...         if n % x == 0:\n...             print(f\"{n} equals {x} * {n//x}\")\n...             break\n...\n4 equals 2 * 2\n6 equals 2 * 3\n8 equals 2 * 4\n9 equals 3 * 3\n```python\n\nThe continue statement continues with the next\niteration of the loop:\n\n```python\n>>> for num in range(2, 10):\n...     if num % 2 == 0:\n...         print(f\"Found an even number {num}\")\n...         continue\n...     print(f\"Found an odd number {num}\")\n...\nFound an even number 2\nFound an odd number 3\nFound an even number 4\nFound an odd number 5\nFound an even number 6\nFound an odd number 7\nFound an even number 8\nFound an odd number 9\n```python\n\n## 4.5.elseClauses on Loops\u00c2\u00b6\n\nIn a for or while loop the break statement\nmay be paired with an else clause.  If the loop finishes without\nexecuting the break , the else clause executes.\n\nIn a for loop, the else clause is executed\nafter the loop finishes its final iteration, that is, if no break occurred.\n\nIn a while loop, it\u00e2\u0080\u0099s executed after the loop\u00e2\u0080\u0099s condition becomes false.\n\nIn either kind of loop, the else clause is not executed if the\nloop was terminated by a break .  Of course, other ways of ending the\nloop early, such as a return or a raised exception, will also skip\nexecution of the else clause.\n\nThis is exemplified in the following for loop,\nwhich searches for prime numbers:\n\n```python\n>>> for n in range(2, 10):\n...     for x in range(2, n):\n...         if n % x == 0:\n...             print(n, 'equals', x, '*', n//x)\n...             break\n...     else:\n...         # loop fell through without finding a factor\n...         print(n, 'is a prime number')\n...\n2 is a prime number\n3 is a prime number\n4 equals 2 * 2\n5 is a prime number\n6 equals 2 * 3\n7 is a prime number\n8 equals 2 * 4\n9 equals 3 * 3\n```python\n\n(Yes, this is the correct code.  Look closely: the else clause belongs to\nthe for loop, not the if statement.)\n\nOne way to think of the else clause is to imagine it paired with the if inside the loop.  As the loop executes, it will run a sequence like\nif/if/if/else. The if is inside the loop, encountered a number of times. If\nthe condition is ever true, a break will happen. If the condition is never\ntrue, the else clause outside the loop will execute.\n\nWhen used with a loop, the else clause has more in common with the else clause of a try statement than it does with that of if statements: a try statement\u00e2\u0080\u0099s else clause runs when no exception\noccurs, and a loop\u00e2\u0080\u0099s else clause runs when no break occurs. For more on\nthe try statement and exceptions, see Handling Exceptions .\n\n## 4.6.passStatements\u00c2\u00b6\n\nThe pass statement does nothing. It can be used when a statement is\nrequired syntactically but the program requires no action. For example:\n\n```python\n>>> while True:\n...     pass  # Busy-wait for keyboard interrupt (Ctrl+C)\n...\n```python\n\nThis is commonly used for creating minimal classes:\n\n```python\n>>> class MyEmptyClass:\n...     pass\n...\n```python\n\nAnother place pass can be used is as a place-holder for a function or\nconditional body when you are working on new code, allowing you to keep thinking\nat a more abstract level.  The pass is silently ignored:\n\n```python\n>>> def initlog(*args):\n...     pass   # Remember to implement this!\n...\n```python\n\nFor this last case, many people use the ellipsis literal ... instead of pass . This use has no special meaning to Python, and is not part of\nthe language definition (you could use any constant expression here), but ... is used conventionally as a placeholder body as well.\nSee The Ellipsis Object .\n\n## 4.7.matchStatements\u00c2\u00b6\n\nA match statement takes an expression and compares its value to successive\npatterns given as one or more case blocks.  This is superficially\nsimilar to a switch statement in C, Java or JavaScript (and many\nother languages), but it\u00e2\u0080\u0099s more similar to pattern matching in\nlanguages like Rust or Haskell. Only the first pattern that matches\ngets executed and it can also extract components (sequence elements\nor object attributes) from the value into variables. If no case matches,\nnone of the branches is executed.\n\nThe simplest form compares a subject value against one or more literals:\n\n```python\ndef http_error(status):\n    match status:\n        case 400:\n            return \"Bad request\"\n        case 404:\n            return \"Not found\"\n        case 418:\n            return \"I'm a teapot\"\n        case _:\n            return \"Something's wrong with the internet\"\n```python\n\nNote the last block: the \u00e2\u0080\u009cvariable name\u00e2\u0080\u009d _ acts as a wildcard and\nnever fails to match.\n\nYou can combine several literals in a single pattern using | (\u00e2\u0080\u009cor\u00e2\u0080\u009d):\n\n```python\ncase 401 | 403 | 404:\n    return \"Not allowed\"\n```python\n\nPatterns can look like unpacking assignments, and can be used to bind\nvariables:\n\n```python\n# point is an (x, y) tuple\nmatch point:\n    case (0, 0):\n        print(\"Origin\")\n    case (0, y):\n        print(f\"Y={y}\")\n    case (x, 0):\n        print(f\"X={x}\")\n    case (x, y):\n        print(f\"X={x}, Y={y}\")\n    case _:\n        raise ValueError(\"Not a point\")\n```python\n\nStudy that one carefully!  The first pattern has two literals, and can\nbe thought of as an extension of the literal pattern shown above.  But\nthe next two patterns combine a literal and a variable, and the\nvariable binds a value from the subject ( point ).  The fourth\npattern captures two values, which makes it conceptually similar to\nthe unpacking assignment (x, y) = point .\n\nIf you are using classes to structure your data\nyou can use the class name followed by an argument list resembling a\nconstructor, but with the ability to capture attributes into variables:\n\n```python\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\ndef where_is(point):\n    match point:\n        case Point(x=0, y=0):\n            print(\"Origin\")\n        case Point(x=0, y=y):\n            print(f\"Y={y}\")\n        case Point(x=x, y=0):\n            print(f\"X={x}\")\n        case Point():\n            print(\"Somewhere else\")\n        case _:\n            print(\"Not a point\")\n```python\n\nYou can use positional parameters with some builtin classes that provide an\nordering for their attributes (e.g. dataclasses). You can also define a specific\nposition for attributes in patterns by setting the __match_args__ special\nattribute in your classes. If it\u00e2\u0080\u0099s set to (\u00e2\u0080\u009cx\u00e2\u0080\u009d, \u00e2\u0080\u009cy\u00e2\u0080\u009d), the following patterns are all\nequivalent (and all bind the y attribute to the var variable):\n\n```python\nPoint(1, var)\nPoint(1, y=var)\nPoint(x=1, y=var)\nPoint(y=var, x=1)\n```python\n\nA recommended way to read patterns is to look at them as an extended form of what you\nwould put on the left of an assignment, to understand which variables would be set to\nwhat.\nOnly the standalone names (like var above) are assigned to by a match statement.\nDotted names (like foo.bar ), attribute names (the x= and y= above) or class names\n(recognized by the \u00e2\u0080\u009c(\u00e2\u0080\u00a6)\u00e2\u0080\u009d next to them like Point above) are never assigned to.\n\nPatterns can be arbitrarily nested.  For example, if we have a short\nlist of Points, with __match_args__ added, we could match it like this:\n\n```python\nclass Point:\n    __match_args__ = ('x', 'y')\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nmatch points:\n    case []:\n        print(\"No points\")\n    case [Point(0, 0)]:\n        print(\"The origin\")\n    case [Point(x, y)]:\n        print(f\"Single point {x}, {y}\")\n    case [Point(0, y1), Point(0, y2)]:\n        print(f\"Two on the Y axis at {y1}, {y2}\")\n    case _:\n        print(\"Something else\")\n```python\n\nWe can add an if clause to a pattern, known as a \u00e2\u0080\u009cguard\u00e2\u0080\u009d.  If the\nguard is false, match goes on to try the next case block.  Note\nthat value capture happens before the guard is evaluated:\n\n```python\nmatch point:\n    case Point(x, y) if x == y:\n        print(f\"Y=X at {x}\")\n    case Point(x, y):\n        print(f\"Not on the diagonal\")\n```python\n\nSeveral other key features of this statement:\n\n- Like unpacking assignments, tuple and list patterns have exactly the\nsame meaning and actually match arbitrary sequences.  An important\nexception is that they don\u00e2\u0080\u0099t match iterators or strings.\n- Sequence patterns support extended unpacking: [x, y, *rest] and (x, y, *rest) work similar to unpacking assignments.  The\nname after * may also be _ , so (x, y, *_) matches a sequence\nof at least two items without binding the remaining items.\n- Mapping patterns: {\"bandwidth\": b, \"latency\": l} captures the \"bandwidth\" and \"latency\" values from a dictionary.  Unlike sequence\npatterns, extra keys are ignored.  An unpacking like **rest is also\nsupported.  (But **_ would be redundant, so it is not allowed.)\n- Subpatterns may be captured using the as keyword: case ( Point ( x1 , y1 ), Point ( x2 , y2 ) as p2 ): ... will capture the second element of the input as p2 (as long as the input is\na sequence of two points)\n- Most literals are compared by equality, however the singletons True , False and None are compared by identity.\n- Patterns may use named constants.  These must be dotted names\nto prevent them from being interpreted as capture variables: from enum import Enum class Color ( Enum ): RED = 'red' GREEN = 'green' BLUE = 'blue' color = Color ( input ( \"Enter your choice of 'red', 'blue' or 'green': \" )) match color : case Color . RED : print ( \"I see red!\" ) case Color . GREEN : print ( \"Grass is green\" ) case Color . BLUE : print ( \"I'm feeling the blues :(\" )\n\nFor a more detailed explanation and additional examples, you can look into PEP 636 which is written in a tutorial format.\n\n## 4.8.Defining Functions\u00c2\u00b6\n\nWe can create a function that writes the Fibonacci series to an arbitrary\nboundary:\n\n```python\n>>> def fib(n):    # write Fibonacci series less than n\n...     \"\"\"Print a Fibonacci series less than n.\"\"\"\n...     a, b = 0, 1\n...     while a < n:\n...         print(a, end=' ')\n...         a, b = b, a+b\n...     print()\n...\n>>> # Now call the function we just defined:\n>>> fib(2000)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597\n```python\n\nThe keyword def introduces a function definition .  It must be\nfollowed by the function name and the parenthesized list of formal parameters.\nThe statements that form the body of the function start at the next line, and\nmust be indented.\n\nThe first statement of the function body can optionally be a string literal;\nthis string literal is the function\u00e2\u0080\u0099s documentation string, or docstring .\n(More about docstrings can be found in the section Documentation Strings .)\nThere are tools which use docstrings to automatically produce online or printed\ndocumentation, or to let the user interactively browse through code; it\u00e2\u0080\u0099s good\npractice to include docstrings in code that you write, so make a habit of it.\n\nThe execution of a function introduces a new symbol table used for the local\nvariables of the function.  More precisely, all variable assignments in a\nfunction store the value in the local symbol table; whereas variable references\nfirst look in the local symbol table, then in the local symbol tables of\nenclosing functions, then in the global symbol table, and finally in the table\nof built-in names. Thus, global variables and variables of enclosing functions\ncannot be directly assigned a value within a function (unless, for global\nvariables, named in a global statement, or, for variables of enclosing\nfunctions, named in a nonlocal statement), although they may be\nreferenced.\n\nThe actual parameters (arguments) to a function call are introduced in the local\nsymbol table of the called function when it is called; thus, arguments are\npassed using call by value (where the value is always an object reference ,\nnot the value of the object). [ 1 ] When a function calls another function,\nor calls itself recursively, a new\nlocal symbol table is created for that call.\n\nA function definition associates the function name with the function object in\nthe current symbol table.  The interpreter recognizes the object pointed to by\nthat name as a user-defined function.  Other names can also point to that same\nfunction object and can also be used to access the function:\n\n```python\n>>> fib\n<function fib at 10042ed0>\n>>> f = fib\n>>> f(100)\n0 1 1 2 3 5 8 13 21 34 55 89\n```python\n\nComing from other languages, you might object that fib is not a function but\na procedure since it doesn\u00e2\u0080\u0099t return a value.  In fact, even functions without a return statement do return a value, albeit a rather boring one.  This\nvalue is called None (it\u00e2\u0080\u0099s a built-in name).  Writing the value None is\nnormally suppressed by the interpreter if it would be the only value written.\nYou can see it if you really want to using print() :\n\n```python\n>>> fib(0)\n>>> print(fib(0))\nNone\n```python\n\nIt is simple to write a function that returns a list of the numbers of the\nFibonacci series, instead of printing it:\n\n```python\n>>> def fib2(n):  # return Fibonacci series up to n\n...     \"\"\"Return a list containing the Fibonacci series up to n.\"\"\"\n...     result = []\n...     a, b = 0, 1\n...     while a < n:\n...         result.append(a)    # see below\n...         a, b = b, a+b\n...     return result\n...\n>>> f100 = fib2(100)    # call it\n>>> f100                # write the result\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n```python\n\nThis example, as usual, demonstrates some new Python features:\n\n- The return statement returns with a value from a function. return without an expression argument returns None . Falling off\nthe end of a function also returns None .\n- The statement result.append(a) calls a method of the list object result .  A method is a function that \u00e2\u0080\u0098belongs\u00e2\u0080\u0099 to an object and is named obj.methodname , where obj is some object (this may be an expression),\nand methodname is the name of a method that is defined by the object\u00e2\u0080\u0099s type.\nDifferent types define different methods.  Methods of different types may have\nthe same name without causing ambiguity.  (It is possible to define your own\nobject types and methods, using classes , see Classes )\nThe method append() shown in the example is defined for list objects; it\nadds a new element at the end of the list.  In this example it is equivalent to result = result + [a] , but more efficient.\n\n## 4.9.More on Defining Functions\u00c2\u00b6\n\nIt is also possible to define functions with a variable number of arguments.\nThere are three forms, which can be combined.\n\n### 4.9.1.Default Argument Values\u00c2\u00b6\n\nThe most useful form is to specify a default value for one or more arguments.\nThis creates a function that can be called with fewer arguments than it is\ndefined to allow.  For example:\n\n```python\ndef ask_ok(prompt, retries=4, reminder='Please try again!'):\n    while True:\n        reply = input(prompt)\n        if reply in {'y', 'ye', 'yes'}:\n            return True\n        if reply in {'n', 'no', 'nop', 'nope'}:\n            return False\n        retries = retries - 1\n        if retries < 0:\n            raise ValueError('invalid user response')\n        print(reminder)\n```python\n\nThis function can be called in several ways:\n\n- giving only the mandatory argument: ask_ok('Do you really want to quit?')\n- giving one of the optional arguments: ask_ok('OK to overwrite the file?', 2)\n- or even giving all arguments: ask_ok('OK to overwrite the file?', 2, 'Come on, only yes or no!')\n\nThis example also introduces the in keyword. This tests whether or\nnot a sequence contains a certain value.\n\nThe default values are evaluated at the point of function definition in the defining scope, so that\n\n```python\ni = 5\n\ndef f(arg=i):\n    print(arg)\n\ni = 6\nf()\n```python\n\nwill print 5 .\n\nImportant warning: The default value is evaluated only once. This makes a\ndifference when the default is a mutable object such as a list, dictionary, or\ninstances of most classes.  For example, the following function accumulates the\narguments passed to it on subsequent calls:\n\n```python\ndef f(a, L=[]):\n    L.append(a)\n    return L\n\nprint(f(1))\nprint(f(2))\nprint(f(3))\n```python\n\nThis will print\n\n```python\n[1]\n[1, 2]\n[1, 2, 3]\n```python\n\nIf you don\u00e2\u0080\u0099t want the default to be shared between subsequent calls, you can\nwrite the function like this instead:\n\n```python\ndef f(a, L=None):\n    if L is None:\n        L = []\n    L.append(a)\n    return L\n```python\n\n### 4.9.2.Keyword Arguments\u00c2\u00b6\n\nFunctions can also be called using keyword arguments of the form kwarg=value .  For instance, the following function:\n\n```python\ndef parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):\n    print(\"-- This parrot wouldn't\", action, end=' ')\n    print(\"if you put\", voltage, \"volts through it.\")\n    print(\"-- Lovely plumage, the\", type)\n    print(\"-- It's\", state, \"!\")\n```python\n\naccepts one required argument ( voltage ) and three optional arguments\n( state , action , and type ).  This function can be called in any\nof the following ways:\n\n```python\nparrot(1000)                                          # 1 positional argument\nparrot(voltage=1000)                                  # 1 keyword argument\nparrot(voltage=1000000, action='VOOOOOM')             # 2 keyword arguments\nparrot(action='VOOOOOM', voltage=1000000)             # 2 keyword arguments\nparrot('a million', 'bereft of life', 'jump')         # 3 positional arguments\nparrot('a thousand', state='pushing up the daisies')  # 1 positional, 1 keyword\n```python\n\nbut all the following calls would be invalid:\n\n```python\nparrot()                     # required argument missing\nparrot(voltage=5.0, 'dead')  # non-keyword argument after a keyword argument\nparrot(110, voltage=220)     # duplicate value for the same argument\nparrot(actor='John Cleese')  # unknown keyword argument\n```python\n\nIn a function call, keyword arguments must follow positional arguments.\nAll the keyword arguments passed must match one of the arguments\naccepted by the function (e.g. actor is not a valid argument for the parrot function), and their order is not important.  This also includes\nnon-optional arguments (e.g. parrot(voltage=1000) is valid too).\nNo argument may receive a value more than once.\nHere\u00e2\u0080\u0099s an example that fails due to this restriction:\n\n```python\n>>> def function(a):\n...     pass\n...\n>>> function(0, a=0)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: function() got multiple values for argument 'a'\n```python\n\nWhen a final formal parameter of the form **name is present, it receives a\ndictionary (see Mapping Types \u00e2\u0080\u0094 dict ) containing all keyword arguments except for\nthose corresponding to a formal parameter.  This may be combined with a formal\nparameter of the form *name (described in the next subsection) which\nreceives a tuple containing the positional\narguments beyond the formal parameter list.  ( *name must occur\nbefore **name .) For example, if we define a function like this:\n\n```python\ndef cheeseshop(kind, *arguments, **keywords):\n    print(\"-- Do you have any\", kind, \"?\")\n    print(\"-- I'm sorry, we're all out of\", kind)\n    for arg in arguments:\n        print(arg)\n    print(\"-\" * 40)\n    for kw in keywords:\n        print(kw, \":\", keywords[kw])\n```python\n\nIt could be called like this:\n\n```python\ncheeseshop(\"Limburger\", \"It's very runny, sir.\",\n           \"It's really very, VERY runny, sir.\",\n           shopkeeper=\"Michael Palin\",\n           client=\"John Cleese\",\n           sketch=\"Cheese Shop Sketch\")\n```python\n\nand of course it would print:\n\n```python\n-- Do you have any Limburger ?\n-- I'm sorry, we're all out of Limburger\nIt's very runny, sir.\nIt's really very, VERY runny, sir.\n----------------------------------------\nshopkeeper : Michael Palin\nclient : John Cleese\nsketch : Cheese Shop Sketch\n```python\n\nNote that the order in which the keyword arguments are printed is guaranteed\nto match the order in which they were provided in the function call.\n\n### 4.9.3.Special parameters\u00c2\u00b6\n\nBy default, arguments may be passed to a Python function either by position\nor explicitly by keyword. For readability and performance, it makes sense to\nrestrict the way arguments can be passed so that a developer need only look\nat the function definition to determine if items are passed by position, by\nposition or keyword, or by keyword.\n\nA function definition may look like:\n\n```python\ndef f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):\n      -----------    ----------     ----------\n        |             |                  |\n        |        Positional or keyword   |\n        |                                - Keyword only\n         -- Positional only\n```python\n\nwhere / and * are optional. If used, these symbols indicate the kind of\nparameter by how the arguments may be passed to the function:\npositional-only, positional-or-keyword, and keyword-only. Keyword parameters\nare also referred to as named parameters.\n\n#### 4.9.3.1.Positional-or-Keyword Arguments\u00c2\u00b6\n\nIf / and * are not present in the function definition, arguments may\nbe passed to a function by position or by keyword.\n\n#### 4.9.3.2.Positional-Only Parameters\u00c2\u00b6\n\nLooking at this in a bit more detail, it is possible to mark certain parameters\nas positional-only . If positional-only , the parameters\u00e2\u0080\u0099 order matters, and\nthe parameters cannot be passed by keyword. Positional-only parameters are\nplaced before a / (forward-slash). The / is used to logically\nseparate the positional-only parameters from the rest of the parameters.\nIf there is no / in the function definition, there are no positional-only\nparameters.\n\nParameters following the / may be positional-or-keyword or keyword-only .\n\n#### 4.9.3.3.Keyword-Only Arguments\u00c2\u00b6\n\nTo mark parameters as keyword-only , indicating the parameters must be passed\nby keyword argument, place an * in the arguments list just before the first keyword-only parameter.\n\n#### 4.9.3.4.Function Examples\u00c2\u00b6\n\nConsider the following example function definitions paying close attention to the\nmarkers / and * :\n\n```python\n>>> def standard_arg(arg):\n...     print(arg)\n...\n>>> def pos_only_arg(arg, /):\n...     print(arg)\n...\n>>> def kwd_only_arg(*, arg):\n...     print(arg)\n...\n>>> def combined_example(pos_only, /, standard, *, kwd_only):\n...     print(pos_only, standard, kwd_only)\n```python\n\nThe first function definition, standard_arg , the most familiar form,\nplaces no restrictions on the calling convention and arguments may be\npassed by position or keyword:\n\n```python\n>>> standard_arg(2)\n2\n\n>>> standard_arg(arg=2)\n2\n```python\n\nThe second function pos_only_arg is restricted to only use positional\nparameters as there is a / in the function definition:\n\n```python\n>>> pos_only_arg(1)\n1\n\n>>> pos_only_arg(arg=1)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: pos_only_arg() got some positional-only arguments passed as keyword arguments: 'arg'\n```python\n\nThe third function kwd_only_arg only allows keyword arguments as indicated\nby a * in the function definition:\n\n```python\n>>> kwd_only_arg(3)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: kwd_only_arg() takes 0 positional arguments but 1 was given\n\n>>> kwd_only_arg(arg=3)\n3\n```python\n\nAnd the last uses all three calling conventions in the same function\ndefinition:\n\n```python\n>>> combined_example(1, 2, 3)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: combined_example() takes 2 positional arguments but 3 were given\n\n>>> combined_example(1, 2, kwd_only=3)\n1 2 3\n\n>>> combined_example(1, standard=2, kwd_only=3)\n1 2 3\n\n>>> combined_example(pos_only=1, standard=2, kwd_only=3)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: combined_example() got some positional-only arguments passed as keyword arguments: 'pos_only'\n```python\n\nFinally, consider this function definition which has a potential collision between the positional argument name and **kwds which has name as a key:\n\n```python\ndef foo(name, **kwds):\n    return 'name' in kwds\n```python\n\nThere is no possible call that will make it return True as the keyword 'name' will always bind to the first parameter. For example:\n\n```python\n>>> foo(1, **{'name': 2})\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: foo() got multiple values for argument 'name'\n>>>\n```python\n\nBut using / (positional only arguments), it is possible since it allows name as a positional argument and 'name' as a key in the keyword arguments:\n\n```python\n>>> def foo(name, /, **kwds):\n...     return 'name' in kwds\n...\n>>> foo(1, **{'name': 2})\nTrue\n```python\n\nIn other words, the names of positional-only parameters can be used in **kwds without ambiguity.\n\n#### 4.9.3.5.Recap\u00c2\u00b6\n\nThe use case will determine which parameters to use in the function definition:\n\n```python\ndef f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):\n```python\n\nAs guidance:\n\n- Use positional-only if you want the name of the parameters to not be\navailable to the user. This is useful when parameter names have no real\nmeaning, if you want to enforce the order of the arguments when the function\nis called or if you need to take some positional parameters and arbitrary\nkeywords.\n- Use keyword-only when names have meaning and the function definition is\nmore understandable by being explicit with names or you want to prevent\nusers relying on the position of the argument being passed.\n- For an API, use positional-only to prevent breaking API changes\nif the parameter\u00e2\u0080\u0099s name is modified in the future.\n\n### 4.9.4.Arbitrary Argument Lists\u00c2\u00b6\n\nFinally, the least frequently used option is to specify that a function can be\ncalled with an arbitrary number of arguments.  These arguments will be wrapped\nup in a tuple (see Tuples and Sequences ).  Before the variable number of arguments,\nzero or more normal arguments may occur.\n\n```python\ndef write_multiple_items(file, separator, *args):\n    file.write(separator.join(args))\n```python\n\nNormally, these variadic arguments will be last in the list of formal\nparameters, because they scoop up all remaining input arguments that are\npassed to the function. Any formal parameters which occur after the *args parameter are \u00e2\u0080\u0098keyword-only\u00e2\u0080\u0099 arguments, meaning that they can only be used as\nkeywords rather than positional arguments.\n\n```python\n>>> def concat(*args, sep=\"/\"):\n...     return sep.join(args)\n...\n>>> concat(\"earth\", \"mars\", \"venus\")\n'earth/mars/venus'\n>>> concat(\"earth\", \"mars\", \"venus\", sep=\".\")\n'earth.mars.venus'\n```python\n\n### 4.9.5.Unpacking Argument Lists\u00c2\u00b6\n\nThe reverse situation occurs when the arguments are already in a list or tuple\nbut need to be unpacked for a function call requiring separate positional\narguments.  For instance, the built-in range() function expects separate start and stop arguments.  If they are not available separately, write the\nfunction call with the * -operator to unpack the arguments out of a list\nor tuple:\n\n```python\n>>> list(range(3, 6))            # normal call with separate arguments\n[3, 4, 5]\n>>> args = [3, 6]\n>>> list(range(*args))            # call with arguments unpacked from a list\n[3, 4, 5]\n```python\n\nIn the same fashion, dictionaries can deliver keyword arguments with the ** -operator:\n\n```python\n>>> def parrot(voltage, state='a stiff', action='voom'):\n...     print(\"-- This parrot wouldn't\", action, end=' ')\n...     print(\"if you put\", voltage, \"volts through it.\", end=' ')\n...     print(\"E's\", state, \"!\")\n...\n>>> d = {\"voltage\": \"four million\", \"state\": \"bleedin' demised\", \"action\": \"VOOM\"}\n>>> parrot(**d)\n-- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised !\n```python\n\n### 4.9.6.Lambda Expressions\u00c2\u00b6\n\nSmall anonymous functions can be created with the lambda keyword.\nThis function returns the sum of its two arguments: lambda a, b: a+b .\nLambda functions can be used wherever function objects are required.  They are\nsyntactically restricted to a single expression.  Semantically, they are just\nsyntactic sugar for a normal function definition.  Like nested function\ndefinitions, lambda functions can reference variables from the containing\nscope:\n\n```python\n>>> def make_incrementor(n):\n...     return lambda x: x + n\n...\n>>> f = make_incrementor(42)\n>>> f(0)\n42\n>>> f(1)\n43\n```python\n\nThe above example uses a lambda expression to return a function.  Another use\nis to pass a small function as an argument.  For instance, list.sort() takes a sorting key function key which can be a lambda function:\n\n```python\n>>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]\n>>> pairs.sort(key=lambda pair: pair[1])\n>>> pairs\n[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]\n```python\n\n### 4.9.7.Documentation Strings\u00c2\u00b6\n\nHere are some conventions about the content and formatting of documentation\nstrings.\n\nThe first line should always be a short, concise summary of the object\u00e2\u0080\u0099s\npurpose.  For brevity, it should not explicitly state the object\u00e2\u0080\u0099s name or type,\nsince these are available by other means (except if the name happens to be a\nverb describing a function\u00e2\u0080\u0099s operation).  This line should begin with a capital\nletter and end with a period.\n\nIf there are more lines in the documentation string, the second line should be\nblank, visually separating the summary from the rest of the description.  The\nfollowing lines should be one or more paragraphs describing the object\u00e2\u0080\u0099s calling\nconventions, its side effects, etc.\n\nThe Python parser strips indentation from multi-line string literals when they\nserve as module, class, or function docstrings.\n\nHere is an example of a multi-line docstring:\n\n```python\n>>> def my_function():\n...     \"\"\"Do nothing, but document it.\n...\n...     No, really, it doesn't do anything:\n...\n...         >>> my_function()\n...         >>>\n...     \"\"\"\n...     pass\n...\n>>> print(my_function.__doc__)\nDo nothing, but document it.\n\nNo, really, it doesn't do anything:\n\n    >>> my_function()\n    >>>\n```python\n\n### 4.9.8.Function Annotations\u00c2\u00b6\n\nFunction annotations are completely optional metadata\ninformation about the types used by user-defined functions (see PEP 3107 and PEP 484 for more information).\n\nAnnotations are stored in the __annotations__ attribute of the function as a dictionary and have no effect on any other part of the\nfunction.  Parameter annotations are defined by a colon after the parameter name, followed\nby an expression evaluating to the value of the annotation.  Return annotations are\ndefined by a literal -> , followed by an expression, between the parameter\nlist and the colon denoting the end of the def statement.  The\nfollowing example has a required argument, an optional argument, and the return\nvalue annotated:\n\n```python\n>>> def f(ham: str, eggs: str = 'eggs') -> str:\n...     print(\"Annotations:\", f.__annotations__)\n...     print(\"Arguments:\", ham, eggs)\n...     return ham + ' and ' + eggs\n...\n>>> f('spam')\nAnnotations: {'ham': <class 'str'>, 'return': <class 'str'>, 'eggs': <class 'str'>}\nArguments: spam eggs\n'spam and eggs'\n```python\n\n## 4.10.Intermezzo: Coding Style\u00c2\u00b6\n\nNow that you are about to write longer, more complex pieces of Python, it is a\ngood time to talk about coding style .  Most languages can be written (or more\nconcisely, formatted ) in different styles; some are more readable than others.\nMaking it easy for others to read your code is always a good idea, and adopting\na nice coding style helps tremendously for that.\n\nFor Python, PEP 8 has emerged as the style guide that most projects adhere to;\nit promotes a very readable and eye-pleasing coding style.  Every Python\ndeveloper should read it at some point; here are the most important points\nextracted for you:\n\n- Use 4-space indentation, and no tabs. 4 spaces are a good compromise between small indentation (allows greater\nnesting depth) and large indentation (easier to read).  Tabs introduce\nconfusion, and are best left out.\n- Wrap lines so that they don\u00e2\u0080\u0099t exceed 79 characters. This helps users with small displays and makes it possible to have several\ncode files side-by-side on larger displays.\n- Use blank lines to separate functions and classes, and larger blocks of\ncode inside functions.\n- When possible, put comments on a line of their own.\n- Use docstrings.\n- Use spaces around operators and after commas, but not directly inside\nbracketing constructs: a = f(1, 2) + g(3, 4) .\n- Name your classes and functions consistently; the convention is to use UpperCamelCase for classes and lowercase_with_underscores for functions\nand methods.  Always use self as the name for the first method argument\n(see A First Look at Classes for more on classes and methods).\n- Don\u00e2\u0080\u0099t use fancy encodings if your code is meant to be used in international\nenvironments.  Python\u00e2\u0080\u0099s default, UTF-8, or even plain ASCII work best in any\ncase.\n- Likewise, don\u00e2\u0080\u0099t use non-ASCII characters in identifiers if there is only the\nslightest chance people speaking a different language will read or maintain\nthe code.\n\nFootnotes",
      "difficulty": "intro",
      "doc_id": "doc-4-more-control-flow-tools-d5287d137f",
      "provenance": {
        "author": "",
        "date": "",
        "license": "PSF Documentation License",
        "source_file": "data/corpus_raw/scraped/3_tutorial_controlflow_html_1e970d.json",
        "url": "https://docs.python.org/3/tutorial/controlflow.html"
      },
      "title": "4.More Control Flow Tools\u00c2\u00b6",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "indexing",
        "lists",
        "loops",
        "slicing"
      ],
      "content": "## 4LISTS\n\nOne more topic you\u2019ll need to understand before you can begin writing programs in earnest is the list data type and its cousin, the tuple. Lists and tuples can contain multiple values, which makes writing programs that handle large amounts of data easier. And since lists themselves can contain other lists, you can use them to arrange data into hierarchical structures.\n\nIn this chapter, I\u2019ll discuss the basics of lists. I\u2019ll also teach you about methods, which are functions that are tied to values of a certain data type. Then I\u2019ll briefly cover the sequence data types (lists, tuples, and strings) and show how they compare with each other. In the next chapter, I\u2019ll introduce you to the dictionary data type.\n\n### The List Data Type\n\nA list is a value that contains multiple values in an ordered sequence. The term list value refers to the list itself (which is a value that can be stored in a variable or passed to a function like any other value), not the values inside the list value. A list value looks like this: ['cat', 'bat', 'rat', 'elephant'] . Just as string values are typed with quote characters to mark where the string begins and ends, a list begins with an opening square bracket and ends with a closing square bracket, [] . Values inside the list are also called items . Items are separated with commas (that is, they are comma-delimited ). For example, enter the following into the interactive shell:\n\n>>> [1, 2, 3] [1, 2, 3] >>> ['cat', 'bat', 'rat', 'elephant'] ['cat', 'bat', 'rat', 'elephant'] >>> ['hello', 3.1415, True, None, 42] ['hello', 3.1415, True, None, 42] \u278a >>> spam = ['cat', 'bat', 'rat', 'elephant'] >>> spam ['cat', 'bat', 'rat', 'elephant']\n\nThe spam variable \u278a is still assigned only one value: the list value. But the list value itself contains other values. The value [] is an empty list that contains no values, similar to '' , the empty string.\n\n#### Getting Individual Values in a List with Indexes\n\nSay you have the list ['cat', 'bat', 'rat', 'elephant'] stored in a variable named spam . The Python code spam[0] would evaluate to 'cat' , and spam[1] would evaluate to 'bat' , and so on. The integer inside the square brackets that follows the list is called an index . The first value in the list is at index 0 , the second value is at index 1 , the third value is at index 2 , and so on. Figure 4-1 shows a list value assigned to spam , along with what the index expressions would evaluate to. Note that because the first index is 0 , the last index is one less than the size of the list; a list of four items has 3 as its last index.\n\nFigure 4-1: A list value stored in the variable spam , showing which value each index refers to\n\nFor example, enter the following expressions into the interactive shell. Start by assigning a list to the variable spam .\n\n>>> spam = ['cat', 'bat', 'rat', 'elephant'] >>> spam[0] 'cat' >>> spam[1] 'bat' >>> spam[2] 'rat' >>> spam[3] 'elephant' >>> ['cat', 'bat', 'rat', 'elephant'][3] 'elephant' \u278a >>> 'Hello, ' + spam[0] \u278b 'Hello, cat' >>> 'The ' + spam[1] + ' ate the ' + spam[0] + '.' 'The bat ate the cat.'\n\nNotice that the expression 'Hello, ' + spam[0] \u278a evaluates to 'Hello, ' + 'cat' because spam[0] evaluates to the string 'cat' . This expression in turn evaluates to the string value 'Hello, cat' \u278b .\n\nPython will give you an IndexError error message if you use an index that exceeds the number of values in your list value.\n\n>>> spam = ['cat', 'bat', 'rat', 'elephant'] >>> spam[10000] Traceback (most recent call last): File \"<pyshell#9>\", line 1, in <module> spam[10000] IndexError: list index out of range\n\nIndexes can be only integer values, not floats. The following example will cause a TypeError error:\n\n>>> spam = ['cat', 'bat', 'rat', 'elephant'] >>> spam[1] 'bat' >>> spam[1.0] Traceback (most recent call last): File \"<pyshell#13>\", line 1, in <module> spam[1.0] TypeError: list indices must be integers or slices, not float >>> spam[int(1.0)] 'bat'\n\nLists can also contain other list values. The values in these lists of lists can be accessed using multiple indexes, like so:\n\n>>> spam = [['cat', 'bat'], [10, 20, 30, 40, 50]] >>> spam[0] ['cat', 'bat'] >>> spam[0][1] 'bat' >>> spam[1][4] 50\n\nThe first index dictates which list value to use, and the second indicates the value within the list value. For example, spam[0][1] prints 'bat' , the second value in the first list. If you only use one index, the program will print the full list value at that index.\n\n#### Negative Indexes\n\nWhile indexes start at 0 and go up, you can also use negative integers for the index. The integer value -1 refers to the last index in a list, the value -2 refers to the second-to-last index in a list, and so on. Enter the following into the interactive shell:\n\n>>> spam = ['cat', 'bat', 'rat', 'elephant'] >>> spam[-1] 'elephant' >>> spam[-3] 'bat' >>> 'The ' + spam[-1] + ' is afraid of the ' + spam[-3] + '.' 'The elephant is afraid of the bat.'\n\n#### Getting a List from Another List with Slices\n\nJust as an index can get a single value from a list, a slice can get several values from a list, in the form of a new list. A slice is typed between square brackets, like an index, but it has two integers separated by a colon. Notice the difference between indexes and slices.\n\n- spam[2] is a list with an index (one integer).\n- spam[1:4] is a list with a slice (two integers).\n\nIn a slice, the first integer is the index where the slice starts. The second integer is the index where the slice ends. A slice goes up to, but will not include, the value at the second index. A slice evaluates to a new list value. Enter the following into the interactive shell:\n\n>>> spam = ['cat', 'bat', 'rat', 'elephant'] >>> spam[0:4] ['cat', 'bat', 'rat', 'elephant'] >>> spam[1:3] ['bat', 'rat'] >>> spam[0:-1] ['cat', 'bat', 'rat']\n\nAs a shortcut, you can leave out one or both of the indexes on either side of the colon in the slice. Leaving out the first index is the same as using 0 , or the beginning of the list. Leaving out the second index is the same as using the length of the list, which will slice to the end of the list. Enter the following into the interactive shell:\n\n>>> spam = ['cat', 'bat', 'rat', 'elephant'] >>> spam[:2] ['cat', 'bat'] >>> spam[1:] ['bat', 'rat', 'elephant'] >>> spam[:] ['cat', 'bat', 'rat', 'elephant']\n\n#### Getting a List\u2019s Length with the len() Function\n\nThe len() function will return the number of values that are in a list value passed to it, just like it can count the number of characters in a string value. Enter the following into the interactive shell:\n\n>>> spam = ['cat', 'dog', 'moose'] >>> len(spam) 3\n\n#### Changing Values in a List with Indexes\n\nNormally, a variable name goes on the left side of an assignment statement, like spam = 42 . However, you can also use an index of a list to change the value at that index. For example, spam[1] = 'aardvark' means \u201cAssign the value at index 1 in the list spam to the string 'aardvark' .\u201d Enter the following into the interactive shell:\n\n>>> spam = ['cat', 'bat', 'rat', 'elephant'] >>> spam[1] = 'aardvark' >>> spam ['cat', 'aardvark', 'rat', 'elephant'] >>> spam[2] = spam[1] >>> spam ['cat', 'aardvark', 'aardvark', 'elephant'] >>> spam[-1] = 12345 >>> spam ['cat', 'aardvark', 'aardvark', 12345]\n\n#### List Concatenation and List Replication\n\nLists can be concatenated and replicated just like strings. The + operator combines two lists to create a new list value and the * operator can be used with a list and an integer value to replicate the list. Enter the following into the interactive shell:\n\n>>> [1, 2, 3] + ['A', 'B', 'C'] [1, 2, 3, 'A', 'B', 'C'] >>> ['X', 'Y', 'Z'] * 3 ['X', 'Y', 'Z', 'X', 'Y', 'Z', 'X', 'Y', 'Z'] >>> spam = [1, 2, 3] >>> spam = spam + ['A', 'B', 'C'] >>> spam [1, 2, 3, 'A', 'B', 'C']\n\n#### Removing Values from Lists with del Statements\n\nThe del statement will delete values at an index in a list. All of the values in the list after the deleted value will be moved up one index. For example, enter the following into the interactive shell:\n\n>>> spam = ['cat', 'bat', 'rat', 'elephant'] >>> del spam[2] >>> spam ['cat', 'bat', 'elephant'] >>> del spam[2] >>> spam ['cat', 'bat']\n\nThe del statement can also be used on a simple variable to delete it, as if it were an \u201cunassignment\u201d statement. If you try to use the variable after deleting it, you will get a NameError error because the variable no longer exists. In practice, you almost never need to delete simple variables. The del statement is mostly used to delete values from lists.\n\n### Working with Lists\n\nWhen you first begin writing programs, it\u2019s tempting to create many individual variables to store a group of similar values. For example, if I wanted to store the names of my cats, I might be tempted to write code like this:\n\ncatName1 = 'Zophie' catName2 = 'Pooka' catName3 = 'Simon' catName4 = 'Lady Macbeth' catName5 = 'Fat-tail' catName6 = 'Miss Cleo'\n\nIt turns out that this is a bad way to write code. (Also, I don\u2019t actually own this many cats, I swear.) For one thing, if the number of cats changes, your program will never be able to store more cats than you have variables. These types of programs also have a lot of duplicate or nearly identical code in them. Consider how much duplicate code is in the following program, which you should enter into the file editor and save as allMyCats1.py :\n\nprint('Enter the name of cat 1:') catName1 = input() print('Enter the name of cat 2:') catName2 = input() print('Enter the name of cat 3:') catName3 = input() print('Enter the name of cat 4:') catName4 = input() print('Enter the name of cat 5:') catName5 = input() print('Enter the name of cat 6:') catName6 = input() print('The cat names are:') print(catName1 + ' ' + catName2 + ' ' + catName3 + ' ' + catName4 + ' ' + catName5 + ' ' + catName6)\n\nInstead of using multiple, repetitive variables, you can use a single variable that contains a list value. For example, here\u2019s a new and improved version of the allMyCats1.py program. This new version uses a single list and can store any number of cats that the user types in. In a new file editor window, enter the following source code and save it as allMyCats2.py :\n\ncatNames = [] while True: print('Enter the name of cat ' + str(len(catNames) + 1) + ' (Or enter nothing to stop.):') name = input() if name == '': break catNames = catNames + [name]\u00a0\u00a0# list concatenation print('The cat names are:') for name in catNames: print('\u00a0\u00a0' + name)\n\nWhen you run this program, the output will look something like this:\n\nEnter the name of cat 1 (Or enter nothing to stop.): Zophie Enter the name of cat 2 (Or enter nothing to stop.): Pooka Enter the name of cat 3 (Or enter nothing to stop.): Simon Enter the name of cat 4 (Or enter nothing to stop.): Lady Macbeth Enter the name of cat 5 (Or enter nothing to stop.): Fat-tail Enter the name of cat 6 (Or enter nothing to stop.): Miss Cleo Enter the name of cat 7 (Or enter nothing to stop.): The cat names are: Zophie Pooka Simon Lady Macbeth Fat-tail Miss Cleo\n\nYou can view the execution of these programs at https://autbor.com/allmycats1/ and https://autbor.com/allmycats2/ . The benefit of using a list is that your data is now in a structure, so your program is much more flexible in processing the data than it would be with several repetitive variables.\n\n#### Using for Loops with Lists\n\nIn Chapter 2, you learned about using for loops to execute a block of code a certain number of times. Technically, a for loop repeats the code block once for each item in a list value. For example, if you ran this code:\n\nfor i in range(4): print(i)\n\nthe output of this program would be as follows:\n\n0 1 2 3\n\nThis is because the return value from range(4) is a sequence value that Python considers similar to [0, 1, 2, 3] . (Sequences are described in \u201cSequence Data Types\u201d on page 93.) The following program has the same output as the previous one:\n\nfor i in [0, 1, 2, 3]: print(i)\n\nThe previous for loop actually loops through its clause with the variable i set to a successive value in the [0, 1, 2, 3] list in each iteration.\n\nA common Python technique is to use range(len( someList )) with a for loop to iterate over the indexes of a list. For example, enter the following into the interactive shell:\n\n>>> supplies = ['pens', 'staplers', 'flamethrowers', 'binders'] >>> for i in range(len(supplies)): ... print('Index ' + str(i) + ' in supplies is: ' + supplies[i]) Index 0 in supplies is: pens Index 1 in supplies is: staplers Index 2 in supplies is: flamethrowers Index 3 in supplies is: binders\n\nUsing range(len(supplies)) in the previously shown for loop is handy because the code in the loop can access the index (as the variable i ) and the value at that index (as supplies[i] ). Best of all, range(len(supplies)) will iterate through all the indexes of supplies , no matter how many items it contains.\n\n#### The in and not in Operators\n\nYou can determine whether a value is or isn\u2019t in a list with the in and not in operators. Like other operators, in and not in are used in expressions and connect two values: a value to look for in a list and the list where it may be found. These expressions will evaluate to a Boolean value. Enter the following into the interactive shell:\n\n>>> 'howdy' in ['hello', 'hi', 'howdy', 'heyas'] True >>> spam = ['hello', 'hi', 'howdy', 'heyas'] >>> 'cat' in spam False >>> 'howdy' not in spam False >>> 'cat' not in spam True\n\nFor example, the following program lets the user type in a pet name and then checks to see whether the name is in a list of pets. Open a new file editor window, enter the following code, and save it as myPets.py :\n\nmyPets = ['Zophie', 'Pooka', 'Fat-tail'] print('Enter a pet name:') name = input() if name not in myPets: print('I do not have a pet named ' + name) else: print(name + ' is my pet.')\n\nThe output may look something like this:\n\nEnter a pet name: Footfoot I do not have a pet named Footfoot\n\nYou can view the execution of this program at https://autbor.com/mypets/ .\n\n#### The Multiple Assignment Trick\n\nThe multiple assignment trick (technically called tuple unpacking ) is a shortcut that lets you assign multiple variables with the values in a list in one line of code. So instead of doing this:\n\n>>> cat = ['fat', 'gray', 'loud'] >>> size = cat[0] >>> color = cat[1] >>> disposition = cat[2]\n\nyou could type this line of code:\n\n>>> cat = ['fat', 'gray', 'loud'] >>> size, color, disposition = cat\n\nThe number of variables and the length of the list must be exactly equal, or Python will give you a ValueError :\n\n>>> cat = ['fat', 'gray', 'loud'] >>> size, color, disposition, name = cat Traceback (most recent call last): File \"<pyshell#84>\", line 1, in <module> size, color, disposition, name = cat ValueError: not enough values to unpack (expected 4, got 3)\n\n#### Using the enumerate() Function with Lists\n\nInstead of using the range(len( someList )) technique with a for loop to obtain the integer index of the items in the list, you can call the enumerate() function instead. On each iteration of the loop, enumerate() will return two values: the index of the item in the list, and the item in the list itself. For example, this code is equivalent to the code in the \u201cUsing for Loops with Lists\u201d on page 84:\n\n>>> supplies = ['pens', 'staplers', 'flamethrowers', 'binders'] >>> for index, item in enumerate(supplies): ... print('Index ' + str(index) + ' in supplies is: ' + item) Index 0 in supplies is: pens Index 1 in supplies is: staplers Index 2 in supplies is: flamethrowers Index 3 in supplies is: binders\n\nThe enumerate() function is useful if you need both the item and the item\u2019s index in the loop\u2019s block.\n\n#### Using the random.choice() and random.shuffle() Functions with Lists\n\nThe random module has a couple functions that accept lists for arguments. The random.choice() function will return a randomly selected item from the list. Enter the following into the interactive shell:\n\n>>> import random >>> pets = ['Dog', 'Cat', 'Moose'] >>> random.choice(pets) 'Dog' >>> random.choice(pets) 'Cat' >>> random.choice(pets) 'Cat'\n\nYou can consider random.choice(someList) to be a shorter form of someList[random.randint(0, len(someList) \u2013 1] .\n\nThe random.shuffle() function will reorder the items in a list. This function modifies the list in place, rather than returning a new list. Enter the following into the interactive shell:\n\n>>> import random >>> people = ['Alice', 'Bob', 'Carol', 'David'] >>> random.shuffle(people) >>> people ['Carol', 'David', 'Alice', 'Bob'] >>> random.shuffle(people) >>> people ['Alice', 'David', 'Bob', 'Carol']\n\n### Augmented Assignment Operators\n\nWhen assigning a value to a variable, you will frequently use the variable itself. For example, after assigning 42 to the variable spam , you would increase the value in spam by 1 with the following code:\n\n>>> spam = 42 >>> spam = spam + 1 >>> spam 43\n\nAs a shortcut, you can use the augmented assignment operator += to do the same thing:\n\n>>> spam = 42 >>> spam += 1 >>> spam 43\n\nThere are augmented assignment operators for the + , - , * , / , and % operators, described in Table 4-1.\n\nTable 4-1: The Augmented Assignment Operators\n\nAugmented assignment statement\n\nEquivalent assignment statement\n\nspam += 1\n\nspam = spam + 1\n\nspam -= 1\n\nspam = spam - 1\n\nspam *= 1\n\nspam = spam * 1\n\nspam /= 1\n\nspam = spam / 1\n\nspam %= 1\n\nspam = spam % 1\n\nThe += operator can also do string and list concatenation, and the *= operator can do string and list replication. Enter the following into the interactive shell:\n\n>>> spam = 'Hello,' >>> spam += ' world!' >>> spam 'Hello world!' >>> bacon = ['Zophie'] >>> bacon *= 3 >>> bacon ['Zophie', 'Zophie', 'Zophie']\n\n### Methods\n\nA method is the same thing as a function, except it is \u201ccalled on\u201d a value. For example, if a list value were stored in spam , you would call the index() list method (which I\u2019ll explain shortly) on that list like so: spam.index('hello') . The method part comes after the value, separated by a period.\n\nEach data type has its own set of methods. The list data type, for example, has several useful methods for finding, adding, removing, and otherwise manipulating values in a list.\n\n#### Finding a Value in a List with the index() Method\n\nList values have an index() method that can be passed a value, and if that value exists in the list, the index of the value is returned. If the value isn\u2019t in the list, then Python produces a ValueError error. Enter the following into the interactive shell:\n\n>>> spam = ['hello', 'hi', 'howdy', 'heyas'] >>> spam.index('hello') 0 >>> spam.index('heyas') 3 >>> spam.index('howdy howdy howdy') Traceback (most recent call last): File \"<pyshell#31>\", line 1, in <module> spam.index('howdy howdy howdy') ValueError: 'howdy howdy howdy' is not in list\n\nWhen there are duplicates of the value in the list, the index of its first appearance is returned. Enter the following into the interactive shell, and notice that index() returns 1 , not 3 :\n\n>>> spam = ['Zophie', 'Pooka', 'Fat-tail', 'Pooka'] >>> spam.index('Pooka') 1\n\n#### Adding Values to Lists with the append() and insert() Methods\n\nTo add new values to a list, use the append() and insert() methods. Enter the following into the interactive shell to call the append() method on a list value stored in the variable spam :\n\n>>> spam = ['cat', 'dog', 'bat'] >>> spam.append('moose') >>> spam ['cat', 'dog', 'bat', 'moose']\n\nThe previous append() method call adds the argument to the end of the list. The insert() method can insert a value at any index in the list. The first argument to insert() is the index for the new value, and the second argument is the new value to be inserted. Enter the following into the interactive shell:\n\n>>> spam = ['cat', 'dog', 'bat'] >>> spam.insert(1, 'chicken' ) >>> spam ['cat', 'chicken', 'dog', 'bat']\n\nNotice that the code is spam.append('moose') and spam.insert(1, 'chicken') , not spam = spam.append('moose') and spam = spam.insert(1, 'chicken') . Neither append() nor insert() gives the new value of spam as its return value. (In fact, the return value of append() and insert() is None , so you definitely wouldn\u2019t want to store this as the new variable value.) Rather, the list is modified in place . Modifying a list in place is covered in more detail later in \u201cMutable and Immutable Data Types\u201d on page 94.\n\nMethods belong to a single data type. The append() and insert() methods are list methods and can be called only on list values, not on other values such as strings or integers. Enter the following into the interactive shell, and note the AttributeError error messages that show up:\n\n>>> eggs = 'hello' >>> eggs.append('world') Traceback (most recent call last): File \"<pyshell#19>\", line 1, in <module> eggs.append('world') AttributeError: 'str' object has no attribute 'append' >>> bacon = 42 >>> bacon.insert(1, 'world') Traceback (most recent call last): File \"<pyshell#22>\", line 1, in <module> bacon.insert(1, 'world') AttributeError: 'int' object has no attribute 'insert'\n\n#### Removing Values from Lists with the remove() Method\n\nThe remove() method is passed the value to be removed from the list it is called on. Enter the following into the interactive shell:\n\n>>> spam = ['cat', 'bat', 'rat', 'elephant'] >>> spam.remove('bat') >>> spam ['cat', 'rat', 'elephant']\n\nAttempting to delete a value that does not exist in the list will result in a ValueError error. For example, enter the following into the interactive shell and notice the error that is displayed:\n\n>>> spam = ['cat', 'bat', 'rat', 'elephant'] >>> spam.remove('chicken') Traceback (most recent call last): File \"<pyshell#11>\", line 1, in <module> spam.remove('chicken') ValueError: list.remove(x): x not in list\n\nIf the value appears multiple times in the list, only the first instance of the value will be removed. Enter the following into the interactive shell:\n\n>>> spam = ['cat', 'bat', 'rat', 'cat', 'hat', 'cat'] >>> spam.remove('cat') >>> spam ['bat', 'rat', 'cat', 'hat', 'cat']\n\nThe del statement is good to use when you know the index of the value you want to remove from the list. The remove() method is useful when you know the value you want to remove from the list.\n\n#### Sorting the Values in a List with the sort() Method\n\nLists of number values or lists of strings can be sorted with the sort() method. For example, enter the following into the interactive shell:\n\n>>> spam = [2, 5, 3.14, 1, -7] >>> spam.sort() >>> spam [-7, 1, 2, 3.14, 5] >>> spam = ['ants', 'cats', 'dogs', 'badgers', 'elephants'] >>> spam.sort() >>> spam ['ants', 'badgers', 'cats', 'dogs', 'elephants']\n\nYou can also pass True for the reverse keyword argument to have sort() sort the values in reverse order. Enter the following into the interactive shell:\n\n>>> spam.sort(reverse=True) >>> spam ['elephants', 'dogs', 'cats', 'badgers', 'ants']\n\nThere are three things you should note about the sort() method. First, the sort() method sorts the list in place; don\u2019t try to capture the return value by writing code like spam = spam.sort() .\n\nSecond, you cannot sort lists that have both number values and string values in them, since Python doesn\u2019t know how to compare these values. Enter the following into the interactive shell and notice the TypeError error:\n\n>>> spam = [1, 3, 2, 4, 'Alice', 'Bob'] >>> spam.sort() Traceback (most recent call last): File \"<pyshell#70>\", line 1, in <module> spam.sort() TypeError: '<' not supported between instances of 'str' and 'int'\n\nThird, sort() uses \u201cASCIIbetical order\u201d rather than actual alphabetical order for sorting strings. This means uppercase letters come before lowercase letters. Therefore, the lowercase a is sorted so that it comes after the uppercase Z . For an example, enter the following into the interactive shell:\n\n>>> spam = ['Alice', 'ants', 'Bob', 'badgers', 'Carol', 'cats'] >>> spam.sort() >>> spam ['Alice', 'Bob', 'Carol', 'ants', 'badgers', 'cats']\n\nIf you need to sort the values in regular alphabetical order, pass str.lower for the key keyword argument in the sort() method call.\n\n>>> spam = ['a', 'z', 'A', 'Z'] >>> spam.sort(key=str.lower) >>> spam ['a', 'A', 'z', 'Z']\n\nThis causes the sort() function to treat all the items in the list as if they were lowercase without actually changing the values in the list.\n\n#### Reversing the Values in a List with the reverse() Method\n\nIf you need to quickly reverse the order of the items in a list, you can call the reverse() list method. Enter the following into the interactive shell:\n\n>>> spam = ['cat', 'dog', 'moose'] >>> spam.reverse() >>> spam ['moose', 'dog', 'cat']\n\nEXCEPTIONS TO INDENTATION RULES IN PYTHON\n\nIn most cases, the amount of indentation for a line of code tells Python what block it is in. There are some exceptions to this rule, however. For example, lists can actually span several lines in the source code file. The indentation of these lines does not matter; Python knows that the list is not finished until it sees the ending square bracket. For example, you can have code that looks like this:\n\nspam = ['apples', 'oranges', 'bananas', 'cats'] print(spam)\n\nOf course, practically speaking, most people use Python\u2019s behavior to make their lists look pretty and readable, like the messages list in the Magic 8 Ball program.\n\nYou can also split up a single instruction across multiple lines using the \\ line continuation character at the end. Think of \\ as saying, \u201cThis instruction continues on the next line.\u201d The indentation on the line after a \\ line continuation is not significant. For example, the following is valid Python code:\n\nprint('Four score and seven ' + \\ 'years ago...')\n\nThese tricks are useful when you want to rearrange long lines of Python code to be a bit more readable.\n\nLike the sort() list method, reverse() doesn\u2019t return a list. This is why you write spam.reverse() , instead of spam = spam.reverse() .\n\n### Example Program: Magic 8 Ball with a List\n\nUsing lists, you can write a much more elegant version of the previous chapter\u2019s Magic 8 Ball program. Instead of several lines of nearly identical elif statements, you can create a single list that the code works with. Open a new file editor window and enter the following code. Save it as magic8Ball2.py .\n\nimport random messages = ['It is certain', 'It is decidedly so', 'Yes definitely', 'Reply hazy try again', 'Ask again later', 'Concentrate and ask again', 'My reply is no', 'Outlook not so good', 'Very doubtful'] print(messages[random.randint(0, len(messages) - 1)])\n\nYou can view the execution of this program at https://autbor.com/magic8ball2/ .\n\nWhen you run this program, you\u2019ll see that it works the same as the previous magic8Ball.py program.\n\nNotice the expression you use as the index for messages : random.randint (0, len(messages) - 1) . This produces a random number to use for the index, regardless of the size of messages . That is, you\u2019ll get a random number between 0 and the value of len(messages) - 1 . The benefit of this approach is that you can easily add and remove strings to the messages list without changing other lines of code. If you later update your code, there will be fewer lines you have to change and fewer chances for you to introduce bugs.\n\n### Sequence Data Types\n\nLists aren\u2019t the only data types that represent ordered sequences of values. For example, strings and lists are actually similar if you consider a string to be a \u201clist\u201d of single text characters. The Python sequence data types include lists, strings, range objects returned by range() , and tuples (explained in the \u201cThe Tuple Data Type\u201d on page 96). Many of the things you can do with lists can also be done with strings and other values of sequence types: indexing; slicing; and using them with for loops, with len() , and with the in and not in operators. To see this, enter the following into the interactive shell:\n\n>>> name = 'Zophie' >>> name[0] 'Z' >>> name[-2] 'i' >>> name[0:4] 'Zoph' >>> 'Zo' in name True >>> 'z' in name False >>> 'p' not in name False >>> for i in name: ... print('* * * ' + i + ' * * *') * * * Z * * * * * * o * * * * * * p * * * * * * h * * * * * * i * * * * * * e * * *\n\n#### Mutable and Immutable Data Types\n\nBut lists and strings are different in an important way. A list value is a mutable data type: it can have values added, removed, or changed. However, a string is immutable : it cannot be changed. Trying to reassign a single character in a string results in a TypeError error, as you can see by entering the following into the interactive shell:\n\n>>> name = 'Zophie a cat' >>> name[7] = 'the' Traceback (most recent call last): File \"<pyshell#50>\", line 1, in <module> name[7] = 'the' TypeError: 'str' object does not support item assignment\n\nThe proper way to \u201cmutate\u201d a string is to use slicing and concatenation to build a new string by copying from parts of the old string. Enter the following into the interactive shell:\n\n>>> name = 'Zophie a cat' >>> newName = name[0:7] + 'the' + name[8:12] >>> name 'Zophie a cat' >>> newName 'Zophie the cat'\n\nWe used [0:7] and [8:12] to refer to the characters that we don\u2019t wish to replace. Notice that the original 'Zophie a cat' string is not modified, because strings are immutable.\n\nAlthough a list value is mutable, the second line in the following code does not modify the list eggs :\n\n>>> eggs = [1, 2, 3] >>> eggs = [4, 5, 6] >>> eggs [4, 5, 6]\n\nThe list value in eggs isn\u2019t being changed here; rather, an entirely new and different list value ( [4, 5, 6] ) is overwriting the old list value ( [1, 2, 3] ). This is depicted in Figure 4-2.\n\nIf you wanted to actually modify the original list in eggs to contain [4, 5, 6] , you would have to do something like this:\n\n>>> eggs = [1, 2, 3] >>> del eggs[2] >>> del eggs[1] >>> del eggs[0] >>> eggs.append(4) >>> eggs.append(5) >>> eggs.append(6) >>> eggs [4, 5, 6]\n\nFigure 4-2: When eggs = [4, 5, 6] is executed, the contents of eggs are replaced with a new list value.\n\nIn the first example, the list value that eggs ends up with is the same list value it started with. It\u2019s just that this list has been changed, rather than overwritten. Figure 4-3 depicts the seven changes made by the first seven lines in the previous interactive shell example.\n\nFigure 4-3: The del statement and the append() method modify the same list value in place.\n\nChanging a value of a mutable data type (like what the del statement and append() method do in the previous example) changes the value in place, since the variable\u2019s value is not replaced with a new list value.\n\nMutable versus immutable types may seem like a meaningless distinction, but \u201cPassing References\u201d on page 100 will explain the different behavior when calling functions with mutable arguments versus immutable arguments. But first, let\u2019s find out about the tuple data type, which is an immutable form of the list data type.\n\n#### The Tuple Data Type\n\nThe tuple data type is almost identical to the list data type, except in two ways. First, tuples are typed with parentheses, ( and ) , instead of square brackets, [ and ] . For example, enter the following into the interactive shell:\n\n>>> eggs = ('hello', 42, 0.5) >>> eggs[0] 'hello' >>> eggs[1:3] (42, 0.5) >>> len(eggs) 3\n\nBut the main way that tuples are different from lists is that tuples, like strings, are immutable. Tuples cannot have their values modified, appended, or removed. Enter the following into the interactive shell, and look at the TypeError error message:\n\n>>> eggs = ('hello', 42, 0.5) >>> eggs[1] = 99 Traceback (most recent call last): File \"<pyshell#5>\", line 1, in <module> eggs[1] = 99 TypeError: 'tuple' object does not support item assignment\n\nIf you have only one value in your tuple, you can indicate this by placing a trailing comma after the value inside the parentheses. Otherwise, Python will think you\u2019ve just typed a value inside regular parentheses. The comma is what lets Python know this is a tuple value. (Unlike some other programming languages, it\u2019s fine to have a trailing comma after the last item in a list or tuple in Python.) Enter the following type() function calls into the interactive shell to see the distinction:\n\n>>> type(('hello',)) <class 'tuple'> >>> type(('hello')) <class 'str'>\n\nYou can use tuples to convey to anyone reading your code that you don\u2019t intend for that sequence of values to change. If you need an ordered sequence of values that never changes, use a tuple. A second benefit of using tuples instead of lists is that, because they are immutable and their contents don\u2019t change, Python can implement some optimizations that make code using tuples slightly faster than code using lists.\n\n#### Converting Types with the list() and tuple() Functions\n\nJust like how str(42) will return '42' , the string representation of the integer 42 , the functions list() and tuple() will return list and tuple versions of the values passed to them. Enter the following into the interactive shell, and notice that the return value is of a different data type than the value passed:\n\n>>> tuple(['cat', 'dog', 5]) ('cat', 'dog', 5) >>> list(('cat', 'dog', 5)) ['cat', 'dog', 5] >>> list('hello') ['h', 'e', 'l', 'l', 'o']\n\nConverting a tuple to a list is handy if you need a mutable version of a tuple value.\n\n### References\n\nAs you\u2019ve seen, variables \u201cstore\u201d strings and integer values. However, this explanation is a simplification of what Python is actually doing. Technically, variables are storing references to the computer memory locations where the values are stored. Enter the following into the interactive shell:\n\n>>> spam = 42 >>> cheese = spam >>> spam = 100 >>> spam 100 >>> cheese 42\n\nWhen you assign 42 to the spam variable, you are actually creating the 42 value in the computer\u2019s memory and storing a reference to it in the spam variable. When you copy the value in spam and assign it to the variable cheese , you are actually copying the reference. Both the spam and cheese variables refer to the 42 value in the computer\u2019s memory. When you later change the value in spam to 100 , you\u2019re creating a new 100 value and storing a reference to it in spam . This doesn\u2019t affect the value in cheese . Integers are immutable values that don\u2019t change; changing the spam variable is actually making it refer to a completely different value in memory.\n\nBut lists don\u2019t work this way, because list values can change; that is, lists are mutable . Here is some code that will make this distinction easier to understand. Enter this into the interactive shell:\n\n\u278a >>> spam = [0, 1, 2, 3, 4, 5] \u278b >>> cheese = spam # The reference is being copied, not the list. \u278c >>> cheese[1] = 'Hello!' # This changes the list value. >>> spam [0, 'Hello!', 2, 3, 4, 5] >>> cheese # The cheese variable refers to the same list. [0, 'Hello!', 2, 3, 4, 5]\n\nThis might look odd to you. The code touched only the cheese list, but it seems that both the cheese and spam lists have changed.\n\nWhen you create the list \u278a , you assign a reference to it in the spam variable. But the next line \u278b copies only the list reference in spam to cheese , not the list value itself. This means the values stored in spam and cheese now both refer to the same list. There is only one underlying list because the list itself was never actually copied. So when you modify the first element of cheese \u278c , you are modifying the same list that spam refers to.\n\nRemember that variables are like boxes that contain values. The previous figures in this chapter show that lists in boxes aren\u2019t exactly accurate, because list variables don\u2019t actually contain lists\u2014they contain references to lists. (These references will have ID numbers that Python uses internally, but you can ignore them.) Using boxes as a metaphor for variables, Figure 4-4 shows what happens when a list is assigned to the spam variable.\n\nFigure 4-4: spam = [0, 1, 2, 3, 4, 5] stores a reference to a list, not the actual list.\n\nThen, in Figure 4-5, the reference in spam is copied to cheese . Only a new reference was created and stored in cheese , not a new list. Note how both references refer to the same list.\n\nFigure 4-5: spam = cheese copies the reference, not the list.\n\nWhen you alter the list that cheese refers to, the list that spam refers to is also changed, because both cheese and spam refer to the same list. You can see this in Figure 4-6.\n\nFigure 4-6: cheese[1] = 'Hello!' modifies the list that both variables refer to.\n\nAlthough Python variables technically contain references to values, people often casually say that the variable contains the value.\n\n#### Identity and the id() Function\n\nYou may be wondering why the weird behavior with mutable lists in the previous section doesn\u2019t happen with immutable values like integers or strings. We can use Python\u2019s id() function to understand this. All values in Python have a unique identity that can be obtained with the id() function. Enter the following into the interactive shell:\n\n>>> id('Howdy') # The returned number will be different on your machine. 44491136\n\nWhen Python runs id('Howdy') , it creates the 'Howdy' string in the computer\u2019s memory. The numeric memory address where the string is stored is returned by the id() function. Python picks this address based on which memory bytes happen to be free on your computer at the time, so it\u2019ll be different each time you run this code.\n\nLike all strings, 'Howdy' is immutable and cannot be changed. If you \u201cchange\u201d the string in a variable, a new string object is being made at a different place in memory, and the variable refers to this new string. For example, enter the following into the interactive shell and see how the identity of the string referred to by bacon changes:\n\n>>> bacon = 'Hello' >>> id(bacon) 44491136 >>> bacon += ' world!' # A new string is made from 'Hello' and ' world!'. >>> id(bacon) # bacon now refers to a completely different string. 44609712\n\nHowever, lists can be modified because they are mutable objects. The append() method doesn\u2019t create a new list object; it changes the existing list object. We call this \u201cmodifying the object in-place. \u201d\n\n>>> eggs = ['cat', 'dog'] # This creates a new list. >>> id(eggs) 35152584 >>> eggs.append('moose') # append() modifies the list \"in place\". >>> id(eggs) # eggs still refers to the same list as before. 35152584 >>> eggs = ['bat', 'rat', 'cow'] # This creates a new list, which has a new identity. >>> id(eggs) # eggs now refers to a completely different list. 44409800\n\nIf two variables refer to the same list (like spam and cheese in the previous section) and the list value itself changes, both variables are affected because they both refer to the same list. The append() , extend() , remove() , sort() , reverse() , and other list methods modify their lists in place.\n\nPython\u2019s automatic garbage collector deletes any values not being referred to by any variables to free up memory. You don\u2019t need to worry about how the garbage collector works, which is a good thing: manual memory management in other programming languages is a common source of bugs.\n\n#### Passing References\n\nReferences are particularly important for understanding how arguments get passed to functions. When a function is called, the values of the arguments are copied to the parameter variables. For lists (and dictionaries, which I\u2019ll describe in the next chapter), this means a copy of the reference is used for the parameter. To see the consequences of this, open a new file editor window, enter the following code, and save it as passingReference.py :\n\ndef eggs(someParameter): someParameter.append('Hello') spam = [1, 2, 3] eggs(spam) print(spam)\n\nNotice that when eggs() is called, a return value is not used to assign a new value to spam . Instead, it modifies the list in place, directly. When run, this program produces the following output:\n\n[1, 2, 3, 'Hello']\n\nEven though spam and someParameter contain separate references, they both refer to the same list. This is why the append('Hello') method call inside the function affects the list even after the function call has returned.\n\nKeep this behavior in mind: forgetting that Python handles list and dictionary variables this way can lead to confusing bugs.\n\n#### The copy Module\u2019s copy() and deepcopy() Functions\n\nAlthough passing around references is often the handiest way to deal with lists and dictionaries, if the function modifies the list or dictionary that is passed, you may not want these changes in the original list or dictionary value. For this, Python provides a module named copy that provides both the copy() and deepcopy() functions. The first of these, copy.copy() , can be used to make a duplicate copy of a mutable value like a list or dictionary, not just a copy of a reference. Enter the following into the interactive shell:\n\n>>> import copy >>> spam = ['A', 'B', 'C', 'D'] >>> id(spam) 44684232 >>> cheese = copy.copy(spam) >>> id(cheese) # cheese is a different list with different identity. 44685832 >>> cheese[1] = 42 >>> spam ['A', 'B', 'C', 'D'] >>> cheese ['A', 42, 'C', 'D']\n\nNow the spam and cheese variables refer to separate lists, which is why only the list in cheese is modified when you assign 42 at index 1 . As you can see in Figure 4-7, the reference ID numbers are no longer the same for both variables because the variables refer to independent lists.\n\nFigure 4-7: cheese = copy.copy(spam) creates a second list that can be modified independently of the first.\n\nIf the list you need to copy contains lists, then use the copy.deepcopy() function instead of copy.copy() . The deepcopy() function will copy these inner lists as well.\n\n### A Short Program: Conway\u2019s Game of Life\n\nConway\u2019s Game of Life is an example of cellular automata : a set of rules governing the behavior of a field made up of discrete cells. In practice, it creates a pretty animation to look at. You can draw out each step on graph paper, using the squares as cells. A filled-in square will be \u201calive\u201d and an empty square will be \u201cdead.\u201d If a living square has two or three living neighbors, it continues to live on the next step. If a dead square has exactly three living neighbors, it comes alive on the next step. Every other square dies or remains dead on the next step. You can see an example of the progression of steps in Figure 4-8.\n\nFigure 4-8: Four steps in a Conway\u2019s Game of Life simulation\n\nEven though the rules are simple, there are many surprising behaviors that emerge. Patterns in Conway\u2019s Game of Life can move, self-replicate, or even mimic CPUs. But at the foundation of all of this complex, advanced behavior is a rather simple program.\n\nWe can use a list of lists to represent the two-dimensional field. The inner list represents each column of squares and stores a '#' hash string for living squares and a ' ' space string for dead squares. Type the following source code into the file editor, and save the file as conway.py . It\u2019s fine if you don\u2019t quite understand how all of the code works; just enter it and follow along with comments and explanations provided here as close as you can:\n\n# Conway's Game of Life import random, time, copy WIDTH = 60 HEIGHT = 20 # Create a list of list for the cells: nextCells = [] for x in range(WIDTH): column = [] # Create a new column. for y in range(HEIGHT): if random.randint(0, 1) == 0: column.append('#') # Add a living cell. else: column.append(' ') # Add a dead cell. nextCells.append(column) # nextCells is a list of column lists. while True: # Main program loop. print('\\n\\n\\n\\n\\n') # Separate each step with newlines. currentCells = copy.deepcopy(nextCells) # Print currentCells on the screen: for y in range(HEIGHT): for x in range(WIDTH): print(currentCells[x][y], end='') # Print the # or space. print() # Print a newline at the end of the row. # Calculate the next step's cells based on current step's cells: for x in range(WIDTH): for y in range(HEIGHT): # Get neighboring coordinates: # `% WIDTH` ensures leftCoord is always between 0 and WIDTH - 1 leftCoord\u00a0\u00a0= (x - 1) % WIDTH rightCoord = (x + 1) % WIDTH aboveCoord = (y - 1) % HEIGHT belowCoord = (y + 1) % HEIGHT # Count number of living neighbors: numNeighbors = 0 if currentCells[leftCoord][aboveCoord] == '#': numNeighbors += 1 # Top-left neighbor is alive. if currentCells[x][aboveCoord] == '#': numNeighbors += 1 # Top neighbor is alive. if currentCells[rightCoord][aboveCoord] == '#': numNeighbors += 1 # Top-right neighbor is alive. if currentCells[leftCoord][y] == '#': numNeighbors += 1 # Left neighbor is alive. if currentCells[rightCoord][y] == '#': numNeighbors += 1 # Right neighbor is alive. if currentCells[leftCoord][belowCoord] == '#': numNeighbors += 1 # Bottom-left neighbor is alive. if currentCells[x][belowCoord] == '#': numNeighbors += 1 # Bottom neighbor is alive. if currentCells[rightCoord][belowCoord] == '#': numNeighbors += 1 # Bottom-right neighbor is alive. # Set cell based on Conway's Game of Life rules: if currentCells[x][y] == '#' and (numNeighbors == 2 or numNeighbors == 3): # Living cells with 2 or 3 neighbors stay alive: nextCells[x][y] = '#' elif currentCells[x][y] == ' ' and numNeighbors == 3: # Dead cells with 3 neighbors become alive: nextCells[x][y] = '#' else: # Everything else dies or stays dead: nextCells[x][y] = ' ' time.sleep(1) # Add a 1-second pause to reduce flickering.\n\nLet\u2019s look at this code line by line, starting at the top.\n\n# Conway's Game of Life import random, time, copy WIDTH = 60 HEIGHT = 20\n\nFirst we import modules that contain functions we\u2019ll need, namely the random.randint() , time.sleep() , and copy.deepcopy() functions.\n\n# Create a list of list for the cells: nextCells = [] for x in range(WIDTH): column = [] # Create a new column. for y in range(HEIGHT): if random.randint(0, 1) == 0: column.append('#') # Add a living cell. else: column.append(' ') # Add a dead cell. nextCells.append(column) # nextCells is a list of column lists.\n\nThe very first step of our cellular automata will be completely random. We need to create a list of lists data structure to store the '#' and ' ' strings that represent a living or dead cell, and their place in the list of lists reflects their position on the screen. The inner lists each represent a column of cells. The random.randint(0, 1) call gives an even 50/50 chance between the cell starting off alive or dead.\n\nWe put this list of lists in a variable called nextCells , because the first step in our main program loop will be to copy nextCells into currentCells . For our list of lists data structure, the x-coordinates start at 0 on the left and increase going right, while the y-coordinates start at 0 at the top and increase going down. So nextCells[0][0] will represent the cell at the top left of the screen, while nextCells[1][0] represents the cell to the right of that cell and nextCells[0][1] represents the cell beneath it.\n\nwhile True: # Main program loop. print('\\n\\n\\n\\n\\n') # Separate each step with newlines. currentCells = copy.deepcopy(nextCells)\n\nEach iteration of our main program loop will be a single step of our cellular automata. On each step, we\u2019ll copy nextCells to currentCells , print currentCells on the screen, and then use the cells in currentCells to calculate the cells in nextCells .\n\n# Print currentCells on the screen: for y in range(HEIGHT): for x in range(WIDTH): print(currentCells[x][y], end='') # Print the # or space. print() # Print a newline at the end of the row.\n\nThese nested for loops ensure that we print a full row of cells to the screen, followed by a newline character at the end of the row. We repeat this for each row in nextCells .\n\n# Calculate the next step's cells based on current step's cells: for x in range(WIDTH): for y in range(HEIGHT): # Get neighboring coordinates: # `% WIDTH` ensures leftCoord is always between 0 and WIDTH - 1 leftCoord\u00a0\u00a0= (x - 1) % WIDTH rightCoord = (x + 1) % WIDTH aboveCoord = (y - 1) % HEIGHT belowCoord = (y + 1) % HEIGHT\n\nNext, we need to use two nested for loops to calculate each cell for the next step. The living or dead state of the cell depends on the neighbors, so let\u2019s first calculate the index of the cells to the left, right, above, and below the current x- and y-coordinates.\n\nThe % mod operator performs a \u201cwraparound.\u201d The left neighbor of a cell in the leftmost column 0 would be 0 - 1 or -1 . To wrap this around to the rightmost column\u2019s index, 59 , we calculate (0 - 1) % WIDTH . Since WIDTH is 60 , this expression evaluates to 59 . This mod-wraparound technique works for the right, above, and below neighbors as well.\n\n# Count number of living neighbors: numNeighbors = 0 if currentCells[leftCoord][aboveCoord] == '#': numNeighbors += 1 # Top-left neighbor is alive. if currentCells[x][aboveCoord] == '#': numNeighbors += 1 # Top neighbor is alive. if currentCells[rightCoord][aboveCoord] == '#': numNeighbors += 1 # Top-right neighbor is alive. if currentCells[leftCoord][y] == '#': numNeighbors += 1 # Left neighbor is alive. if currentCells[rightCoord][y] == '#': numNeighbors += 1 # Right neighbor is alive. if currentCells[leftCoord][belowCoord] == '#': numNeighbors += 1 # Bottom-left neighbor is alive. if currentCells[x][belowCoord] == '#': numNeighbors += 1 # Bottom neighbor is alive. if currentCells[rightCoord][belowCoord] == '#': numNeighbors += 1 # Bottom-right neighbor is alive.\n\nTo decide if the cell at nextCells[x][y] should be living or dead, we need to count the number of living neighbors currentCells[x][y] has. This series of if statements checks each of the eight neighbors of this cell, and adds 1 to numNeighbors for each living one.\n\n# Set cell based on Conway's Game of Life rules: if currentCells[x][y] == '#' and (numNeighbors == 2 or numNeighbors == 3): # Living cells with 2 or 3 neighbors stay alive: nextCells[x][y] = '#' elif currentCells[x][y] == ' ' and numNeighbors == 3: # Dead cells with 3 neighbors become alive: nextCells[x][y] = '#' else: # Everything else dies or stays dead: nextCells[x][y] = ' ' time.sleep(1) # Add a 1-second pause to reduce flickering.\n\nNow that we know the number of living neighbors for the cell at currentCells[x][y] , we can set nextCells[x][y] to either '#' or ' ' . After we loop over every possible x- and y-coordinate, the program takes a 1-second pause by calling time.sleep(1) . Then the program execution goes back to the start of the main program loop to continue with the next step.\n\nSeveral patterns have been discovered with names such as \u201cglider,\u201d \u201cpropeller,\u201d or \u201cheavyweight spaceship.\u201d The glider pattern, pictured in Figure 4-8, results in a pattern that \u201cmoves\u201d diagonally every four steps. You can create a single glider by replacing this line in our conway.py program:\n\nif random.randint(0, 1) == 0:\n\nwith this line:\n\nif (x, y) in ((1, 0), (2, 1), (0, 2), (1, 2), (2, 2)):\n\nYou can find out more about the intriguing devices made using Conway\u2019s Game of Life by searching the web. And you can find other short, text-based Python programs like this one at https://github.com/asweigart/pythonstdiogames .\n\n### Summary\n\nLists are useful data types since they allow you to write code that works on a modifiable number of values in a single variable. Later in this book, you will see programs using lists to do things that would be difficult or impossible to do without them.\n\nLists are a sequence data type that is mutable, meaning that their contents can change. Tuples and strings, though also sequence data types, are immutable and cannot be changed. A variable that contains a tuple or string value can be overwritten with a new tuple or string value, but this is not the same thing as modifying the existing value in place\u2014like, say, the append() or remove() methods do on lists.\n\nVariables do not store list values directly; they store references to lists. This is an important distinction when you are copying variables or passing lists as arguments in function calls. Because the value that is being copied is the list reference, be aware that any changes you make to the list might impact another variable in your program. You can use copy() or deepcopy() if you want to make changes to a list in one variable without modifying the original list.\n\n### Practice Questions\n\n1. What is [] ?\n\n2. How would you assign the value 'hello' as the third value in a list stored in a variable named spam ? (Assume spam contains [2, 4, 6, 8, 10] .)\n\nFor the following three questions, let\u2019s say spam contains the list ['a', 'b', 'c', 'd'] .\n\n3. What does spam[int(int('3' * 2) // 11)] evaluate to?\n\n4. What does spam[-1] evaluate to?\n\n5. What does spam[:2] evaluate to?\n\nFor the following three questions, let\u2019s say bacon contains the list [3.14, 'cat', 11, 'cat', True] .\n\n6. What does bacon.index('cat') evaluate to?\n\n7. What does bacon.append(99) make the list value in bacon look like?\n\n8. What does bacon.remove('cat') make the list value in bacon look like?\n\n9. What are the operators for list concatenation and list replication?\n\n10. What is the difference between the append() and insert() list methods?\n\n11. What are two ways to remove values from a list?\n\n12. Name a few ways that list values are similar to string values.\n\n13. What is the difference between lists and tuples?\n\n14. How do you type the tuple value that has just the integer value 42 in it?\n\n15. How can you get the tuple form of a list value? How can you get the list form of a tuple value?\n\n16. Variables that \u201ccontain\u201d list values don\u2019t actually contain lists directly. What do they contain instead?\n\n17. What is the difference between copy.copy() and copy.deepcopy() ?\n\n### Practice Projects\n\nFor practice, write programs to do the following tasks.\n\n#### Comma Code\n\nSay you have a list value like this:\n\nspam = ['apples', 'bananas', 'tofu', 'cats']\n\nWrite a function that takes a list value as an argument and returns a string with all the items separated by a comma and a space, with and inserted before the last item. For example, passing the previous spam list to the function would return 'apples, bananas, tofu, and cats' . But your function should be able to work with any list value passed to it. Be sure to test the case where an empty list [] is passed to your function.\n\n#### Coin Flip Streaks\n\nFor this exercise, we\u2019ll try doing an experiment. If you flip a coin 100 times and write down an \u201cH\u201d for each heads and \u201cT\u201d for each tails, you\u2019ll create a list that looks like \u201cT T T T H H H H T T.\u201d If you ask a human to make up 100 random coin flips, you\u2019ll probably end up with alternating head-tail results like \u201cH T H T H H T H T T,\u201d which looks random (to humans), but isn\u2019t mathematically random. A human will almost never write down a streak of six heads or six tails in a row, even though it is highly likely to happen in truly random coin flips. Humans are predictably bad at being random.\n\nWrite a program to find out how often a streak of six heads or a streak of six tails comes up in a randomly generated list of heads and tails. Your program breaks up the experiment into two parts: the first part generates a list of randomly selected 'heads' and 'tails' values, and the second part checks if there is a streak in it. Put all of this code in a loop that repeats the experiment 10,000 times so we can find out what percentage of the coin flips contains a streak of six heads or tails in a row. As a hint, the function call random.randint(0, 1) will return a 0 value 50% of the time and a 1 value the other 50% of the time.\n\nYou can start with the following template:\n\nimport random numberOfStreaks = 0 for experimentNumber in range(10000): # Code that creates a list of 100 'heads' or 'tails' values. # Code that checks if there is a streak of 6 heads or tails in a row. print('Chance of streak: %s%%' % (numberOfStreaks / 100))\n\nOf course, this is only an estimate, but 10,000 is a decent sample size. Some knowledge of mathematics could give you the exact answer and save you the trouble of writing a program, but programmers are notoriously bad at math.\n\n#### Character Picture Grid\n\nSay you have a list of lists where each value in the inner lists is a one-character string, like this:\n\ngrid = [['.', '.', '.', '.', '.', '.'], ['.', 'O', 'O', '.', '.', '.'], ['O', 'O', 'O', 'O', '.', '.'], ['O', 'O', 'O', 'O', 'O', '.'], ['.', 'O', 'O', 'O', 'O', 'O'], ['O', 'O', 'O', 'O', 'O', '.'], ['O', 'O', 'O', 'O', '.', '.'], ['.', 'O', 'O', '.', '.', '.'], ['.', '.', '.', '.', '.', '.']]\n\nThink of grid[x][y] as being the character at the x- and y-coordinates of a \u201cpicture\u201d drawn with text characters. The (0, 0) origin is in the upper-left corner, the x-coordinates increase going right, and the y-coordinates increase going down.\n\nCopy the previous grid value, and write code that uses it to print the image.\n\n..OO.OO.. .OOOOOOO. .OOOOOOO. ..OOOOO.. ...OOO... ....O....\n\nHint: You will need to use a loop in a loop in order to print grid[0][0] , then grid[1][0] , then grid[2][0] , and so on, up to grid[8][0] . This will finish the first row, so then print a newline. Then your program should print grid[0][1] , then grid[1][1] , then grid[2][1] , and so on. The last thing your program will print is grid[8][5] .\n\nAlso, remember to pass the end keyword argument to print() if you don\u2019t want a newline printed automatically after each print() call.",
      "difficulty": "intro",
      "doc_id": "doc-4lists-8d4c6036cb",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-NC-SA 3.0",
        "source_file": "data/corpus_raw/2e_chapter4_36e5ad.json",
        "url": "https://automatetheboringstuff.com/2e/chapter4/"
      },
      "title": "4LISTS",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "comprehensions",
        "dictionaries",
        "lists",
        "sets",
        "tuples"
      ],
      "content": "# 5.Data Structures\u00c2\u00b6\n\nThis chapter describes some things you\u00e2\u0080\u0099ve learned about already in more detail,\nand adds some new things as well.\n\n## 5.1.More on Lists\u00c2\u00b6\n\nThe list data type has some more methods. Here are all\nof the methods of list objects:\n\nlist.\nappend\n(\nx\n)\nAdd an item to the end of the list.  Similar to a[len(a):] = [x] .\n\nlist.\nextend\n(\niterable\n)\nExtend the list by appending all the items from the iterable.  Similar to a[len(a):] = iterable .\n\nlist.\ninsert\n(\ni\n,\nx\n)\nInsert an item at a given position.  The first argument is the index of the\nelement before which to insert, so a.insert(0, x) inserts at the front of\nthe list, and a.insert(len(a), x) is equivalent to a.append(x) .\n\nlist.\nremove\n(\nx\n)\nRemove the first item from the list whose value is equal to x .  It raises a ValueError if there is no such item.\n\nlist.\npop\n(\n[\ni\n]\n)\nRemove the item at the given position in the list, and return it.  If no index\nis specified, a.pop() removes and returns the last item in the list.\nIt raises an IndexError if the list is empty or the index is\noutside the list range.\n\nlist.\nclear\n(\n)\nRemove all items from the list.  Similar to del a[:] .\n\nlist.\nindex\n(\nx\n[\n,\nstart\n[\n,\nend\n]\n]\n)\nReturn zero-based index of the first occurrence of x in the list.\nRaises a ValueError if there is no such item.\n\nThe optional arguments start and end are interpreted as in the slice\nnotation and are used to limit the search to a particular subsequence of\nthe list.  The returned index is computed relative to the beginning of the full\nsequence rather than the start argument.\n\nlist.\ncount\n(\nx\n)\nReturn the number of times x appears in the list.\n\nlist.\nsort\n(\n*\n,\nkey\n=\nNone\n,\nreverse\n=\nFalse\n)\nSort the items of the list in place (the arguments can be used for sort\ncustomization, see sorted() for their explanation).\n\nlist.\nreverse\n(\n)\nReverse the elements of the list in place.\n\nlist.\ncopy\n(\n)\nReturn a shallow copy of the list.  Similar to a[:] .\n\nAn example that uses most of the list methods:\n\n```python\n>>> fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana']\n>>> fruits.count('apple')\n2\n>>> fruits.count('tangerine')\n0\n>>> fruits.index('banana')\n3\n>>> fruits.index('banana', 4)  # Find next banana starting at position 4\n6\n>>> fruits.reverse()\n>>> fruits\n['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange']\n>>> fruits.append('grape')\n>>> fruits\n['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape']\n>>> fruits.sort()\n>>> fruits\n['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear']\n>>> fruits.pop()\n'pear'\n```python\n\nYou might have noticed that methods like insert , remove or sort that\nonly modify the list have no return value printed \u00e2\u0080\u0093 they return the default None . [ 1 ] This is a design principle for all mutable data structures in\nPython.\n\nAnother thing you might notice is that not all data can be sorted or\ncompared.  For instance, [None, 'hello', 10] doesn\u00e2\u0080\u0099t sort because\nintegers can\u00e2\u0080\u0099t be compared to strings and None can\u00e2\u0080\u0099t be compared to\nother types.  Also, there are some types that don\u00e2\u0080\u0099t have a defined\nordering relation.  For example, 3+4j < 5+7j isn\u00e2\u0080\u0099t a valid\ncomparison.\n\n### 5.1.1.Using Lists as Stacks\u00c2\u00b6\n\nThe list methods make it very easy to use a list as a stack, where the last\nelement added is the first element retrieved (\u00e2\u0080\u009clast-in, first-out\u00e2\u0080\u009d).  To add an\nitem to the top of the stack, use append() .  To retrieve an item from the\ntop of the stack, use pop() without an explicit index.  For example:\n\n```python\n>>> stack = [3, 4, 5]\n>>> stack.append(6)\n>>> stack.append(7)\n>>> stack\n[3, 4, 5, 6, 7]\n>>> stack.pop()\n7\n>>> stack\n[3, 4, 5, 6]\n>>> stack.pop()\n6\n>>> stack.pop()\n5\n>>> stack\n[3, 4]\n```python\n\n### 5.1.2.Using Lists as Queues\u00c2\u00b6\n\nIt is also possible to use a list as a queue, where the first element added is\nthe first element retrieved (\u00e2\u0080\u009cfirst-in, first-out\u00e2\u0080\u009d); however, lists are not\nefficient for this purpose.  While appends and pops from the end of list are\nfast, doing inserts or pops from the beginning of a list is slow (because all\nof the other elements have to be shifted by one).\n\nTo implement a queue, use collections.deque which was designed to\nhave fast appends and pops from both ends.  For example:\n\n```python\n>>> from collections import deque\n>>> queue = deque([\"Eric\", \"John\", \"Michael\"])\n>>> queue.append(\"Terry\")           # Terry arrives\n>>> queue.append(\"Graham\")          # Graham arrives\n>>> queue.popleft()                 # The first to arrive now leaves\n'Eric'\n>>> queue.popleft()                 # The second to arrive now leaves\n'John'\n>>> queue                           # Remaining queue in order of arrival\ndeque(['Michael', 'Terry', 'Graham'])\n```python\n\n### 5.1.3.List Comprehensions\u00c2\u00b6\n\nList comprehensions provide a concise way to create lists.\nCommon applications are to make new lists where each element is the result of\nsome operations applied to each member of another sequence or iterable, or to\ncreate a subsequence of those elements that satisfy a certain condition.\n\nFor example, assume we want to create a list of squares, like:\n\n```python\n>>> squares = []\n>>> for x in range(10):\n...     squares.append(x**2)\n...\n>>> squares\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n```python\n\nNote that this creates (or overwrites) a variable named x that still exists\nafter the loop completes.  We can calculate the list of squares without any\nside effects using:\n\n```python\nsquares = list(map(lambda x: x**2, range(10)))\n```python\n\nor, equivalently:\n\n```python\nsquares = [x**2 for x in range(10)]\n```python\n\nwhich is more concise and readable.\n\nA list comprehension consists of brackets containing an expression followed\nby a for clause, then zero or more for or if clauses.  The result will be a new list resulting from evaluating the expression\nin the context of the for and if clauses which follow it.\nFor example, this listcomp combines the elements of two lists if they are not\nequal:\n\n```python\n>>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]\n[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]\n```python\n\nand it\u00e2\u0080\u0099s equivalent to:\n\n```python\n>>> combs = []\n>>> for x in [1,2,3]:\n...     for y in [3,1,4]:\n...         if x != y:\n...             combs.append((x, y))\n...\n>>> combs\n[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]\n```python\n\nNote how the order of the for and if statements is the\nsame in both these snippets.\n\nIf the expression is a tuple (e.g. the (x, y) in the previous example),\nit must be parenthesized.\n\n```python\n>>> vec = [-4, -2, 0, 2, 4]\n>>> # create a new list with the values doubled\n>>> [x*2 for x in vec]\n[-8, -4, 0, 4, 8]\n>>> # filter the list to exclude negative numbers\n>>> [x for x in vec if x >= 0]\n[0, 2, 4]\n>>> # apply a function to all the elements\n>>> [abs(x) for x in vec]\n[4, 2, 0, 2, 4]\n>>> # call a method on each element\n>>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']\n>>> [weapon.strip() for weapon in freshfruit]\n['banana', 'loganberry', 'passion fruit']\n>>> # create a list of 2-tuples like (number, square)\n>>> [(x, x**2) for x in range(6)]\n[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]\n>>> # the tuple must be parenthesized, otherwise an error is raised\n>>> [x, x**2 for x in range(6)]\n  File \"<stdin>\", line 1\n    [x, x**2 for x in range(6)]\n     ^^^^^^^\nSyntaxError: did you forget parentheses around the comprehension target?\n>>> # flatten a list using a listcomp with two 'for'\n>>> vec = [[1,2,3], [4,5,6], [7,8,9]]\n>>> [num for elem in vec for num in elem]\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n```python\n\nList comprehensions can contain complex expressions and nested functions:\n\n```python\n>>> from math import pi\n>>> [str(round(pi, i)) for i in range(1, 6)]\n['3.1', '3.14', '3.142', '3.1416', '3.14159']\n```python\n\n### 5.1.4.Nested List Comprehensions\u00c2\u00b6\n\nThe initial expression in a list comprehension can be any arbitrary expression,\nincluding another list comprehension.\n\nConsider the following example of a 3x4 matrix implemented as a list of\n3 lists of length 4:\n\n```python\n>>> matrix = [\n...     [1, 2, 3, 4],\n...     [5, 6, 7, 8],\n...     [9, 10, 11, 12],\n... ]\n```python\n\nThe following list comprehension will transpose rows and columns:\n\n```python\n>>> [[row[i] for row in matrix] for i in range(4)]\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\n```python\n\nAs we saw in the previous section, the inner list comprehension is evaluated in\nthe context of the for that follows it, so this example is\nequivalent to:\n\n```python\n>>> transposed = []\n>>> for i in range(4):\n...     transposed.append([row[i] for row in matrix])\n...\n>>> transposed\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\n```python\n\nwhich, in turn, is the same as:\n\n```python\n>>> transposed = []\n>>> for i in range(4):\n...     # the following 3 lines implement the nested listcomp\n...     transposed_row = []\n...     for row in matrix:\n...         transposed_row.append(row[i])\n...     transposed.append(transposed_row)\n...\n>>> transposed\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\n```python\n\nIn the real world, you should prefer built-in functions to complex flow statements.\nThe zip() function would do a great job for this use case:\n\n```python\n>>> list(zip(*matrix))\n[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]\n```python\n\nSee Unpacking Argument Lists for details on the asterisk in this line.\n\n## 5.2.Thedelstatement\u00c2\u00b6\n\nThere is a way to remove an item from a list given its index instead of its\nvalue: the del statement.  This differs from the pop() method\nwhich returns a value.  The del statement can also be used to remove\nslices from a list or clear the entire list (which we did earlier by assignment\nof an empty list to the slice).  For example:\n\n```python\n>>> a = [-1, 1, 66.25, 333, 333, 1234.5]\n>>> del a[0]\n>>> a\n[1, 66.25, 333, 333, 1234.5]\n>>> del a[2:4]\n>>> a\n[1, 66.25, 1234.5]\n>>> del a[:]\n>>> a\n[]\n```python\n\ndel can also be used to delete entire variables:\n\n```python\n>>> del a\n```python\n\nReferencing the name a hereafter is an error (at least until another value\nis assigned to it).  We\u00e2\u0080\u0099ll find other uses for del later.\n\n## 5.3.Tuples and Sequences\u00c2\u00b6\n\nWe saw that lists and strings have many common properties, such as indexing and\nslicing operations.  They are two examples of sequence data types (see Sequence Types \u00e2\u0080\u0094 list, tuple, range ).  Since Python is an evolving language, other sequence data\ntypes may be added.  There is also another standard sequence data type: the tuple .\n\nA tuple consists of a number of values separated by commas, for instance:\n\n```python\n>>> t = 12345, 54321, 'hello!'\n>>> t[0]\n12345\n>>> t\n(12345, 54321, 'hello!')\n>>> # Tuples may be nested:\n>>> u = t, (1, 2, 3, 4, 5)\n>>> u\n((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))\n>>> # Tuples are immutable:\n>>> t[0] = 88888\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: 'tuple' object does not support item assignment\n>>> # but they can contain mutable objects:\n>>> v = ([1, 2, 3], [3, 2, 1])\n>>> v\n([1, 2, 3], [3, 2, 1])\n```python\n\nAs you see, on output tuples are always enclosed in parentheses, so that nested\ntuples are interpreted correctly; they may be input with or without surrounding\nparentheses, although often parentheses are necessary anyway (if the tuple is\npart of a larger expression).  It is not possible to assign to the individual\nitems of a tuple, however it is possible to create tuples which contain mutable\nobjects, such as lists.\n\nThough tuples may seem similar to lists, they are often used in different\nsituations and for different purposes.\nTuples are immutable , and usually contain a heterogeneous sequence of\nelements that are accessed via unpacking (see later in this section) or indexing\n(or even by attribute in the case of namedtuples ).\nLists are mutable , and their elements are usually homogeneous and are\naccessed by iterating over the list.\n\nA special problem is the construction of tuples containing 0 or 1 items: the\nsyntax has some extra quirks to accommodate these.  Empty tuples are constructed\nby an empty pair of parentheses; a tuple with one item is constructed by\nfollowing a value with a comma (it is not sufficient to enclose a single value\nin parentheses). Ugly, but effective.  For example:\n\n```python\n>>> empty = ()\n>>> singleton = 'hello',    # <-- note trailing comma\n>>> len(empty)\n0\n>>> len(singleton)\n1\n>>> singleton\n('hello',)\n```python\n\nThe statement t = 12345, 54321, 'hello!' is an example of tuple packing :\nthe values 12345 , 54321 and 'hello!' are packed together in a tuple.\nThe reverse operation is also possible:\n\n```python\n>>> x, y, z = t\n```python\n\nThis is called, appropriately enough, sequence unpacking and works for any\nsequence on the right-hand side.  Sequence unpacking requires that there are as\nmany variables on the left side of the equals sign as there are elements in the\nsequence.  Note that multiple assignment is really just a combination of tuple\npacking and sequence unpacking.\n\n## 5.4.Sets\u00c2\u00b6\n\nPython also includes a data type for sets .  A set is\nan unordered collection with no duplicate elements.  Basic uses include\nmembership testing and eliminating duplicate entries.  Set objects also\nsupport mathematical operations like union, intersection, difference, and\nsymmetric difference.\n\nCurly braces or the set() function can be used to create sets.  Note: to\ncreate an empty set you have to use set() , not {} ; the latter creates an\nempty dictionary, a data structure that we discuss in the next section.\n\nHere is a brief demonstration:\n\n```python\n>>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}\n>>> print(basket)                      # show that duplicates have been removed\n{'orange', 'banana', 'pear', 'apple'}\n>>> 'orange' in basket                 # fast membership testing\nTrue\n>>> 'crabgrass' in basket\nFalse\n\n>>> # Demonstrate set operations on unique letters from two words\n>>>\n>>> a = set('abracadabra')\n>>> b = set('alacazam')\n>>> a                                  # unique letters in a\n{'a', 'r', 'b', 'c', 'd'}\n>>> a - b                              # letters in a but not in b\n{'r', 'd', 'b'}\n>>> a | b                              # letters in a or b or both\n{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}\n>>> a & b                              # letters in both a and b\n{'a', 'c'}\n>>> a ^ b                              # letters in a or b but not both\n{'r', 'd', 'b', 'm', 'z', 'l'}\n```python\n\nSimilarly to list comprehensions , set comprehensions\nare also supported:\n\n```python\n>>> a = {x for x in 'abracadabra' if x not in 'abc'}\n>>> a\n{'r', 'd'}\n```python\n\n## 5.5.Dictionaries\u00c2\u00b6\n\nAnother useful data type built into Python is the dictionary (see Mapping Types \u00e2\u0080\u0094 dict ). Dictionaries are sometimes found in other languages as\n\u00e2\u0080\u009cassociative memories\u00e2\u0080\u009d or \u00e2\u0080\u009cassociative arrays\u00e2\u0080\u009d.  Unlike sequences, which are\nindexed by a range of numbers, dictionaries are indexed by keys , which can be\nany immutable type; strings and numbers can always be keys.  Tuples can be used\nas keys if they contain only strings, numbers, or tuples; if a tuple contains\nany mutable object either directly or indirectly, it cannot be used as a key.\nYou can\u00e2\u0080\u0099t use lists as keys, since lists can be modified in place using index\nassignments, slice assignments, or methods like append() and extend() .\n\nIt is best to think of a dictionary as a set of key: value pairs,\nwith the requirement that the keys are unique (within one dictionary). A pair of\nbraces creates an empty dictionary: {} . Placing a comma-separated list of\nkey:value pairs within the braces adds initial key:value pairs to the\ndictionary; this is also the way dictionaries are written on output.\n\nThe main operations on a dictionary are storing a value with some key and\nextracting the value given the key.  It is also possible to delete a key:value\npair with del . If you store using a key that is already in use, the old\nvalue associated with that key is forgotten.\n\nExtracting a value for a non-existent key by subscripting ( d[key] ) raises a KeyError . To avoid getting this error when trying to access a possibly\nnon-existent key, use the get() method instead, which returns None (or a specified default value) if the key is not in the dictionary.\n\nPerforming list(d) on a dictionary returns a list of all the keys\nused in the dictionary, in insertion order (if you want it sorted, just use sorted(d) instead). To check whether a single key is in the\ndictionary, use the in keyword.\n\nHere is a small example using a dictionary:\n\n```python\n>>> tel = {'jack': 4098, 'sape': 4139}\n>>> tel['guido'] = 4127\n>>> tel\n{'jack': 4098, 'sape': 4139, 'guido': 4127}\n>>> tel['jack']\n4098\n>>> tel['irv']\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nKeyError: 'irv'\n>>> print(tel.get('irv'))\nNone\n>>> del tel['sape']\n>>> tel['irv'] = 4127\n>>> tel\n{'jack': 4098, 'guido': 4127, 'irv': 4127}\n>>> list(tel)\n['jack', 'guido', 'irv']\n>>> sorted(tel)\n['guido', 'irv', 'jack']\n>>> 'guido' in tel\nTrue\n>>> 'jack' not in tel\nFalse\n```python\n\nThe dict() constructor builds dictionaries directly from sequences of\nkey-value pairs:\n\n```python\n>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n{'sape': 4139, 'guido': 4127, 'jack': 4098}\n```python\n\nIn addition, dict comprehensions can be used to create dictionaries from\narbitrary key and value expressions:\n\n```python\n>>> {x: x**2 for x in (2, 4, 6)}\n{2: 4, 4: 16, 6: 36}\n```python\n\nWhen the keys are simple strings, it is sometimes easier to specify pairs using\nkeyword arguments:\n\n```python\n>>> dict(sape=4139, guido=4127, jack=4098)\n{'sape': 4139, 'guido': 4127, 'jack': 4098}\n```python\n\n## 5.6.Looping Techniques\u00c2\u00b6\n\nWhen looping through dictionaries, the key and corresponding value can be\nretrieved at the same time using the items() method.\n\n```python\n>>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}\n>>> for k, v in knights.items():\n...     print(k, v)\n...\ngallahad the pure\nrobin the brave\n```python\n\nWhen looping through a sequence, the position index and corresponding value can\nbe retrieved at the same time using the enumerate() function.\n\n```python\n>>> for i, v in enumerate(['tic', 'tac', 'toe']):\n...     print(i, v)\n...\n0 tic\n1 tac\n2 toe\n```python\n\nTo loop over two or more sequences at the same time, the entries can be paired\nwith the zip() function.\n\n```python\n>>> questions = ['name', 'quest', 'favorite color']\n>>> answers = ['lancelot', 'the holy grail', 'blue']\n>>> for q, a in zip(questions, answers):\n...     print('What is your {0}?  It is {1}.'.format(q, a))\n...\nWhat is your name?  It is lancelot.\nWhat is your quest?  It is the holy grail.\nWhat is your favorite color?  It is blue.\n```python\n\nTo loop over a sequence in reverse, first specify the sequence in a forward\ndirection and then call the reversed() function.\n\n```python\n>>> for i in reversed(range(1, 10, 2)):\n...     print(i)\n...\n9\n7\n5\n3\n1\n```python\n\nTo loop over a sequence in sorted order, use the sorted() function which\nreturns a new sorted list while leaving the source unaltered.\n\n```python\n>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n>>> for i in sorted(basket):\n...     print(i)\n...\napple\napple\nbanana\norange\norange\npear\n```python\n\nUsing set() on a sequence eliminates duplicate elements. The use of sorted() in combination with set() over a sequence is an idiomatic\nway to loop over unique elements of the sequence in sorted order.\n\n```python\n>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n>>> for f in sorted(set(basket)):\n...     print(f)\n...\napple\nbanana\norange\npear\n```python\n\nIt is sometimes tempting to change a list while you are looping over it;\nhowever, it is often simpler and safer to create a new list instead.\n\n```python\n>>> import math\n>>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]\n>>> filtered_data = []\n>>> for value in raw_data:\n...     if not math.isnan(value):\n...         filtered_data.append(value)\n...\n>>> filtered_data\n[56.2, 51.7, 55.3, 52.5, 47.8]\n```python\n\n## 5.7.More on Conditions\u00c2\u00b6\n\nThe conditions used in while and if statements can contain any\noperators, not just comparisons.\n\nThe comparison operators in and not in are membership tests that\ndetermine whether a value is in (or not in) a container.  The operators is and is not compare whether two objects are really the same object.  All\ncomparison operators have the same priority, which is lower than that of all\nnumerical operators.\n\nComparisons can be chained.  For example, a < b == c tests whether a is\nless than b and moreover b equals c .\n\nComparisons may be combined using the Boolean operators and and or , and\nthe outcome of a comparison (or of any other Boolean expression) may be negated\nwith not .  These have lower priorities than comparison operators; between\nthem, not has the highest priority and or the lowest, so that A and not B or C is equivalent to (A and (not B)) or C . As always, parentheses\ncan be used to express the desired composition.\n\nThe Boolean operators and and or are so-called short-circuit operators: their arguments are evaluated from left to right, and evaluation\nstops as soon as the outcome is determined.  For example, if A and C are\ntrue but B is false, A and B and C does not evaluate the expression C .  When used as a general value and not as a Boolean, the return value of a\nshort-circuit operator is the last evaluated argument.\n\nIt is possible to assign the result of a comparison or other Boolean expression\nto a variable.  For example,\n\n```python\n>>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'\n>>> non_null = string1 or string2 or string3\n>>> non_null\n'Trondheim'\n```python\n\nNote that in Python, unlike C, assignment inside expressions must be done\nexplicitly with the walrus operator := .\nThis avoids a common class of problems encountered in C programs: typing = in an expression when == was intended.\n\n## 5.8.Comparing Sequences and Other Types\u00c2\u00b6\n\nSequence objects typically may be compared to other objects with the same sequence\ntype. The comparison uses lexicographical ordering: first the first two\nitems are compared, and if they differ this determines the outcome of the\ncomparison; if they are equal, the next two items are compared, and so on, until\neither sequence is exhausted. If two items to be compared are themselves\nsequences of the same type, the lexicographical comparison is carried out\nrecursively.  If all items of two sequences compare equal, the sequences are\nconsidered equal. If one sequence is an initial sub-sequence of the other, the\nshorter sequence is the smaller (lesser) one.  Lexicographical ordering for\nstrings uses the Unicode code point number to order individual characters.\nSome examples of comparisons between sequences of the same type:\n\n```python\n(1, 2, 3)              < (1, 2, 4)\n[1, 2, 3]              < [1, 2, 4]\n'ABC' < 'C' < 'Pascal' < 'Python'\n(1, 2, 3, 4)           < (1, 2, 4)\n(1, 2)                 < (1, 2, -1)\n(1, 2, 3)             == (1.0, 2.0, 3.0)\n(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)\n```python\n\nNote that comparing objects of different types with < or > is legal\nprovided that the objects have appropriate comparison methods.  For example,\nmixed numeric types are compared according to their numeric value, so 0 equals\n0.0, etc.  Otherwise, rather than providing an arbitrary ordering, the\ninterpreter will raise a TypeError exception.\n\nFootnotes",
      "difficulty": "intro",
      "doc_id": "doc-5-data-structures-5b0746c54d",
      "provenance": {
        "author": "",
        "date": "",
        "license": "PSF Documentation License",
        "source_file": "data/corpus_raw/3_tutorial_datastructures_html_d15070.json",
        "url": "https://docs.python.org/3/tutorial/datastructures.html"
      },
      "title": "5.Data Structures\u00c2\u00b6",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "data_structures",
        "dictionaries",
        "sets"
      ],
      "content": "## 5DICTIONARIES AND STRUCTURING DATA\n\nIn this chapter, I will cover the dictionary data type, which provides a flexible way to access and organize data. Then, combining dictionaries with your knowledge of lists from the previous chapter, you\u2019ll learn how to create a data structure to model a tic-tac-toe board.\n\n### The Dictionary Data Type\n\nLike a list, a dictionary is a mutable collection of many values. But unlike indexes for lists, indexes for dictionaries can use many different data types, not just integers. Indexes for dictionaries are called keys , and a key with its associated value is called a key-value pair .\n\nIn code, a dictionary is typed with braces, {} . Enter the following into the interactive shell:\n\n>>> myCat = {'size': 'fat', 'color': 'gray', 'disposition': 'loud'}\n\nThis assigns a dictionary to the myCat variable. This dictionary\u2019s keys are 'size' , 'color' , and 'disposition' . The values for these keys are 'fat' , 'gray' , and 'loud' , respectively. You can access these values through their keys:\n\n>>> myCat['size'] 'fat' >>> 'My cat has ' + myCat['color'] + ' fur.' 'My cat has gray fur.'\n\nDictionaries can still use integer values as keys, just like lists use integers for indexes, but they do not have to start at 0 and can be any number.\n\n>>> spam = {12345: 'Luggage Combination', 42: 'The Answer'}\n\n#### Dictionaries vs. Lists\n\nUnlike lists, items in dictionaries are unordered. The first item in a list named spam would be spam[0] . But there is no \u201cfirst\u201d item in a dictionary. While the order of items matters for determining whether two lists are the same, it does not matter in what order the key-value pairs are typed in a dictionary. Enter the following into the interactive shell:\n\n>>> spam = ['cats', 'dogs', 'moose'] >>> bacon = ['dogs', 'moose', 'cats'] >>> spam == bacon False >>> eggs = {'name': 'Zophie', 'species': 'cat', 'age': '8'} >>> ham = {'species': 'cat', 'age': '8', 'name': 'Zophie'} >>> eggs == ham True\n\nBecause dictionaries are not ordered, they can\u2019t be sliced like lists.\n\nTrying to access a key that does not exist in a dictionary will result in a KeyError error message, much like a list\u2019s \u201cout-of-range\u201d IndexError error message. Enter the following into the interactive shell, and notice the error message that shows up because there is no 'color' key:\n\n>>> spam = {'name': 'Zophie', 'age': 7} >>> spam['color'] Traceback (most recent call last): File \"<pyshell#1>\", line 1, in <module> spam['color'] KeyError: 'color'\n\nThough dictionaries are not ordered, the fact that you can have arbitrary values for the keys allows you to organize your data in powerful ways. Say you wanted your program to store data about your friends\u2019 birthdays. You can use a dictionary with the names as keys and the birthdays as values. Open a new file editor window and enter the following code. Save it as birthdays.py .\n\n\u278a birthdays = {'Alice': 'Apr 1', 'Bob': 'Dec 12', 'Carol': 'Mar 4'} while True: print('Enter a name: (blank to quit)') name = input() if name == '': break \u278b if name in birthdays: \u278c print(birthdays[name] + ' is the birthday of ' + name) else: print('I do not have birthday information for ' + name) print('What is their birthday?') bday = input() \u278d birthdays[name] = bday print('Birthday database updated.')\n\nYou can view the execution of this program at https://autbor.com/bdaydb . You create an initial dictionary and store it in birthdays \u278a . You can see if the entered name exists as a key in the dictionary with the in keyword \u278b , just as you did for lists. If the name is in the dictionary, you access the associated value using square brackets \u278c ; if not, you can add it using the same square bracket syntax combined with the assignment operator \u278d .\n\nWhen you run this program, it will look like this:\n\nEnter a name: (blank to quit) Alice Apr 1 is the birthday of Alice Enter a name: (blank to quit) Eve I do not have birthday information for Eve What is their birthday? Dec 5 Birthday database updated. Enter a name: (blank to quit) Eve Dec 5 is the birthday of Eve Enter a name: (blank to quit)\n\nOf course, all the data you enter in this program is forgotten when the program terminates. You\u2019ll learn how to save data to files on the hard drive in Chapter 9.\n\nORDERED DICTIONARIES IN PYTHON 3.7\n\nWhile they\u2019re still not ordered and have no \u201cfirst\u201d key-value pair, dictionaries in Python 3.7 and later will remember the insertion order of their key-value pairs if you create a sequence value from them. For example, notice the order of items in the lists made from the eggs and ham dictionaries matches the order in which they were entered:\n\n>>> eggs = {'name': 'Zophie', 'species': 'cat', 'age': '8'} >>> list(eggs) ['name', 'species', 'age'] >>> ham = {'species': 'cat', 'age': '8', 'name': 'Zophie'} >>> list(ham) ['species', 'age', 'name']\n\nThe dictionaries are still unordered, as you can\u2019t access items in them using integer indexes like eggs[0] or ham[2] . You shouldn\u2019t rely on this behavior, as dictionaries in older versions of Python don\u2019t remember the insertion order of key-value pairs. For example, notice how the list doesn\u2019t match the insertion order of the dictionary\u2019s key-value pairs when I run this code in Python 3.5:\n\n>>> spam = {} >>> spam['first key'] = 'value' >>> spam['second key'] = 'value' >>> spam['third key'] = 'value' >>> list(spam) ['first key', 'third key', 'second key']\n\n#### The keys(), values(), and items() Methods\n\nThere are three dictionary methods that will return list-like values of the dictionary\u2019s keys, values, or both keys and values: keys() , values() , and items() . The values returned by these methods are not true lists: they cannot be modified and do not have an append() method. But these data types ( dict_keys , dict_values , and dict_items , respectively) can be used in for loops. To see how these methods work, enter the following into the interactive shell:\n\n>>> spam = {'color': 'red', 'age': 42} >>> for v in spam.values(): ... print(v) red 42\n\nHere, a for loop iterates over each of the values in the spam dictionary. A for loop can also iterate over the keys or both keys and values:\n\n>>> for k in spam.keys(): ... print(k) color age >>> for i in spam.items(): ... print(i) ('color', 'red') ('age', 42)\n\nWhen you use the keys() , values() , and items() methods, a for loop can iterate over the keys, values, or key-value pairs in a dictionary, respectively. Notice that the values in the dict_items value returned by the items() method are tuples of the key and value.\n\nIf you want a true list from one of these methods, pass its list-like return value to the list() function. Enter the following into the interactive shell:\n\n>>> spam = {'color': 'red', 'age': 42} >>> spam.keys() dict_keys(['color', 'age']) >>> list(spam.keys()) ['color', 'age']\n\nThe list(spam.keys()) line takes the dict_keys value returned from keys() and passes it to list() , which then returns a list value of ['color', 'age'] .\n\nYou can also use the multiple assignment trick in a for loop to assign the key and value to separate variables. Enter the following into the interactive shell:\n\n>>> spam = {'color': 'red', 'age': 42} >>> for k, v in spam.items(): ...\u00a0\u00a0\u00a0\u00a0\u00a0print('Key: ' + k + ' Value: ' + str(v)) Key: age Value: 42 Key: color Value: red\n\n#### Checking Whether a Key or Value Exists in a Dictionary\n\nRecall from the previous chapter that the in and not in operators can check whether a value exists in a list. You can also use these operators to see whether a certain key or value exists in a dictionary. Enter the following into the interactive shell:\n\n>>> spam = {'name': 'Zophie', 'age': 7} >>> 'name' in spam.keys() True >>> 'Zophie' in spam.values() True >>> 'color' in spam.keys() False >>> 'color' not in spam.keys() True >>> 'color' in spam False\n\nIn the previous example, notice that 'color' in spam is essentially a shorter version of writing 'color' in spam.keys() . This is always the case: if you ever want to check whether a value is (or isn\u2019t) a key in the dictionary, you can simply use the in (or not in ) keyword with the dictionary value itself.\n\n#### The get() Method\n\nIt\u2019s tedious to check whether a key exists in a dictionary before accessing that key\u2019s value. Fortunately, dictionaries have a get() method that takes two arguments: the key of the value to retrieve and a fallback value to return if that key does not exist.\n\nEnter the following into the interactive shell:\n\n>>> picnicItems = {'apples': 5, 'cups': 2} >>> 'I am bringing ' + str(picnicItems.get('cups', 0)) + ' cups.' 'I am bringing 2 cups.' >>> 'I am bringing ' + str(picnicItems.get('eggs', 0)) + ' eggs.' 'I am bringing 0 eggs.'\n\nBecause there is no 'eggs' key in the picnicItems dictionary, the default value 0 is returned by the get() method. Without using get() , the code would have caused an error message, such as in the following example:\n\n>>> picnicItems = {'apples': 5, 'cups': 2} >>> 'I am bringing ' + str(picnicItems['eggs']) + ' eggs.' Traceback (most recent call last): File \"<pyshell#34>\", line 1, in <module> 'I am bringing ' + str(picnicItems['eggs']) + ' eggs.' KeyError: 'eggs'\n\n#### The setdefault() Method\n\nYou\u2019ll often have to set a value in a dictionary for a certain key only if that key does not already have a value. The code looks something like this:\n\nspam = {'name': 'Pooka', 'age': 5} if 'color' not in spam: spam['color'] = 'black'\n\nThe setdefault() method offers a way to do this in one line of code. The first argument passed to the method is the key to check for, and the second argument is the value to set at that key if the key does not exist. If the key does exist, the setdefault() method returns the key\u2019s value. Enter the following into the interactive shell:\n\n>>> spam = {'name': 'Pooka', 'age': 5} >>> spam.setdefault('color', 'black') 'black' >>> spam {'color': 'black', 'age': 5, 'name': 'Pooka'} >>> spam.setdefault('color', 'white') 'black' >>> spam {'color': 'black', 'age': 5, 'name': 'Pooka'}\n\nThe first time setdefault() is called, the dictionary in spam changes to {'color': 'black', 'age': 5, 'name': 'Pooka'} . The method returns the value 'black' because this is now the value set for the key 'color' . When spam.setdefault('color', 'white') is called next, the value for that key is not changed to 'white' , because spam already has a key named 'color' .\n\nThe setdefault() method is a nice shortcut to ensure that a key exists. Here is a short program that counts the number of occurrences of each letter in a string. Open the file editor window and enter the following code, saving it as characterCount.py :\n\nmessage = 'It was a bright cold day in April, and the clocks were striking thirteen.' count = {} for character in message: \u278a count.setdefault(character, 0) \u278b count[character] = count[character] + 1 print(count)\n\nYou can view the execution of this program at https://autbor.com/setdefault . The program loops over each character in the message variable\u2019s string, counting how often each character appears. The setdefault() method call \u278a ensures that the key is in the count dictionary (with a default value of 0 ) so the program doesn\u2019t throw a KeyError error when count[character] = count[character] + 1 is executed \u278b . When you run this program, the output will look like this:\n\n{' ': 13, ',': 1, '.': 1, 'A': 1, 'I': 1, 'a': 4, 'c': 3, 'b': 1, 'e': 5, 'd': 3, 'g': 2, 'i': 6, 'h': 3, 'k': 2, 'l': 3, 'o': 2, 'n': 4, 'p': 1, 's': 3, 'r': 5, 't': 6, 'w': 2, 'y': 1}\n\nFrom the output, you can see that the lowercase letter c appears 3 times, the space character appears 13 times, and the uppercase letter A appears 1 time. This program will work no matter what string is inside the message variable, even if the string is millions of characters long!\n\n### Pretty Printing\n\nIf you import the pprint module into your programs, you\u2019ll have access to the pprint() and pformat() functions that will \u201cpretty print\u201d a dictionary\u2019s values. This is helpful when you want a cleaner display of the items in a dictionary than what print() provides. Modify the previous characterCount.py program and save it as prettyCharacterCount.py .\n\nimport pprint message = 'It was a bright cold day in April, and the clocks were striking thirteen.' count = {} for character in message: count.setdefault(character, 0) count[character] = count[character] + 1 pprint.pprint (count)\n\nYou can view the execution of this program at https://autbor.com/pprint/ . This time, when the program is run, the output looks much cleaner, with the keys sorted.\n\n{' ': 13, ',': 1, '.': 1, 'A': 1, 'I': 1, --snip-- 't': 6, 'w': 2, 'y': 1}\n\nThe pprint.pprint() function is especially helpful when the dictionary itself contains nested lists or dictionaries.\n\nIf you want to obtain the prettified text as a string value instead of displaying it on the screen, call pprint.pformat() instead. These two lines are equivalent to each other:\n\npprint.pprint(someDictionaryValue) print(pprint.pformat(someDictionaryValue))\n\n### Using Data Structures to Model Real-World Things\n\nEven before the internet, it was possible to play a game of chess with someone on the other side of the world. Each player would set up a chessboard at their home and then take turns mailing a postcard to each other describing each move. To do this, the players needed a way to unambiguously describe the state of the board and their moves.\n\nIn algebraic chess notation , the spaces on the chessboard are identified by a number and letter coordinate, as in Figure 5-1.\n\nFigure 5-1: The coordinates of a chessboard in algebraic chess notation\n\nThe chess pieces are identified by letters: K for king, Q for queen, R for rook, B for bishop, and N for knight. Describing a move uses the letter of the piece and the coordinates of its destination. A pair of these moves describes what happens in a single turn (with white going first); for instance, the notation 2. Nf3 Nc6 indicates that white moved a knight to f3 and black moved a knight to c6 on the second turn of the game.\n\nThere\u2019s a bit more to algebraic notation than this, but the point is that you can unambiguously describe a game of chess without needing to be in front of a chessboard. Your opponent can even be on the other side of the world! In fact, you don\u2019t even need a physical chess set if you have a good memory: you can just read the mailed chess moves and update boards you have in your imagination.\n\nComputers have good memories. A program on a modern computer can easily store billions of strings like '2. Nf3 Nc6' . This is how computers can play chess without having a physical chessboard. They model data to represent a chessboard, and you can write code to work with this model.\n\nThis is where lists and dictionaries can come in. For example, the dictionary {'1h': 'bking', '6c': 'wqueen', '2g': 'bbishop', '5h': 'bqueen', '3e': 'wking'} could represent the chess board in Figure 5-2.\n\nFigure 5-2: A chess board modeled by the dictionary '1h': 'bking', '6c': 'wqueen', '2g': 'bbishop', '5h': 'bqueen', '3e': 'wking'}\n\nBut for another example, you\u2019ll use a game that\u2019s a little simpler than chess: tic-tac-toe.\n\n#### A Tic-Tac-Toe Board\n\nA tic-tac-toe board looks like a large hash symbol (#) with nine slots that can each contain an X , an O , or a blank. To represent the board with a dictionary, you can assign each slot a string-value key, as shown in Figure 5-3.\n\nFigure 5-3: The slots of a tic-tac-toe board with their corresponding keys\n\nYou can use string values to represent what\u2019s in each slot on the board: 'X' , 'O' , or ' ' (a space). Thus, you\u2019ll need to store nine strings. You can use a dictionary of values for this. The string value with the key 'top-R' can represent the top-right corner, the string value with the key 'low-L' can represent the bottom-left corner, the string value with the key 'mid-M' can represent the middle, and so on.\n\nThis dictionary is a data structure that represents a tic-tac-toe board. Store this board-as-a-dictionary in a variable named theBoard . Open a new file editor window, and enter the following source code, saving it as ticTacToe.py :\n\ntheBoard = {'top-L': ' ', 'top-M': ' ', 'top-R': ' ', 'mid-L': ' ', 'mid-M': ' ', 'mid-R': ' ', 'low-L': ' ', 'low-M': ' ', 'low-R': ' '}\n\nThe data structure stored in the theBoard variable represents the tic-tac-toe board in Figure 5-4.\n\nFigure 5-4: An empty tic-tac-toe board\n\nSince the value for every key in theBoard is a single-space string, this dictionary represents a completely clear board. If player X went first and chose the middle space, you could represent that board with this dictionary:\n\ntheBoard = {'top-L': ' ', 'top-M': ' ', 'top-R': ' ', 'mid-L': ' ', 'mid-M': 'X', 'mid-R': ' ', 'low-L': ' ', 'low-M': ' ', 'low-R': ' '}\n\nThe data structure in theBoard now represents the tic-tac-toe board in Figure 5-5.\n\nFigure 5-5: The first move\n\nA board where player O has won by placing O s across the top might look like this:\n\ntheBoard = {'top-L': 'O', 'top-M': 'O', 'top-R': 'O', 'mid-L': 'X', 'mid-M': 'X', 'mid-R': ' ', 'low-L': ' ', 'low-M': ' ', 'low-R': 'X'}\n\nThe data structure in theBoard now represents the tic-tac-toe board in Figure 5-6.\n\nFigure 5-6: Player O wins.\n\nOf course, the player sees only what is printed to the screen, not the contents of variables. Let\u2019s create a function to print the board dictionary onto the screen. Make the following addition to ticTacToe.py (new code is in bold):\n\ntheBoard = {'top-L': ' ', 'top-M': ' ', 'top-R': ' ', 'mid-L': ' ', 'mid-M': ' ', 'mid-R': ' ', 'low-L': ' ', 'low-M': ' ', 'low-R': ' '} def printBoard(board): print(board['top-L'] + '|' + board['top-M'] + '|' + board['top-R']) print('-+-+-') print(board['mid-L'] + '|' + board['mid-M'] + '|' + board['mid-R']) print('-+-+-') print(board['low-L'] + '|' + board['low-M'] + '|' + board['low-R']) printBoard(theBoard)\n\nYou can view the execution of this program at https://autbor.com/tictactoe1/ . When you run this program, printBoard() will print out a blank tic-tac-toe board.\n\n| | -+-+- | | -+-+- | |\n\nThe printBoard() function can handle any tic-tac-toe data structure you pass it. Try changing the code to the following:\n\ntheBoard = {'top-L': 'O', 'top-M': 'O', 'top-R': 'O', 'mid-L': 'X', 'mid-M': 'X', 'mid-R': ' ', 'low-L': ' ', 'low-M': ' ', 'low-R': 'X'} def printBoard(board): print(board['top-L'] + '|' + board['top-M'] + '|' + board['top-R']) print('-+-+-') print(board['mid-L'] + '|' + board['mid-M'] + '|' + board['mid-R']) print('-+-+-') print(board['low-L'] + '|' + board['low-M'] + '|' + board['low-R']) printBoard(theBoard)\n\nYou can view the execution of this program at https://autbor.com/tictactoe2/ . Now when you run this program, the new board will be printed to the screen.\n\nO|O|O -+-+- X|X| -+-+- | |X\n\nBecause you created a data structure to represent a tic-tac-toe board and wrote code in printBoard() to interpret that data structure, you now have a program that \u201cmodels\u201d the tic-tac-toe board. You could have organized your data structure differently (for example, using keys like 'TOP-LEFT' instead of 'top-L' ), but as long as the code works with your data structures, you will have a correctly working program.\n\nFor example, the printBoard() function expects the tic-tac-toe data structure to be a dictionary with keys for all nine slots. If the dictionary you passed was missing, say, the 'mid-L' key, your program would no longer work.\n\nO|O|O -+-+- Traceback (most recent call last): File \"ticTacToe.py\", line 10, in <module> printBoard(theBoard) File \"ticTacToe.py\", line 6, in printBoard print(board['mid-L'] + '|' + board['mid-M'] + '|' + board['mid-R']) KeyError: 'mid-L'\n\nNow let\u2019s add code that allows the players to enter their moves. Modify the ticTacToe.py program to look like this:\n\ntheBoard = {'top-L': ' ', 'top-M': ' ', 'top-R': ' ', 'mid-L': ' ', 'mid-M': ' ', 'mid-R': ' ', 'low-L': ' ', 'low-M': ' ', 'low-R': ' '} def printBoard(board): print(board['top-L'] + '|' + board['top-M'] + '|' + board['top-R']) print('-+-+-') print(board['mid-L'] + '|' + board['mid-M'] + '|' + board['mid-R']) print('-+-+-') print(board['low-L'] + '|' + board['low-M'] + '|' + board['low-R']) turn = 'X' for i in range(9): \u278a printBoard(theBoard) print('Turn for ' + turn + '. Move on which space?') \u278b move = input() \u278c theBoard[move] = turn \u278d if turn == 'X': turn = 'O' else: turn = 'X' printBoard(theBoard)\n\nYou can view the execution of this program at https://autbor.com/tictactoe3/ . The new code prints out the board at the start of each new turn \u278a , gets the active player\u2019s move \u278b , updates the game board accordingly \u278c , and then swaps the active player \u278d before moving on to the next turn.\n\nWhen you run this program, it will look something like this:\n\n| | -+-+- | | -+-+- | | Turn for X. Move on which space? mid-M | | -+-+- |X| -+-+- | | --snip-- O|O|X -+-+- X|X|O -+-+- O| |X Turn for X. Move on which space? low-M O|O|X -+-+- X|X|O -+-+- O|X|X\n\nThis isn\u2019t a complete tic-tac-toe game\u2014for instance, it doesn\u2019t ever check whether a player has won\u2014but it\u2019s enough to see how data structures can be used in programs.\n\nNOTE\n\nIf you are curious, the source code for a complete tic-tac-toe program is described in the resources available from https://nostarch.com/automatestuff2/ .\n\n#### Nested Dictionaries and Lists\n\nModeling a tic-tac-toe board was fairly simple: the board needed only a single dictionary value with nine key-value pairs. As you model more complicated things, you may find you need dictionaries and lists that contain other dictionaries and lists. Lists are useful to contain an ordered series of values, and dictionaries are useful for associating keys with values. For example, here\u2019s a program that uses a dictionary that contains other dictionaries of what items guests are bringing to a picnic. The totalBrought() function can read this data structure and calculate the total number of an item being brought by all the guests.\n\nallGuests = {'Alice': {'apples': 5, 'pretzels': 12}, 'Bob': {'ham sandwiches': 3, 'apples': 2}, 'Carol': {'cups': 3, 'apple pies': 1}} def totalBrought(guests, item): numBrought = 0 \u278a for k, v in guests.items(): \u278b numBrought = numBrought + v.get(item, 0) return numBrought print('Number of things being brought:') print(' - Apples\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0' + str(totalBrought(allGuests, 'apples'))) print(' - Cups\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0' + str(totalBrought(allGuests, 'cups'))) print(' - Cakes\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0' + str(totalBrought(allGuests, 'cakes'))) print(' - Ham Sandwiches ' + str(totalBrought(allGuests, 'ham sandwiches'))) print(' - Apple Pies\u00a0\u00a0\u00a0\u00a0\u00a0' + str(totalBrought(allGuests, 'apple pies')))\n\nYou can view the execution of this program at https://autbor.com/guestpicnic/ . Inside the totalBrought() function, the for loop iterates over the key-value pairs in guests \u278a . Inside the loop, the string of the guest\u2019s name is assigned to k , and the dictionary of picnic items they\u2019re bringing is assigned to v . If the item parameter exists as a key in this dictionary, its value (the quantity) is added to numBrought \u278b . If it does not exist as a key, the get() method returns 0 to be added to numBrought .\n\nThe output of this program looks like this:\n\nNumber of things being brought: - Apples 7 - Cups 3 - Cakes 0 - Ham Sandwiches 3 - Apple Pies 1\n\nThis may seem like such a simple thing to model that you wouldn\u2019t need to bother with writing a program to do it. But realize that this same totalBrought() function could easily handle a dictionary that contains thousands of guests, each bringing thousands of different picnic items. Then having this information in a data structure along with the totalBrought() function would save you a lot of time!\n\nYou can model things with data structures in whatever way you like, as long as the rest of the code in your program can work with the data model correctly. When you first begin programming, don\u2019t worry so much about the \u201cright\u201d way to model data. As you gain more experience, you may come up with more efficient models, but the important thing is that the data model works for your program\u2019s needs.\n\n### Summary\n\nYou learned all about dictionaries in this chapter. Lists and dictionaries are values that can contain multiple values, including other lists and dictionaries. Dictionaries are useful because you can map one item (the key) to another (the value), as opposed to lists, which simply contain a series of values in order. Values inside a dictionary are accessed using square brackets just as with lists. Instead of an integer index, dictionaries can have keys of a variety of data types: integers, floats, strings, or tuples. By organizing a program\u2019s values into data structures, you can create representations of real-world objects. You saw an example of this with a tic-tac-toe board.\n\n### Practice Questions\n\n1. What does the code for an empty dictionary look like?\n\n2. What does a dictionary value with a key 'foo' and a value 42 look like?\n\n3. What is the main difference between a dictionary and a list?\n\n4. What happens if you try to access spam['foo'] if spam is {'bar': 100} ?\n\n5. If a dictionary is stored in spam , what is the difference between the expressions 'cat' in spam and 'cat' in spam.keys() ?\n\n6. If a dictionary is stored in spam , what is the difference between the expressions 'cat' in spam and 'cat' in spam.values() ?\n\n7. What is a shortcut for the following code?\n\nif 'color' not in spam: spam['color'] = 'black'\n\n8. What module and function can be used to \u201cpretty print\u201d dictionary values?\n\n### Practice Projects\n\nFor practice, write programs to do the following tasks.\n\n#### Chess Dictionary Validator\n\nIn this chapter, we used the dictionary value {'1h': 'bking', '6c': 'wqueen', '2g': 'bbishop', '5h': 'bqueen', '3e': 'wking'} to represent a chess board. Write a function named isValidChessBoard() that takes a dictionary argument and returns True or False depending on if the board is valid.\n\nA valid board will have exactly one black king and exactly one white king. Each player can only have at most 16 pieces, at most 8 pawns, and all pieces must be on a valid space from '1a' to '8h'; that is, a piece can\u2019t be on space '9z' . The piece names begin with either a 'w' or 'b' to represent white or black, followed by 'pawn' , 'knight' , 'bishop' , 'rook' , 'queen' , or 'king' . This function should detect when a bug has resulted in an improper chess board.\n\n#### Fantasy Game Inventory\n\nYou are creating a fantasy video game. The data structure to model the player\u2019s inventory will be a dictionary where the keys are string values describing the item in the inventory and the value is an integer value detailing how many of that item the player has. For example, the dictionary value {'rope': 1, 'torch': 6, 'gold coin': 42, 'dagger': 1, 'arrow': 12} means the player has 1 rope, 6 torches, 42 gold coins, and so on.\n\nWrite a function named displayInventory() that would take any possible \u201cinventory\u201d and display it like the following:\n\nInventory: 12 arrow 42 gold coin 1 rope 6 torch 1 dagger Total number of items: 62\n\nHint: You can use a for loop to loop through all the keys in a dictionary.\n\n# inventory.py stuff = {'rope': 1, 'torch': 6, 'gold coin': 42, 'dagger': 1, 'arrow': 12} def displayInventory(inventory): print(\"Inventory:\") item_total = 0 for k, v in inventory.items(): # FILL THIS PART IN print(\"Total number of items: \" + str(item_total)) displayInventory(stuff)\n\n#### List to Dictionary Function for Fantasy Game Inventory\n\nImagine that a vanquished dragon\u2019s loot is represented as a list of strings like this:\n\ndragonLoot = ['gold coin', 'dagger', 'gold coin', 'gold coin', 'ruby']\n\nWrite a function named addToInventory(inventory, addedItems) , where the inventory parameter is a dictionary representing the player\u2019s inventory (like in the previous project) and the addedItems parameter is a list like dragonLoot . The addToInventory() function should return a dictionary that represents the updated inventory. Note that the addedItems list can contain multiples of the same item. Your code could look something like this:\n\ndef addToInventory(inventory, addedItems): # your code goes here inv = {'gold coin': 42, 'rope': 1} dragonLoot = ['gold coin', 'dagger', 'gold coin', 'gold coin', 'ruby'] inv = addToInventory(inv, dragonLoot) displayInventory(inv)\n\nThe previous program (with your displayInventory() function from the previous project) would output the following:\n\nInventory: 45 gold coin 1 rope 1 ruby 1 dagger Total number of items: 48",
      "difficulty": "intro",
      "doc_id": "doc-5dictionaries-and-structuring-data-52e7d636e1",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-NC-SA 3.0",
        "source_file": "data/corpus_raw/scraped/2e_chapter5_e29be8.json",
        "url": "https://automatetheboringstuff.com/2e/chapter5/"
      },
      "title": "5DICTIONARIES AND STRUCTURING DATA",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "imports",
        "modules",
        "scope"
      ],
      "content": "# 6.Modules\u00c2\u00b6\n\nIf you quit from the Python interpreter and enter it again, the definitions you\nhave made (functions and variables) are lost. Therefore, if you want to write a\nsomewhat longer program, you are better off using a text editor to prepare the\ninput for the interpreter and running it with that file as input instead.  This\nis known as creating a script .  As your program gets longer, you may want to\nsplit it into several files for easier maintenance.  You may also want to use a\nhandy function that you\u00e2\u0080\u0099ve written in several programs without copying its\ndefinition into each program.\n\nTo support this, Python has a way to put definitions in a file and use them in a\nscript or in an interactive instance of the interpreter. Such a file is called a module ; definitions from a module can be imported into other modules or into\nthe main module (the collection of variables that you have access to in a\nscript executed at the top level and in calculator mode).\n\nA module is a file containing Python definitions and statements.  The file name\nis the module name with the suffix .py appended.  Within a module, the\nmodule\u00e2\u0080\u0099s name (as a string) is available as the value of the global variable __name__ .  For instance, use your favorite text editor to create a file\ncalled fibo.py in the current directory with the following contents:\n\n```python\n# Fibonacci numbers module\n\ndef fib(n):\n    \"\"\"Write Fibonacci series up to n.\"\"\"\n    a, b = 0, 1\n    while a < n:\n        print(a, end=' ')\n        a, b = b, a+b\n    print()\n\ndef fib2(n):\n    \"\"\"Return Fibonacci series up to n.\"\"\"\n    result = []\n    a, b = 0, 1\n    while a < n:\n        result.append(a)\n        a, b = b, a+b\n    return result\n```python\n\nNow enter the Python interpreter and import this module with the following\ncommand:\n\n```python\n>>> import fibo\n```python\n\nThis does not add the names of the functions defined in fibo directly to\nthe current namespace (see Python Scopes and Namespaces for more details);\nit only adds the module name fibo there. Using\nthe module name you can access the functions:\n\n```python\n>>> fibo.fib(1000)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987\n>>> fibo.fib2(100)\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n>>> fibo.__name__\n'fibo'\n```python\n\nIf you intend to use a function often you can assign it to a local name:\n\n```python\n>>> fib = fibo.fib\n>>> fib(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\n```python\n\n## 6.1.More on Modules\u00c2\u00b6\n\nA module can contain executable statements as well as function definitions.\nThese statements are intended to initialize the module. They are executed only\nthe first time the module name is encountered in an import statement. [ 1 ] (They are also run if the file is executed as a script.)\n\nEach module has its own private namespace, which is used as the global namespace\nby all functions defined in the module. Thus, the author of a module can\nuse global variables in the module without worrying about accidental clashes\nwith a user\u00e2\u0080\u0099s global variables. On the other hand, if you know what you are\ndoing you can touch a module\u00e2\u0080\u0099s global variables with the same notation used to\nrefer to its functions, modname.itemname .\n\nModules can import other modules.  It is customary but not required to place all import statements at the beginning of a module (or script, for that\nmatter).  The imported module names, if placed at the top level of a module\n(outside any functions or classes), are added to the module\u00e2\u0080\u0099s global namespace.\n\nThere is a variant of the import statement that imports names from a\nmodule directly into the importing module\u00e2\u0080\u0099s namespace.  For example:\n\n```python\n>>> from fibo import fib, fib2\n>>> fib(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\n```python\n\nThis does not introduce the module name from which the imports are taken in the\nlocal namespace (so in the example, fibo is not defined).\n\nThere is even a variant to import all names that a module defines:\n\n```python\n>>> from fibo import *\n>>> fib(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\n```python\n\nThis imports all names except those beginning with an underscore ( _ ).\nIn most cases Python programmers do not use this facility since it introduces\nan unknown set of names into the interpreter, possibly hiding some things\nyou have already defined.\n\nNote that in general the practice of importing * from a module or package is\nfrowned upon, since it often causes poorly readable code. However, it is okay to\nuse it to save typing in interactive sessions.\n\nIf the module name is followed by as , then the name\nfollowing as is bound directly to the imported module.\n\n```python\n>>> import fibo as fib\n>>> fib.fib(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\n```python\n\nThis is effectively importing the module in the same way that import fibo will do, with the only difference of it being available as fib .\n\nIt can also be used when utilising from with similar effects:\n\n```python\n>>> from fibo import fib as fibonacci\n>>> fibonacci(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\n```python\n\nNote\n\nFor efficiency reasons, each module is only imported once per interpreter\nsession.  Therefore, if you change your modules, you must restart the\ninterpreter \u00e2\u0080\u0093 or, if it\u00e2\u0080\u0099s just one module you want to test interactively,\nuse importlib.reload() , e.g. import importlib; importlib.reload(modulename) .\n\n### 6.1.1.Executing modules as scripts\u00c2\u00b6\n\nWhen you run a Python module with\n\n```python\npython fibo.py <arguments>\n```python\n\nthe code in the module will be executed, just as if you imported it, but with\nthe __name__ set to \"__main__\" .  That means that by adding this code at\nthe end of your module:\n\n```python\nif __name__ == \"__main__\":\n    import sys\n    fib(int(sys.argv[1]))\n```python\n\nyou can make the file usable as a script as well as an importable module,\nbecause the code that parses the command line only runs if the module is\nexecuted as the \u00e2\u0080\u009cmain\u00e2\u0080\u009d file:\n\n```python\n$ python fibo.py 50\n0 1 1 2 3 5 8 13 21 34\n```python\n\nIf the module is imported, the code is not run:\n\n```python\n>>> import fibo\n>>>\n```python\n\nThis is often used either to provide a convenient user interface to a module, or\nfor testing purposes (running the module as a script executes a test suite).\n\n### 6.1.2.The Module Search Path\u00c2\u00b6\n\nWhen a module named spam is imported, the interpreter first searches for\na built-in module with that name. These module names are listed in sys.builtin_module_names . If not found, it then searches for a file\nnamed spam.py in a list of directories given by the variable sys.path . sys.path is initialized from these locations:\n\n- The directory containing the input script (or the current directory when no\nfile is specified).\n- PYTHONPATH (a list of directory names, with the same syntax as the\nshell variable PATH ).\n- The installation-dependent default (by convention including a site-packages directory, handled by the site module).\n\nMore details are at The initialization of the sys.path module search path .\n\nNote\n\nOn file systems which support symlinks, the directory containing the input\nscript is calculated after the symlink is followed. In other words the\ndirectory containing the symlink is not added to the module search path.\n\nAfter initialization, Python programs can modify sys.path .  The\ndirectory containing the script being run is placed at the beginning of the\nsearch path, ahead of the standard library path. This means that scripts in that\ndirectory will be loaded instead of modules of the same name in the library\ndirectory. This is an error unless the replacement is intended.  See section Standard Modules for more information.\n\n### 6.1.3.\u00e2\u0080\u009cCompiled\u00e2\u0080\u009d Python files\u00c2\u00b6\n\nTo speed up loading modules, Python caches the compiled version of each module\nin the __pycache__ directory under the name module. version .pyc ,\nwhere the version encodes the format of the compiled file; it generally contains\nthe Python version number.  For example, in CPython release 3.3 the compiled\nversion of spam.py would be cached as __pycache__/spam.cpython-33.pyc .  This\nnaming convention allows compiled modules from different releases and different\nversions of Python to coexist.\n\nPython checks the modification date of the source against the compiled version\nto see if it\u00e2\u0080\u0099s out of date and needs to be recompiled.  This is a completely\nautomatic process.  Also, the compiled modules are platform-independent, so the\nsame library can be shared among systems with different architectures.\n\nPython does not check the cache in two circumstances.  First, it always\nrecompiles and does not store the result for the module that\u00e2\u0080\u0099s loaded directly\nfrom the command line.  Second, it does not check the cache if there is no\nsource module.  To support a non-source (compiled only) distribution, the\ncompiled module must be in the source directory, and there must not be a source\nmodule.\n\nSome tips for experts:\n\n- You can use the -O or -OO switches on the Python command\nto reduce the size of a compiled module.  The -O switch removes assert\nstatements, the -OO switch removes both assert statements and __doc__\nstrings.  Since some programs may rely on having these available, you should\nonly use this option if you know what you\u00e2\u0080\u0099re doing.  \u00e2\u0080\u009cOptimized\u00e2\u0080\u009d modules have\nan opt- tag and are usually smaller.  Future releases may\nchange the effects of optimization.\n- A program doesn\u00e2\u0080\u0099t run any faster when it is read from a .pyc file than when it is read from a .py file; the only thing that\u00e2\u0080\u0099s faster\nabout .pyc files is the speed with which they are loaded.\n- The module compileall can create .pyc files for all modules in a\ndirectory.\n- There is more detail on this process, including a flow chart of the\ndecisions, in PEP 3147 .\n\n## 6.2.Standard Modules\u00c2\u00b6\n\nPython comes with a library of standard modules, described in a separate\ndocument, the Python Library Reference (\u00e2\u0080\u009cLibrary Reference\u00e2\u0080\u009d hereafter).  Some\nmodules are built into the interpreter; these provide access to operations that\nare not part of the core of the language but are nevertheless built in, either\nfor efficiency or to provide access to operating system primitives such as\nsystem calls.  The set of such modules is a configuration option which also\ndepends on the underlying platform.  For example, the winreg module is only\nprovided on Windows systems. One particular module deserves some attention: sys , which is built into every Python interpreter.  The variables sys.ps1 and sys.ps2 define the strings used as primary and secondary\nprompts:\n\n```python\n>>> import sys\n>>> sys.ps1\n'>>> '\n>>> sys.ps2\n'... '\n>>> sys.ps1 = 'C> '\nC> print('Yuck!')\nYuck!\nC>\n```python\n\nThese two variables are only defined if the interpreter is in interactive mode.\n\nThe variable sys.path is a list of strings that determines the interpreter\u00e2\u0080\u0099s\nsearch path for modules. It is initialized to a default path taken from the\nenvironment variable PYTHONPATH , or from a built-in default if PYTHONPATH is not set.  You can modify it using standard list\noperations:\n\n```python\n>>> import sys\n>>> sys.path.append('/ufs/guido/lib/python')\n```python\n\n## 6.3.Thedir()Function\u00c2\u00b6\n\nThe built-in function dir() is used to find out which names a module\ndefines.  It returns a sorted list of strings:\n\n```python\n>>> import fibo, sys\n>>> dir(fibo)\n['__name__', 'fib', 'fib2']\n>>> dir(sys)\n['__breakpointhook__', '__displayhook__', '__doc__', '__excepthook__',\n '__interactivehook__', '__loader__', '__name__', '__package__', '__spec__',\n '__stderr__', '__stdin__', '__stdout__', '__unraisablehook__',\n '_clear_type_cache', '_current_frames', '_debugmallocstats', '_framework',\n '_getframe', '_git', '_home', '_xoptions', 'abiflags', 'addaudithook',\n 'api_version', 'argv', 'audit', 'base_exec_prefix', 'base_prefix',\n 'breakpointhook', 'builtin_module_names', 'byteorder', 'call_tracing',\n 'excepthook', 'exec_prefix', 'executable', 'exit', 'flags', 'float_info',\n 'float_repr_style', 'get_asyncgen_hooks', 'get_coroutine_origin_tracking_depth',\n 'getallocatedblocks', 'getdefaultencoding', 'getdlopenflags',\n 'getfilesystemencodeerrors', 'getfilesystemencoding', 'getprofile',\n 'getrecursionlimit', 'getrefcount', 'getsizeof', 'getswitchinterval',\n 'gettrace', 'hash_info', 'hexversion', 'implementation', 'int_info',\n 'intern', 'is_finalizing', 'last_traceback', 'last_type', 'last_value',\n 'maxsize', 'maxunicode', 'meta_path', 'modules', 'path', 'path_hooks',\n 'path_importer_cache', 'platform', 'prefix', 'ps1', 'ps2', 'pycache_prefix',\n 'set_asyncgen_hooks', 'set_coroutine_origin_tracking_depth', 'setdlopenflags',\n 'setprofile', 'setrecursionlimit', 'setswitchinterval', 'settrace', 'stderr',\n 'stdin', 'stdout', 'thread_info', 'unraisablehook', 'version', 'version_info',\n 'warnoptions']\n```python\n\nWithout arguments, dir() lists the names you have defined currently:\n\n```python\n>>> a = [1, 2, 3, 4, 5]\n>>> import fibo\n>>> fib = fibo.fib\n>>> dir()\n['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys']\n```python\n\nNote that it lists all types of names: variables, modules, functions, etc.\n\ndir() does not list the names of built-in functions and variables.  If you\nwant a list of those, they are defined in the standard module builtins :\n\n```python\n>>> import builtins\n>>> dir(builtins)\n['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException',\n 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning',\n 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError',\n 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning',\n 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False',\n 'FileExistsError', 'FileNotFoundError', 'FloatingPointError',\n 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError',\n 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError',\n 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError',\n 'MemoryError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented',\n 'NotImplementedError', 'OSError', 'OverflowError',\n 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError',\n 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning',\n 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError',\n 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError',\n 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError',\n 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning',\n 'ValueError', 'Warning', 'ZeroDivisionError', '_', '__build_class__',\n '__debug__', '__doc__', '__import__', '__name__', '__package__', 'abs',\n 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable',\n 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit',\n 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr',\n 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass',\n 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview',\n 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property',\n 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice',\n 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars',\n 'zip']\n```python\n\n## 6.4.Packages\u00c2\u00b6\n\nPackages are a way of structuring Python\u00e2\u0080\u0099s module namespace by using \u00e2\u0080\u009cdotted\nmodule names\u00e2\u0080\u009d.  For example, the module name A.B designates a submodule\nnamed B in a package named A .  Just like the use of modules saves the\nauthors of different modules from having to worry about each other\u00e2\u0080\u0099s global\nvariable names, the use of dotted module names saves the authors of multi-module\npackages like NumPy or Pillow from having to worry about\neach other\u00e2\u0080\u0099s module names.\n\nSuppose you want to design a collection of modules (a \u00e2\u0080\u009cpackage\u00e2\u0080\u009d) for the uniform\nhandling of sound files and sound data.  There are many different sound file\nformats (usually recognized by their extension, for example: .wav , .aiff , .au ), so you may need to create and maintain a growing\ncollection of modules for the conversion between the various file formats.\nThere are also many different operations you might want to perform on sound data\n(such as mixing, adding echo, applying an equalizer function, creating an\nartificial stereo effect), so in addition you will be writing a never-ending\nstream of modules to perform these operations.  Here\u00e2\u0080\u0099s a possible structure for\nyour package (expressed in terms of a hierarchical filesystem):\n\n```python\nsound/                          Top-level package\n      __init__.py               Initialize the sound package\n      formats/                  Subpackage for file format conversions\n              __init__.py\n              wavread.py\n              wavwrite.py\n              aiffread.py\n              aiffwrite.py\n              auread.py\n              auwrite.py\n              ...\n      effects/                  Subpackage for sound effects\n              __init__.py\n              echo.py\n              surround.py\n              reverse.py\n              ...\n      filters/                  Subpackage for filters\n              __init__.py\n              equalizer.py\n              vocoder.py\n              karaoke.py\n              ...\n```python\n\nWhen importing the package, Python searches through the directories on sys.path looking for the package subdirectory.\n\nThe __init__.py files are required to make Python treat directories\ncontaining the file as packages (unless using a namespace package , a\nrelatively advanced feature). This prevents directories with a common name,\nsuch as string , from unintentionally hiding valid modules that occur later\non the module search path. In the simplest case, __init__.py can just be\nan empty file, but it can also execute initialization code for the package or\nset the __all__ variable, described later.\n\nUsers of the package can import individual modules from the package, for\nexample:\n\n```python\nimport sound.effects.echo\n```python\n\nThis loads the submodule sound.effects.echo .  It must be referenced with\nits full name.\n\n```python\nsound.effects.echo.echofilter(input, output, delay=0.7, atten=4)\n```python\n\nAn alternative way of importing the submodule is:\n\n```python\nfrom sound.effects import echo\n```python\n\nThis also loads the submodule echo , and makes it available without its\npackage prefix, so it can be used as follows:\n\n```python\necho.echofilter(input, output, delay=0.7, atten=4)\n```python\n\nYet another variation is to import the desired function or variable directly:\n\n```python\nfrom sound.effects.echo import echofilter\n```python\n\nAgain, this loads the submodule echo , but this makes its function echofilter() directly available:\n\n```python\nechofilter(input, output, delay=0.7, atten=4)\n```python\n\nNote that when using from package import item , the item can be either a\nsubmodule (or subpackage) of the package, or some  other name defined in the\npackage, like a function, class or variable.  The import statement first\ntests whether the item is defined in the package; if not, it assumes it is a\nmodule and attempts to load it.  If it fails to find it, an ImportError exception is raised.\n\nContrarily, when using syntax like import item.subitem.subsubitem , each item\nexcept for the last must be a package; the last item can be a module or a\npackage but can\u00e2\u0080\u0099t be a class or function or variable defined in the previous\nitem.\n\n### 6.4.1.Importing * From a Package\u00c2\u00b6\n\nNow what happens when the user writes from sound.effects import * ?  Ideally,\none would hope that this somehow goes out to the filesystem, finds which\nsubmodules are present in the package, and imports them all.  This could take a\nlong time and importing sub-modules might have unwanted side-effects that should\nonly happen when the sub-module is explicitly imported.\n\nThe only solution is for the package author to provide an explicit index of the\npackage.  The import statement uses the following convention: if a package\u00e2\u0080\u0099s __init__.py code defines a list named __all__ , it is taken to be the\nlist of module names that should be imported when from package import * is\nencountered.  It is up to the package author to keep this list up-to-date when a\nnew version of the package is released.  Package authors may also decide not to\nsupport it, if they don\u00e2\u0080\u0099t see a use for importing * from their package.  For\nexample, the file sound/effects/__init__.py could contain the following\ncode:\n\n```python\n__all__ = [\"echo\", \"surround\", \"reverse\"]\n```python\n\nThis would mean that from sound.effects import * would import the three\nnamed submodules of the sound.effects package.\n\nBe aware that submodules might become shadowed by locally defined names. For\nexample, if you added a reverse function to the sound/effects/__init__.py file, the from sound.effects import * would only import the two submodules echo and surround , but not the reverse submodule, because it is shadowed by the locally defined reverse function:\n\n```python\n__all__ = [\n    \"echo\",      # refers to the 'echo.py' file\n    \"surround\",  # refers to the 'surround.py' file\n    \"reverse\",   # !!! refers to the 'reverse' function now !!!\n]\n\ndef reverse(msg: str):  # <-- this name shadows the 'reverse.py' submodule\n    return msg[::-1]    #     in the case of a 'from sound.effects import *'\n```python\n\nIf __all__ is not defined, the statement from sound.effects import * does not import all submodules from the package sound.effects into the\ncurrent namespace; it only ensures that the package sound.effects has\nbeen imported (possibly running any initialization code in __init__.py )\nand then imports whatever names are defined in the package.  This includes any\nnames defined (and submodules explicitly loaded) by __init__.py .  It\nalso includes any submodules of the package that were explicitly loaded by\nprevious import statements.  Consider this code:\n\n```python\nimport sound.effects.echo\nimport sound.effects.surround\nfrom sound.effects import *\n```python\n\nIn this example, the echo and surround modules are imported in the\ncurrent namespace because they are defined in the sound.effects package\nwhen the from...import statement is executed.  (This also works when __all__ is defined.)\n\nAlthough certain modules are designed to export only names that follow certain\npatterns when you use import * , it is still considered bad practice in\nproduction code.\n\nRemember, there is nothing wrong with using from package import specific_submodule !  In fact, this is the recommended notation unless the\nimporting module needs to use submodules with the same name from different\npackages.\n\n### 6.4.2.Intra-package References\u00c2\u00b6\n\nWhen packages are structured into subpackages (as with the sound package\nin the example), you can use absolute imports to refer to submodules of siblings\npackages.  For example, if the module sound.filters.vocoder needs to use\nthe echo module in the sound.effects package, it can use from sound.effects import echo .\n\nYou can also write relative imports, with the from module import name form\nof import statement.  These imports use leading dots to indicate the current and\nparent packages involved in the relative import.  From the surround module for example, you might use:\n\n```python\nfrom . import echo\nfrom .. import formats\nfrom ..filters import equalizer\n```python\n\nNote that relative imports are based on the name of the current module\u00e2\u0080\u0099s package.\nSince the main module does not have a package, modules intended for use\nas the main module of a Python application must always use absolute imports.\n\n### 6.4.3.Packages in Multiple Directories\u00c2\u00b6\n\nPackages support one more special attribute, __path__ .  This is\ninitialized to be a sequence of strings containing the name of the\ndirectory holding the\npackage\u00e2\u0080\u0099s __init__.py before the code in that file is executed.  This\nvariable can be modified; doing so affects future searches for modules and\nsubpackages contained in the package.\n\nWhile this feature is not often needed, it can be used to extend the set of\nmodules found in a package.\n\nFootnotes",
      "difficulty": "intro",
      "doc_id": "doc-6-modules-f6847329c8",
      "provenance": {
        "author": "",
        "date": "",
        "license": "PSF Documentation License",
        "source_file": "data/corpus_raw/scraped/3_tutorial_modules_html_b24f02.json",
        "url": "https://docs.python.org/3/tutorial/modules.html"
      },
      "title": "6.Modules\u00c2\u00b6",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "formatting",
        "string_methods",
        "strings"
      ],
      "content": "## 6MANIPULATING STRINGS\n\nText is one of the most common forms of data your programs will handle. You already know how to concatenate two string values together with the + operator, but you can do much more than that. You can extract partial strings from string values, add or remove spacing, convert letters to lowercase or uppercase, and check that strings are formatted correctly. You can even write Python code to access the clipboard for copying and pasting text.\n\nIn this chapter, you\u2019ll learn all this and more. Then you\u2019ll work through two different programming projects: a simple clipboard that stores multiple strings of text and a program to automate the boring chore of formatting pieces of text.\n\n### Working with Strings\n\nLet\u2019s look at some of the ways Python lets you write, print, and access strings in your code.\n\n#### String Literals\n\nTyping string values in Python code is fairly straightforward: they begin and end with a single quote. But then how can you use a quote inside a string? Typing 'That is Alice's cat.' won\u2019t work, because Python thinks the string ends after Alice , and the rest ( s cat.' ) is invalid Python code. Fortunately, there are multiple ways to type strings.\n\n#### Double Quotes\n\nStrings can begin and end with double quotes, just as they do with single quotes. One benefit of using double quotes is that the string can have a single quote character in it. Enter the following into the interactive shell:\n\n>>> spam = \"That is Alice's cat.\"\n\nSince the string begins with a double quote, Python knows that the single quote is part of the string and not marking the end of the string. However, if you need to use both single quotes and double quotes in the string, you\u2019ll need to use escape characters.\n\n#### Escape Characters\n\nAn escape character lets you use characters that are otherwise impossible to put into a string. An escape character consists of a backslash ( \\ ) followed by the character you want to add to the string. (Despite consisting of two characters, it is commonly referred to as a singular escape character.) For example, the escape character for a single quote is \\' . You can use this inside a string that begins and ends with single quotes. To see how escape characters work, enter the following into the interactive shell:\n\n>>> spam = 'Say hi to Bob\\'s mother.'\n\nPython knows that since the single quote in Bob\\'s has a backslash, it is not a single quote meant to end the string value. The escape characters \\' and \\\" let you put single quotes and double quotes inside your strings, respectively.\n\nTable 6-1 lists the escape characters you can use.\n\nTable 6-1: Escape Characters\n\nEscape character\n\nPrints as\n\n\\'\n\nSingle quote\n\n\\\"\n\nDouble quote\n\n\\t\n\nTab\n\n\\n\n\nNewline (line break)\n\n\\\\\n\nBackslash\n\nEnter the following into the interactive shell:\n\n>>> print(\"Hello there!\\nHow are you?\\nI\\'m doing fine.\") Hello there! How are you? I'm doing fine.\n\n#### Raw Strings\n\nYou can place an r before the beginning quotation mark of a string to make it a raw string. A raw string completely ignores all escape characters and prints any backslash that appears in the string. For example, enter the following into the interactive shell:\n\n>>> print(r'That is Carol\\'s cat.') That is Carol\\'s cat.\n\nBecause this is a raw string, Python considers the backslash as part of the string and not as the start of an escape character. Raw strings are helpful if you are typing string values that contain many backslashes, such as the strings used for Windows file paths like r'C:\\Users\\Al\\Desktop' or regular expressions described in the next chapter.\n\n#### Multiline Strings with Triple Quotes\n\nWhile you can use the \\n escape character to put a newline into a string, it is often easier to use multiline strings. A multiline string in Python begins and ends with either three single quotes or three double quotes. Any quotes, tabs, or newlines in between the \u201ctriple quotes\u201d are considered part of the string. Python\u2019s indentation rules for blocks do not apply to lines inside a multiline string.\n\nOpen the file editor and write the following:\n\nprint('''Dear Alice, Eve's cat has been arrested for catnapping, cat burglary, and extortion. Sincerely, Bob''')\n\nSave this program as catnapping.py and run it. The output will look like this:\n\nDear Alice, Eve's cat has been arrested for catnapping, cat burglary, and extortion. Sincerely, Bob\n\nNotice that the single quote character in Eve's does not need to be escaped. Escaping single and double quotes is optional in multiline strings. The following print() call would print identical text but doesn\u2019t use a multiline string:\n\nprint('Dear Alice,\\n\\nEve\\'s cat has been arrested for catnapping, cat burglary, and extortion.\\n\\nSincerely,\\nBob')\n\n#### Multiline Comments\n\nWhile the hash character ( # ) marks the beginning of a comment for the rest of the line, a multiline string is often used for comments that span multiple lines. The following is perfectly valid Python code:\n\n\"\"\"This is a test Python program. Written by Al Sweigart al@inventwithpython.com This program was designed for Python 3, not Python 2. \"\"\" def spam(): \"\"\"This is a multiline comment to help explain what the spam() function does.\"\"\" print('Hello!')\n\n#### Indexing and Slicing Strings\n\nStrings use indexes and slices the same way lists do. You can think of the string 'Hello, world!' as a list and each character in the string as an item with a corresponding index.\n\n'\u00a0\u00a0\u00a0H\u00a0\u00a0\u00a0e\u00a0\u00a0\u00a0l\u00a0\u00a0\u00a0l\u00a0\u00a0\u00a0o\u00a0\u00a0\u00a0,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0w\u00a0\u00a0\u00a0o\u00a0\u00a0\u00a0r\u00a0\u00a0\u00a0l\u00a0\u00a0\u00a0\u00a0d\u00a0\u00a0\u00a0\u00a0!\u00a0\u00a0\u00a0' 0\u00a0\u00a0\u00a01\u00a0\u00a0\u00a02\u00a0\u00a0\u00a03\u00a0\u00a0\u00a04\u00a0\u00a0\u00a05\u00a0\u00a0\u00a06\u00a0\u00a0\u00a07\u00a0\u00a0\u00a08\u00a0\u00a0\u00a09\u00a0\u00a0\u00a010\u00a0\u00a0\u00a011\u00a0\u00a0\u00a012\n\nThe space and exclamation point are included in the character count, so 'Hello, world!' is 13 characters long, from H at index 0 to ! at index 12.\n\nEnter the following into the interactive shell:\n\n>>> spam = 'Hello, world!' >>> spam[0] 'H' >>> spam[4] 'o' >>> spam[-1] '!' >>> spam[0:5] 'Hello' >>> spam[:5] 'Hello' >>> spam[7:] 'world!'\n\nIf you specify an index, you\u2019ll get the character at that position in the string. If you specify a range from one index to another, the starting index is included and the ending index is not. That\u2019s why, if spam is 'Hello, world!' , spam[0:5] is 'Hello' . The substring you get from spam[0:5] will include everything from spam[0] to spam[4] , leaving out the comma at index 5 and the space at index 6. This is similar to how range(5) will cause a for loop to iterate up to, but not including, 5 .\n\nNote that slicing a string does not modify the original string. You can capture a slice from one variable in a separate variable. Try entering the following into the interactive shell:\n\n>>> spam = 'Hello, world!' >>> fizz = spam[0:5] >>> fizz 'Hello'\n\nBy slicing and storing the resulting substring in another variable, you can have both the whole string and the substring handy for quick, easy access.\n\n#### The in and not in Operators with Strings\n\nThe in and not in operators can be used with strings just like with list values. An expression with two strings joined using in or not in will evaluate to a Boolean True or False . Enter the following into the interactive shell:\n\n>>> 'Hello' in 'Hello, World' True >>> 'Hello' in 'Hello' True >>> 'HELLO' in 'Hello, World' False >>> '' in 'spam' True >>> 'cats' not in 'cats and dogs' False\n\nThese expressions test whether the first string (the exact string, case-sensitive) can be found within the second string.\n\n### Putting Strings Inside Other Strings\n\nPutting strings inside other strings is a common operation in programming. So far, we\u2019ve been using the + operator and string concatenation to do this:\n\n>>> name = 'Al' >>> age = 4000 >>> 'Hello, my name is ' + name + '. I am ' + str(age) + ' years old.' 'Hello, my name is Al. I am 4000 years old.'\n\nHowever, this requires a lot of tedious typing. A simpler approach is to use string interpolation , in which the %s operator inside the string acts as a marker to be replaced by values following the string. One benefit of string interpolation is that str() doesn\u2019t have to be called to convert values to strings. Enter the following into the interactive shell:\n\n>>> name = 'Al' >>> age = 4000 >>> 'My name is %s. I am %s years old.' % (name, age) 'My name is Al. I am 4000 years old.'\n\nPython 3.6 introduced f-strings , which is similar to string interpolation except that braces are used instead of %s , with the expressions placed directly inside the braces. Like raw strings, f-strings have an f prefix before the starting quotation mark. Enter the following into the interactive shell:\n\n>>> name = 'Al' >>> age = 4000 >>> f'My name is {name}. Next year I will be {age + 1}.' 'My name is Al. Next year I will be 4001.'\n\nRemember to include the f prefix; otherwise, the braces and their contents will be a part of the string value:\n\n>>> 'My name is {name}. Next year I will be {age + 1}.' 'My name is {name}. Next year I will be {age + 1}.'\n\n### Useful String Methods\n\nSeveral string methods analyze strings or create transformed string values. This section describes the methods you\u2019ll be using most often.\n\n#### The upper(), lower(), isupper(), and islower() Methods\n\nThe upper() and lower() string methods return a new string where all the letters in the original string have been converted to uppercase or lowercase, respectively. Nonletter characters in the string remain unchanged. Enter the following into the interactive shell:\n\n>>> spam = 'Hello, world!' >>> spam = spam.upper() >>> spam 'HELLO, WORLD!' >>> spam = spam.lower() >>> spam 'hello, world!'\n\nNote that these methods do not change the string itself but return new string values. If you want to change the original string, you have to call upper() or lower() on the string and then assign the new string to the variable where the original was stored. This is why you must use spam = spam.upper() to change the string in spam instead of simply spam.upper() . (This is just like if a variable eggs contains the value 10 . Writing eggs + 3 does not change the value of eggs , but eggs = eggs + 3 does.)\n\nThe upper() and lower() methods are helpful if you need to make a case-insensitive comparison. For example, the strings 'great' and 'GREat' are not equal to each other. But in the following small program, it does not matter whether the user types Great , GREAT , or grEAT , because the string is first converted to lowercase.\n\nprint('How are you?') feeling = input() if feeling.lower() == 'great': print('I feel great too.') else: print('I hope the rest of your day is good.')\n\nWhen you run this program, the question is displayed, and entering a variation on great , such as GREat , will still give the output I feel great too . Adding code to your program to handle variations or mistakes in user input, such as inconsistent capitalization, will make your programs easier to use and less likely to fail.\n\nHow are you? GREat I feel great too.\n\nYou can view the execution of this program at https://autbor.com/convertlowercase/ . The isupper() and islower() methods will return a Boolean True value if the string has at least one letter and all the letters are uppercase or lowercase, respectively. Otherwise, the method returns False . Enter the following into the interactive shell, and notice what each method call returns:\n\n>>> spam = 'Hello, world!' >>> spam.islower() False >>> spam.isupper() False >>> 'HELLO'.isupper() True >>> 'abc12345'.islower() True >>> '12345'.islower() False >>> '12345'.isupper() False\n\nSince the upper() and lower() string methods themselves return strings, you can call string methods on those returned string values as well. Expressions that do this will look like a chain of method calls. Enter the following into the interactive shell:\n\n>>> 'Hello'.upper() 'HELLO' >>> 'Hello'.upper().lower() 'hello' >>> 'Hello'.upper().lower().upper() 'HELLO' >>> 'HELLO'.lower() 'hello' >>> 'HELLO'.lower().islower() True\n\n#### The isX() Methods\n\nAlong with islower() and isupper() , there are several other string methods that have names beginning with the word is . These methods return a Boolean value that describes the nature of the string. Here are some common is X string methods:\n\nisalpha() Returns True if the string consists only of letters and isn\u2019t blank\n\nisalnum() Returns True if the string consists only of letters and numbers and is not blank\n\nisdecimal() Returns True if the string consists only of numeric characters and is not blank\n\nisspace() Returns True if the string consists only of spaces, tabs, and newlines and is not blank\n\nistitle() Returns True if the string consists only of words that begin with an uppercase letter followed by only lowercase letters\n\nEnter the following into the interactive shell:\n\n>>> 'hello'.isalpha() True >>> 'hello123'.isalpha() False >>> 'hello123'.isalnum() True >>> 'hello'.isalnum() True >>> '123'.isdecimal() True >>> '\u00a0\u00a0\u00a0\u00a0'.isspace() True >>> 'This Is Title Case'.istitle() True >>> 'This Is Title Case 123'.istitle() True >>> 'This Is not Title Case'.istitle() False >>> 'This Is NOT Title Case Either'.istitle() False\n\nThe is X() string methods are helpful when you need to validate user input. For example, the following program repeatedly asks users for their age and a password until they provide valid input. Open a new file editor window and enter this program, saving it as validateInput.py :\n\nwhile True: print('Enter your age:') age = input() if age.isdecimal(): break print('Please enter a number for your age.') while True: print('Select a new password (letters and numbers only):') password = input() if password.isalnum(): break print('Passwords can only have letters and numbers.')\n\nIn the first while loop, we ask the user for their age and store their input in age . If age is a valid (decimal) value, we break out of this first while loop and move on to the second, which asks for a password. Otherwise, we inform the user that they need to enter a number and again ask them to enter their age. In the second while loop, we ask for a password, store the user\u2019s input in password , and break out of the loop if the input was alpha\u00adnumeric. If it wasn\u2019t, we\u2019re not satisfied, so we tell the user the password needs to be alphanumeric and again ask them to enter a password.\n\nWhen run, the program\u2019s output looks like this:\n\nEnter your age: forty two Please enter a number for your age. Enter your age: 42 Select a new password (letters and numbers only): secr3t! Passwords can only have letters and numbers. Select a new password (letters and numbers only): secr3t\n\nYou can view the execution of this program at https://autbor.com/validateinput/ . Calling isdecimal() and isalnum() on variables, we\u2019re able to test whether the values stored in those variables are decimal or not, alphanumeric or not. Here, these tests help us reject the input forty two but accept 42 , and reject secr3t! but accept secr3t .\n\n#### The startswith() and endswith() Methods\n\nThe startswith() and endswith() methods return True if the string value they are called on begins or ends (respectively) with the string passed to the method; otherwise, they return False . Enter the following into the interactive shell:\n\n>>> 'Hello, world!'.startswith('Hello') True >>> 'Hello, world!'.endswith('world!') True >>> 'abc123'.startswith('abcdef') False >>> 'abc123'.endswith('12') False >>> 'Hello, world!'.startswith('Hello, world!') True >>> 'Hello, world!'.endswith('Hello, world!') True\n\nThese methods are useful alternatives to the == equals operator if you need to check only whether the first or last part of the string, rather than the whole thing, is equal to another string.\n\n#### The join() and split() Methods\n\nThe join() method is useful when you have a list of strings that need to be joined together into a single string value. The join() method is called on a string, gets passed a list of strings, and returns a string. The returned string is the concatenation of each string in the passed-in list. For example, enter the following into the interactive shell:\n\n>>> ', '.join(['cats', 'rats', 'bats']) 'cats, rats, bats' >>> ' '.join(['My', 'name', 'is', 'Simon']) 'My name is Simon' >>> 'ABC'.join(['My', 'name', 'is', 'Simon']) 'MyABCnameABCisABCSimon'\n\nNotice that the string join() calls on is inserted between each string of the list argument. For example, when join(['cats', 'rats', 'bats']) is called on the ', ' string, the returned string is 'cats, rats, bats' .\n\nRemember that join() is called on a string value and is passed a list value. (It\u2019s easy to accidentally call it the other way around.) The split() method does the opposite: It\u2019s called on a string value and returns a list of strings. Enter the following into the interactive shell:\n\n>>> 'My name is Simon'.split() ['My', 'name', 'is', 'Simon']\n\nBy default, the string 'My name is Simon' is split wherever whitespace characters such as the space, tab, or newline characters are found. These whitespace characters are not included in the strings in the returned list. You can pass a delimiter string to the split() method to specify a different string to split upon. For example, enter the following into the interactive shell:\n\n>>> 'MyABCnameABCisABCSimon'.split('ABC') ['My', 'name', 'is', 'Simon'] >>> 'My name is Simon'.split('m') ['My na', 'e is Si', 'on']\n\nA common use of split() is to split a multiline string along the newline characters. Enter the following into the interactive shell:\n\n>>> spam = '''Dear Alice, How have you been? I am fine. There is a container in the fridge that is labeled \"Milk Experiment.\" Please do not drink it. Sincerely, Bob''' >>> spam.split('\\n') ['Dear Alice,', 'How have you been? I am fine.', 'There is a container in the fridge', 'that is labeled \"Milk Experiment.\"', '', 'Please do not drink it.', 'Sincerely,', 'Bob']\n\nPassing split() the argument '\\n' lets us split the multiline string stored in spam along the newlines and return a list in which each item corresponds to one line of the string.\n\n#### Splitting Strings with the partition() Method\n\nThe partition() string method can split a string into the text before and after a separator string. This method searches the string it is called on for the separator string it is passed, and returns a tuple of three substrings for the \u201cbefore,\u201d \u201cseparator,\u201d and \u201cafter\u201d substrings. Enter the following into the interactive shell:\n\n>>> 'Hello, world!'.partition('w') ('Hello, ', 'w', 'orld!') >>> 'Hello, world!'.partition('world') ('Hello, ', 'world', '!')\n\nIf the separator string you pass to partition() occurs multiple times in the string that partition() calls on, the method splits the string only on the first occurrence:\n\n>>> 'Hello, world!'.partition('o') ('Hell', 'o', ', world!')\n\nIf the separator string can\u2019t be found, the first string returned in the tuple will be the entire string, and the other two strings will be empty:\n\n>>> 'Hello, world!'.partition('XYZ') ('Hello, world!', '', '')\n\nYou can use the multiple assignment trick to assign the three returned strings to three variables:\n\n>>> before, sep, after = 'Hello, world!'.partition(' ') >>> before 'Hello,' >>> after 'world!'\n\nThe partition() method is useful for splitting a string whenever you need the parts before, including, and after a particular separator string.\n\n#### Justifying Text with the rjust(), ljust(), and center() Methods\n\nThe rjust() and ljust() string methods return a padded version of the string they are called on, with spaces inserted to justify the text. The first argument to both methods is an integer length for the justified string. Enter the following into the interactive shell:\n\n>>> 'Hello'.rjust(10) '\u00a0\u00a0\u00a0\u00a0\u00a0Hello' >>> 'Hello'.rjust(20) '\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Hello' >>> 'Hello, World'.rjust(20) '\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Hello, World' >>> 'Hello'.ljust(10) 'Hello\u00a0\u00a0\u00a0\u00a0\u00a0'\n\n'Hello'.rjust(10) says that we want to right-justify 'Hello' in a string of total length 10 . 'Hello' is five characters, so five spaces will be added to its left, giving us a string of 10 characters with 'Hello' justified right.\n\nAn optional second argument to rjust() and ljust() will specify a fill character other than a space character. Enter the following into the interactive shell:\n\n>>> 'Hello'.rjust(20, '*') '***************Hello' >>> 'Hello'.ljust(20, '-') 'Hello---------------'\n\nThe center() string method works like ljust() and rjust() but centers the text rather than justifying it to the left or right. Enter the following into the interactive shell:\n\n>>> 'Hello'.center(20) '\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Hello\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0' >>> 'Hello'.center(20, '=') '=======Hello========'\n\nThese methods are especially useful when you need to print tabular data that has correct spacing. Open a new file editor window and enter the following code, saving it as picnicTable.py :\n\ndef printPicnic(itemsDict, leftWidth, rightWidth): print('PICNIC ITEMS'.center(leftWidth + rightWidth, '-')) for k, v in itemsDict.items(): print(k.ljust(leftWidth, '.') + str(v).rjust(rightWidth)) picnicItems = {'sandwiches': 4, 'apples': 12, 'cups': 4, 'cookies': 8000} printPicnic(picnicItems, 12, 5) printPicnic(picnicItems, 20, 6)\n\nYou can view the execution of this program at https://autbor.com/picnictable/ . In this program, we define a printPicnic() method that will take in a dictionary of information and use center() , ljust() , and rjust() to display that information in a neatly aligned table-like format.\n\nThe dictionary that we\u2019ll pass to printPicnic() is picnicItems . In picnicItems , we have 4 sandwiches, 12 apples, 4 cups, and 8,000 cookies. We want to organize this information into two columns, with the name of the item on the left and the quantity on the right.\n\nTo do this, we decide how wide we want the left and right columns to be. Along with our dictionary, we\u2019ll pass these values to printPicnic() .\n\nThe printPicnic() function takes in a dictionary, a leftWidth for the left column of a table, and a rightWidth for the right column. It prints a title, PICNIC ITEMS , centered above the table. Then, it loops through the dictionary, printing each key-value pair on a line with the key justified left and padded by periods, and the value justified right and padded by spaces.\n\nAfter defining printPicnic() , we define the dictionary picnicItems and call printPicnic() twice, passing it different widths for the left and right table columns.\n\nWhen you run this program, the picnic items are displayed twice. The first time the left column is 12 characters wide, and the right column is 5 characters wide. The second time they are 20 and 6 characters wide, respectively.\n\n---PICNIC ITEMS-- sandwiches..\u00a0\u00a0\u00a0\u00a04 apples......\u00a0\u00a0\u00a012 cups........\u00a0\u00a0\u00a0\u00a04 cookies..... 8000 -------PICNIC ITEMS------- sandwiches..........\u00a0\u00a0\u00a0\u00a0\u00a04 apples..............\u00a0\u00a0\u00a0\u00a012 cups................\u00a0\u00a0\u00a0\u00a0\u00a04 cookies.............\u00a0\u00a08000\n\nUsing rjust() , ljust() , and center() lets you ensure that strings are neatly aligned, even if you aren\u2019t sure how many characters long your strings are.\n\n#### Removing Whitespace with the strip(), rstrip(), and lstrip() Methods\n\nSometimes you may want to strip off whitespace characters (space, tab, and newline) from the left side, right side, or both sides of a string. The strip() string method will return a new string without any whitespace characters at the beginning or end. The lstrip() and rstrip() methods will remove whitespace characters from the left and right ends, respectively. Enter the following into the interactive shell:\n\n>>> spam = '\u00a0\u00a0\u00a0\u00a0Hello, World\u00a0\u00a0\u00a0\u00a0' >>> spam.strip() 'Hello, World' >>> spam.lstrip() 'Hello, World\u00a0\u00a0\u00a0\u00a0' >>> spam.rstrip() '\u00a0\u00a0\u00a0\u00a0Hello, World'\n\nOptionally, a string argument will specify which characters on the ends should be stripped. Enter the following into the interactive shell:\n\n>>> spam = 'SpamSpamBaconSpamEggsSpamSpam' >>> spam.strip('ampS') 'BaconSpamEggs'\n\nPassing strip() the argument 'ampS' will tell it to strip occurrences of a , m , p , and capital S from the ends of the string stored in spam . The order of the characters in the string passed to strip() does not matter: strip('ampS') will do the same thing as strip('mapS') or strip('Spam') .\n\n### Numeric Values of Characters with the ord() and chr() Functions\n\nComputers store information as bytes\u2014strings of binary numbers, which means we need to be able to convert text to numbers. Because of this, every text character has a corresponding numeric value called a Unicode code point . For example, the numeric code point is 65 for 'A' , 52 for '4' , and 33 for '!' . You can use the ord() function to get the code point of a one-character string, and the chr() function to get the one-character string of an integer code point. Enter the following into the interactive shell:\n\n>>> ord('A') 65 >>> ord('4') 52 >>> ord('!') 33 >>> chr(65) 'A'\n\nThese functions are useful when you need to do an ordering or mathematical operation on characters:\n\n>>> ord('B') 66 >>> ord('A') < ord('B') True >>> chr(ord('A')) 'A' >>> chr(ord('A') + 1) 'B'\n\nThere is more to Unicode and code points, but those details are beyond the scope of this book. If you\u2019d like to know more, I recommend watching Ned Batchelder\u2019s 2012 PyCon talk, \u201cPragmatic Unicode, or, How Do I Stop the Pain?\u201d at https://youtu.be/sgHbC6udIqc .\n\n### Copying and Pasting Strings with the pyperclip Module\n\nThe pyperclip module has copy() and paste() functions that can send text to and receive text from your computer\u2019s clipboard. Sending the output of your program to the clipboard will make it easy to paste it into an email, word processor, or some other software.\n\nRUNNING PYTHON SCRIPTS OUTSIDE OF MU\n\nSo far, you\u2019ve been running your Python scripts using the interactive shell and file editor in Mu. However, you won\u2019t want to go through the inconvenience of opening Mu and the Python script each time you want to run a script. Fortunately, there are shortcuts you can set up to make running Python scripts easier. The steps are slightly different for Windows, macOS, and Linux, but each is described in Appendix B. Turn to Appendix B to learn how to run your Python scripts conveniently and be able to pass command line arguments to them. (You will not be able to pass command line arguments to your programs using Mu.)\n\nThe pyperclip module does not come with Python. To install it, follow the directions for installing third-party modules in Appendix A. After installing pyperclip , enter the following into the interactive shell:\n\n>>> import pyperclip >>> pyperclip.copy('Hello, world!') >>> pyperclip.paste() 'Hello, world!'\n\nOf course, if something outside of your program changes the clipboard contents, the paste() function will return it. For example, if I copied this sentence to the clipboard and then called paste() , it would look like this:\n\n>>> pyperclip.paste() 'For example, if I copied this sentence to the clipboard and then called paste(), it would look like this:'\n\n### Project: Multi-Clipboard Automatic Messages\n\nIf you\u2019ve responded to a large number of emails with similar phrasing, you\u2019ve probably had to do a lot of repetitive typing. Maybe you keep a text document with these phrases so you can easily copy and paste them using the clipboard. But your clipboard can only store one message at a time, which isn\u2019t very convenient. Let\u2019s make this process a bit easier with a program that stores multiple phrases.\n\n#### Step 1: Program Design and Data Structures\n\nYou want to be able to run this program with a command line argument that is a short key phrase\u2014for instance, agree or busy . The message associated with that key phrase will be copied to the clipboard so that the user can paste it into an email. This way, the user can have long, detailed messages without having to retype them.\n\nTHE CHAPTER PROJECTS\n\nThis is the first \u201cchapter project\u201d of the book. From here on, each chapter will have projects that demonstrate the concepts covered in the chapter. The projects are written in a style that takes you from a blank file editor window to a full, working program. Just like with the interactive shell examples, don\u2019t only read the project sections\u2014follow along on your computer!\n\nOpen a new file editor window and save the program as mclip.py . You need to start the program with a #! ( shebang ) line (see Appendix B) and should also write a comment that briefly describes the program. Since you want to associate each piece of text with its key phrase, you can store these as strings in a dictionary. The dictionary will be the data structure that organizes your key phrases and text. Make your program look like the following:\n\n#! python3 # mclip.py - A multi-clipboard program. TEXT = {'agree': \"\"\"Yes, I agree. That sounds fine to me.\"\"\", 'busy': \"\"\"Sorry, can we do this later this week or next week?\"\"\", 'upsell': \"\"\"Would you consider making this a monthly donation?\"\"\"}\n\n#### Step 2: Handle Command Line Arguments\n\nThe command line arguments will be stored in the variable sys.argv . (See Appendix B for more information on how to use command line arguments in your programs.) The first item in the sys.argv list should always be a string containing the program\u2019s filename ( 'mclip.py' ), and the second item should be the first command line argument. For this program, this argument is the key phrase of the message you want. Since the command line argument is mandatory, you display a usage message to the user if they forget to add it (that is, if the sys.argv list has fewer than two values in it). Make your program look like the following:\n\n#! python3 # mclip.py - A multi-clipboard program. TEXT = {'agree': \"\"\"Yes, I agree. That sounds fine to me.\"\"\", 'busy': \"\"\"Sorry, can we do this later this week or next week?\"\"\", 'upsell': \"\"\"Would you consider making this a monthly donation?\"\"\"} i mport sys if len(sys.argv) < 2: print('Usage: python mclip.py [keyphrase] - copy phrase text') sys.exit() keyphrase = sys.argv[1]\u00a0\u00a0\u00a0\u00a0# first command line arg is the keyphrase\n\n#### Step 3: Copy the Right Phrase\n\nNow that the key phrase is stored as a string in the variable keyphrase , you need to see whether it exists in the TEXT dictionary as a key. If so, you want to copy the key\u2019s value to the clipboard using pyperclip.copy() . (Since you\u2019re using the pyperclip module, you need to import it.) Note that you don\u2019t actually need the keyphrase variable; you could just use sys.argv[1] everywhere keyphrase is used in this program. But a variable named keyphrase is much more readable than something cryptic like sys.argv[1] .\n\nMake your program look like the following:\n\n#! python3 # mclip.py - A multi-clipboard program. TEXT = {'agree': \"\"\"Yes, I agree. That sounds fine to me.\"\"\", 'busy': \"\"\"Sorry, can we do this later this week or next week?\"\"\", 'upsell': \"\"\"Would you consider making this a monthly donation?\"\"\"} import sys , pyperclip if len(sys.argv) < 2: print('Usage: py mclip.py [keyphrase] - copy phrase text') sys.exit() keyphrase = sys.argv[1]\u00a0\u00a0\u00a0\u00a0# first command line arg is the keyphrase if keyphrase in TEXT: pyperclip.copy(TEXT[keyphrase]) print('Text for ' + keyphrase + ' copied to clipboard.') else: print('There is no text for ' + keyphrase)\n\nThis new code looks in the TEXT dictionary for the key phrase. If the key phrase is a key in the dictionary, we get the value corresponding to that key, copy it to the clipboard, and print a message saying that we copied the value. Otherwise, we print a message saying there\u2019s no key phrase with that name.\n\nThat\u2019s the complete script. Using the instructions in Appendix B for launching command line programs easily, you now have a fast way to copy messages to the clipboard. You will have to modify the TEXT dictionary value in the source whenever you want to update the program with a new message.\n\nOn Windows, you can create a batch file to run this program with the WIN-R Run window. (For more about batch files, see Appendix B.) Enter the following into the file editor and save the file as mclip.bat in the C:\\Windows folder:\n\n@py.exe C:\\ path_to_file \\mclip.py %* @pause\n\nWith this batch file created, running the multi-clipboard program on Windows is just a matter of pressing WIN-R and typing mclip key phrase .\n\n### Project: Adding Bullets to Wiki Markup\n\nWhen editing a Wikipedia article, you can create a bulleted list by putting each list item on its own line and placing a star in front. But say you have a really large list that you want to add bullet points to. You could just type those stars at the beginning of each line, one by one. Or you could automate this task with a short Python script.\n\nThe bulletPointAdder.py script will get the text from the clipboard, add a star and space to the beginning of each line, and then paste this new text to the clipboard. For example, if I copied the following text (for the Wikipedia article \u201cList of Lists of Lists\u201d) to the clipboard:\n\nLists of animals Lists of aquarium life Lists of biologists by author abbreviation Lists of cultivars\n\nand then ran the bulletPointAdder.py program, the clipboard would then contain the following:\n\n* Lists of animals * Lists of aquarium life * Lists of biologists by author abbreviation * Lists of cultivars\n\nThis star-prefixed text is ready to be pasted into a Wikipedia article as a bulleted list.\n\n#### Step 1: Copy and Paste from the Clipboard\n\nYou want the bulletPointAdder.py program to do the following:\n\n- Paste text from the clipboard.\n- Do something to it.\n- Copy the new text to the clipboard.\n\nThat second step is a little tricky, but steps 1 and 3 are pretty straightforward: they just involve the pyperclip.copy() and pyperclip.paste() functions. For now, let\u2019s just write the part of the program that covers steps 1 and 3. Enter the following, saving the program as bulletPointAdder.py :\n\n#! python3 # bulletPointAdder.py - Adds Wikipedia bullet points to the start # of each line of text on the clipboard. import pyperclip text = pyperclip.paste() # TODO: Separate lines and add stars. pyperclip.copy(text)\n\nThe TODO comment is a reminder that you should complete this part of the program eventually. The next step is to actually implement that piece of the program.\n\n#### Step 2: Separate the Lines of Text and Add the Star\n\nThe call to pyperclip.paste() returns all the text on the clipboard as one big string. If we used the \u201cList of Lists of Lists\u201d example, the string stored in text would look like this:\n\n'Lists of animals\\nLists of aquarium life\\nLists of biologists by author abbreviation\\nLists of cultivars'\n\nThe \\n newline characters in this string cause it to be displayed with multiple lines when it is printed or pasted from the clipboard. There are many \u201clines\u201d in this one string value. You want to add a star to the start of each of these lines.\n\nYou could write code that searches for each \\n newline character in the string and then adds the star just after that. But it would be easier to use the split() method to return a list of strings, one for each line in the original string, and then add the star to the front of each string in the list.\n\nMake your program look like the following:\n\n#! python3 # bulletPointAdder.py - Adds Wikipedia bullet points to the start # of each line of text on the clipboard. import pyperclip text = pyperclip.paste() # Separate lines and add stars. lines = text.split('\\n') for i in range(len(lines)):\u00a0\u00a0\u00a0\u00a0# loop through all indexes in the \"lines\" list lines[i] = '* ' + lines[i] # add star to each string in \"lines\" list pyperclip.copy(text)\n\nWe split the text along its newlines to get a list in which each item is one line of the text. We store the list in lines and then loop through the items in lines . For each line, we add a star and a space to the start of the line. Now each string in lines begins with a star.\n\n#### Step 3: Join the Modified Lines\n\nThe lines list now contains modified lines that start with stars. But pyperclip.copy() is expecting a single string value, however, not a list of string values. To make this single string value, pass lines into the join() method to get a single string joined from the list\u2019s strings. Make your program look like the following:\n\n#! python3 # bulletPointAdder.py - Adds Wikipedia bullet points to the start # of each line of text on the clipboard. import pyperclip text = pyperclip.paste() # Separate lines and add stars. lines = text.split('\\n') for i in range(len(lines)):\u00a0\u00a0\u00a0\u00a0# loop through all indexes for \"lines\" list lines[i] = '* ' + lines[i] # add star to each string in \"lines\" list text = '\\n'.join(lines) pyperclip.copy(text)\n\nWhen this program is run, it replaces the text on the clipboard with text that has stars at the start of each line. Now the program is complete, and you can try running it with text copied to the clipboard.\n\nEven if you don\u2019t need to automate this specific task, you might want to automate some other kind of text manipulation, such as removing trailing spaces from the end of lines or converting text to uppercase or lowercase. Whatever your needs, you can use the clipboard for input and output.\n\n### A Short Program: Pig Latin\n\nPig Latin is a silly made-up language that alters English words. If a word begins with a vowel, the word yay is added to the end of it. If a word begins with a consonant or consonant cluster (like ch or gr ), that consonant or cluster is moved to the end of the word followed by ay .\n\nLet\u2019s write a Pig Latin program that will output something like this:\n\nEnter the English message to translate into Pig Latin: My name is AL SWEIGART and I am 4,000 years old. Ymay amenay isyay ALYAY EIGARTSWAY andyay Iyay amyay 4,000 yearsyay oldyay.\n\nThis program works by altering a string using the methods introduced in this chapter. Type the following source code into the file editor, and save the file as pigLat.py :\n\n# English to Pig Latin print('Enter the English message to translate into Pig Latin:') message = input() VOWELS = ('a', 'e', 'i', 'o', 'u', 'y') pigLatin = [] # A list of the words in Pig Latin. for word in message.split(): # Separate the non-letters at the start of this word: prefixNonLetters = '' while len(word) > 0 and not word[0].isalpha(): prefixNonLetters += word[0] word = word[1:] if len(word) == 0: pigLatin.append(prefixNonLetters) continue # Separate the non-letters at the end of this word: suffixNonLetters = '' while not word[-1].isalpha(): suffixNonLetters = word[-1] + suffixNonLetters word = word[:-1] # Remember if the word was in uppercase or title case. wasUpper = word.isupper() wasTitle = word.istitle() word = word.lower() # Make the word lowercase for translation. # Separate the consonants at the start of this word: prefixConsonants = '' while len(word) > 0 and not word[0] in VOWELS: prefixConsonants += word[0] word = word[1:] # Add the Pig Latin ending to the word: if prefixConsonants != '': word += prefixConsonants + 'ay' else: word += 'yay' # Set the word back to uppercase or title case: if wasUpper: word = word.upper() if wasTitle: word = word.title() # Add the non-letters back to the start or end of the word. pigLatin.append(prefixNonLetters + word + suffixNonLetters) # Join all the words back together into a single string: print(' '.join(pigLatin))\n\nLet\u2019s look at this code line by line, starting at the top:\n\n# English to Pig Latin print('Enter the English message to translate into Pig Latin:') message = input() VOWELS = ('a', 'e', 'i', 'o', 'u', 'y')\n\nFirst, we ask the user to enter the English text to translate into Pig Latin. Also, we create a constant that holds every lowercase vowel letter (and y ) as a tuple of strings. This will be used later in our program.\n\nNext, we\u2019re going to create the pigLatin variable to store the words as we translate them into Pig Latin:\n\npigLatin = [] # A list of the words in Pig Latin. for word in message.split(): # Separate the non-letters at the start of this word: prefixNonLetters = '' while len(word) > 0 and not word[0].isalpha(): prefixNonLetters += word[0] word = word[1:] if len(word) == 0: pigLatin.append(prefixNonLetters) continue\n\nWe need each word to be its own string, so we call message.split() to get a list of the words as separate strings. The string 'My name is AL SWEIGART and I am 4,000 years old.' would cause split() to return ['My', 'name', 'is', 'AL', 'SWEIGART', 'and', 'I', 'am', '4,000', 'years', 'old.'] .\n\nWe need to remove any non-letters from the start and end of each word so that strings like 'old.' translate to 'oldyay.' instead of 'old.yay' . We\u2019ll save these non-letters to a variable named prefixNonLetters .\n\n# Separate the non-letters at the end of this word: suffixNonLetters = '' while not word[-1].isalpha(): suffixNonLetters = word[-1] + suffixNonLetters word = word[:-1]\n\nA loop that calls isalpha() on the first character in the word will determine if we should remove a character from a word and concatenate it to the end of prefixNonLetters . If the entire word is made of non-letter characters, like '4,000' , we can simply append it to the pigLatin list and continue to the next word to translate. We also need to save the non-letters at the end of the word string. This code is similar to the previous loop.\n\nNext, we\u2019ll make sure the program remembers if the word was in uppercase or title case so we can restore it after translating the word to Pig Latin:\n\n# Remember if the word was in uppercase or title case. wasUpper = word.isupper() wasTitle = word.istitle() word = word.lower() # Make the word lowercase for translation.\n\nFor the rest of the code in the for loop, we\u2019ll work on a lowercase version of word .\n\nTo convert a word like sweigart to eigart-sway , we need to remove all of the consonants from the beginning of word :\n\n# Separate the consonants at the start of this word: prefixConsonants = '' while len(word) > 0 and not word[0] in VOWELS: prefixConsonants += word[0] word = word[1:]\n\nWe use a loop similar to the loop that removed the non-letters from the start of word , except now we are pulling off consonants and storing them to a variable named prefixConsonants .\n\nIf there were any consonants at the start of the word, they are now in prefixConsonants and we should concatenate that variable and the string 'ay' to the end of word . Otherwise, we can assume word begins with a vowel and we only need to concatenate 'yay' :\n\n# Add the Pig Latin ending to the word: if prefixConsonants != '': word += prefixConsonants + 'ay' else: word += 'yay'\n\nRecall that we set word to its lowercase version with word = word.lower() . If word was originally in uppercase or title case, this code will convert word back to its original case:\n\n# Set the word back to uppercase or title case: if wasUpper: word = word.upper() if wasTitle: word = word.title()\n\nAt the end of the for loop, we append the word, along with any non-letter prefix or suffix it originally had, to the pigLatin list:\n\n# Add the non-letters back to the start or end of the word. pigLatin.append(prefixNonLetters + word + suffixNonLetters) # Join all the words back together into a single string: print(' '.join(pigLatin))\n\nAfter this loop finishes, we combine the list of strings into a single string by calling the join() method. This single string is passed to print() to display our Pig Latin on the screen.\n\nYou can find other short, text-based Python programs like this one at https://github.com/asweigart/pythonstdiogames/ .\n\n### Summary\n\nText is a common form of data, and Python comes with many helpful string methods to process the text stored in string values. You will make use of indexing, slicing, and string methods in almost every Python program you write.\n\nThe programs you are writing now don\u2019t seem too sophisticated\u2014they don\u2019t have graphical user interfaces with images and colorful text. So far, you\u2019re displaying text with print() and letting the user enter text with input() . However, the user can quickly enter large amounts of text through the clipboard. This ability provides a useful avenue for writing programs that manipulate massive amounts of text. These text-based programs might not have flashy windows or graphics, but they can get a lot of useful work done quickly.\n\nAnother way to manipulate large amounts of text is reading and writing files directly off the hard drive. You\u2019ll learn how to do this with Python in Chapter 9.\n\nThat just about covers all the basic concepts of Python programming! You\u2019ll continue to learn new concepts throughout the rest of this book, but you now know enough to start writing some useful programs that can automate tasks. If you\u2019d like to see a collection of short, simple Python programs built from the basic concepts you\u2019ve learned so far, check out https://github.com/asweigart/pythonstdiogames/ . Try copying the source code for each program by hand, and then make modifications to see how they affect the behavior of the program. Once you have an understanding of how the program works, try re-creating the program yourself from scratch. You don\u2019t need to re-create the source code exactly; just focus on what the program does rather than how it does it.\n\nYou might not think you have enough Python knowledge to do things such as download web pages, update spreadsheets, or send text messages, but that\u2019s where Python modules come in! These modules, written by other programmers, provide functions that make it easy for you to do all these things. So let\u2019s learn how to write real programs to do useful automated tasks.\n\n### Practice Questions\n\n1. What are escape characters?\n\n2. What do the \\n and \\t escape characters represent?\n\n3. How can you put a \\ backslash character in a string?\n\n4. The string value \"Howl's Moving Castle\" is a valid string. Why isn\u2019t it a problem that the single quote character in the word Howl's isn\u2019t escaped?\n\n5. If you don\u2019t want to put \\n in your string, how can you write a string with newlines in it?\n\n6. What do the following expressions evaluate to?\n\n- 'Hello, world!'[1]\n- 'Hello, world!'[0:5]\n- 'Hello, world!'[:5]\n- 'Hello, world!'[3:]\n\n7. What do the following expressions evaluate to?\n\n- 'Hello'.upper()\n- 'Hello'.upper().isupper()\n- 'Hello'.upper().lower()\n\n8. What do the following expressions evaluate to?\n\n- 'Remember, remember, the fifth of November.'.split()\n- '-'.join('There can be only one.'.split())\n\n9. What string methods can you use to right-justify, left-justify, and center a string?\n\n10. How can you trim whitespace characters from the beginning or end of a string?\n\n### Practice Projects\n\nFor practice, write programs that do the following.\n\n#### Table Printer\n\nWrite a function named printTable() that takes a list of lists of strings and displays it in a well-organized table with each column right-justified. Assume that all the inner lists will contain the same number of strings. For example, the value could look like this:\n\ntableData = [['apples', 'oranges', 'cherries', 'banana'], ['Alice', 'Bob', 'Carol', 'David'], ['dogs', 'cats', 'moose', 'goose']]\n\nYour printTable() function would print the following:\n\napples Alice\u00a0\u00a0dogs oranges\u00a0\u00a0\u00a0Bob\u00a0\u00a0cats cherries Carol moose banana David goose\n\nHint: your code will first have to find the longest string in each of the inner lists so that the whole column can be wide enough to fit all the strings. You can store the maximum width of each column as a list of integers. The printTable() function can begin with colWidths = [0] * len(tableData) , which will create a list containing the same number of 0 values as the number of inner lists in tableData . That way, colWidths[0] can store the width of the longest string in tableData[0] , colWidths[1] can store the width of the longest string in tableData[1] , and so on. You can then find the largest value in the colWidths list to find out what integer width to pass to the rjust() string method.\n\n#### Zombie Dice Bots\n\nProgramming games are a game genre where instead of playing a game directly, players write bot programs to play the game autonomously. I\u2019ve created a Zombie Dice simulator, which allows programmers to practice their skills while making game-playing AIs. Zombie Dice bots can be simple or incredibly complex, and are great for a class exercise or an individual programming challenge.\n\nZombie Dice is a quick, fun dice game from Steve Jackson Games. The players are zombies trying to eat as many human brains as possible without getting shot three times. There is a cup of 13 dice with brains, footsteps, and shotgun icons on their faces. The dice icons are colored, and each color has a different likelihood of each event occurring. Every die has two sides with footsteps, but dice with green icons have more sides with brains, red-icon dice have more shotguns, and yellow-icon dice have an even split of brains and shotguns. Do the following on each player\u2019s turn:\n\n- Place all 13 dice in the cup. The player randomly draws three dice from the cup and then rolls them. Players always roll exactly three dice.\n- They set aside and count up any brains (humans whose brains were eaten) and shotguns (humans who fought back). Accumulating three shotguns automatically ends a player\u2019s turn with zero points (regardless of how many brains they had). If they have between zero and two shotguns, they may continue rolling if they want. They may also choose to end their turn and collect one point per brain.\n- If the player decides to keep rolling, they must reroll all dice with footsteps. Remember that the player must always roll three dice; they must draw more dice out of the cup if they have fewer than three footsteps to roll. A player may keep rolling dice until either they get three shotguns\u2014losing everything\u2014or all 13 dice have been rolled. A player may not reroll only one or two dice, and may not stop mid-reroll.\n- When someone reaches 13 brains, the rest of the players finish out the round. The person with the most brains wins. If there\u2019s a tie, the tied players play one last tiebreaker round.\n\nZombie Dice has a push-your-luck game mechanic: the more you reroll the dice, the more brains you can get, but the more likely you\u2019ll eventually accrue three shotguns and lose everything. Once a player reaches 13 points, the rest of the players get one more turn (to potentially catch up) and the game ends. The player with the most points wins. You can find the complete rules at https://github.com/asweigart/zombiedice/ .\n\nInstall the zombiedice module with pip by following the instructions in Appendix A. You can run a demo of the simulator with some pre-made bots by running the following in the interactive shell:\n\n>>> import zombiedice >>> zombiedice.demo() Zombie Dice Visualization is running. Open your browser to http:// localhost:51810 to view it. Press Ctrl-C to quit.\n\nThe program launches your web browser, which will look like Figure 6-1.\n\nFigure 6-1: The web GUI for the Zombie Dice simulator\n\nYou\u2019ll create bots by writing a class with a turn() method, which is called by the simulator when it\u2019s your bot\u2019s turn to roll the dice. Classes are beyond the scope of this book, so the class code is already set up for you in the myzombie.py program, which is in the downloadable ZIP file for this book at https://nostarch.com/automatestuff2/ . Writing a method is essentially the same as writing a function, and you can use the turn() code in the myZombie.py program as a template. Inside this turn() method, you\u2019ll call the zombiedice.roll() function as often as you want your bot to roll the dice.\n\nimport zombiedice class MyZombie: def __init__(self, name): # All zombies must have a name: self.name = name def turn(self, gameState): # gameState is a dict with info about the current state of the game. # You can choose to ignore it in your code. diceRollResults = zombiedice.roll() # first roll # roll() returns a dictionary with keys 'brains', 'shotgun', and # 'footsteps' with how many rolls of each type there were. # The 'rolls' key is a list of (color, icon) tuples with the # exact roll result information. # Example of a roll() return value: # {'brains': 1, 'footsteps': 1, 'shotgun': 1, #\u00a0\u00a0'rolls': [('yellow', 'brains'), ('red', 'footsteps'), #\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0('green', 'shotgun')]} # REPLACE THIS ZOMBIE CODE WITH YOUR OWN: brains = 0 while diceRollResults is not None: brains += diceRollResults['brains'] if brains < 2: diceRollResults = zombiedice.roll() # roll again else: break zombies = ( zombiedice.examples.RandomCoinFlipZombie(name='Random'), zombiedice.examples.RollsUntilInTheLeadZombie(name='Until Leading'), zombiedice.examples.MinNumShotgunsThenStopsZombie(name='Stop at 2 Shotguns', minShotguns=2), zombiedice.examples.MinNumShotgunsThenStopsZombie(name='Stop at 1 Shotgun', minShotguns=1), MyZombie(name='My Zombie Bot'), # Add any other zombie players here. ) # Uncomment one of the following lines to run in CLI or Web GUI mode: #zombiedice.runTournament(zombies=zombies, numGames=1000) zombiedice.runWebGui(zombies=zombies, numGames=1000)\n\nThe turn() method takes two parameters: self and gameState . You can ignore these in your first few zombie bots and consult the online documentation for details later if you want to learn more. The turn() method should call zombiedice.roll() at least once for the initial roll. Then, depending on the strategy the bot uses, it can call zombiedice.roll() again as many times as it wants. In myZombie.py , the turn() method calls zombiedice.roll() twice, which means the zombie bot will always roll its dice two times per turn regardless of the results of the roll.\n\nThe return value of zombiedice.roll() tells your code the results of the dice roll. It is a dictionary with four keys. Three of the keys, 'shotgun' , 'brains' , and 'footsteps' , have integer values of how many dice came up with those icons. The fourth 'rolls' key has a value that is a list of tuples for each die roll. The tuples contain two strings: the color of the die at index 0 and the icon rolled at index 1 . Look at the code comments in the turn() method\u2019s definition for an example. If the bot has already rolled three shotguns, then zombiedice.roll() will return None .\n\nTry writing some of your own bots to play Zombie Dice and see how they compare against the other bots. Specifically, try to create the following bots:\n\n- A bot that, after the first roll, randomly decides if it will continue or stop\n- A bot that stops rolling after it has rolled two brains\n- A bot that stops rolling after it has rolled two shotguns\n- A bot that initially decides it\u2019ll roll the dice one to four times, but will stop early if it rolls two shotguns\n- A bot that stops rolling after it has rolled more shotguns than brains\n\nRun these bots through the simulator and see how they compare to each other. You can also examine the code of some premade bots at https://github.com/asweigart/zombiedice/ . If you find yourself playing this game in the real world, you\u2019ll have the benefit of thousands of simulated games telling you that one of the best strategies is to simply stop once you\u2019ve rolled two shotguns. But you could always try pressing your luck . . .",
      "difficulty": "intro",
      "doc_id": "doc-6manipulating-strings-3078131358",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-NC-SA 3.0",
        "source_file": "data/corpus_raw/scraped/2e_chapter6_bf44ee.json",
        "url": "https://automatetheboringstuff.com/2e/chapter6/"
      },
      "title": "6MANIPULATING STRINGS",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "file_io",
        "formatting",
        "strings"
      ],
      "content": "# 7.Input and Output\u00c2\u00b6\n\nThere are several ways to present the output of a program; data can be printed\nin a human-readable form, or written to a file for future use. This chapter will\ndiscuss some of the possibilities.\n\n## 7.1.Fancier Output Formatting\u00c2\u00b6\n\nSo far we\u00e2\u0080\u0099ve encountered two ways of writing values: expression statements and\nthe print() function.  (A third way is using the write() method\nof file objects; the standard output file can be referenced as sys.stdout .\nSee the Library Reference for more information on this.)\n\nOften you\u00e2\u0080\u0099ll want more control over the formatting of your output than simply\nprinting space-separated values. There are several ways to format output.\n\n- To use formatted string literals , begin a string\nwith f or F before the opening quotation mark or triple quotation mark.\nInside this string, you can write a Python expression between { and } characters that can refer to variables or literal values. >>> year = 2016 >>> event = 'Referendum' >>> f 'Results of the { year } { event } ' 'Results of the 2016 Referendum'\n- The str.format() method of strings requires more manual\neffort.  You\u00e2\u0080\u0099ll still use { and } to mark where a variable\nwill be substituted and can provide detailed formatting directives,\nbut you\u00e2\u0080\u0099ll also need to provide the information to be formatted. In the following code\nblock there are two examples of how to format variables: >>> yes_votes = 42_572_654 >>> total_votes = 85_705_149 >>> percentage = yes_votes / total_votes >>> ' {:-9} YES votes {:2.2%} ' . format ( yes_votes , percentage ) ' 42572654 YES votes  49.67%' Notice how the yes_votes are padded with spaces and a negative sign only for negative numbers.\nThe example also prints percentage multiplied by 100, with 2 decimal\nplaces and followed by a percent sign (see Format Specification Mini-Language for details).\n- Finally, you can do all the string handling yourself by using string slicing and\nconcatenation operations to create any layout you can imagine.  The\nstring type has some methods that perform useful operations for padding\nstrings to a given column width.\n\nWhen you don\u00e2\u0080\u0099t need fancy output but just want a quick display of some\nvariables for debugging purposes, you can convert any value to a string with\nthe repr() or str() functions.\n\nThe str() function is meant to return representations of values which are\nfairly human-readable, while repr() is meant to generate representations\nwhich can be read by the interpreter (or will force a SyntaxError if\nthere is no equivalent syntax).  For objects which don\u00e2\u0080\u0099t have a particular\nrepresentation for human consumption, str() will return the same value as repr() .  Many values, such as numbers or structures like lists and\ndictionaries, have the same representation using either function.  Strings, in\nparticular, have two distinct representations.\n\nSome examples:\n\n```python\n>>> s = 'Hello, world.'\n>>> str(s)\n'Hello, world.'\n>>> repr(s)\n\"'Hello, world.'\"\n>>> str(1/7)\n'0.14285714285714285'\n>>> x = 10 * 3.25\n>>> y = 200 * 200\n>>> s = 'The value of x is ' + repr(x) + ', and y is ' + repr(y) + '...'\n>>> print(s)\nThe value of x is 32.5, and y is 40000...\n>>> # The repr() of a string adds string quotes and backslashes:\n>>> hello = 'hello, world\\n'\n>>> hellos = repr(hello)\n>>> print(hellos)\n'hello, world\\n'\n>>> # The argument to repr() may be any Python object:\n>>> repr((x, y, ('spam', 'eggs')))\n\"(32.5, 40000, ('spam', 'eggs'))\"\n```python\n\nThe string module contains support for a simple templating approach\nbased upon regular expressions, via string.Template .\nThis offers yet another way to substitute values into strings,\nusing placeholders like $x and replacing them with values from a dictionary.\nThis syntax is easy to use, although it offers much less control for formatting.\n\n### 7.1.1.Formatted String Literals\u00c2\u00b6\n\nFormatted string literals (also called f-strings for\nshort) let you include the value of Python expressions inside a string by\nprefixing the string with f or F and writing expressions as {expression} .\n\nAn optional format specifier can follow the expression. This allows greater\ncontrol over how the value is formatted. The following example rounds pi to\nthree places after the decimal:\n\n```python\n>>> import math\n>>> print(f'The value of pi is approximately {math.pi:.3f}.')\nThe value of pi is approximately 3.142.\n```python\n\nPassing an integer after the ':' will cause that field to be a minimum\nnumber of characters wide.  This is useful for making columns line up.\n\n```python\n>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}\n>>> for name, phone in table.items():\n...     print(f'{name:10} ==> {phone:10d}')\n...\nSjoerd     ==>       4127\nJack       ==>       4098\nDcab       ==>       7678\n```python\n\nOther modifiers can be used to convert the value before it is formatted. '!a' applies ascii() , '!s' applies str() , and '!r' applies repr() :\n\n```python\n>>> animals = 'eels'\n>>> print(f'My hovercraft is full of {animals}.')\nMy hovercraft is full of eels.\n>>> print(f'My hovercraft is full of {animals!r}.')\nMy hovercraft is full of 'eels'.\n```python\n\nThe = specifier can be used to expand an expression to the text of the\nexpression, an equal sign, then the representation of the evaluated expression:\n\n```python\n>>> bugs = 'roaches'\n>>> count = 13\n>>> area = 'living room'\n>>> print(f'Debugging {bugs=} {count=} {area=}')\nDebugging bugs='roaches' count=13 area='living room'\n```python\n\nSee self-documenting expressions for more information\non the = specifier. For a reference on these format specifications, see\nthe reference guide for the Format Specification Mini-Language .\n\n### 7.1.2.The String format() Method\u00c2\u00b6\n\nBasic usage of the str.format() method looks like this:\n\n```python\n>>> print('We are the {} who say \"{}!\"'.format('knights', 'Ni'))\nWe are the knights who say \"Ni!\"\n```python\n\nThe brackets and characters within them (called format fields) are replaced with\nthe objects passed into the str.format() method.  A number in the\nbrackets can be used to refer to the position of the object passed into the str.format() method.\n\n```python\n>>> print('{0} and {1}'.format('spam', 'eggs'))\nspam and eggs\n>>> print('{1} and {0}'.format('spam', 'eggs'))\neggs and spam\n```python\n\nIf keyword arguments are used in the str.format() method, their values\nare referred to by using the name of the argument.\n\n```python\n>>> print('This {food} is {adjective}.'.format(\n...       food='spam', adjective='absolutely horrible'))\nThis spam is absolutely horrible.\n```python\n\nPositional and keyword arguments can be arbitrarily combined:\n\n```python\n>>> print('The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred',\n...                                                    other='Georg'))\nThe story of Bill, Manfred, and Georg.\n```python\n\nIf you have a really long format string that you don\u00e2\u0080\u0099t want to split up, it\nwould be nice if you could reference the variables to be formatted by name\ninstead of by position.  This can be done by simply passing the dict and using\nsquare brackets '[]' to access the keys.\n\n```python\n>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}\n>>> print('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; '\n...       'Dcab: {0[Dcab]:d}'.format(table))\nJack: 4098; Sjoerd: 4127; Dcab: 8637678\n```python\n\nThis could also be done by passing the table dictionary as keyword arguments with the ** notation.\n\n```python\n>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}\n>>> print('Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: {Dcab:d}'.format(**table))\nJack: 4098; Sjoerd: 4127; Dcab: 8637678\n```python\n\nThis is particularly useful in combination with the built-in function vars() , which returns a dictionary containing all local variables:\n\n```python\n>>> table = {k: str(v) for k, v in vars().items()}\n>>> message = \" \".join([f'{k}: ' + '{' + k +'};' for k in table.keys()])\n>>> print(message.format(**table))\n__name__: __main__; __doc__: None; __package__: None; __loader__: ...\n```python\n\nAs an example, the following lines produce a tidily aligned\nset of columns giving integers and their squares and cubes:\n\n```python\n>>> for x in range(1, 11):\n...     print('{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x))\n...\n 1   1    1\n 2   4    8\n 3   9   27\n 4  16   64\n 5  25  125\n 6  36  216\n 7  49  343\n 8  64  512\n 9  81  729\n10 100 1000\n```python\n\nFor a complete overview of string formatting with str.format() , see Format String Syntax .\n\n### 7.1.3.Manual String Formatting\u00c2\u00b6\n\nHere\u00e2\u0080\u0099s the same table of squares and cubes, formatted manually:\n\n```python\n>>> for x in range(1, 11):\n...     print(repr(x).rjust(2), repr(x*x).rjust(3), end=' ')\n...     # Note use of 'end' on previous line\n...     print(repr(x*x*x).rjust(4))\n...\n 1   1    1\n 2   4    8\n 3   9   27\n 4  16   64\n 5  25  125\n 6  36  216\n 7  49  343\n 8  64  512\n 9  81  729\n10 100 1000\n```python\n\n(Note that the one space between each column was added by the\nway print() works: it always adds spaces between its arguments.)\n\nThe str.rjust() method of string objects right-justifies a string in a\nfield of a given width by padding it with spaces on the left. There are\nsimilar methods str.ljust() and str.center() . These methods do\nnot write anything, they just return a new string. If the input string is too\nlong, they don\u00e2\u0080\u0099t truncate it, but return it unchanged; this will mess up your\ncolumn lay-out but that\u00e2\u0080\u0099s usually better than the alternative, which would be\nlying about a value. (If you really want truncation you can always add a\nslice operation, as in x.ljust(n)[:n] .)\n\nThere is another method, str.zfill() , which pads a numeric string on the\nleft with zeros.  It understands about plus and minus signs:\n\n```python\n>>> '12'.zfill(5)\n'00012'\n>>> '-3.14'.zfill(7)\n'-003.14'\n>>> '3.14159265359'.zfill(5)\n'3.14159265359'\n```python\n\n### 7.1.4.Old string formatting\u00c2\u00b6\n\nThe % operator (modulo) can also be used for string formatting.\nGiven format % values (where format is a string), % conversion specifications in format are replaced with\nzero or more elements of values .\nThis operation is commonly known as string\ninterpolation. For example:\n\n```python\n>>> import math\n>>> print('The value of pi is approximately %5.3f.' % math.pi)\nThe value of pi is approximately 3.142.\n```python\n\nMore information can be found in the printf-style String Formatting section.\n\n## 7.2.Reading and Writing Files\u00c2\u00b6\n\nopen() returns a file object , and is most commonly used with\ntwo positional arguments and one keyword argument: open(filename, mode, encoding=None)\n\n```python\n>>> f = open('workfile', 'w', encoding=\"utf-8\")\n```python\n\nThe first argument is a string containing the filename.  The second argument is\nanother string containing a few characters describing the way in which the file\nwill be used. mode can be 'r' when the file will only be read, 'w' for only writing (an existing file with the same name will be erased), and 'a' opens the file for appending; any data written to the file is\nautomatically added to the end. 'r+' opens the file for both reading and\nwriting. The mode argument is optional; 'r' will be assumed if it\u00e2\u0080\u0099s\nomitted.\n\nNormally, files are opened in text mode , that means, you read and write\nstrings from and to the file, which are encoded in a specific encoding .\nIf encoding is not specified, the default is platform dependent\n(see open() ).\nBecause UTF-8 is the modern de-facto standard, encoding=\"utf-8\" is\nrecommended unless you know that you need to use a different encoding.\nAppending a 'b' to the mode opens the file in binary mode .\nBinary mode data is read and written as bytes objects.\nYou can not specify encoding when opening file in binary mode.\n\nIn text mode, the default when reading is to convert platform-specific line\nendings ( \\n on Unix, \\r\\n on Windows) to just \\n .  When writing in\ntext mode, the default is to convert occurrences of \\n back to\nplatform-specific line endings.  This behind-the-scenes modification\nto file data is fine for text files, but will corrupt binary data like that in JPEG or EXE files.  Be very careful to use binary mode when\nreading and writing such files.\n\nIt is good practice to use the with keyword when dealing\nwith file objects.  The advantage is that the file is properly closed\nafter its suite finishes, even if an exception is raised at some\npoint.  Using with is also much shorter than writing\nequivalent try - finally blocks:\n\n```python\n>>> with open('workfile', encoding=\"utf-8\") as f:\n...     read_data = f.read()\n\n>>> # We can check that the file has been automatically closed.\n>>> f.closed\nTrue\n```python\n\nIf you\u00e2\u0080\u0099re not using the with keyword, then you should call f.close() to close the file and immediately free up any system\nresources used by it.\n\nWarning\n\nCalling f.write() without using the with keyword or calling f.close() might result in the arguments\nof f.write() not being completely written to the disk, even if the\nprogram exits successfully.\n\nAfter a file object is closed, either by a with statement\nor by calling f.close() , attempts to use the file object will\nautomatically fail.\n\n```python\n>>> f.close()\n>>> f.read()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: I/O operation on closed file.\n```python\n\n### 7.2.1.Methods of File Objects\u00c2\u00b6\n\nThe rest of the examples in this section will assume that a file object called f has already been created.\n\nTo read a file\u00e2\u0080\u0099s contents, call f.read(size) , which reads some quantity of\ndata and returns it as a string (in text mode) or bytes object (in binary mode). size is an optional numeric argument.  When size is omitted or negative, the\nentire contents of the file will be read and returned; it\u00e2\u0080\u0099s your problem if the\nfile is twice as large as your machine\u00e2\u0080\u0099s memory. Otherwise, at most size characters (in text mode) or size bytes (in binary mode) are read and returned.\nIf the end of the file has been reached, f.read() will return an empty\nstring ( '' ).\n\n```python\n>>> f.read()\n'This is the entire file.\\n'\n>>> f.read()\n''\n```python\n\nf.readline() reads a single line from the file; a newline character ( \\n )\nis left at the end of the string, and is only omitted on the last line of the\nfile if the file doesn\u00e2\u0080\u0099t end in a newline.  This makes the return value\nunambiguous; if f.readline() returns an empty string, the end of the file\nhas been reached, while a blank line is represented by '\\n' , a string\ncontaining only a single newline.\n\n```python\n>>> f.readline()\n'This is the first line of the file.\\n'\n>>> f.readline()\n'Second line of the file\\n'\n>>> f.readline()\n''\n```python\n\nFor reading lines from a file, you can loop over the file object. This is memory\nefficient, fast, and leads to simple code:\n\n```python\n>>> for line in f:\n...     print(line, end='')\n...\nThis is the first line of the file.\nSecond line of the file\n```python\n\nIf you want to read all the lines of a file in a list you can also use list(f) or f.readlines() .\n\nf.write(string) writes the contents of string to the file, returning\nthe number of characters written.\n\n```python\n>>> f.write('This is a test\\n')\n15\n```python\n\nOther types of objects need to be converted \u00e2\u0080\u0093 either to a string (in text mode)\nor a bytes object (in binary mode) \u00e2\u0080\u0093 before writing them:\n\n```python\n>>> value = ('the answer', 42)\n>>> s = str(value)  # convert the tuple to string\n>>> f.write(s)\n18\n```python\n\nf.tell() returns an integer giving the file object\u00e2\u0080\u0099s current position in the file\nrepresented as number of bytes from the beginning of the file when in binary mode and\nan opaque number when in text mode.\n\nTo change the file object\u00e2\u0080\u0099s position, use f.seek(offset, whence) .  The position is computed\nfrom adding offset to a reference point; the reference point is selected by\nthe whence argument.  A whence value of 0 measures from the beginning\nof the file, 1 uses the current file position, and 2 uses the end of the file as\nthe reference point. whence can be omitted and defaults to 0, using the\nbeginning of the file as the reference point.\n\n```python\n>>> f = open('workfile', 'rb+')\n>>> f.write(b'0123456789abcdef')\n16\n>>> f.seek(5)      # Go to the 6th byte in the file\n5\n>>> f.read(1)\nb'5'\n>>> f.seek(-3, 2)  # Go to the 3rd byte before the end\n13\n>>> f.read(1)\nb'd'\n```python\n\nIn text files (those opened without a b in the mode string), only seeks\nrelative to the beginning of the file are allowed (the exception being seeking\nto the very file end with seek(0, 2) ) and the only valid offset values are\nthose returned from the f.tell() , or zero. Any other offset value produces\nundefined behaviour.\n\nFile objects have some additional methods, such as isatty() and truncate() which are less frequently used; consult the Library\nReference for a complete guide to file objects.\n\n### 7.2.2.Saving structured data withjson\u00c2\u00b6\n\nStrings can easily be written to and read from a file.  Numbers take a bit more\neffort, since the read() method only returns strings, which will have to\nbe passed to a function like int() , which takes a string like '123' and returns its numeric value 123.  When you want to save more complex data\ntypes like nested lists and dictionaries, parsing and serializing by hand\nbecomes complicated.\n\nRather than having users constantly writing and debugging code to save\ncomplicated data types to files, Python allows you to use the popular data\ninterchange format called JSON (JavaScript Object Notation) .  The standard module called json can take Python\ndata hierarchies, and convert them to string representations; this process is\ncalled serializing .  Reconstructing the data from the string representation\nis called deserializing .  Between serializing and deserializing, the\nstring representing the object may have been stored in a file or data, or\nsent over a network connection to some distant machine.\n\nNote\n\nThe JSON format is commonly used by modern applications to allow for data\nexchange.  Many programmers are already familiar with it, which makes\nit a good choice for interoperability.\n\nIf you have an object x , you can view its JSON string representation with a\nsimple line of code:\n\n```python\n>>> import json\n>>> x = [1, 'simple', 'list']\n>>> json.dumps(x)\n'[1, \"simple\", \"list\"]'\n```python\n\nAnother variant of the dumps() function, called dump() ,\nsimply serializes the object to a text file .  So if f is a text file object opened for writing, we can do this:\n\n```python\njson.dump(x, f)\n```python\n\nTo decode the object again, if f is a binary file or text file object which has been opened for reading:\n\n```python\nx = json.load(f)\n```python\n\nNote\n\nJSON files must be encoded in UTF-8. Use encoding=\"utf-8\" when opening\nJSON file as a text file for both of reading and writing.\n\nThis simple serialization technique can handle lists and dictionaries, but\nserializing arbitrary class instances in JSON requires a bit of extra effort.\nThe reference for the json module contains an explanation of this.\n\nSee also\n\npickle - the pickle module\n\nContrary to JSON , pickle is a protocol which allows\nthe serialization of arbitrarily complex Python objects.  As such, it is\nspecific to Python and cannot be used to communicate with applications\nwritten in other languages.  It is also insecure by default:\ndeserializing pickle data coming from an untrusted source can execute\narbitrary code, if the data was crafted by a skilled attacker.",
      "difficulty": "intro",
      "doc_id": "doc-7-input-and-output-6350c56c82",
      "provenance": {
        "author": "",
        "date": "",
        "license": "PSF Documentation License",
        "source_file": "data/corpus_raw/scraped/3_tutorial_inputoutput_html_d3ac38.json",
        "url": "https://docs.python.org/3/tutorial/inputoutput.html"
      },
      "title": "7.Input and Output\u00c2\u00b6",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "pattern_matching",
        "regex",
        "strings"
      ],
      "content": "## 7PATTERN MATCHING WITH REGULAR EXPRESSIONS\n\nYou may be familiar with searching for text by pressing CTRL- F and entering the words you\u2019re looking for. Regular expressions go one step further: they allow you to specify a pattern of text to search for. You may not know a business\u2019s exact phone number, but if you live in the United States or Canada, you know it will be three digits, followed by a hyphen, and then four more digits (and optionally, a three-digit area code at the start). This is how you, as a human, know a phone number when you see it: 415-555-1234 is a phone number, but 4,155,551,234 is not.\n\nWe also recognize all sorts of other text patterns every day: email addresses have @ symbols in the middle, US social security numbers have nine digits and two hyphens, website URLs often have periods and forward slashes, news headlines use title case, social media hashtags begin with # and contain no spaces, and more.\n\nRegular expressions are helpful, but few non-programmers know about them even though most modern text editors and word processors, such as Microsoft Word or OpenOffice, have find and find-and-replace features that can search based on regular expressions. Regular expressions are huge time-savers, not just for software users but also for programmers. In fact, tech writer Cory Doctorow argues that we should be teaching regular expressions even before programming:\n\nKnowing [regular expressions] can mean the difference between solving a problem in 3 steps and solving it in 3,000 steps. When you\u2019re a nerd, you forget that the problems you solve with a couple keystrokes can take other people days of tedious, error-prone work to slog through. 1\n\nIn this chapter, you\u2019ll start by writing a program to find text patterns without using regular expressions and then see how to use regular expressions to make the code much less bloated. I\u2019ll show you basic matching with regular expressions and then move on to some more powerful features, such as string substitution and creating your own character classes. Finally, at the end of the chapter, you\u2019ll write a program that can automatically extract phone numbers and email addresses from a block of text.\n\n### Finding Patterns of Text Without Regular Expressions\n\nSay you want to find an American phone number in a string. You know the pattern if you\u2019re American: three numbers, a hyphen, three numbers, a hyphen, and four numbers. Here\u2019s an example: 415-555-4242.\n\nLet\u2019s use a function named isPhoneNumber() to check whether a string matches this pattern, returning either True or False . Open a new file editor tab and enter the following code; then save the file as isPhoneNumber.py :\n\ndef isPhoneNumber(text): \u278a if len(text) != 12: return False for i in range(0, 3): \u278b if not text[i].isdecimal(): return False \u278c if text[3] != '-': return False for i in range(4, 7): \u278d if not text[i].isdecimal(): return False \u278e if text[7] != '-': return False for i in range(8, 12): \u278f if not text[i].isdecimal(): return False \u2790 return True print('Is 415-555-4242 a phone number?') print(isPhoneNumber('415-555-4242')) print('Is Moshi moshi a phone number?') print(isPhoneNumber('Moshi moshi'))\n\nWhen this program is run, the output looks like this:\n\nIs 415-555-4242 a phone number? True Is Moshi moshi a phone number? False\n\nThe isPhoneNumber() function has code that does several checks to see whether the string in text is a valid phone number. If any of these checks fail, the function returns False . First the code checks that the string is exactly 12 characters \u278a . Then it checks that the area code (that is, the first three characters in text ) consists of only numeric characters \u278b . The rest of the function checks that the string follows the pattern of a phone number: the number must have the first hyphen after the area code \u278c , three more numeric characters \u278d , then another hyphen \u278e , and finally four more numbers \u278f . If the program execution manages to get past all the checks, it returns True \u2790 .\n\nCalling isPhoneNumber() with the argument '415-555-4242' will return True . Calling isPhoneNumber() with 'Moshi moshi' will return False ; the first test fails because 'Moshi moshi' is not 12 characters long.\n\nIf you wanted to find a phone number within a larger string, you would have to add even more code to find the phone number pattern. Replace the last four print() function calls in isPhoneNumber.py with the following:\n\nmessage = 'Call me at 415-555-1011 tomorrow. 415-555-9999 is my office.' for i in range(len(message)): \u278a chunk = message[i:i+12] \u278b if isPhoneNumber(chunk): print('Phone number found: ' + chunk) print('Done')\n\nWhen this program is run, the output will look like this:\n\nPhone number found: 415-555-1011 Phone number found: 415-555-9999 Done\n\nOn each iteration of the for loop, a new chunk of 12 characters from message is assigned to the variable chunk \u278a . For example, on the first iteration, i is 0 , and chunk is assigned message[0:12] (that is, the string 'Call me at 4' ). On the next iteration, i is 1 , and chunk is assigned message[1:13] (the string 'all me at 41' ). In other words, on each iteration of the for loop, chunk takes on the following values:\n\n- 'Call me at 4'\n- 'all me at 41'\n- 'll me at 415'\n- 'l me at 415-'\n- . . . and so on.\n\nYou pass chunk to isPhoneNumber() to see whether it matches the phone number pattern \u278b , and if so, you print the chunk.\n\nContinue to loop through message , and eventually the 12 characters in chunk will be a phone number. The loop goes through the entire string, testing each 12-character piece and printing any chunk it finds that satisfies isPhoneNumber() . Once we\u2019re done going through message , we print Done .\n\nWhile the string in message is short in this example, it could be millions of characters long and the program would still run in less than a second. A similar program that finds phone numbers using regular expressions would also run in less than a second, but regular expressions make it quicker to write these programs.\n\n### Finding Patterns of Text with Regular Expressions\n\nThe previous phone number\u2013finding program works, but it uses a lot of code to do something limited: the isPhoneNumber() function is 17 lines but can find only one pattern of phone numbers. What about a phone number formatted like 415.555.4242 or (415) 555-4242? What if the phone number had an extension, like 415-555-4242 x99? The isPhoneNumber() function would fail to validate them. You could add yet more code for these additional patterns, but there is an easier way.\n\nRegular expressions, called regexes for short, are descriptions for a pattern of text. For example, a \\d in a regex stands for a digit character\u2014that is, any single numeral from 0 to 9. The regex \\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d is used by Python to match the same text pattern the previous isPhoneNumber() function did: a string of three numbers, a hyphen, three more numbers, another hyphen, and four numbers. Any other string would not match the \\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d regex.\n\nBut regular expressions can be much more sophisticated. For example, adding a 3 in braces ( {3} ) after a pattern is like saying, \u201cMatch this pattern three times.\u201d So the slightly shorter regex \\d{3}-\\d{3}-\\d{4} also matches the correct phone number format.\n\n#### Creating Regex Objects\n\nAll the regex functions in Python are in the re module. Enter the following into the interactive shell to import this module:\n\n>>> import re\n\nNOTE\n\nMost of the examples in this chapter will require the re module, so remember to import it at the beginning of any script you write or any time you restart Mu. Otherwise, you\u2019ll get a NameError: name 're' is not defined error message.\n\nPassing a string value representing your regular expression to re.compile() returns a Regex pattern object (or simply, a Regex object).\n\nTo create a Regex object that matches the phone number pattern, enter the following into the interactive shell. (Remember that \\d means \u201ca digit character\u201d and \\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d is the regular expression for a phone number pattern.)\n\n>>> phoneNumRegex = re.compile(r'\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d')\n\nNow the phoneNumRegex variable contains a Regex object.\n\n#### Matching Regex Objects\n\nA Regex object\u2019s search() method searches the string it is passed for any matches to the regex. The search() method will return None if the regex pattern is not found in the string. If the pattern is found, the search() method returns a Match object, which have a group() method that will return the actual matched text from the searched string. (I\u2019ll explain groups shortly.) For example, enter the following into the interactive shell:\n\n>>> phoneNumRegex = re.compile(r'\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d') >>> mo = phoneNumRegex.search('My number is 415-555-4242.') >>> print('Phone number found: ' + mo.group()) Phone number found: 415-555-4242\n\nThe mo variable name is just a generic name to use for Match objects. This example might seem complicated at first, but it is much shorter than the earlier isPhoneNumber.py program and does the same thing.\n\nHere, we pass our desired pattern to re.compile() and store the resulting Regex object in phoneNumRegex . Then we call search() on phoneNumRegex and pass search() the string we want to match for during the search. The result of the search gets stored in the variable mo . In this example, we know that our pattern will be found in the string, so we know that a Match object will be returned. Knowing that mo contains a Match object and not the null value None , we can call group() on mo to return the match. Writing mo.group() inside our print() function call displays the whole match, 415-555-4242 .\n\n#### Review of Regular Expression Matching\n\nWhile there are several steps to using regular expressions in Python, each step is fairly simple.\n\n- Import the regex module with import re .\n- Create a Regex object with the re.compile() function. (Remember to use a raw string.)\n- Pass the string you want to search into the Regex object\u2019s search() method. This returns a Match object.\n- Call the Match object\u2019s group() method to return a string of the actual matched text.\n\nNOTE\n\nWhile I encourage you to enter the example code into the interactive shell, you should also make use of web-based regular expression testers, which can show you exactly how a regex matches a piece of text that you enter. I recommend the tester at https://pythex.org/ .\n\n### More Pattern Matching with Regular Expressions\n\nNow that you know the basic steps for creating and finding regular expression objects using Python, you\u2019re ready to try some of their more powerful pattern-matching capabilities.\n\n#### Grouping with Parentheses\n\nSay you want to separate the area code from the rest of the phone number. Adding parentheses will create groups in the regex: (\\d\\d\\d)-(\\d\\d\\d-\\d\\d\\d\\d) . Then you can use the group() match object method to grab the matching text from just one group.\n\nThe first set of parentheses in a regex string will be group 1 . The second set will be group 2 . By passing the integer 1 or 2 to the group() match object method, you can grab different parts of the matched text. Passing 0 or nothing to the group() method will return the entire matched text. Enter the following into the interactive shell:\n\n>>> phoneNumRegex = re.compile(r'(\\d\\d\\d)-(\\d\\d\\d-\\d\\d\\d\\d)') >>> mo = phoneNumRegex.search('My number is 415-555-4242.') >>> mo.group(1) '415' >>> mo.group(2) '555-4242' >>> mo.group(0) '415-555-4242' >>> mo.group() '415-555-4242'\n\nIf you would like to retrieve all the groups at once, use the groups() method\u2014note the plural form for the name.\n\n>>> mo.groups() ('415', '555-4242') >>> areaCode, mainNumber = mo.groups() >>> print(areaCode) 415 >>> print(mainNumber) 555-4242\n\nSince mo.groups() returns a tuple of multiple values, you can use the multiple-assignment trick to assign each value to a separate variable, as in the previous areaCode, mainNumber = mo.groups() line.\n\nParentheses have a special meaning in regular expressions, but what do you do if you need to match a parenthesis in your text? For instance, maybe the phone numbers you are trying to match have the area code set in parentheses. In this case, you need to escape the ( and ) characters with a backslash. Enter the following into the interactive shell:\n\n>>> phoneNumRegex = re.compile(r'(\\(\\d\\d\\d\\)) (\\d\\d\\d-\\d\\d\\d\\d)') >>> mo = phoneNumRegex.search('My phone number is (415) 555-4242.') >>> mo.group(1) '(415)' >>> mo.group(2) '555-4242'\n\nThe \\( and \\) escape characters in the raw string passed to re.compile() will match actual parenthesis characters. In regular expressions, the following characters have special meanings:\n\n.\u00a0\u00a0^\u00a0\u00a0$\u00a0\u00a0*\u00a0\u00a0+\u00a0\u00a0?\u00a0\u00a0{\u00a0\u00a0}\u00a0\u00a0[\u00a0\u00a0]\u00a0\u00a0\\\u00a0\u00a0|\u00a0\u00a0(\u00a0\u00a0)\n\nIf you want to detect these characters as part of your text pattern, you need to escape them with a backslash:\n\n\\.\u00a0\u00a0\\^\u00a0\u00a0\\$\u00a0\u00a0\\*\u00a0\u00a0\\+\u00a0\u00a0\\?\u00a0\u00a0\\{\u00a0\u00a0\\}\u00a0\u00a0\\[\u00a0\u00a0\\]\u00a0\u00a0\\\\\u00a0\u00a0\\|\u00a0\u00a0\\(\u00a0\u00a0\\)\n\nMake sure to double-check that you haven\u2019t mistaken escaped parentheses \\( and \\) for parentheses ( and ) in a regular expression. If you receive an error message about \u201cmissing )\u201d or \u201cunbalanced parenthesis,\u201d you may have forgotten to include the closing unescaped parenthesis for a group, like in this example:\n\n>>> re.compile(r'(\\(Parentheses\\)') Traceback (most recent call last): -- snip -- re.error: missing ), unterminated subpattern at position 0\n\nThe error message tells you that there is an opening parenthesis at index 0 of the r'(\\(Parentheses\\)' string that is missing its corresponding closing parenthesis.\n\n#### Matching Multiple Groups with the Pipe\n\nThe | character is called a pipe . You can use it anywhere you want to match one of many expressions. For example, the regular expression r'Batman|Tina Fey' will match either 'Batman' or 'Tina Fey' .\n\nWhen both Batman and Tina Fey occur in the searched string, the first occurrence of matching text will be returned as the Match object. Enter the following into the interactive shell:\n\n>>> heroRegex = re.compile (r'Batman|Tina Fey') >>> mo1 = heroRegex.search('Batman and Tina Fey') >>> mo1.group() 'Batman' >>> mo2 = heroRegex.search('Tina Fey and Batman') >>> mo2.group() 'Tina Fey'\n\nNOTE\n\nYou can find all matching occurrences with the findall() method that\u2019s discussed in \u201cThe findall() Method\u201d on page 171.\n\nYou can also use the pipe to match one of several patterns as part of your regex. For example, say you wanted to match any of the strings 'Batman' , 'Batmobile' , 'Batcopter' , and 'Batbat' . Since all these strings start with Bat , it would be nice if you could specify that prefix only once. This can be done with parentheses. Enter the following into the interactive shell:\n\n>>> batRegex = re.compile(r'Bat(man|mobile|copter|bat)') >>> mo = batRegex.search('Batmobile lost a wheel') >>> mo.group() 'Batmobile' >>> mo.group(1) 'mobile'\n\nThe method call mo.group() returns the full matched text 'Batmobile' , while mo.group(1) returns just the part of the matched text inside the first parentheses group, 'mobile' . By using the pipe character and grouping parentheses, you can specify several alternative patterns you would like your regex to match.\n\nIf you need to match an actual pipe character, escape it with a backslash, like \\| .\n\n#### Optional Matching with the Question Mark\n\nSometimes there is a pattern that you want to match only optionally. That is, the regex should find a match regardless of whether that bit of text is there. The ? character flags the group that precedes it as an optional part of the pattern. For example, enter the following into the interactive shell:\n\n>>> batRegex = re.compile(r'Bat(wo)?man') >>> mo1 = batRegex.search('The Adventures of Batman') >>> mo1.group() 'Batman' >>> mo2 = batRegex.search('The Adventures of Batwoman') >>> mo2.group() 'Batwoman'\n\nThe (wo)? part of the regular expression means that the pattern wo is an optional group. The regex will match text that has zero instances or one instance of wo in it. This is why the regex matches both 'Batwoman' and 'Batman' .\n\nUsing the earlier phone number example, you can make the regex look for phone numbers that do or do not have an area code. Enter the following into the interactive shell:\n\n>>> phoneRegex = re.compile(r'(\\d\\d\\d-)?\\d\\d\\d-\\d\\d\\d\\d') >>> mo1 = phoneRegex.search('My number is 415-555-4242') >>> mo1.group() '415-555-4242' >>> mo2 = phoneRegex.search('My number is 555-4242') >>> mo2.group() '555-4242'\n\nYou can think of the ? as saying, \u201cMatch zero or one of the group preceding this question mark.\u201d\n\nIf you need to match an actual question mark character, escape it with \\? .\n\n#### Matching Zero or More with the Star\n\nThe * (called the star or asterisk ) means \u201cmatch zero or more\u201d\u2014the group that precedes the star can occur any number of times in the text. It can be completely absent or repeated over and over again. Let\u2019s look at the Batman example again.\n\n>>> batRegex = re.compile(r'Bat(wo)*man') >>> mo1 = batRegex.search('The Adventures of Batman') >>> mo1.group() 'Batman' >>> mo2 = batRegex.search('The Adventures of Batwoman') >>> mo2.group() 'Batwoman' >>> mo3 = batRegex.search('The Adventures of Batwowowowoman') >>> mo3.group() 'Batwowowowoman'\n\nFor 'Batman' , the (wo)* part of the regex matches zero instances of wo in the string; for 'Batwoman' , the (wo)* matches one instance of wo ; and for 'Batwowowowoman' , (wo)* matches four instances of wo .\n\nIf you need to match an actual star character, prefix the star in the regular expression with a backslash, \\* .\n\n#### Matching One or More with the Plus\n\nWhile * means \u201cmatch zero or more,\u201d the + (or plus ) means \u201cmatch one or more.\u201d Unlike the star, which does not require its group to appear in the matched string, the group preceding a plus must appear at least once . It is not optional. Enter the following into the interactive shell, and compare it with the star regexes in the previous section:\n\n>>> batRegex = re.compile(r'Bat(wo)+man') >>> mo1 = batRegex.search('The Adventures of Batwoman') >>> mo1.group() 'Batwoman' >>> mo2 = batRegex.search('The Adventures of Batwowowowoman') >>> mo2.group() 'Batwowowowoman' >>> mo3 = batRegex.search('The Adventures of Batman') >>> mo3 == None True\n\nThe regex Bat(wo)+man will not match the string 'The Adventures of Batman' , because at least one wo is required by the plus sign.\n\nIf you need to match an actual plus sign character, prefix the plus sign with a backslash to escape it: \\+ .\n\n#### Matching Specific Repetitions with Braces\n\nIf you have a group that you want to repeat a specific number of times, follow the group in your regex with a number in braces. For example, the regex (Ha){3} will match the string 'HaHaHa' , but it will not match 'HaHa' , since the latter has only two repeats of the (Ha) group.\n\nInstead of one number, you can specify a range by writing a minimum, a comma, and a maximum in between the braces. For example, the regex (Ha){3,5} will match 'HaHaHa' , 'HaHaHaHa' , and 'HaHaHaHaHa' .\n\nYou can also leave out the first or second number in the braces to leave the minimum or maximum unbounded. For example, (Ha){3,} will match three or more instances of the (Ha) group, while (Ha){,5} will match zero to five instances. Braces can help make your regular expressions shorter. These two regular expressions match identical patterns:\n\n(Ha){3} (Ha)(Ha)(Ha)\n\nAnd these two regular expressions also match identical patterns:\n\n(Ha){3,5} ((Ha)(Ha)(Ha))|((Ha)(Ha)(Ha)(Ha))|((Ha)(Ha)(Ha)(Ha)(Ha))\n\nEnter the following into the interactive shell:\n\n>>> haRegex = re.compile(r'(Ha){3}') >>> mo1 = haRegex.search('HaHaHa') >>> mo1.group() 'HaHaHa' >>> mo2 = haRegex.search('Ha') >>> mo2 == None True\n\nHere, (Ha){3} matches 'HaHaHa' but not 'Ha' . Since it doesn\u2019t match 'Ha' , search() returns None .\n\n### Greedy and Non-greedy Matching\n\nSince (Ha){3,5} can match three, four, or five instances of Ha in the string 'HaHaHaHaHa' , you may wonder why the Match object\u2019s call to group() in the previous brace example returns 'HaHaHaHaHa' instead of the shorter possibilities. After all, 'HaHaHa' and 'HaHaHaHa' are also valid matches of the regular expression (Ha){3,5} .\n\nPython\u2019s regular expressions are greedy by default, which means that in ambiguous situations they will match the longest string possible. The non-greedy (also called lazy ) version of the braces, which matches the shortest string possible, has the closing brace followed by a question mark.\n\nEnter the following into the interactive shell, and notice the difference between the greedy and non-greedy forms of the braces searching the same string:\n\n>>> greedyHaRegex = re.compile(r'(Ha){3,5}') >>> mo1 = greedyHaRegex.search('HaHaHaHaHa') >>> mo1.group() 'HaHaHaHaHa' >>> nongreedyHaRegex = re.compile(r'(Ha){3,5}?') >>> mo2 = nongreedyHaRegex.search('HaHaHaHaHa') >>> mo2.group() 'HaHaHa'\n\nNote that the question mark can have two meanings in regular expressions: declaring a non-greedy match or flagging an optional group. These meanings are entirely unrelated.\n\n### The findall() Method\n\nIn addition to the search() method, Regex objects also have a findall() method. While search() will return a Match object of the first matched text in the searched string, the findall() method will return the strings of every match in the searched string. To see how search() returns a Match object only on the first instance of matching text, enter the following into the interactive shell:\n\n>>> phoneNumRegex = re.compile(r'\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d') >>> mo = phoneNumRegex.search('Cell: 415-555-9999 Work: 212-555-0000') >>> mo.group() '415-555-9999'\n\nOn the other hand, findall() will not return a Match object but a list of strings\u2014 as long as there are no groups in the regular expression . Each string in the list is a piece of the searched text that matched the regular expression. Enter the following into the interactive shell:\n\n>>> phoneNumRegex = re.compile(r'\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d') # has no groups >>> phoneNumRegex.findall('Cell: 415-555-9999 Work: 212-555-0000') ['415-555-9999', '212-555-0000']\n\nIf there are groups in the regular expression, then findall() will return a list of tuples. Each tuple represents a found match, and its items are the matched strings for each group in the regex. To see findall() in action, enter the following into the interactive shell (notice that the regular expression being compiled now has groups in parentheses):\n\n>>> phoneNumRegex = re.compile(r'(\\d\\d\\d)-(\\d\\d\\d)-(\\d\\d\\d\\d)') # has groups >>> phoneNumRegex.findall('Cell: 415-555-9999 Work: 212-555-0000') [('415', '555', '9999'), ('212', '555', '0000')]\n\nTo summarize what the findall() method returns, remember the following:\n\n- When called on a regex with no groups, such as \\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d , the method findall() returns a list of string matches, such as ['415-555-9999', '212-555-0000'] .\n- When called on a regex that has groups, such as (\\d\\d\\d)-(\\d\\d\\d)-(\\d\\d\\d\\d) , the method findall() returns a list of tuples of strings (one string for each group), such as [('415', '555', '9999'), ('212', '555', '0000')] .\n\n### Character Classes\n\nIn the earlier phone number regex example, you learned that \\d could stand for any numeric digit. That is, \\d is shorthand for the regular expression (0|1|2|3|4|5|6|7|8|9) . There are many such shorthand character classes , as shown in Table 7-1.\n\nTable 7-1: Shorthand Codes for Common Character Classes\n\nShorthand character class\n\nRepresents\n\n\\d\n\nAny numeric digit from 0 to 9.\n\n\\D\n\nAny character that is not a numeric digit from 0 to 9.\n\n\\w\n\nAny letter, numeric digit, or the underscore character. (Think of this as matching \u201cword\u201d characters.)\n\n\\W\n\nAny character that is not a letter, numeric digit, or the underscore character.\n\n\\s\n\nAny space, tab, or newline character. (Think of this as matching \u201cspace\u201d characters.)\n\n\\S\n\nAny character that is not a space, tab, or newline.\n\nCharacter classes are nice for shortening regular expressions. The character class [0-5] will match only the numbers 0 to 5 ; this is much shorter than typing (0|1|2|3|4|5) . Note that while \\d matches digits and \\w matches digits, letters, and the underscore, there is no shorthand character class that matches only letters. (Though you can use the [a-zA-Z] character class, as explained next.)\n\nFor example, enter the following into the interactive shell:\n\n>>> xmasRegex = re.compile(r'\\d+\\s\\w+') >>> xmasRegex.findall('12 drummers, 11 pipers, 10 lords, 9 ladies, 8 maids, 7 swans, 6 geese, 5 rings, 4 birds, 3 hens, 2 doves, 1 partridge') ['12 drummers', '11 pipers', '10 lords', '9 ladies', '8 maids', '7 swans', '6 geese', '5 rings', '4 birds', '3 hens', '2 doves', '1 partridge']\n\nThe regular expression \\d+\\s\\w+ will match text that has one or more numeric digits ( \\d+ ), followed by a whitespace character ( \\s ), followed by one or more letter/digit/underscore characters ( \\w+ ). The findall() method returns all matching strings of the regex pattern in a list.\n\n### Making Your Own Character Classes\n\nThere are times when you want to match a set of characters but the shorthand character classes ( \\d , \\w , \\s , and so on) are too broad. You can define your own character class using square brackets. For example, the character class [aeiouAEIOU] will match any vowel, both lowercase and uppercase. Enter the following into the interactive shell:\n\n>>> vowelRegex = re.compile(r'[aeiouAEIOU]') >>> vowelRegex.findall('RoboCop eats baby food. BABY FOOD.') ['o', 'o', 'o', 'e', 'a', 'a', 'o', 'o', 'A', 'O', 'O']\n\nYou can also include ranges of letters or numbers by using a hyphen. For example, the character class [a-zA-Z0-9] will match all lowercase letters, uppercase letters, and numbers.\n\nNote that inside the square brackets, the normal regular expression symbols are not interpreted as such. This means you do not need to escape the . , * , ? , or () characters with a preceding backslash. For example, the character class [0-5.] will match digits 0 to 5 and a period. You do not need to write it as [0-5\\.] .\n\nBy placing a caret character ( ^ ) just after the character class\u2019s opening bracket, you can make a negative character class . A negative character class will match all the characters that are not in the character class. For example, enter the following into the interactive shell:\n\n>>> consonantRegex = re.compile(r'[^aeiouAEIOU]') >>> consonantRegex.findall('RoboCop eats baby food. BABY FOOD.') ['R', 'b', 'C', 'p', ' ', 't', 's', ' ', 'b', 'b', 'y', ' ', 'f', 'd', '.', ' ', 'B', 'B', 'Y', ' ', 'F', 'D', '.']\n\nNow, instead of matching every vowel, we\u2019re matching every character that isn\u2019t a vowel.\n\n### The Caret and Dollar Sign Characters\n\nYou can also use the caret symbol ( ^ ) at the start of a regex to indicate that a match must occur at the beginning of the searched text. Likewise, you can put a dollar sign ( $ ) at the end of the regex to indicate the string must end with this regex pattern. And you can use the ^ and $ together to indicate that the entire string must match the regex\u2014that is, it\u2019s not enough for a match to be made on some subset of the string.\n\nFor example, the r'^Hello' regular expression string matches strings that begin with 'Hello' . Enter the following into the interactive shell:\n\n>>> beginsWithHello = re.compile(r'^Hello') >>> beginsWithHello.search('Hello, world!') <re.Match object; span=(0, 5), match='Hello'> >>> beginsWithHello.search('He said hello.') == None True\n\nThe r'\\d$' regular expression string matches strings that end with a numeric character from 0 to 9. Enter the following into the interactive shell:\n\n>>> endsWithNumber = re.compile(r'\\d$') >>> endsWithNumber.search('Your number is 42') <re.Match object; span=(16, 17), match='2'> >>> endsWithNumber.search('Your number is forty two.') == None True\n\nThe r'^\\d+$' regular expression string matches strings that both begin and end with one or more numeric characters. Enter the following into the interactive shell:\n\n>>> wholeStringIsNum = re.compile(r'^\\d+$') >>> wholeStringIsNum.search('1234567890') <re.Match object; span=(0, 10), match='1234567890'> >>> wholeStringIsNum.search('12345xyz67890') == None True >>> wholeStringIsNum.search('12\u00a0\u00a034567890') == None True\n\nThe last two search() calls in the previous interactive shell example demonstrate how the entire string must match the regex if ^ and $ are used.\n\nI always confuse the meanings of these two symbols, so I use the mnemonic \u201cCarrots cost dollars\u201d to remind myself that the caret comes first and the dollar sign comes last.\n\n### The Wildcard Character\n\nThe . (or dot ) character in a regular expression is called a wildcard and will match any character except for a newline. For example, enter the following into the interactive shell:\n\n>>> atRegex = re.compile(r'.at') >>> atRegex.findall('The cat in the hat sat on the flat mat.') ['cat', 'hat', 'sat', 'lat', 'mat']\n\nRemember that the dot character will match just one character, which is why the match for the text flat in the previous example matched only lat . To match an actual dot, escape the dot with a backslash: \\. .\n\n#### Matching Everything with Dot-Star\n\nSometimes you will want to match everything and anything. For example, say you want to match the string 'First Name:' , followed by any and all text, followed by 'Last Name:' , and then followed by anything again. You can use the dot-star ( .* ) to stand in for that \u201canything.\u201d Remember that the dot character means \u201cany single character except the newline,\u201d and the star character means \u201czero or more of the preceding character.\u201d\n\nEnter the following into the interactive shell:\n\n>>> nameRegex = re.compile(r'First Name: (.*) Last Name: (.*)') >>> mo = nameRegex.search('First Name: Al Last Name: Sweigart') >>> mo.group(1) 'Al' >>> mo.group(2) 'Sweigart'\n\nThe dot-star uses greedy mode: It will always try to match as much text as possible. To match any and all text in a non-greedy fashion, use the dot, star, and question mark ( .*? ). Like with braces, the question mark tells Python to match in a non-greedy way.\n\nEnter the following into the interactive shell to see the difference between the greedy and non-greedy versions:\n\n>>> nongreedyRegex = re.compile(r'<.*?>') >>> mo = nongreedyRegex.search('<To serve man> for dinner.>') >>> mo.group() '<To serve man>' >>> greedyRegex = re.compile(r'<.*>') >>> mo = greedyRegex.search('<To serve man> for dinner.>') >>> mo.group() '<To serve man> for dinner.>'\n\nBoth regexes roughly translate to \u201cMatch an opening angle bracket, followed by anything, followed by a closing angle bracket.\u201d But the string '<To serve man> for dinner.>' has two possible matches for the closing angle bracket. In the non-greedy version of the regex, Python matches the shortest possible string: '<To serve man>' . In the greedy version, Python matches the longest possible string: '<To serve man> for dinner.>' .\n\n#### Matching Newlines with the Dot Character\n\nThe dot-star will match everything except a newline. By passing re.DOTALL as the second argument to re.compile() , you can make the dot character match all characters, including the newline character.\n\nEnter the following into the interactive shell:\n\n>>> noNewlineRegex = re.compile('.*') >>> noNewlineRegex.search('Serve the public trust.\\nProtect the innocent. \\nUphold the law.').group() 'Serve the public trust.' >>> newlineRegex = re.compile('.*', re.DOTALL) >>> newlineRegex.search('Serve the public trust.\\nProtect the innocent. \\nUphold the law.').group() 'Serve the public trust.\\nProtect the innocent.\\nUphold the law.'\n\nThe regex noNewlineRegex , which did not have re.DOTALL passed to the re.compile() call that created it, will match everything only up to the first newline character, whereas newlineRegex , which did have re.DOTALL passed to re.compile() , matches everything. This is why the newlineRegex.search() call matches the full string, including its newline characters.\n\n### Review of Regex Symbols\n\nThis chapter covered a lot of notation, so here\u2019s a quick review of what you learned about basic regular expression syntax:\n\n- The ? matches zero or one of the preceding group.\n- The * matches zero or more of the preceding group.\n- The + matches one or more of the preceding group.\n- The {n} matches exactly n of the preceding group.\n- The {n,} matches n or more of the preceding group.\n- The {,m} matches 0 to m of the preceding group.\n- The {n,m} matches at least n and at most m of the preceding group.\n- {n,m}? or *? or +? performs a non-greedy match of the preceding group.\n- ^spam means the string must begin with spam .\n- spam$ means the string must end with spam .\n- The . matches any character, except newline characters.\n- \\d , \\w , and \\s match a digit, word, or space character, respectively.\n- \\D , \\W , and \\S match anything except a digit, word, or space character, respectively.\n- [abc] matches any character between the brackets (such as a , b , or c ).\n- [^abc] matches any character that isn\u2019t between the brackets.\n\n### Case-Insensitive Matching\n\nNormally, regular expressions match text with the exact casing you specify. For example, the following regexes match completely different strings:\n\n>>> regex1 = re.compile('RoboCop') >>> regex2 = re.compile('ROBOCOP') >>> regex3 = re.compile('robOcop') >>> regex4 = re.compile('RobocOp')\n\nBut sometimes you care only about matching the letters without worrying whether they\u2019re uppercase or lowercase. To make your regex case-insensitive, you can pass re.IGNORECASE or re.I as a second argument to re.compile() . Enter the following into the interactive shell:\n\n>>> robocop = re.compile(r'robocop', re.I) >>> robocop.search('RoboCop is part man, part machine, all cop.').group() 'RoboCop' >>> robocop.search('ROBOCOP protects the innocent.').group() 'ROBOCOP' >>> robocop.search('Al, why does your programming book talk about robocop so much?').group() 'robocop'\n\n### Substituting Strings with the sub() Method\n\nRegular expressions can not only find text patterns but can also substitute new text in place of those patterns. The sub() method for Regex objects is passed two arguments. The first argument is a string to replace any matches. The second is the string for the regular expression. The sub() method returns a string with the substitutions applied.\n\nFor example, enter the following into the interactive shell:\n\n>>> namesRegex = re.compile(r'Agent \\w+') >>> namesRegex.sub('CENSORED', 'Agent Alice gave the secret documents to Agent Bob.') 'CENSORED gave the secret documents to CENSORED.'\n\nSometimes you may need to use the matched text itself as part of the substitution. In the first argument to sub() , you can type \\1 , \\2 , \\3 , and so on, to mean \u201cEnter the text of group 1 , 2 , 3 , and so on, in the substitution.\u201d\n\nFor example, say you want to censor the names of the secret agents by showing just the first letters of their names. To do this, you could use the regex Agent (\\w)\\w* and pass r'\\1****' as the first argument to sub() . The \\1 in that string will be replaced by whatever text was matched by group 1 \u2014that is, the (\\w) group of the regular expression.\n\n>>> agentNamesRegex = re.compile(r'Agent (\\w)\\w*') >>> agentNamesRegex.sub(r'\\1****', 'Agent Alice told Agent Carol that Agent Eve knew Agent Bob was a double agent.') A**** told C**** that E**** knew B**** was a double agent.'\n\n### Managing Complex Regexes\n\nRegular expressions are fine if the text pattern you need to match is simple. But matching complicated text patterns might require long, convoluted regular expressions. You can mitigate this by telling the re.compile() function to ignore whitespace and comments inside the regular expression string. This \u201cverbose mode\u201d can be enabled by passing the variable re.VERBOSE as the second argument to re.compile() .\n\nNow instead of a hard-to-read regular expression like this:\n\nphoneRegex = re.compile(r'((\\d{3}|\\(\\d{3}\\))?(\\s|-|\\.)?\\d{3}(\\s|-|\\.)\\d{4} (\\s*(ext|x|ext.)\\s*\\d{2,5})?)')\n\nyou can spread the regular expression over multiple lines with comments like this:\n\nphoneRegex = re.compile(r'''( (\\d{3}|\\(\\d{3}\\))?\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# area code (\\s|-|\\.)?\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# separator \\d{3}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# first 3 digits (\\s|-|\\.)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# separator \\d{4}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# last 4 digits (\\s*(ext|x|ext.)\\s*\\d{2,5})?\u00a0\u00a0# extension )''', re.VERBOSE)\n\nNote how the previous example uses the triple-quote syntax ( ''' ) to create a multiline string so that you can spread the regular expression definition over many lines, making it much more legible.\n\nThe comment rules inside the regular expression string are the same as regular Python code: the # symbol and everything after it to the end of the line are ignored. Also, the extra spaces inside the multiline string for the regular expression are not considered part of the text pattern to be matched. This lets you organize the regular expression so it\u2019s easier to read.\n\n### Combining re.IGNORECASE, re.DOTALL, and re.VERBOSE\n\nWhat if you want to use re.VERBOSE to write comments in your regular expression but also want to use re.IGNORECASE to ignore capitalization? Unfortunately, the re.compile() function takes only a single value as its second argument. You can get around this limitation by combining the re.IGNORECASE , re.DOTALL , and re.VERBOSE variables using the pipe character ( | ), which in this context is known as the bitwise or operator.\n\nSo if you want a regular expression that\u2019s case-insensitive and includes newlines to match the dot character, you would form your re.compile() call like this:\n\n>>> someRegexValue = re.compile('foo', re.IGNORECASE | re.DOTALL)\n\nIncluding all three options in the second argument will look like this:\n\n>>> someRegexValue = re.compile('foo', re.IGNORECASE | re.DOTALL | re.VERBOSE)\n\nThis syntax is a little old-fashioned and originates from early versions of Python. The details of the bitwise operators are beyond the scope of this book, but check out the resources at https://nostarch.com/automatestuff2/ for more information. You can also pass other options for the second argument; they\u2019re uncommon, but you can read more about them in the resources, too.\n\n### Project: Phone Number and Email Address Extractor\n\nSay you have the boring task of finding every phone number and email address in a long web page or document. If you manually scroll through the page, you might end up searching for a long time. But if you had a program that could search the text in your clipboard for phone numbers and email addresses, you could simply press CTRL- A to select all the text, press CTRL- C to copy it to the clipboard, and then run your program. It could replace the text on the clipboard with just the phone numbers and email addresses it finds.\n\nWhenever you\u2019re tackling a new project, it can be tempting to dive right into writing code. But more often than not, it\u2019s best to take a step back and consider the bigger picture. I recommend first drawing up a high-level plan for what your program needs to do. Don\u2019t think about the actual code yet\u2014you can worry about that later. Right now, stick to broad strokes.\n\nFor example, your phone and email address extractor will need to do the following:\n\n- Get the text off the clipboard.\n- Find all phone numbers and email addresses in the text.\n- Paste them onto the clipboard.\n\nNow you can start thinking about how this might work in code. The code will need to do the following:\n\n- Use the pyperclip module to copy and paste strings.\n- Create two regexes, one for matching phone numbers and the other for matching email addresses.\n- Find all matches, not just the first match, of both regexes.\n- Neatly format the matched strings into a single string to paste.\n- Display some kind of message if no matches were found in the text.\n\nThis list is like a road map for the project. As you write the code, you can focus on each of these steps separately. Each step is fairly manageable and expressed in terms of things you already know how to do in Python.\n\n#### Step 1: Create a Regex for Phone Numbers\n\nFirst, you have to create a regular expression to search for phone numbers. Create a new file, enter the following, and save it as phoneAndEmail.py :\n\n#! python3 # phoneAndEmail.py - Finds phone numbers and email addresses on the clipboard. import pyperclip, re phoneRegex = re.compile(r'''( (\\d{3}|\\(\\d{3}\\))?\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# area code (\\s|-|\\.)?\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# separator (\\d{3})\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# first 3 digits (\\s|-|\\.)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# separator (\\d{4})\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# last 4 digits (\\s*(ext|x|ext.)\\s*(\\d{2,5}))?\u00a0\u00a0\u00a0\u00a0# extension )''', re.VERBOSE) # TODO: Create email regex. # TODO: Find matches in clipboard text. # TODO: Copy results to the clipboard.\n\nThe TODO comments are just a skeleton for the program. They\u2019ll be replaced as you write the actual code.\n\nThe phone number begins with an optional area code, so the area code group is followed with a question mark. Since the area code can be just three digits (that is, \\d{3} ) or three digits within parentheses (that is, \\(\\d{3}\\) ), you should have a pipe joining those parts. You can add the regex comment # Area code to this part of the multiline string to help you remember what (\\d{3}|\\(\\d{3}\\))? is supposed to match.\n\nThe phone number separator character can be a space ( \\s ), hyphen ( - ), or period ( . ), so these parts should also be joined by pipes. The next few parts of the regular expression are straightforward: three digits, followed by another separator, followed by four digits. The last part is an optional extension made up of any number of spaces followed by ext , x , or ext. , followed by two to five digits.\n\nNOTE\n\nIt\u2019s easy to get mixed up with regular expressions that contain groups with parentheses ( ) and escaped parentheses \\( \\) . Remember to double-check that you\u2019re using the correct one if you get a \u201cmissing ), unterminated subpattern\u201d error message.\n\n#### Step 2: Create a Regex for Email Addresses\n\nYou will also need a regular expression that can match email addresses. Make your program look like the following:\n\n#! python3 # phoneAndEmail.py - Finds phone numbers and email addresses on the clipboard. import pyperclip, re phoneRegex = re.compile(r'''( -- snip -- # Create email regex. emailRegex = re.compile(r'''( \u278a [a-zA-Z0-9._%+-]+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# username \u278b @\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# @ symbol \u278c [a-zA-Z0-9.-]+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# domain name (\\.[a-zA-Z]{2,4})\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# dot-something )''', re.VERBOSE) # TODO: Find matches in clipboard text. # TODO: Copy results to the clipboard.\n\nThe username part of the email address \u278a is one or more characters that can be any of the following: lowercase and uppercase letters, numbers, a dot, an underscore, a percent sign, a plus sign, or a hyphen. You can put all of these into a character class: [a-zA-Z0-9._%+-] .\n\nThe domain and username are separated by an @ symbol \u278b . The domain name \u278c has a slightly less permissive character class with only letters, numbers, periods, and hyphens: [a-zA-Z0-9.-] . And last will be the \u201cdot-com\u201d part (technically known as the top-level domain ), which can really be dot-anything. This is between two and four characters.\n\nThe format for email addresses has a lot of weird rules. This regular expression won\u2019t match every possible valid email address, but it\u2019ll match almost any typical email address you\u2019ll encounter.\n\n#### Step 3: Find All Matches in the Clipboard Text\n\nNow that you have specified the regular expressions for phone numbers and email addresses, you can let Python\u2019s re module do the hard work of finding all the matches on the clipboard. The pyperclip.paste() function will get a string value of the text on the clipboard, and the findall() regex method will return a list of tuples.\n\nMake your program look like the following:\n\n#! python3 # phoneAndEmail.py - Finds phone numbers and email addresses on the clipboard. import pyperclip, re phoneRegex = re.compile(r'''( -- snip -- # Find matches in clipboard text. text = str(pyperclip.paste()) \u278a matches = [] \u278b for groups in phoneRegex.findall(text): phoneNum = '-'.join([groups[1], groups[3], groups[5]]) if groups[8] != '': phoneNum += ' x' + groups[8] matches.append(phoneNum) \u278c for groups in emailRegex.findall(text): matches.append(groups[0]) # TODO: Copy results to the clipboard.\n\nThere is one tuple for each match, and each tuple contains strings for each group in the regular expression. Remember that group 0 matches the entire regular expression, so the group at index 0 of the tuple is the one you are interested in.\n\nAs you can see at \u278a , you\u2019ll store the matches in a list variable named matches . It starts off as an empty list, and a couple for loops. For the email addresses, you append group 0 of each match \u278c . For the matched phone numbers, you don\u2019t want to just append group 0 . While the program detects phone numbers in several formats, you want the phone number appended to be in a single, standard format. The phoneNum variable contains a string built from groups 1 , 3 , 5 , and 8 of the matched text \u278b . (These groups are the area code, first three digits, last four digits, and extension.)\n\n#### Step 4: Join the Matches into a String for the Clipboard\n\nNow that you have the email addresses and phone numbers as a list of strings in matches , you want to put them on the clipboard. The pyperclip.copy() function takes only a single string value, not a list of strings, so you call the join() method on matches .\n\nTo make it easier to see that the program is working, let\u2019s print any matches you find to the terminal. If no phone numbers or email addresses were found, the program should tell the user this.\n\nMake your program look like the following:\n\n#! python3 # phoneAndEmail.py - Finds phone numbers and email addresses on the clipboard. -- snip -- for groups in emailRegex.findall(text): matches.append(groups[0]) # Copy results to the clipboard. if len(matches) > 0: pyperclip.copy('\\n'.join(matches)) print('Copied to clipboard:') print('\\n'.join(matches)) else: print('No phone numbers or email addresses found.')\n\n#### Running the Program\n\nFor an example, open your web browser to the No Starch Press contact page at https://nostarch.com/contactus/ , press CTRL- A to select all the text on the page, and press CTRL -C to copy it to the clipboard. When you run this program, the output will look something like this:\n\nCopied to clipboard: 800-420-7240 415-863-9900 415-863-9950 info@nostarch.com media@nostarch.com academic@nostarch.com info@nostarch.com\n\n#### Ideas for Similar Programs\n\nIdentifying patterns of text (and possibly substituting them with the sub() method) has many different potential applications. For example, you could:\n\n- Find website URLs that begin with http:// or https:// .\n- Clean up dates in different date formats (such as 3/14/2019, 03-14-2019, and 2015/3/19) by replacing them with dates in a single, standard format.\n- Remove sensitive information such as Social Security or credit card numbers.\n- Find common typos such as multiple spaces between words, accidentally accidentally repeated words, or multiple exclamation marks at the end of sentences. Those are annoying!!\n\n### Summary\n\nWhile a computer can search for text quickly, it must be told precisely what to look for. Regular expressions allow you to specify the pattern of characters you are looking for, rather than the exact text itself. In fact, some word processing and spreadsheet applications provide find-and-replace features that allow you to search using regular expressions.\n\nThe re module that comes with Python lets you compile Regex objects. These objects have several methods: search() to find a single match, findall() to find all matching instances, and sub() to do a find-and-replace substitution of text.\n\nYou can find out more in the official Python documentation at https://docs.python.org/3/library/re.html . Another useful resource is the tutorial website https://www.regular-expressions.info/ .\n\n### Practice Questions\n\n1. What is the function that creates Regex objects?\n\n2. Why are raw strings often used when creating Regex objects?\n\n3. What does the search() method return?\n\n4. How do you get the actual strings that match the pattern from a Match object?\n\n5. In the regex created from r'(\\d\\d\\d)-(\\d\\d\\d-\\d\\d\\d\\d)' , what does group 0 cover? Group 1 ? Group 2 ?\n\n6. Parentheses and periods have specific meanings in regular expression syntax. How would you specify that you want a regex to match actual parentheses and period characters?\n\n7. The findall() method returns a list of strings or a list of tuples of strings. What makes it return one or the other?\n\n8. What does the | character signify in regular expressions?\n\n9. What two things does the ? character signify in regular expressions?\n\n10. What is the difference between the + and * characters in regular expressions?\n\n11. What is the difference between {3} and {3,5} in regular expressions?\n\n12. What do the \\d , \\w , and \\s shorthand character classes signify in regular expressions?\n\n13. What do the \\D , \\W , and \\S shorthand character classes signify in regular expressions?\n\n14. What is the difference between .* and .*? ?\n\n15. What is the character class syntax to match all numbers and lowercase letters?\n\n16. How do you make a regular expression case-insensitive?\n\n17. What does the . character normally match? What does it match if re.DOTALL is passed as the second argument to re.compile() ?\n\n18. If numRegex = re.compile(r'\\d+') , what will numRegex.sub('X', '12 drummers, 11 pipers, five rings, 3 hens') return?\n\n19. What does passing re.VERBOSE as the second argument to re.compile() allow you to do?\n\n20. How would you write a regex that matches a number with commas for every three digits? It must match the following:\n\n- '42'\n- '1,234'\n- '6,368,745'\n\nbut not the following:\n\n- '12,34,567' (which has only two digits between the commas)\n- '1234' (which lacks commas)\n\n21. How would you write a regex that matches the full name of someone whose last name is Watanabe? You can assume that the first name that comes before it will always be one word that begins with a capital letter. The regex must match the following:\n\n- 'Haruto Watanabe'\n- 'Alice Watanabe'\n- 'RoboCop Watanabe'\n\nbut not the following:\n\n- 'haruto Watanabe' (where the first name is not capitalized)\n- 'Mr. Watanabe' (where the preceding word has a nonletter character)\n- 'Watanabe' (which has no first name)\n- 'Haruto watanabe' (where Watanabe is not capitalized)\n\n22. How would you write a regex that matches a sentence where the first word is either Alice , Bob , or Carol ; the second word is either eats , pets , or throws ; the third word is apples , cats , or baseballs ; and the sentence ends with a period? This regex should be case-insensitive. It must match the following:\n\n- 'Alice eats apples.'\n- 'Bob pets cats.'\n- 'Carol throws baseballs.'\n- 'Alice throws Apples.'\n- 'BOB EATS CATS.'\n\nbut not the following:\n\n- 'RoboCop eats apples.'\n- 'ALICE THROWS FOOTBALLS.'\n- 'Carol eats 7 cats.'\n\n### Practice Projects\n\nFor practice, write programs to do the following tasks.\n\n#### Date Detection\n\nWrite a regular expression that can detect dates in the DD/MM/YYYY format. Assume that the days range from 01 to 31, the months range from 01 to 12, and the years range from 1000 to 2999. Note that if the day or month is a single digit, it\u2019ll have a leading zero.\n\nThe regular expression doesn\u2019t have to detect correct days for each month or for leap years; it will accept nonexistent dates like 31/02/2020 or 31/04/2021. Then store these strings into variables named month , day , and year , and write additional code that can detect if it is a valid date. April, June, September, and November have 30 days, February has 28 days, and the rest of the months have 31 days. February has 29 days in leap years. Leap years are every year evenly divisible by 4, except for years evenly divisible by 100, unless the year is also evenly divisible by 400. Note how this calculation makes it impossible to make a reasonably sized regular expression that can detect a valid date.\n\n#### Strong Password Detection\n\nWrite a function that uses regular expressions to make sure the password string it is passed is strong. A strong password is defined as one that is at least eight characters long, contains both uppercase and lowercase characters, and has at least one digit. You may need to test the string against multiple regex patterns to validate its strength.\n\n#### Regex Version of the strip() Method\n\nWrite a function that takes a string and does the same thing as the strip() string method. If no other arguments are passed other than the string to strip, then whitespace characters will be removed from the beginning and end of the string. Otherwise, the characters specified in the second argument to the function will be removed from the string.",
      "difficulty": "intermediate",
      "doc_id": "doc-7pattern-matching-with-regular-expressions-14d02f7187",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-NC-SA 3.0",
        "source_file": "data/corpus_raw/2e_chapter7_3889e4.json",
        "url": "https://automatetheboringstuff.com/2e/chapter7/"
      },
      "title": "7PATTERN MATCHING WITH REGULAR EXPRESSIONS",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "debugging",
        "error_handling",
        "exceptions"
      ],
      "content": "# 8.Errors and Exceptions\u00c2\u00b6\n\nUntil now error messages haven\u00e2\u0080\u0099t been more than mentioned, but if you have tried\nout the examples you have probably seen some.  There are (at least) two\ndistinguishable kinds of errors: syntax errors and exceptions .\n\n## 8.1.Syntax Errors\u00c2\u00b6\n\nSyntax errors, also known as parsing errors, are perhaps the most common kind of\ncomplaint you get while you are still learning Python:\n\n```python\n>>> while True print('Hello world')\n  File \"<stdin>\", line 1\n    while True print('Hello world')\n               ^^^^^\nSyntaxError: invalid syntax\n```python\n\nThe parser repeats the offending line and displays little arrows pointing\nat the place where the error was detected.  Note that this is not always the\nplace that needs to be fixed.  In the example, the error is detected at the\nfunction print() , since a colon ( ':' ) is missing just before it.\n\nThe file name ( <stdin> in our example) and line number are printed so you\nknow where to look in case the input came from a file.\n\n## 8.2.Exceptions\u00c2\u00b6\n\nEven if a statement or expression is syntactically correct, it may cause an\nerror when an attempt is made to execute it. Errors detected during execution\nare called exceptions and are not unconditionally fatal: you will soon learn\nhow to handle them in Python programs.  Most exceptions are not handled by\nprograms, however, and result in error messages as shown here:\n\n```python\n>>> 10 * (1/0)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n    10 * (1/0)\n          ~^~\nZeroDivisionError: division by zero\n>>> 4 + spam*3\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n    4 + spam*3\n        ^^^^\nNameError: name 'spam' is not defined\n>>> '2' + 2\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n    '2' + 2\n    ~~~~^~~\nTypeError: can only concatenate str (not \"int\") to str\n```python\n\nThe last line of the error message indicates what happened. Exceptions come in\ndifferent types, and the type is printed as part of the message: the types in\nthe example are ZeroDivisionError , NameError and TypeError .\nThe string printed as the exception type is the name of the built-in exception\nthat occurred.  This is true for all built-in exceptions, but need not be true\nfor user-defined exceptions (although it is a useful convention). Standard\nexception names are built-in identifiers (not reserved keywords).\n\nThe rest of the line provides detail based on the type of exception and what\ncaused it.\n\nThe preceding part of the error message shows the context where the exception\noccurred, in the form of a stack traceback. In general it contains a stack\ntraceback listing source lines; however, it will not display lines read from\nstandard input.\n\nBuilt-in Exceptions lists the built-in exceptions and their meanings.\n\n## 8.3.Handling Exceptions\u00c2\u00b6\n\nIt is possible to write programs that handle selected exceptions. Look at the\nfollowing example, which asks the user for input until a valid integer has been\nentered, but allows the user to interrupt the program (using Control - C or\nwhatever the operating system supports); note that a user-generated interruption\nis signalled by raising the KeyboardInterrupt exception.\n\n```python\n>>> while True:\n...     try:\n...         x = int(input(\"Please enter a number: \"))\n...         break\n...     except ValueError:\n...         print(\"Oops!  That was no valid number.  Try again...\")\n...\n```python\n\nThe try statement works as follows.\n\n- First, the try clause (the statement(s) between the try and except keywords) is executed.\n- If no exception occurs, the except clause is skipped and execution of the try statement is finished.\n- If an exception occurs during execution of the try clause, the rest of the\nclause is skipped.  Then, if its type matches the exception named after the except keyword, the except clause is executed, and then execution\ncontinues after the try/except block.\n- If an exception occurs which does not match the exception named in the except\nclause , it is passed on to outer try statements; if no handler is\nfound, it is an unhandled exception and execution stops with an error message.\n\nA try statement may have more than one except clause , to specify\nhandlers for different exceptions.  At most one handler will be executed.\nHandlers only handle exceptions that occur in the corresponding try clause ,\nnot in other handlers of the same try statement.  An except clause may name multiple exceptions as a parenthesized tuple, for example:\n\n```python\n... except (RuntimeError, TypeError, NameError):\n...     pass\n```python\n\nA class in an except clause matches exceptions which are instances of the\nclass itself or one of its derived classes (but not the other way around \u00e2\u0080\u0094 an except clause listing a derived class does not match instances of its base classes).\nFor example, the following code will print B, C, D in that order:\n\n```python\nclass B(Exception):\n    pass\n\nclass C(B):\n    pass\n\nclass D(C):\n    pass\n\nfor cls in [B, C, D]:\n    try:\n        raise cls()\n    except D:\n        print(\"D\")\n    except C:\n        print(\"C\")\n    except B:\n        print(\"B\")\n```python\n\nNote that if the except clauses were reversed (with except B first), it\nwould have printed B, B, B \u00e2\u0080\u0094 the first matching except clause is triggered.\n\nWhen an exception occurs, it may have associated values, also known as the\nexception\u00e2\u0080\u0099s arguments . The presence and types of the arguments depend on the\nexception type.\n\nThe except clause may specify a variable after the exception name.  The\nvariable is bound to the exception instance which typically has an args attribute that stores the arguments. For convenience, builtin exception\ntypes define __str__() to print all the arguments without explicitly\naccessing .args .\n\n```python\n>>> try:\n...     raise Exception('spam', 'eggs')\n... except Exception as inst:\n...     print(type(inst))    # the exception type\n...     print(inst.args)     # arguments stored in .args\n...     print(inst)          # __str__ allows args to be printed directly,\n...                          # but may be overridden in exception subclasses\n...     x, y = inst.args     # unpack args\n...     print('x =', x)\n...     print('y =', y)\n...\n<class 'Exception'>\n('spam', 'eggs')\n('spam', 'eggs')\nx = spam\ny = eggs\n```python\n\nThe exception\u00e2\u0080\u0099s __str__() output is printed as the last part (\u00e2\u0080\u0098detail\u00e2\u0080\u0099)\nof the message for unhandled exceptions.\n\nBaseException is the common base class of all exceptions. One of its\nsubclasses, Exception , is the base class of all the non-fatal exceptions.\nExceptions which are not subclasses of Exception are not typically\nhandled, because they are used to indicate that the program should terminate.\nThey include SystemExit which is raised by sys.exit() and KeyboardInterrupt which is raised when a user wishes to interrupt\nthe program.\n\nException can be used as a wildcard that catches (almost) everything.\nHowever, it is good practice to be as specific as possible with the types\nof exceptions that we intend to handle, and to allow any unexpected\nexceptions to propagate on.\n\nThe most common pattern for handling Exception is to print or log\nthe exception and then re-raise it (allowing a caller to handle the\nexception as well):\n\n```python\nimport sys\n\ntry:\n    f = open('myfile.txt')\n    s = f.readline()\n    i = int(s.strip())\nexcept OSError as err:\n    print(\"OS error:\", err)\nexcept ValueError:\n    print(\"Could not convert data to an integer.\")\nexcept Exception as err:\n    print(f\"Unexpected {err=}, {type(err)=}\")\n    raise\n```python\n\nThe try \u00e2\u0080\u00a6 except statement has an optional else\nclause , which, when present, must follow all except clauses .  It is useful\nfor code that must be executed if the try clause does not raise an exception.\nFor example:\n\n```python\nfor arg in sys.argv[1:]:\n    try:\n        f = open(arg, 'r')\n    except OSError:\n        print('cannot open', arg)\n    else:\n        print(arg, 'has', len(f.readlines()), 'lines')\n        f.close()\n```python\n\nThe use of the else clause is better than adding additional code to\nthe try clause because it avoids accidentally catching an exception\nthat wasn\u00e2\u0080\u0099t raised by the code being protected by the try \u00e2\u0080\u00a6 except statement.\n\nException handlers do not handle only exceptions that occur immediately in the try clause , but also those that occur inside functions that are called (even\nindirectly) in the try clause . For example:\n\n```python\n>>> def this_fails():\n...     x = 1/0\n...\n>>> try:\n...     this_fails()\n... except ZeroDivisionError as err:\n...     print('Handling run-time error:', err)\n...\nHandling run-time error: division by zero\n```python\n\n## 8.4.Raising Exceptions\u00c2\u00b6\n\nThe raise statement allows the programmer to force a specified\nexception to occur. For example:\n\n```python\n>>> raise NameError('HiThere')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n    raise NameError('HiThere')\nNameError: HiThere\n```python\n\nThe sole argument to raise indicates the exception to be raised.\nThis must be either an exception instance or an exception class (a class that\nderives from BaseException , such as Exception or one of its\nsubclasses).  If an exception class is passed, it will be implicitly\ninstantiated by calling its constructor with no arguments:\n\n```python\nraise ValueError  # shorthand for 'raise ValueError()'\n```python\n\nIf you need to determine whether an exception was raised but don\u00e2\u0080\u0099t intend to\nhandle it, a simpler form of the raise statement allows you to\nre-raise the exception:\n\n```python\n>>> try:\n...     raise NameError('HiThere')\n... except NameError:\n...     print('An exception flew by!')\n...     raise\n...\nAn exception flew by!\nTraceback (most recent call last):\n  File \"<stdin>\", line 2, in <module>\n    raise NameError('HiThere')\nNameError: HiThere\n```python\n\n## 8.5.Exception Chaining\u00c2\u00b6\n\nIf an unhandled exception occurs inside an except section, it will\nhave the exception being handled attached to it and included in the error\nmessage:\n\n```python\n>>> try:\n...     open(\"database.sqlite\")\n... except OSError:\n...     raise RuntimeError(\"unable to handle error\")\n...\nTraceback (most recent call last):\n  File \"<stdin>\", line 2, in <module>\n    open(\"database.sqlite\")\n    ~~~~^^^^^^^^^^^^^^^^^^^\nFileNotFoundError: [Errno 2] No such file or directory: 'database.sqlite'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<stdin>\", line 4, in <module>\n    raise RuntimeError(\"unable to handle error\")\nRuntimeError: unable to handle error\n```python\n\nTo indicate that an exception is a direct consequence of another, the raise statement allows an optional from clause:\n\n```python\n# exc must be exception instance or None.\nraise RuntimeError from exc\n```python\n\nThis can be useful when you are transforming exceptions. For example:\n\n```python\n>>> def func():\n...     raise ConnectionError\n...\n>>> try:\n...     func()\n... except ConnectionError as exc:\n...     raise RuntimeError('Failed to open database') from exc\n...\nTraceback (most recent call last):\n  File \"<stdin>\", line 2, in <module>\n    func()\n    ~~~~^^\n  File \"<stdin>\", line 2, in func\nConnectionError\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"<stdin>\", line 4, in <module>\n    raise RuntimeError('Failed to open database') from exc\nRuntimeError: Failed to open database\n```python\n\nIt also allows disabling automatic exception chaining using the from None idiom:\n\n```python\n>>> try:\n...     open('database.sqlite')\n... except OSError:\n...     raise RuntimeError from None\n...\nTraceback (most recent call last):\n  File \"<stdin>\", line 4, in <module>\n    raise RuntimeError from None\nRuntimeError\n```python\n\nFor more information about chaining mechanics, see Built-in Exceptions .\n\n## 8.6.User-defined Exceptions\u00c2\u00b6\n\nPrograms may name their own exceptions by creating a new exception class (see Classes for more about Python classes).  Exceptions should typically\nbe derived from the Exception class, either directly or indirectly.\n\nException classes can be defined which do anything any other class can do, but\nare usually kept simple, often only offering a number of attributes that allow\ninformation about the error to be extracted by handlers for the exception.\n\nMost exceptions are defined with names that end in \u00e2\u0080\u009cError\u00e2\u0080\u009d, similar to the\nnaming of the standard exceptions.\n\nMany standard modules define their own exceptions to report errors that may\noccur in functions they define.\n\n## 8.7.Defining Clean-up Actions\u00c2\u00b6\n\nThe try statement has another optional clause which is intended to\ndefine clean-up actions that must be executed under all circumstances.  For\nexample:\n\n```python\n>>> try:\n...     raise KeyboardInterrupt\n... finally:\n...     print('Goodbye, world!')\n...\nGoodbye, world!\nTraceback (most recent call last):\n  File \"<stdin>\", line 2, in <module>\n    raise KeyboardInterrupt\nKeyboardInterrupt\n```python\n\nIf a finally clause is present, the finally clause will execute as the last task before the try statement completes. The finally clause runs whether or\nnot the try statement produces an exception. The following\npoints discuss more complex cases when an exception occurs:\n\n- If an exception occurs during execution of the try clause, the exception may be handled by an except clause. If the exception is not handled by an except clause, the exception is re-raised after the finally clause has been executed.\n- An exception could occur during execution of an except or else clause. Again, the exception is re-raised after\nthe finally clause has been executed.\n- If the finally clause executes a break , continue or return statement, exceptions are not\nre-raised. This can be confusing and is therefore discouraged. From\nversion 3.14 the compiler emits a SyntaxWarning for it\n(see PEP 765 ).\n- If the try statement reaches a break , continue or return statement, the finally clause will execute just prior to the break , continue or return statement\u00e2\u0080\u0099s execution.\n- If a finally clause includes a return statement, the returned value will be the one from the finally clause\u00e2\u0080\u0099s return statement, not the\nvalue from the try clause\u00e2\u0080\u0099s return statement. This can be confusing and is therefore discouraged. From\nversion 3.14 the compiler emits a SyntaxWarning for it\n(see PEP 765 ).\n\nFor example:\n\n```python\n>>> def bool_return():\n...     try:\n...         return True\n...     finally:\n...         return False\n...\n>>> bool_return()\nFalse\n```python\n\nA more complicated example:\n\n```python\n>>> def divide(x, y):\n...     try:\n...         result = x / y\n...     except ZeroDivisionError:\n...         print(\"division by zero!\")\n...     else:\n...         print(\"result is\", result)\n...     finally:\n...         print(\"executing finally clause\")\n...\n>>> divide(2, 1)\nresult is 2.0\nexecuting finally clause\n>>> divide(2, 0)\ndivision by zero!\nexecuting finally clause\n>>> divide(\"2\", \"1\")\nexecuting finally clause\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n    divide(\"2\", \"1\")\n    ~~~~~~^^^^^^^^^^\n  File \"<stdin>\", line 3, in divide\n    result = x / y\n             ~~^~~\nTypeError: unsupported operand type(s) for /: 'str' and 'str'\n```python\n\nAs you can see, the finally clause is executed in any event.  The TypeError raised by dividing two strings is not handled by the except clause and therefore re-raised after the finally clause has been executed.\n\nIn real world applications, the finally clause is useful for\nreleasing external resources (such as files or network connections), regardless\nof whether the use of the resource was successful.\n\n## 8.8.Predefined Clean-up Actions\u00c2\u00b6\n\nSome objects define standard clean-up actions to be undertaken when the object\nis no longer needed, regardless of whether or not the operation using the object\nsucceeded or failed. Look at the following example, which tries to open a file\nand print its contents to the screen.\n\n```python\nfor line in open(\"myfile.txt\"):\n    print(line, end=\"\")\n```python\n\nThe problem with this code is that it leaves the file open for an indeterminate\namount of time after this part of the code has finished executing.\nThis is not an issue in simple scripts, but can be a problem for larger\napplications. The with statement allows objects like files to be\nused in a way that ensures they are always cleaned up promptly and correctly.\n\n```python\nwith open(\"myfile.txt\") as f:\n    for line in f:\n        print(line, end=\"\")\n```python\n\nAfter the statement is executed, the file f is always closed, even if a\nproblem was encountered while processing the lines. Objects which, like files,\nprovide predefined clean-up actions will indicate this in their documentation.\n\n## 8.9.Raising and Handling Multiple Unrelated Exceptions\u00c2\u00b6\n\nThere are situations where it is necessary to report several exceptions that\nhave occurred. This is often the case in concurrency frameworks, when several\ntasks may have failed in parallel, but there are also other use cases where\nit is desirable to continue execution and collect multiple errors rather than\nraise the first exception.\n\nThe builtin ExceptionGroup wraps a list of exception instances so\nthat they can be raised together. It is an exception itself, so it can be\ncaught like any other exception.\n\n```python\n>>> def f():\n...     excs = [OSError('error 1'), SystemError('error 2')]\n...     raise ExceptionGroup('there were problems', excs)\n...\n>>> f()\n  + Exception Group Traceback (most recent call last):\n  |   File \"<stdin>\", line 1, in <module>\n  |     f()\n  |     ~^^\n  |   File \"<stdin>\", line 3, in f\n  |     raise ExceptionGroup('there were problems', excs)\n  | ExceptionGroup: there were problems (2 sub-exceptions)\n  +-+---------------- 1 ----------------\n    | OSError: error 1\n    +---------------- 2 ----------------\n    | SystemError: error 2\n    +------------------------------------\n>>> try:\n...     f()\n... except Exception as e:\n...     print(f'caught {type(e)}: e')\n...\ncaught <class 'ExceptionGroup'>: e\n>>>\n```python\n\nBy using except* instead of except , we can selectively\nhandle only the exceptions in the group that match a certain\ntype. In the following example, which shows a nested exception\ngroup, each except* clause extracts from the group exceptions\nof a certain type while letting all other exceptions propagate to\nother clauses and eventually to be reraised.\n\n```python\n>>> def f():\n...     raise ExceptionGroup(\n...         \"group1\",\n...         [\n...             OSError(1),\n...             SystemError(2),\n...             ExceptionGroup(\n...                 \"group2\",\n...                 [\n...                     OSError(3),\n...                     RecursionError(4)\n...                 ]\n...             )\n...         ]\n...     )\n...\n>>> try:\n...     f()\n... except* OSError as e:\n...     print(\"There were OSErrors\")\n... except* SystemError as e:\n...     print(\"There were SystemErrors\")\n...\nThere were OSErrors\nThere were SystemErrors\n  + Exception Group Traceback (most recent call last):\n  |   File \"<stdin>\", line 2, in <module>\n  |     f()\n  |     ~^^\n  |   File \"<stdin>\", line 2, in f\n  |     raise ExceptionGroup(\n  |     ...<12 lines>...\n  |     )\n  | ExceptionGroup: group1 (1 sub-exception)\n  +-+---------------- 1 ----------------\n    | ExceptionGroup: group2 (1 sub-exception)\n    +-+---------------- 1 ----------------\n      | RecursionError: 4\n      +------------------------------------\n>>>\n```python\n\nNote that the exceptions nested in an exception group must be instances,\nnot types. This is because in practice the exceptions would typically\nbe ones that have already been raised and caught by the program, along\nthe following pattern:\n\n```python\n>>> excs = []\n... for test in tests:\n...     try:\n...         test.run()\n...     except Exception as e:\n...         excs.append(e)\n...\n>>> if excs:\n...    raise ExceptionGroup(\"Test Failures\", excs)\n...\n```python\n\n## 8.10.Enriching Exceptions with Notes\u00c2\u00b6\n\nWhen an exception is created in order to be raised, it is usually initialized\nwith information that describes the error that has occurred. There are cases\nwhere it is useful to add information after the exception was caught. For this\npurpose, exceptions have a method add_note(note) that accepts a string and\nadds it to the exception\u00e2\u0080\u0099s notes list. The standard traceback rendering\nincludes all notes, in the order they were added, after the exception.\n\n```python\n>>> try:\n...     raise TypeError('bad type')\n... except Exception as e:\n...     e.add_note('Add some information')\n...     e.add_note('Add some more information')\n...     raise\n...\nTraceback (most recent call last):\n  File \"<stdin>\", line 2, in <module>\n    raise TypeError('bad type')\nTypeError: bad type\nAdd some information\nAdd some more information\n>>>\n```python\n\nFor example, when collecting exceptions into an exception group, we may want\nto add context information for the individual errors. In the following each\nexception in the group has a note indicating when this error has occurred.\n\n```python\n>>> def f():\n...     raise OSError('operation failed')\n...\n>>> excs = []\n>>> for i in range(3):\n...     try:\n...         f()\n...     except Exception as e:\n...         e.add_note(f'Happened in Iteration {i+1}')\n...         excs.append(e)\n...\n>>> raise ExceptionGroup('We have some problems', excs)\n  + Exception Group Traceback (most recent call last):\n  |   File \"<stdin>\", line 1, in <module>\n  |     raise ExceptionGroup('We have some problems', excs)\n  | ExceptionGroup: We have some problems (3 sub-exceptions)\n  +-+---------------- 1 ----------------\n    | Traceback (most recent call last):\n    |   File \"<stdin>\", line 3, in <module>\n    |     f()\n    |     ~^^\n    |   File \"<stdin>\", line 2, in f\n    |     raise OSError('operation failed')\n    | OSError: operation failed\n    | Happened in Iteration 1\n    +---------------- 2 ----------------\n    | Traceback (most recent call last):\n    |   File \"<stdin>\", line 3, in <module>\n    |     f()\n    |     ~^^\n    |   File \"<stdin>\", line 2, in f\n    |     raise OSError('operation failed')\n    | OSError: operation failed\n    | Happened in Iteration 2\n    +---------------- 3 ----------------\n    | Traceback (most recent call last):\n    |   File \"<stdin>\", line 3, in <module>\n    |     f()\n    |     ~^^\n    |   File \"<stdin>\", line 2, in f\n    |     raise OSError('operation failed')\n    | OSError: operation failed\n    | Happened in Iteration 3\n    +------------------------------------\n>>>\n```",
      "difficulty": "intro",
      "doc_id": "doc-8-errors-and-exceptions-4be803f400",
      "provenance": {
        "author": "",
        "date": "",
        "license": "PSF Documentation License",
        "source_file": "data/corpus_raw/3_tutorial_errors_html_418c6e.json",
        "url": "https://docs.python.org/3/tutorial/errors.html"
      },
      "title": "8.Errors and Exceptions\u00c2\u00b6",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "file_io",
        "pathlib",
        "reading_writing"
      ],
      "content": "## 8INPUT VALIDATION\n\nInput validation code checks that values entered by the user, such as text from the input() function, are formatted correctly. For example, if you want users to enter their ages, your code shouldn\u2019t accept nonsensical answers such as negative numbers (which are outside the range of acceptable integers) or words (which are the wrong data type). Input validation can also prevent bugs or security vulnerabilities. If you implement a withdrawFromAccount() function that takes an argument for the amount to subtract from an account, you need to ensure the amount is a positive number. If the withdrawFromAccount() function subtracts a negative number from the account, the \u201cwithdrawal\u201d will end up adding money!\n\nTypically, we perform input validation by repeatedly asking the user for input until they enter valid text, as in the following example:\n\nwhile True: print('Enter your age:') age = input() try: age = int(age) except: print('Please use numeric digits.') continue if age < 1: print('Please enter a positive number.') continue break print(f'Your age is {age}.')\n\nWhen you run this program, the output could look like this:\n\nEnter your age: five Please use numeric digits. Enter your age: -2 Please enter a positive number. Enter your age: 30 Your age is 30.\n\nWhen you run this code, you\u2019ll be prompted for your age until you enter a valid one. This ensures that by the time the execution leaves the while loop, the age variable will contain a valid value that won\u2019t crash the program later on.\n\nHowever, writing input validation code for every input() call in your program quickly becomes tedious. Also, you may miss certain cases and allow invalid input to pass through your checks. In this chapter, you\u2019ll learn how to use the third-party PyInputPlus module for input validation.\n\n### The PyInputPlus Module\n\nPyInputPlus contains functions similar to input() for several kinds of data: numbers, dates, email addresses, and more. If the user ever enters invalid input, such as a badly formatted date or a number that is outside of an intended range, PyInputPlus will reprompt them for input just like our code in the previous section did. PyInputPlus also has other useful features like a limit for the number of times it reprompts users and a timeout if users are required to respond within a time limit.\n\nPyInputPlus is not a part of the Python Standard Library, so you must install it separately using Pip. To install PyInputPlus, run pip install --user pyinputplus from the command line. Appendix A has complete instructions for installing third-party modules. To check if PyInputPlus installed correctly, import it in the interactive shell:\n\n>>> import pyinputplus\n\nIf no errors appear when you import the module, it has been successfully installed.\n\nPyInputPlus has several functions for different kinds of input:\n\ninputStr() Is like the built-in input() function but has the general PyInputPlus features. You can also pass a custom validation function to it\n\ninputNum() Ensures the user enters a number and returns an int or float, depending on if the number has a decimal point in it\n\ninputChoice() Ensures the user enters one of the provided choices\n\ninputMenu() Is similar to inputChoice() , but provides a menu with numbered or lettered options\n\ninputDatetime() Ensures the user enters a date and time\n\ninputYesNo() Ensures the user enters a \u201cyes\u201d or \u201cno\u201d response\n\ninputBool() Is similar to inputYesNo() , but takes a \u201cTrue\u201d or \u201cFalse\u201d response and returns a Boolean value\n\ninputEmail() Ensures the user enters a valid email address\n\ninputFilepath() Ensures the user enters a valid file path and filename, and can optionally check that a file with that name exists\n\ninputPassword() Is like the built-in input() , but displays * characters as the user types so that passwords, or other sensitive information, aren\u2019t displayed on the screen\n\nThese functions will automatically reprompt the user for as long as they enter invalid input:\n\n>>> import pyinputplus as pyip >>> response = pyip.inputNum() five 'five' is not a number. 42 >>> response 42\n\nThe as pyip code in the import statement saves us from typing pyinputplus each time we want to call a PyInputPlus function. Instead we can use the shorter pyip name. If you take a look at the example, you see that unlike input() , these functions return an int or float value: 42 and 3.14 instead of the strings '42' and '3.14' .\n\nJust as you can pass a string to input() to provide a prompt, you can pass a string to a PyInputPlus function\u2019s prompt keyword argument to display a prompt:\n\n>>> response = input('Enter a number: ') Enter a number: 42 >>> response '42' >>> import pyinputplus as pyip >>> response = pyip.inputInt(prompt='Enter a number: ') Enter a number: cat 'cat' is not an integer. Enter a number: 42 >>> response 42\n\nUse Python\u2019s help() function to find out more about each of these functions. For example, help(pyip.inputChoice) displays help information for the inputChoice() function. Complete documentation can be found at https://pyinputplus.readthedocs.io/ .\n\nUnlike Python\u2019s built-in input() , PyInputPlus functions have several additional features for input validation, as shown in the next section.\n\n#### The min, max, greaterThan, and lessThan Keyword Arguments\n\nThe inputNum() , inputInt() , and inputFloat() functions, which accept int and float numbers, also have min , max , greaterThan , and lessThan keyword arguments for specifying a range of valid values. For example, enter the following into the interactive shell:\n\n>>> import pyinputplus as pyip >>> response = pyip.inputNum('Enter num: ', min=4) Enter num: 3 Input must be at minimum 4. Enter num: 4 >>> response 4 >>> response = pyip.inputNum('Enter num: ', greaterThan=4) Enter num: 4 Input must be greater than 4. Enter num: 5 >>> response 5 >>> response = pyip.inputNum('>', min=4, lessThan=6) Enter num: 6 Input must be less than 6. Enter num: 3 Input must be at minimum 4. Enter num: 4 >>> response 4\n\nThese keyword arguments are optional, but if supplied, the input cannot be less than the min argument or greater than the max argument (though the input can be equal to them). Also, the input must be greater than the greaterThan and less than the lessThan arguments (that is, the input cannot be equal to them).\n\n#### The blank Keyword Argument\n\nBy default, blank input isn\u2019t allowed unless the blank keyword argument is set to True :\n\n>>> import pyinputplus as pyip >>> response = pyip.inputNum('Enter num: ') Enter num: (blank input entered here) Blank values are not allowed. Enter num: 42 >>> response 42 >>> response = pyip.inputNum(blank=True) (blank input entered here) >>> response ''\n\nUse blank=True if you\u2019d like to make input optional so that the user doesn\u2019t need to enter anything.\n\n#### The limit, timeout, and default Keyword Arguments\n\nBy default, the PyInputPlus functions will continue to ask the user for valid input forever (or for as long as the program runs). If you\u2019d like a function to stop asking the user for input after a certain number of tries or a certain amount of time, you can use the limit and timeout keyword arguments. Pass an integer for the limit keyword argument to determine how many attempts a PyInputPlus function will make to receive valid input before giving up, and pass an integer for the timeout keyword argument to determine how many seconds the user has to enter valid input before the PyInputPlus function gives up.\n\nIf the user fails to enter valid input, these keyword arguments will cause the function to raise a RetryLimitException or TimeoutException , respectively. For example, enter the following into the interactive shell:\n\n>>> import pyinputplus as pyip >>> response = pyip.inputNum(limit=2) blah 'blah' is not a number. Enter num: number 'number' is not a number. Traceback (most recent call last): --snip-- pyinputplus.RetryLimitException >>> response = pyip.inputNum(timeout=10) 42 (entered after 10 seconds of waiting) Traceback (most recent call last): --snip-- pyinputplus.TimeoutException\n\nWhen you use these keyword arguments and also pass a default keyword argument, the function returns the default value instead of raising an exception. Enter the following into the interactive shell:\n\n>>> response = pyip.inputNum(limit=2, default='N/A') hello 'hello' is not a number. world 'world' is not a number. >>> response 'N/A'\n\nInstead of raising RetryLimitException , the inputNum() function simply returns the string 'N/A' .\n\n#### The allowRegexes and blockRegexes Keyword Arguments\n\nYou can also use regular expressions to specify whether an input is allowed or not. The allowRegexes and blockRegexes keyword arguments take a list of regular expression strings to determine what the PyInputPlus function will accept or reject as valid input. For example, enter the following code into the interactive shell so that inputNum() will accept Roman numerals in addition to the usual numbers:\n\n>>> import pyinputplus as pyip >>> response = pyip.inputNum(allowRegexes=[r'(I|V|X|L|C|D|M)+', r'zero']) XLII >>> response 'XLII' >>> response = pyip.inputNum(allowRegexes=[r'(i|v|x|l|c|d|m)+', r'zero']) xlii >>> response 'xlii'\n\nOf course, this regex affects only what letters the inputNum() function will accept from the user; the function will still accept Roman numerals with invalid ordering such as 'XVX' or 'MILLI' because the r'(I|V|X|L|C|D|M)+' regular expression accepts those strings.\n\nYou can also specify a list of regular expression strings that a PyInputPlus function won\u2019t accept by using the blockRegexes keyword argument. Enter the following into the interactive shell so that inputNum() won\u2019t accept even numbers:\n\n>>> import pyinputplus as pyip >>> response = pyip.inputNum(blockRegexes=[r'[02468]$']) 42 This response is invalid. 44 This response is invalid. 43 >>> response 43\n\nIf you specify both an allowRegexes and blockRegexes argument, the allow list overrides the block list. For example, enter the following into the interactive shell, which allows 'caterpillar' and 'category' but blocks anything else that has the word 'cat' in it:\n\n>>> import pyinputplus as pyip >>> response = pyip.inputStr(allowRegexes=[r'caterpillar', 'category'], blockRegexes=[r'cat']) cat This response is invalid. catastrophe This response is invalid. category >>> response 'category'\n\nThe PyInputPlus module\u2019s functions can save you from writing tedious input validation code yourself. But there\u2019s more to the PyInputPlus module than what has been detailed here. You can examine its full documentation online at https://pyinputplus.readthedocs.io/ .\n\n#### Passing a Custom Validation Function to inputCustom()\n\nYou can write a function to perform your own custom validation logic by passing the function to inputCustom() . For example, say you want the user to enter a series of digits that adds up to 10. There is no pyinputplus.inputAddsUpToTen() function, but you can create your own function that:\n\n- Accepts a single string argument of what the user entered\n- Raises an exception if the string fails validation\n- Returns None (or has no return statement) if inputCustom() should return the string unchanged\n- Returns a non- None value if inputCustom() should return a different string from the one the user entered\n- Is passed as the first argument to inputCustom()\n\nFor example, we can create our own addsUpToTen() function, and then pass it to inputCustom() . Note that the function call looks like inputCustom(addsUpToTen) and not inputCustom(addsUpToTen()) because we are passing the addsUpToTen() function itself to inputCustom() , not calling addsUpToTen() and passing its return value.\n\n>>> import pyinputplus as pyip >>> def addsUpToTen(numbers): ... numbersList = list(numbers) ... for i, digit in enumerate(numbersList): ... numbersList[i] = int(digit) ... if sum(numbersList) != 10: ... raise Exception('The digits must add up to 10, not %s.' % (sum(numbersList))) ... return int(numbers) # Return an int form of numbers. ... >>> response = pyip.inputCustom(addsUpToTen) # No parentheses after addsUpToTen here. 123 The digits must add up to 10, not 6. 1235 The digits must add up to 10, not 11. 1234 >>> response # inputStr() returned an int, not a string. 1234 >>> response = pyip.inputCustom(addsUpToTen) hello invalid literal for int() with base 10: 'h' 55 >>> response\n\nThe inputCustom() function also supports the general PyInputPlus features, such as the blank , limit , timeout , default , allowRegexes , and blockRegexes keyword arguments. Writing your own custom validation function is useful when it\u2019s otherwise difficult or impossible to write a regular expression for valid input, as in the \u201cadds up to 10\u201d example.\n\n### Project: How to Keep an Idiot Busy for Hours\n\nLet\u2019s use PyInputPlus to create a simple program that does the following:\n\n- Ask the user if they\u2019d like to know how to keep an idiot busy for hours.\n- If the user answers no, quit.\n- If the user answers yes, go to Step 1.\n\nOf course, we don\u2019t know if the user will enter something besides \u201cyes\u201d or \u201cno,\u201d so we need to perform input validation. It would also be convenient for the user to be able to enter \u201cy\u201d or \u201cn\u201d instead of the full words. PyInputPlus\u2019s inputYesNo() function will handle this for us and, no matter what case the user enters, return a lowercase 'yes' or 'no' string value.\n\nWhen you run this program, it should look like the following:\n\nWant to know how to keep an idiot busy for hours? sure 'sure' is not a valid yes/no response. Want to know how to keep an idiot busy for hours? yes Want to know how to keep an idiot busy for hours? y Want to know how to keep an idiot busy for hours? Yes Want to know how to keep an idiot busy for hours? YES Want to know how to keep an idiot busy for hours? YES!!!!!! 'YES!!!!!!' is not a valid yes/no response. Want to know how to keep an idiot busy for hours? TELL ME HOW TO KEEP AN IDIOT BUSY FOR HOURS. 'TELL ME HOW TO KEEP AN IDIOT BUSY FOR HOURS.' is not a valid yes/no response. Want to know how to keep an idiot busy for hours? no Thank you. Have a nice day.\n\nOpen a new file editor tab and save it as idiot.py . Then enter the following code:\n\nimport pyinputplus as pyip\n\nThis imports the PyInputPlus module. Since pyinputplus is a bit much to type, we\u2019ll use the name pyip for short.\n\nwhile True: prompt = 'Want to know how to keep an idiot busy for hours?\\n' response = pyip.inputYesNo(prompt)\n\nNext, while True: creates an infinite loop that continues to run until it encounters a break statement. In this loop, we call pyip.inputYesNo() to ensure that this function call won\u2019t return until the user enters a valid answer.\n\nif response == 'no': break\n\nThe pyip.inputYesNo() call is guaranteed to only return either the string yes or the string no . If it returned no , then our program breaks out of the infinite loop and continues to the last line, which thanks the user:\n\nprint('Thank you. Have a nice day.')\n\nOtherwise, the loop iterates once again.\n\nYou can also make use of the inputYesNo() function in non-English languages by passing yesVal and noVal keyword arguments. For example, the Spanish version of this program would have these two lines:\n\nprompt = '\u00bfQuieres saber c\u00f3mo mantener ocupado a un idiota durante horas?\\n' response = pyip.inputYesNo(prompt, yesVal='s\u00ed', noVal='no') if response == 's\u00ed':\n\nNow the user can enter either s\u00ed or s (in lower- or uppercase) instead of yes or y for an affirmative answer.\n\n### Project: Multiplication Quiz\n\nPyInputPlus\u2019s features can be useful for creating a timed multiplication quiz. By setting the allowRegexes , blockRegexes , timeout , and limit keyword argument to pyip.inputStr() , you can leave most of the implementation to PyInputPlus. The less code you need to write, the faster you can write your programs. Let\u2019s create a program that poses 10 multiplication problems to the user, where the valid input is the problem\u2019s correct answer. Open a new file editor tab and save the file as multiplicationQuiz.py .\n\nFirst, we\u2019ll import pyinputplus , random , and time . We\u2019ll keep track of how many questions the program asks and how many correct answers the user gives with the variables numberOfQuestions and correctAnswers . A for loop will repeatedly pose a random multiplication problem 10 times:\n\nimport pyinputplus as pyip import random, time numberOfQuestions = 10 correctAnswers = 0 for questionNumber in range(numberOfQuestions):\n\nInside the for loop, the program will pick two single-digit numbers to multiply. We\u2019ll use these numbers to create a #Q: N \u00d7 N = prompt for the user, where Q is the question number (1 to 10) and N are the two numbers to multiply.\n\n# Pick two random numbers: num1 = random.randint(0, 9) num2 = random.randint(0, 9) prompt = '#%s: %s x %s = ' % (questionNumber, num1, num2)\n\nThe pyip.inputStr() function will handle most of the features of this quiz program. The argument we pass for allowRegexes is a list with the regex string '^%s$' , where %s is replaced with the correct answer. The ^ and % characters ensure that the answer begins and ends with the correct number, though PyInputPlus trims any whitespace from the start and end of the user\u2019s response first just in case they inadvertently pressed the spacebar before or after their answer. The argument we pass for blocklistRegexes is a list with ('.*', 'Incorrect!') . The first string in the tuple is a regex that matches every possible string. Therefore, if the user response doesn\u2019t match the correct answer, the program will reject any other answer they provide. In that case, the 'Incorrect!' string is displayed and the user is prompted to answer again. Additionally, passing 8 for timeout and 3 for limit will ensure that the user only has 8 seconds and 3 tries to provide a correct answer:\n\ntry: # Right answers are handled by allowRegexes. # Wrong answers are handled by blockRegexes, with a custom message. pyip.inputStr(prompt, allowRegexes=['^%s$' % (num1 * num2)], blockRegexes=[('.*', 'Incorrect!')], timeout=8, limit=3)\n\nIf the user answers after the 8-second timeout has expired, even if they answer correctly, pyip.inputStr() raises a TimeoutException exception. If the user answers incorrectly more than 3 times, it raises a RetryLimitException exception. Both of these exception types are in the PyInputPlus module, so pyip. needs to prepend them:\n\nexcept pyip.TimeoutException: print('Out of time!') except pyip.RetryLimitException: print('Out of tries!')\n\nRemember that, just like how else blocks can follow an if or elif block, they can optionally follow the last except block. The code inside the following else block will run if no exception was raised in the try block. In our case, that means the code runs if the user entered the correct answer:\n\nelse: # This block runs if no exceptions were raised in the try block. print('Correct!') correctAnswers += 1\n\nNo matter which of the three messages, \u201cOut of time!\u201d, \u201cOut of tries!\u201d, or \u201cCorrect!\u201d, displays, let\u2019s place a 1-second pause at the end of the for loop to give the user time to read it. After the program has asked 10 questions and the for loop continues, let\u2019s show the user how many correct answers they made:\n\ntime.sleep(1) # Brief pause to let user see the result. print('Score: %s / %s' % (correctAnswers, numberOfQuestions))\n\nPyInputPlus is flexible enough that you can use it in a wide variety of programs that take keyboard input from the user, as demonstrated by the programs in this chapter.\n\n### Summary\n\nIt\u2019s easy to forget to write input validation code, but without it, your programs will almost certainly have bugs. The values you expect users to enter and the values they actually enter can be completely different, and your programs need to be robust enough to handle these exceptional cases. You can use regular expressions to create your own input validation code, but for common cases, it\u2019s easier to use an existing module, such as PyInputPlus. You can import the module with import pyinputplus as pyip so that you can enter a shorter name when calling the module\u2019s functions.\n\nPyInputPlus has functions for entering a variety of input, including strings, numbers, dates, yes/no, True / False , emails, and files. While input() always returns a string, these functions return the value in an appropriate data type. The inputChoice() function allow you to select one of several pre-selected options, while inputMenu() also adds numbers or letters for quick selection.\n\nAll of these functions have the following standard features: stripping whitespace from the sides, setting timeout and retry limits with the timeout and limit keyword arguments, and passing lists of regular expression strings to allowRegexes or blockRegexes to include or exclude particular responses. You'll no longer need to write your own tedious while loops that check for valid input and reprompt the user.\n\nIf none of the PyInputPlus module\u2019s, functions fit your needs, but you\u2019d still like the other features that PyInputPlus provides, you can call inputCustom() and pass your own custom validation function for PyInputPlus to use. The documentation at https://pyinputplus.readthedocs.io/en/latest/ has a complete listing of PyInputPlus\u2019s functions and additional features. There\u2019s far more in the PyInputPlus online documentation than what was described in this chapter. There\u2019s no use in reinventing the wheel, and learning to use this module will save you from having to write and debug code for yourself.\n\nNow that you have expertise manipulating and validating text, it\u2019s time to learn how to read from and write to files on your computer\u2019s hard drive.\n\n### Practice Questions\n\n1. Does PyInputPlus come with the Python Standard Library?\n\n2. Why is PyInputPlus commonly imported with import pyinputplus as pyip ?\n\n3. What is the difference between inputInt() and inputFloat() ?\n\n4. How can you ensure that the user enters a whole number between 0 and 99 using PyInputPlus?\n\n5. What is passed to the allowRegexes and blockRegexes keyword arguments?\n\n6. What does inputStr(limit=3) do if blank input is entered three times?\n\n7. What does inputStr(limit=3, default='hello') do if blank input is entered three times?\n\n### Practice Projects\n\nFor practice, write programs to do the following tasks.\n\n#### Sandwich Maker\n\nWrite a program that asks users for their sandwich preferences. The program should use PyInputPlus to ensure that they enter valid input, such as:\n\n- Using inputMenu() for a bread type: wheat, white, or sourdough.\n- Using inputMenu() for a protein type: chicken, turkey, ham, or tofu.\n- Using inputYesNo() to ask if they want cheese.\n- If so, using inputMenu() to ask for a cheese type: cheddar, Swiss, or mozzarella.\n- Using inputYesNo() to ask if they want mayo, mustard, lettuce, or tomato.\n- Using inputInt() to ask how many sandwiches they want. Make sure this number is 1 or more.\n\nCome up with prices for each of these options, and have your program display a total cost after the user enters their selection.\n\n#### Write Your Own Multiplication Quiz\n\nTo see how much PyInputPlus is doing for you, try re-creating the multiplication quiz project on your own without importing it. This program will prompt the user with 10 multiplication questions, ranging from 0 \u00d7 0 to 9 \u00d7 9. You\u2019ll need to implement the following features:\n\n- If the user enters the correct answer, the program displays \u201cCorrect!\u201d for 1 second and moves on to the next question.\n- The user gets three tries to enter the correct answer before the program moves on to the next question.\n- Eight seconds after first displaying the question, the question is marked as incorrect even if the user enters the correct answer after the 8-second limit.\n\nCompare your code to the code using PyInputPlus in \u201cProject: Multiplication Quiz\u201d on page 196.",
      "difficulty": "intro",
      "doc_id": "doc-8input-validation-775383f118",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-NC-SA 3.0",
        "source_file": "data/corpus_raw/scraped/2e_chapter8_88673c.json",
        "url": "https://automatetheboringstuff.com/2e/chapter8/"
      },
      "title": "8INPUT VALIDATION",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "OOP",
        "classes",
        "inheritance",
        "objects",
        "scope"
      ],
      "content": "# 9.Classes\u00c2\u00b6\n\nClasses provide a means of bundling data and functionality together.  Creating\na new class creates a new type of object, allowing new instances of that\ntype to be made.  Each class instance can have attributes attached to it for\nmaintaining its state.  Class instances can also have methods (defined by its\nclass) for modifying its state.\n\nCompared with other programming languages, Python\u00e2\u0080\u0099s class mechanism adds classes\nwith a minimum of new syntax and semantics.  It is a mixture of the class\nmechanisms found in C++ and Modula-3.  Python classes provide all the standard\nfeatures of Object Oriented Programming: the class inheritance mechanism allows\nmultiple base classes, a derived class can override any methods of its base\nclass or classes, and a method can call the method of a base class with the same\nname.  Objects can contain arbitrary amounts and kinds of data.  As is true for\nmodules, classes partake of the dynamic nature of Python: they are created at\nruntime, and can be modified further after creation.\n\nIn C++ terminology, normally class members (including the data members) are public (except see below Private Variables ), and all member functions are virtual .  As in Modula-3, there are no shorthands for referencing the object\u00e2\u0080\u0099s\nmembers from its methods: the method function is declared with an explicit first\nargument representing the object, which is provided implicitly by the call.  As\nin Smalltalk, classes themselves are objects.  This provides semantics for\nimporting and renaming.  Unlike C++ and Modula-3, built-in types can be used as\nbase classes for extension by the user.  Also, like in C++, most built-in\noperators with special syntax (arithmetic operators, subscripting etc.) can be\nredefined for class instances.\n\n(Lacking universally accepted terminology to talk about classes, I will make\noccasional use of Smalltalk and C++ terms.  I would use Modula-3 terms, since\nits object-oriented semantics are closer to those of Python than C++, but I\nexpect that few readers have heard of it.)\n\n## 9.1.A Word About Names and Objects\u00c2\u00b6\n\nObjects have individuality, and multiple names (in multiple scopes) can be bound\nto the same object.  This is known as aliasing in other languages.  This is\nusually not appreciated on a first glance at Python, and can be safely ignored\nwhen dealing with immutable basic types (numbers, strings, tuples).  However,\naliasing has a possibly surprising effect on the semantics of Python code\ninvolving mutable objects such as lists, dictionaries, and most other types.\nThis is usually used to the benefit of the program, since aliases behave like\npointers in some respects.  For example, passing an object is cheap since only a\npointer is passed by the implementation; and if a function modifies an object\npassed as an argument, the caller will see the change \u00e2\u0080\u0094 this eliminates the\nneed for two different argument passing mechanisms as in Pascal.\n\n## 9.2.Python Scopes and Namespaces\u00c2\u00b6\n\nBefore introducing classes, I first have to tell you something about Python\u00e2\u0080\u0099s\nscope rules.  Class definitions play some neat tricks with namespaces, and you\nneed to know how scopes and namespaces work to fully understand what\u00e2\u0080\u0099s going on.\nIncidentally, knowledge about this subject is useful for any advanced Python\nprogrammer.\n\nLet\u00e2\u0080\u0099s begin with some definitions.\n\nA namespace is a mapping from names to objects.  Most namespaces are currently\nimplemented as Python dictionaries, but that\u00e2\u0080\u0099s normally not noticeable in any\nway (except for performance), and it may change in the future.  Examples of\nnamespaces are: the set of built-in names (containing functions such as abs() , and\nbuilt-in exception names); the global names in a module; and the local names in\na function invocation.  In a sense the set of attributes of an object also form\na namespace.  The important thing to know about namespaces is that there is\nabsolutely no relation between names in different namespaces; for instance, two\ndifferent modules may both define a function maximize without confusion \u00e2\u0080\u0094\nusers of the modules must prefix it with the module name.\n\nBy the way, I use the word attribute for any name following a dot \u00e2\u0080\u0094 for\nexample, in the expression z.real , real is an attribute of the object z .  Strictly speaking, references to names in modules are attribute\nreferences: in the expression modname.funcname , modname is a module\nobject and funcname is an attribute of it.  In this case there happens to be\na straightforward mapping between the module\u00e2\u0080\u0099s attributes and the global names\ndefined in the module: they share the same namespace! [ 1 ]\n\nAttributes may be read-only or writable.  In the latter case, assignment to\nattributes is possible.  Module attributes are writable: you can write modname.the_answer = 42 .  Writable attributes may also be deleted with the del statement.  For example, del modname.the_answer will remove\nthe attribute the_answer from the object named by modname .\n\nNamespaces are created at different moments and have different lifetimes.  The\nnamespace containing the built-in names is created when the Python interpreter\nstarts up, and is never deleted.  The global namespace for a module is created\nwhen the module definition is read in; normally, module namespaces also last\nuntil the interpreter quits.  The statements executed by the top-level\ninvocation of the interpreter, either read from a script file or interactively,\nare considered part of a module called __main__ , so they have their own\nglobal namespace.  (The built-in names actually also live in a module; this is\ncalled builtins .)\n\nThe local namespace for a function is created when the function is called, and\ndeleted when the function returns or raises an exception that is not handled\nwithin the function.  (Actually, forgetting would be a better way to describe\nwhat actually happens.)  Of course, recursive invocations each have their own\nlocal namespace.\n\nA scope is a textual region of a Python program where a namespace is directly\naccessible.  \u00e2\u0080\u009cDirectly accessible\u00e2\u0080\u009d here means that an unqualified reference to a\nname attempts to find the name in the namespace.\n\nAlthough scopes are determined statically, they are used dynamically. At any\ntime during execution, there are 3 or 4 nested scopes whose namespaces are\ndirectly accessible:\n\n- the innermost scope, which is searched first, contains the local names\n- the scopes of any enclosing functions, which are searched starting with the\nnearest enclosing scope, contain non-local, but also non-global names\n- the next-to-last scope contains the current module\u00e2\u0080\u0099s global names\n- the outermost scope (searched last) is the namespace containing built-in names\n\nIf a name is declared global, then all references and assignments go directly to\nthe next-to-last scope containing the module\u00e2\u0080\u0099s global names.  To rebind variables\nfound outside of the innermost scope, the nonlocal statement can be\nused; if not declared nonlocal, those variables are read-only (an attempt to\nwrite to such a variable will simply create a new local variable in the\ninnermost scope, leaving the identically named outer variable unchanged).\n\nUsually, the local scope references the local names of the (textually) current\nfunction.  Outside functions, the local scope references the same namespace as\nthe global scope: the module\u00e2\u0080\u0099s namespace. Class definitions place yet another\nnamespace in the local scope.\n\nIt is important to realize that scopes are determined textually: the global\nscope of a function defined in a module is that module\u00e2\u0080\u0099s namespace, no matter\nfrom where or by what alias the function is called.  On the other hand, the\nactual search for names is done dynamically, at run time \u00e2\u0080\u0094 however, the\nlanguage definition is evolving towards static name resolution, at \u00e2\u0080\u009ccompile\u00e2\u0080\u009d\ntime, so don\u00e2\u0080\u0099t rely on dynamic name resolution!  (In fact, local variables are\nalready determined statically.)\n\nA special quirk of Python is that \u00e2\u0080\u0093 if no global or nonlocal statement is in effect \u00e2\u0080\u0093 assignments to names always go into the innermost scope.\nAssignments do not copy data \u00e2\u0080\u0094 they just bind names to objects.  The same is true\nfor deletions: the statement del x removes the binding of x from the\nnamespace referenced by the local scope.  In fact, all operations that introduce\nnew names use the local scope: in particular, import statements and\nfunction definitions bind the module or function name in the local scope.\n\nThe global statement can be used to indicate that particular\nvariables live in the global scope and should be rebound there; the nonlocal statement indicates that particular variables live in\nan enclosing scope and should be rebound there.\n\n### 9.2.1.Scopes and Namespaces Example\u00c2\u00b6\n\nThis is an example demonstrating how to reference the different scopes and\nnamespaces, and how global and nonlocal affect variable\nbinding:\n\n```python\ndef scope_test():\n    def do_local():\n        spam = \"local spam\"\n\n    def do_nonlocal():\n        nonlocal spam\n        spam = \"nonlocal spam\"\n\n    def do_global():\n        global spam\n        spam = \"global spam\"\n\n    spam = \"test spam\"\n    do_local()\n    print(\"After local assignment:\", spam)\n    do_nonlocal()\n    print(\"After nonlocal assignment:\", spam)\n    do_global()\n    print(\"After global assignment:\", spam)\n\nscope_test()\nprint(\"In global scope:\", spam)\n```python\n\nThe output of the example code is:\n\n```python\nAfter local assignment: test spam\nAfter nonlocal assignment: nonlocal spam\nAfter global assignment: nonlocal spam\nIn global scope: global spam\n```python\n\nNote how the local assignment (which is default) didn\u00e2\u0080\u0099t change scope_test 's\nbinding of spam .  The nonlocal assignment changed scope_test 's\nbinding of spam , and the global assignment changed the module-level\nbinding.\n\nYou can also see that there was no previous binding for spam before the global assignment.\n\n## 9.3.A First Look at Classes\u00c2\u00b6\n\nClasses introduce a little bit of new syntax, three new object types, and some\nnew semantics.\n\n### 9.3.1.Class Definition Syntax\u00c2\u00b6\n\nThe simplest form of class definition looks like this:\n\n```python\nclass ClassName:\n    <statement-1>\n    .\n    .\n    .\n    <statement-N>\n```python\n\nClass definitions, like function definitions ( def statements) must be\nexecuted before they have any effect.  (You could conceivably place a class\ndefinition in a branch of an if statement, or inside a function.)\n\nIn practice, the statements inside a class definition will usually be function\ndefinitions, but other statements are allowed, and sometimes useful \u00e2\u0080\u0094 we\u00e2\u0080\u0099ll\ncome back to this later.  The function definitions inside a class normally have\na peculiar form of argument list, dictated by the calling conventions for\nmethods \u00e2\u0080\u0094 again, this is explained later.\n\nWhen a class definition is entered, a new namespace is created, and used as the\nlocal scope \u00e2\u0080\u0094 thus, all assignments to local variables go into this new\nnamespace.  In particular, function definitions bind the name of the new\nfunction here.\n\nWhen a class definition is left normally (via the end), a class object is\ncreated.  This is basically a wrapper around the contents of the namespace\ncreated by the class definition; we\u00e2\u0080\u0099ll learn more about class objects in the\nnext section.  The original local scope (the one in effect just before the class\ndefinition was entered) is reinstated, and the class object is bound here to the\nclass name given in the class definition header ( ClassName in the\nexample).\n\n### 9.3.2.Class Objects\u00c2\u00b6\n\nClass objects support two kinds of operations: attribute references and\ninstantiation.\n\nAttribute references use the standard syntax used for all attribute references\nin Python: obj.name .  Valid attribute names are all the names that were in\nthe class\u00e2\u0080\u0099s namespace when the class object was created.  So, if the class\ndefinition looked like this:\n\n```python\nclass MyClass:\n    \"\"\"A simple example class\"\"\"\n    i = 12345\n\n    def f(self):\n        return 'hello world'\n```python\n\nthen MyClass.i and MyClass.f are valid attribute references, returning\nan integer and a function object, respectively. Class attributes can also be\nassigned to, so you can change the value of MyClass.i by assignment. __doc__ is also a valid attribute, returning the docstring\nbelonging to the class: \"A simple example class\" .\n\nClass instantiation uses function notation.  Just pretend that the class\nobject is a parameterless function that returns a new instance of the class.\nFor example (assuming the above class):\n\n```python\nx = MyClass()\n```python\n\ncreates a new instance of the class and assigns this object to the local\nvariable x .\n\nThe instantiation operation (\u00e2\u0080\u009ccalling\u00e2\u0080\u009d a class object) creates an empty object.\nMany classes like to create objects with instances customized to a specific\ninitial state. Therefore a class may define a special method named __init__() , like this:\n\n```python\ndef __init__(self):\n    self.data = []\n```python\n\nWhen a class defines an __init__() method, class instantiation\nautomatically invokes __init__() for the newly created class instance.  So\nin this example, a new, initialized instance can be obtained by:\n\n```python\nx = MyClass()\n```python\n\nOf course, the __init__() method may have arguments for greater\nflexibility.  In that case, arguments given to the class instantiation operator\nare passed on to __init__() .  For example,\n\n```python\n>>> class Complex:\n...     def __init__(self, realpart, imagpart):\n...         self.r = realpart\n...         self.i = imagpart\n...\n>>> x = Complex(3.0, -4.5)\n>>> x.r, x.i\n(3.0, -4.5)\n```python\n\n### 9.3.3.Instance Objects\u00c2\u00b6\n\nNow what can we do with instance objects?  The only operations understood by\ninstance objects are attribute references.  There are two kinds of valid\nattribute names: data attributes and methods.\n\nData attributes correspond to \u00e2\u0080\u009cinstance variables\u00e2\u0080\u009d in Smalltalk, and to \u00e2\u0080\u009cdata\nmembers\u00e2\u0080\u009d in C++.  Data attributes need not be declared; like local variables,\nthey spring into existence when they are first assigned to.  For example, if x is the instance of MyClass created above, the following piece of\ncode will print the value 16 , without leaving a trace:\n\n```python\nx.counter = 1\nwhile x.counter < 10:\n    x.counter = x.counter * 2\nprint(x.counter)\ndel x.counter\n```python\n\nThe other kind of instance attribute reference is a method . A method is a\nfunction that \u00e2\u0080\u009cbelongs to\u00e2\u0080\u009d an object.\n\nValid method names of an instance object depend on its class.  By definition,\nall attributes of a class that are function  objects define corresponding\nmethods of its instances.  So in our example, x.f is a valid method\nreference, since MyClass.f is a function, but x.i is not, since MyClass.i is not.  But x.f is not the same thing as MyClass.f \u00e2\u0080\u0094 it\nis a method object , not a function object.\n\n### 9.3.4.Method Objects\u00c2\u00b6\n\nUsually, a method is called right after it is bound:\n\n```python\nx.f()\n```python\n\nIf x = MyClass() , as above, this will return the string 'hello world' .\nHowever, it is not necessary to call a method right away: x.f is a method\nobject, and can be stored away and called at a later time.  For example:\n\n```python\nxf = x.f\nwhile True:\n    print(xf())\n```python\n\nwill continue to print hello world until the end of time.\n\nWhat exactly happens when a method is called?  You may have noticed that x.f() was called without an argument above, even though the function\ndefinition for f() specified an argument.  What happened to the argument?\nSurely Python raises an exception when a function that requires an argument is\ncalled without any \u00e2\u0080\u0094 even if the argument isn\u00e2\u0080\u0099t actually used\u00e2\u0080\u00a6\n\nActually, you may have guessed the answer: the special thing about methods is\nthat the instance object is passed as the first argument of the function.  In our\nexample, the call x.f() is exactly equivalent to MyClass.f(x) .  In\ngeneral, calling a method with a list of n arguments is equivalent to calling\nthe corresponding function with an argument list that is created by inserting\nthe method\u00e2\u0080\u0099s instance object before the first argument.\n\nIn general, methods work as follows.  When a non-data attribute\nof an instance is referenced, the instance\u00e2\u0080\u0099s class is searched.\nIf the name denotes a valid class attribute that is a function object,\nreferences to both the instance object and the function object\nare packed into a method object.  When the method object is called\nwith an argument list, a new argument list is constructed from the instance\nobject and the argument list, and the function object is called with this new\nargument list.\n\n### 9.3.5.Class and Instance Variables\u00c2\u00b6\n\nGenerally speaking, instance variables are for data unique to each instance\nand class variables are for attributes and methods shared by all instances\nof the class:\n\n```python\nclass Dog:\n\n    kind = 'canine'         # class variable shared by all instances\n\n    def __init__(self, name):\n        self.name = name    # instance variable unique to each instance\n\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.kind                  # shared by all dogs\n'canine'\n>>> e.kind                  # shared by all dogs\n'canine'\n>>> d.name                  # unique to d\n'Fido'\n>>> e.name                  # unique to e\n'Buddy'\n```python\n\nAs discussed in A Word About Names and Objects , shared data can have possibly surprising\neffects involving mutable objects such as lists and dictionaries.\nFor example, the tricks list in the following code should not be used as a\nclass variable because just a single list would be shared by all Dog instances:\n\n```python\nclass Dog:\n\n    tricks = []             # mistaken use of a class variable\n\n    def __init__(self, name):\n        self.name = name\n\n    def add_trick(self, trick):\n        self.tricks.append(trick)\n\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.add_trick('roll over')\n>>> e.add_trick('play dead')\n>>> d.tricks                # unexpectedly shared by all dogs\n['roll over', 'play dead']\n```python\n\nCorrect design of the class should use an instance variable instead:\n\n```python\nclass Dog:\n\n    def __init__(self, name):\n        self.name = name\n        self.tricks = []    # creates a new empty list for each dog\n\n    def add_trick(self, trick):\n        self.tricks.append(trick)\n\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.add_trick('roll over')\n>>> e.add_trick('play dead')\n>>> d.tricks\n['roll over']\n>>> e.tricks\n['play dead']\n```python\n\n## 9.4.Random Remarks\u00c2\u00b6\n\nIf the same attribute name occurs in both an instance and in a class,\nthen attribute lookup prioritizes the instance:\n\n```python\n>>> class Warehouse:\n...    purpose = 'storage'\n...    region = 'west'\n...\n>>> w1 = Warehouse()\n>>> print(w1.purpose, w1.region)\nstorage west\n>>> w2 = Warehouse()\n>>> w2.region = 'east'\n>>> print(w2.purpose, w2.region)\nstorage east\n```python\n\nData attributes may be referenced by methods as well as by ordinary users\n(\u00e2\u0080\u009cclients\u00e2\u0080\u009d) of an object.  In other words, classes are not usable to implement\npure abstract data types.  In fact, nothing in Python makes it possible to\nenforce data hiding \u00e2\u0080\u0094 it is all based upon convention.  (On the other hand,\nthe Python implementation, written in C, can completely hide implementation\ndetails and control access to an object if necessary; this can be used by\nextensions to Python written in C.)\n\nClients should use data attributes with care \u00e2\u0080\u0094 clients may mess up invariants\nmaintained by the methods by stamping on their data attributes.  Note that\nclients may add data attributes of their own to an instance object without\naffecting the validity of the methods, as long as name conflicts are avoided \u00e2\u0080\u0094\nagain, a naming convention can save a lot of headaches here.\n\nThere is no shorthand for referencing data attributes (or other methods!) from\nwithin methods.  I find that this actually increases the readability of methods:\nthere is no chance of confusing local variables and instance variables when\nglancing through a method.\n\nOften, the first argument of a method is called self .  This is nothing more\nthan a convention: the name self has absolutely no special meaning to\nPython.  Note, however, that by not following the convention your code may be\nless readable to other Python programmers, and it is also conceivable that a class browser program might be written that relies upon such a convention.\n\nAny function object that is a class attribute defines a method for instances of\nthat class.  It is not necessary that the function definition is textually\nenclosed in the class definition: assigning a function object to a local\nvariable in the class is also ok.  For example:\n\n```python\n# Function defined outside the class\ndef f1(self, x, y):\n    return min(x, x+y)\n\nclass C:\n    f = f1\n\n    def g(self):\n        return 'hello world'\n\n    h = g\n```python\n\nNow f , g and h are all attributes of class C that refer to\nfunction objects, and consequently they are all methods of instances of C \u00e2\u0080\u0094 h being exactly equivalent to g .  Note that this practice\nusually only serves to confuse the reader of a program.\n\nMethods may call other methods by using method attributes of the self argument:\n\n```python\nclass Bag:\n    def __init__(self):\n        self.data = []\n\n    def add(self, x):\n        self.data.append(x)\n\n    def addtwice(self, x):\n        self.add(x)\n        self.add(x)\n```python\n\nMethods may reference global names in the same way as ordinary functions.  The\nglobal scope associated with a method is the module containing its\ndefinition.  (A class is never used as a global scope.)  While one\nrarely encounters a good reason for using global data in a method, there are\nmany legitimate uses of the global scope: for one thing, functions and modules\nimported into the global scope can be used by methods, as well as functions and\nclasses defined in it.  Usually, the class containing the method is itself\ndefined in this global scope, and in the next section we\u00e2\u0080\u0099ll find some good\nreasons why a method would want to reference its own class.\n\nEach value is an object, and therefore has a class (also called its type ).\nIt is stored as object.__class__ .\n\n## 9.5.Inheritance\u00c2\u00b6\n\nOf course, a language feature would not be worthy of the name \u00e2\u0080\u009cclass\u00e2\u0080\u009d without\nsupporting inheritance.  The syntax for a derived class definition looks like\nthis:\n\n```python\nclass DerivedClassName(BaseClassName):\n    <statement-1>\n    .\n    .\n    .\n    <statement-N>\n```python\n\nThe name BaseClassName must be defined in a\nnamespace accessible from the scope containing the\nderived class definition.  In place of a base class name, other arbitrary\nexpressions are also allowed.  This can be useful, for example, when the base\nclass is defined in another module:\n\n```python\nclass DerivedClassName(modname.BaseClassName):\n```python\n\nExecution of a derived class definition proceeds the same as for a base class.\nWhen the class object is constructed, the base class is remembered.  This is\nused for resolving attribute references: if a requested attribute is not found\nin the class, the search proceeds to look in the base class.  This rule is\napplied recursively if the base class itself is derived from some other class.\n\nThere\u00e2\u0080\u0099s nothing special about instantiation of derived classes: DerivedClassName() creates a new instance of the class.  Method references\nare resolved as follows: the corresponding class attribute is searched,\ndescending down the chain of base classes if necessary, and the method reference\nis valid if this yields a function object.\n\nDerived classes may override methods of their base classes.  Because methods\nhave no special privileges when calling other methods of the same object, a\nmethod of a base class that calls another method defined in the same base class\nmay end up calling a method of a derived class that overrides it.  (For C++\nprogrammers: all methods in Python are effectively virtual .)\n\nAn overriding method in a derived class may in fact want to extend rather than\nsimply replace the base class method of the same name. There is a simple way to\ncall the base class method directly: just call BaseClassName.methodname(self, arguments) .  This is occasionally useful to clients as well.  (Note that this\nonly works if the base class is accessible as BaseClassName in the global\nscope.)\n\nPython has two built-in functions that work with inheritance:\n\n- Use isinstance() to check an instance\u00e2\u0080\u0099s type: isinstance(obj, int) will be True only if obj.__class__ is int or some class\nderived from int .\n- Use issubclass() to check class inheritance: issubclass(bool, int) is True since bool is a subclass of int .  However, issubclass(float, int) is False since float is not a\nsubclass of int .\n\n### 9.5.1.Multiple Inheritance\u00c2\u00b6\n\nPython supports a form of multiple inheritance as well.  A class definition with\nmultiple base classes looks like this:\n\n```python\nclass DerivedClassName(Base1, Base2, Base3):\n    <statement-1>\n    .\n    .\n    .\n    <statement-N>\n```python\n\nFor most purposes, in the simplest cases, you can think of the search for\nattributes inherited from a parent class as depth-first, left-to-right, not\nsearching twice in the same class where there is an overlap in the hierarchy.\nThus, if an attribute is not found in DerivedClassName , it is searched\nfor in Base1 , then (recursively) in the base classes of Base1 ,\nand if it was not found there, it was searched for in Base2 , and so on.\n\nIn fact, it is slightly more complex than that; the method resolution order\nchanges dynamically to support cooperative calls to super() .  This\napproach is known in some other multiple-inheritance languages as\ncall-next-method and is more powerful than the super call found in\nsingle-inheritance languages.\n\nDynamic ordering is necessary because all cases of multiple inheritance exhibit\none or more diamond relationships (where at least one of the parent classes\ncan be accessed through multiple paths from the bottommost class).  For example,\nall classes inherit from object , so any case of multiple inheritance\nprovides more than one path to reach object .  To keep the base classes\nfrom being accessed more than once, the dynamic algorithm linearizes the search\norder in a way that preserves the left-to-right ordering specified in each\nclass, that calls each parent only once, and that is monotonic (meaning that a\nclass can be subclassed without affecting the precedence order of its parents).\nTaken together, these properties make it possible to design reliable and\nextensible classes with multiple inheritance.  For more detail, see The Python 2.3 Method Resolution Order .\n\n## 9.6.Private Variables\u00c2\u00b6\n\n\u00e2\u0080\u009cPrivate\u00e2\u0080\u009d instance variables that cannot be accessed except from inside an\nobject don\u00e2\u0080\u0099t exist in Python.  However, there is a convention that is followed\nby most Python code: a name prefixed with an underscore (e.g. _spam ) should\nbe treated as a non-public part of the API (whether it is a function, a method\nor a data member).  It should be considered an implementation detail and subject\nto change without notice.\n\nSince there is a valid use-case for class-private members (namely to avoid name\nclashes of names with names defined by subclasses), there is limited support for\nsuch a mechanism, called name mangling .  Any identifier of the form __spam (at least two leading underscores, at most one trailing underscore)\nis textually replaced with _classname__spam , where classname is the\ncurrent class name with leading underscore(s) stripped.  This mangling is done\nwithout regard to the syntactic position of the identifier, as long as it\noccurs within the definition of a class.\n\nSee also\n\nThe private name mangling specifications for details and special cases.\n\nName mangling is helpful for letting subclasses override methods without\nbreaking intraclass method calls.  For example:\n\n```python\nclass Mapping:\n    def __init__(self, iterable):\n        self.items_list = []\n        self.__update(iterable)\n\n    def update(self, iterable):\n        for item in iterable:\n            self.items_list.append(item)\n\n    __update = update   # private copy of original update() method\n\nclass MappingSubclass(Mapping):\n\n    def update(self, keys, values):\n        # provides new signature for update()\n        # but does not break __init__()\n        for item in zip(keys, values):\n            self.items_list.append(item)\n```python\n\nThe above example would work even if MappingSubclass were to introduce a __update identifier since it is replaced with _Mapping__update in the Mapping class  and _MappingSubclass__update in the MappingSubclass class respectively.\n\nNote that the mangling rules are designed mostly to avoid accidents; it still is\npossible to access or modify a variable that is considered private.  This can\neven be useful in special circumstances, such as in the debugger.\n\nNotice that code passed to exec() or eval() does not consider the\nclassname of the invoking class to be the current class; this is similar to the\neffect of the global statement, the effect of which is likewise restricted\nto code that is byte-compiled together.  The same restriction applies to getattr() , setattr() and delattr() , as well as when referencing __dict__ directly.\n\n## 9.7.Odds and Ends\u00c2\u00b6\n\nSometimes it is useful to have a data type similar to the Pascal \u00e2\u0080\u009crecord\u00e2\u0080\u009d or C\n\u00e2\u0080\u009cstruct\u00e2\u0080\u009d, bundling together a few named data items. The idiomatic approach\nis to use dataclasses for this purpose:\n\n```python\nfrom dataclasses import dataclass\n\n@dataclass\nclass Employee:\n    name: str\n    dept: str\n    salary: int\n```python\n\n```python\n>>> john = Employee('john', 'computer lab', 1000)\n>>> john.dept\n'computer lab'\n>>> john.salary\n1000\n```python\n\nA piece of Python code that expects a particular abstract data type can often be\npassed a class that emulates the methods of that data type instead.  For\ninstance, if you have a function that formats some data from a file object, you\ncan define a class with methods read() and readline() that get the\ndata from a string buffer instead, and pass it as an argument.\n\nInstance method objects have attributes, too: m.__self__ is the instance\nobject with the method m() , and m.__func__ is\nthe function object corresponding to the method.\n\n## 9.8.Iterators\u00c2\u00b6\n\nBy now you have probably noticed that most container objects can be looped over\nusing a for statement:\n\n```python\nfor element in [1, 2, 3]:\n    print(element)\nfor element in (1, 2, 3):\n    print(element)\nfor key in {'one':1, 'two':2}:\n    print(key)\nfor char in \"123\":\n    print(char)\nfor line in open(\"myfile.txt\"):\n    print(line, end='')\n```python\n\nThis style of access is clear, concise, and convenient.  The use of iterators\npervades and unifies Python.  Behind the scenes, the for statement\ncalls iter() on the container object.  The function returns an iterator\nobject that defines the method __next__() which accesses\nelements in the container one at a time.  When there are no more elements, __next__() raises a StopIteration exception which tells the for loop to terminate.  You can call the __next__() method\nusing the next() built-in function; this example shows how it all works:\n\n```python\n>>> s = 'abc'\n>>> it = iter(s)\n>>> it\n<str_iterator object at 0x10c90e650>\n>>> next(it)\n'a'\n>>> next(it)\n'b'\n>>> next(it)\n'c'\n>>> next(it)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n    next(it)\nStopIteration\n```python\n\nHaving seen the mechanics behind the iterator protocol, it is easy to add\niterator behavior to your classes.  Define an __iter__() method which\nreturns an object with a __next__() method.  If the class\ndefines __next__() , then __iter__() can just return self :\n\n```python\nclass Reverse:\n    \"\"\"Iterator for looping over a sequence backwards.\"\"\"\n    def __init__(self, data):\n        self.data = data\n        self.index = len(data)\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.index == 0:\n            raise StopIteration\n        self.index = self.index - 1\n        return self.data[self.index]\n```python\n\n```python\n>>> rev = Reverse('spam')\n>>> iter(rev)\n<__main__.Reverse object at 0x00A1DB50>\n>>> for char in rev:\n...     print(char)\n...\nm\na\np\ns\n```python\n\n## 9.9.Generators\u00c2\u00b6\n\nGenerators are a simple and powerful tool for creating iterators.  They\nare written like regular functions but use the yield statement\nwhenever they want to return data.  Each time next() is called on it, the\ngenerator resumes where it left off (it remembers all the data values and which\nstatement was last executed).  An example shows that generators can be trivially\neasy to create:\n\n```python\ndef reverse(data):\n    for index in range(len(data)-1, -1, -1):\n        yield data[index]\n```python\n\n```python\n>>> for char in reverse('golf'):\n...     print(char)\n...\nf\nl\no\ng\n```python\n\nAnything that can be done with generators can also be done with class-based\niterators as described in the previous section.  What makes generators so\ncompact is that the __iter__() and __next__() methods\nare created automatically.\n\nAnother key feature is that the local variables and execution state are\nautomatically saved between calls.  This made the function easier to write and\nmuch more clear than an approach using instance variables like self.index and self.data .\n\nIn addition to automatic method creation and saving program state, when\ngenerators terminate, they automatically raise StopIteration . In\ncombination, these features make it easy to create iterators with no more effort\nthan writing a regular function.\n\n## 9.10.Generator Expressions\u00c2\u00b6\n\nSome simple generators can be coded succinctly as expressions using a syntax\nsimilar to list comprehensions but with parentheses instead of square brackets.\nThese expressions are designed for situations where the generator is used right\naway by an enclosing function.  Generator expressions are more compact but less\nversatile than full generator definitions and tend to be more memory friendly\nthan equivalent list comprehensions.\n\nExamples:\n\n```python\n>>> sum(i*i for i in range(10))                 # sum of squares\n285\n\n>>> xvec = [10, 20, 30]\n>>> yvec = [7, 5, 3]\n>>> sum(x*y for x,y in zip(xvec, yvec))         # dot product\n260\n\n>>> unique_words = set(word for line in page  for word in line.split())\n\n>>> valedictorian = max((student.gpa, student.name) for student in graduates)\n\n>>> data = 'golf'\n>>> list(data[i] for i in range(len(data)-1, -1, -1))\n['f', 'l', 'o', 'g']\n```python\n\nFootnotes",
      "difficulty": "intermediate",
      "doc_id": "doc-9-classes-d7daee5b86",
      "provenance": {
        "author": "",
        "date": "",
        "license": "PSF Documentation License",
        "source_file": "data/corpus_raw/scraped/3_tutorial_classes_html_bd3d0c.json",
        "url": "https://docs.python.org/3/tutorial/classes.html"
      },
      "title": "9.Classes\u00c2\u00b6",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "directories",
        "file_io",
        "os",
        "pathlib"
      ],
      "content": "## 9READING AND WRITING FILES\n\nVariables are a fine way to store data while your program is running, but if you want your data to persist even after your program has finished, you need to save it to a file. You can think of a file\u2019s contents as a single string value, potentially gigabytes in size. In this chapter, you will learn how to use Python to create, read, and save files on the hard drive.\n\n### Files and File Paths\n\nA file has two key properties: a filename (usually written as one word) and a path . The path specifies the location of a file on the computer. For example, there is a file on my Windows laptop with the filename project.docx in the path C:\\Users\\Al\\Documents . The part of the filename after the last period is called the file\u2019s extension and tells you a file\u2019s type. The filename project.docx is a Word document, and Users , Al , and Documents all refer to folders (also called directories ). Folders can contain files and other folders. For example, project.docx is in the Documents folder, which is inside the Al folder, which is inside the Users folder. Figure 9-1 shows this folder organization.\n\nFigure 9-1: A file in a hierarchy of folders\n\nThe C:\\ part of the path is the root folder , which contains all other folders. On Windows, the root folder is named C:\\ and is also called the C: drive . On macOS and Linux, the root folder is / . In this book, I\u2019ll use the Windows-style root folder, C:\\ . If you are entering the interactive shell examples on macOS or Linux, enter / instead.\n\nAdditional volumes , such as a DVD drive or USB flash drive, will appear differently on different operating systems. On Windows, they appear as new, lettered root drives, such as D:\\ or E:\\ . On macOS, they appear as new folders under the /Volumes folder. On Linux, they appear as new folders under the /mnt (\u201cmount\u201d) folder. Also note that while folder names and filenames are not case-sensitive on Windows and macOS, they are case-sensitive on Linux.\n\nNOTE\n\nSince your system probably has different files and folders on it than mine, you won\u2019t be able to follow every example in this chapter exactly. Still, try to follow along using folders that exist on your computer.\n\n#### Backslash on Windows and Forward Slash on macOS and Linux\n\nOn Windows, paths are written using backslashes ( \\ ) as the separator between folder names. The macOS and Linux operating systems, however, use the forward slash ( / ) as their path separator. If you want your programs to work on all operating systems, you will have to write your Python scripts to handle both cases.\n\nFortunately, this is simple to do with the Path() function in the pathlib module. If you pass it the string values of individual file and folder names in your path, Path() will return a string with a file path using the correct path separators. Enter the following into the interactive shell:\n\n>>> from pathlib import Path >>> Path('spam', 'bacon', 'eggs') WindowsPath('spam/bacon/eggs') >>> str(Path('spam', 'bacon', 'eggs')) 'spam\\\\bacon\\\\eggs'\n\nNote that the convention for importing pathlib is to run from pathlib import Path , since otherwise we\u2019d have to enter pathlib.Path everywhere Path shows up in our code. Not only is this extra typing redundant, but it\u2019s also redundant.\n\nI\u2019m running this chapter\u2019s interactive shell examples on Windows, so Path('spam', 'bacon', 'eggs') returned a WindowsPath object for the joined path, represented as WindowsPath('spam/bacon/eggs') . Even though Windows uses backslashes, the WindowsPath representation in the interactive shell displays them using forward slashes, since open source software developers have historically favored the Linux operating system.\n\nIf you want to get a simple text string of this path, you can pass it to the str() function, which in our example returns 'spam\\\\bacon\\\\eggs' . (Notice that the backslashes are doubled because each backslash needs to be escaped by another backslash character.) If I had called this function on, say, Linux, Path() would have returned a PosixPath object that, when passed to str() , would have returned 'spam/bacon/eggs' . ( POSIX is a set of standards for Unix-like operating systems such as Linux.)\n\nThese Path objects (really, WindowsPath or PosixPath objects, depending on your operating system) will be passed to several of the file-related functions introduced in this chapter. For example, the following code joins names from a list of filenames to the end of a folder\u2019s name:\n\n>>> from pathlib import Path >>> myFiles = ['accounts.txt', 'details.csv', 'invite.docx'] >>> for filename in myFiles: print(Path(r'C:\\Users\\Al', filename)) C:\\Users\\Al\\accounts.txt C:\\Users\\Al\\details.csv C:\\Users\\Al\\invite.docx\n\nOn Windows, the backslash separates directories, so you can\u2019t use it in filenames. However, you can use backslashes in filenames on macOS and Linux. So while Path(r'spam\\eggs') refers to two separate folders (or a file eggs in a folder spam ) on Windows, the same command would refer to a single folder (or file) named spam\\eggs on macOS and Linux. For this reason, it\u2019s usually a good idea to always use forward slashes in your Python code (and I\u2019ll be doing so for the rest of this chapter). The pathlib module will ensure that it always works on all operating systems.\n\nNote that pathlib was introduced in Python 3.4 to replace older os.path functions. The Python Standard Library modules support it as of Python 3.6, but if you are working with legacy Python 2 versions, I recommend using pathlib2 , which gives you pathlib \u2019s features on Python 2.7. Appendix A has instructions for installing pathlib2 using pip. Whenever I\u2019ve replaced an older os.path function with pathlib , I\u2019ve made a short note. You can look up the older functions at https://docs.python.org/3/library/os.path.html .\n\n#### Using the / Operator to Join Paths\n\nWe normally use the + operator to add two integer or floating-point numbers, such as in the expression 2 + 2 , which evaluates to the integer value 4 . But we can also use the + operator to concatenate two string values, like the expression 'Hello' + 'World' , which evaluates to the string value 'HelloWorld' . Similarly, the / operator that we normally use for division can also combine Path objects and strings. This is helpful for modifying a Path object after you\u2019ve already created it with the Path() function.\n\nFor example, enter the following into the interactive shell:\n\n>>> from pathlib import Path >>> Path('spam') / 'bacon' / 'eggs' WindowsPath('spam/bacon/eggs') >>> Path('spam') / Path('bacon/eggs') WindowsPath('spam/bacon/eggs') >>> Path('spam') / Path('bacon', 'eggs') WindowsPath('spam/bacon/eggs')\n\nUsing the / operator with Path objects makes joining paths just as easy as string concatenation. It\u2019s also safer than using string concatenation or the join() method, like we do in this example:\n\n>>> homeFolder = r'C:\\Users\\Al' >>> subFolder = 'spam' >>> homeFolder + '\\\\' + subFolder 'C:\\\\Users\\\\Al\\\\spam' >>> '\\\\'.join([homeFolder, subFolder]) 'C:\\\\Users\\\\Al\\\\spam'\n\nA script that uses this code isn\u2019t safe, because its backslashes would only work on Windows. You could add an if statement that checks sys.platform (which contains a string describing the computer\u2019s operating system) to decide what kind of slash to use, but applying this custom code everywhere it\u2019s needed can be inconsistent and bug-prone.\n\nThe pathlib module solves these problems by reusing the / math division operator to join paths correctly, no matter what operating system your code is running on. The following example uses this strategy to join the same paths as in the previous example:\n\n>>> homeFolder = Path('C:/Users/Al') >>> subFolder = Path('spam') >>> homeFolder / subFolder WindowsPath('C:/Users/Al/spam') >>> str(homeFolder / subFolder) 'C:\\\\Users\\\\Al\\\\spam'\n\nThe only thing you need to keep in mind when using the / operator for joining paths is that one of the first two values must be a Path object. Python will give you an error if you try entering the following into the interactive shell:\n\n>>> 'spam' / 'bacon' / 'eggs' Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: unsupported operand type(s) for /: 'str' and 'str'\n\nPython evaluates the / operator from left to right and evaluates to a Path object, so either the first or second leftmost value must be a Path object for the entire expression to evaluate to a Path object. Here\u2019s how the / operator and a Path object evaluate to the final Path object.\n\nIf you see the TypeError: unsupported operand type(s) for /: 'str' and 'str' error message shown previously, you need to put a Path object on the left side of the expression.\n\nThe / operator replaces the older os.path.join() function, which you can learn more about from https://docs.python.org/3/library/os.path.html#os.path.join .\n\n#### The Current Working Directory\n\nEvery program that runs on your computer has a current working directory , or cwd . Any filenames or paths that do not begin with the root folder are assumed to be under the current working directory.\n\nNOTE\n\nWhile folder is the more modern name for directory, note that current working directory (or just working directory ) is the standard term, not \u201ccurrent working folder.\u201d\n\nYou can get the current working directory as a string value with the Path.cwd() function and change it using os.chdir() . Enter the following into the interactive shell:\n\n>>> from pathlib import Path >>> import os >>> Path.cwd() WindowsPath('C:/Users/Al/AppData/Local/Programs/Python/Python37')' >>> os.chdir('C:\\\\Windows\\\\System32') >>> Path.cwd() WindowsPath('C:/Windows/System32')\n\nHere, the current working directory is set to C:\\Users\\Al\\AppData\\Local\\Programs\\Python\\Python37 , so the filename project.docx refers to C:\\Users\\Al\\AppData\\Local\\Programs\\Python\\Python37\\project.docx . When we change the current working directory to C:\\Windows\\System32 , the filename project.docx is interpreted as C:\\Windows\\System32\\project.docx .\n\nPython will display an error if you try to change to a directory that does not exist.\n\n>>> os.chdir('C:/ThisFolderDoesNotExist') Traceback (most recent call last): File \"<stdin>\", line 1, in <module> FileNotFoundError: [WinError 2] The system cannot find the file specified: 'C:/ThisFolderDoesNotExist'\n\nThere is no pathlib function for changing the working directory, because changing the current working directory while a program is running can often lead to subtle bugs.\n\nThe os.getcwd() function is the older way of getting the current working directory as a string.\n\n#### The Home Directory\n\nAll users have a folder for their own files on the computer called the home directory or home folder . You can get a Path object of the home folder by calling Path.home() :\n\n>>> Path.home() WindowsPath('C:/Users/Al')\n\nThe home directories are located in a set place depending on your operating system:\n\n- On Windows, home directories are under C:\\Users .\n- On Mac, home directories are under /Users .\n- On Linux, home directories are often under /home .\n\nYour scripts will almost certainly have permissions to read and write the files under your home directory, so it\u2019s an ideal place to put the files that your Python programs will work with.\n\n#### Absolute vs. Relative Paths\n\nThere are two ways to specify a file path:\n\n- An absolute path , which always begins with the root folder\n- A relative path , which is relative to the program\u2019s current working directory\n\nThere are also the dot ( . ) and dot-dot ( .. ) folders. These are not real folders but special names that can be used in a path. A single period (\u201cdot\u201d) for a folder name is shorthand for \u201cthis directory.\u201d Two periods (\u201cdot-dot\u201d) means \u201cthe parent folder.\u201d\n\nFigure 9-2 is an example of some folders and files. When the current working directory is set to C:\\bacon , the relative paths for the other folders and files are set as they are in the figure.\n\nFigure 9-2: The relative paths for folders and files in the working directory C:\\bacon\n\nThe .\\ at the start of a relative path is optional. For example, .\\spam.txt and spam.txt refer to the same file.\n\n#### Creating New Folders Using the os.makedirs() Function\n\nYour programs can create new folders (directories) with the os.makedirs() function. Enter the following into the interactive shell:\n\n>>> import os >>> os.makedirs('C:\\\\delicious\\\\walnut\\\\waffles')\n\nThis will create not just the C:\\delicious folder but also a walnut folder inside C:\\delicious and a waffles folder inside C:\\delicious\\walnut . That is, os.makedirs() will create any necessary intermediate folders in order to ensure that the full path exists. Figure 9-3 shows this hierarchy of folders.\n\nFigure 9-3: The result of os.makedirs('C:\\\\delicious\\\\walnut\\\\waffles')\n\nTo make a directory from a Path object, call the mkdir() method. For example, this code will create a spam folder under the home folder on my computer:\n\n>>> from pathlib import Path >>> Path(r'C:\\Users\\Al\\spam').mkdir()\n\nNote that mkdir() can only make one directory at a time; it won\u2019t make several subdirectories at once like os.makedirs() .\n\n#### Handling Absolute and Relative Paths\n\nThe pathlib module provides methods for checking whether a given path is an absolute path and returning the absolute path of a relative path.\n\nCalling the is_absolute() method on a Path object will return True if it represents an absolute path or False if it represents a relative path. For example, enter the following into the interactive shell, using your own files and folders instead of the exact ones listed here:\n\n>>> Path.cwd() WindowsPath('C:/Users/Al/AppData/Local/Programs/Python/Python37') >>> Path.cwd().is_absolute() True >>> Path('spam/bacon/eggs').is_absolute() False\n\nTo get an absolute path from a relative path, you can put Path.cwd() / in front of the relative Path object. After all, when we say \u201crelative path,\u201d we almost always mean a path that is relative to the current working directory. Enter the following into the interactive shell:\n\n>>> Path('my/relative/path') WindowsPath('my/relative/path') >>> Path.cwd() / Path('my/relative/path') WindowsPath('C:/Users/Al/AppData/Local/Programs/Python/Python37/my/relative/ path')\n\nIf your relative path is relative to another path besides the current working directory, just replace Path.cwd() with that other path instead. The following example gets an absolute path using the home directory instead of the current working directory:\n\n>>> Path('my/relative/path') WindowsPath('my/relative/path') >>> Path.home() / Path('my/relative/path') WindowsPath('C:/Users/Al/my/relative/path')\n\nThe os.path module also has some useful functions related to absolute and relative paths:\n\n- Calling os.path.abspath( path ) will return a string of the absolute path of the argument. This is an easy way to convert a relative path into an absolute one.\n- Calling os.path.isabs( path ) will return True if the argument is an absolute path and False if it is a relative path.\n- Calling os.path.relpath( path , start ) will return a string of a relative path from the start path to path . If start is not provided, the current working directory is used as the start path.\n\nTry these functions in the interactive shell:\n\n>>> os.path.abspath('.') 'C:\\\\Users\\\\Al\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37' >>> os.path.abspath('.\\\\Scripts') 'C:\\\\Users\\\\Al\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\Scripts' >>> os.path.isabs('.') False >>> os.path.isabs(os.path.abspath('.')) True\n\nSince C:\\Users\\Al\\AppData\\Local\\Programs\\Python\\Python37 was the working directory when os.path.abspath() was called, the \u201csingle-dot\u201d folder represents the absolute path 'C:\\\\Users\\\\Al\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37' .\n\nEnter the following calls to os.path.relpath() into the interactive shell:\n\n>>> os.path.relpath('C:\\\\Windows', 'C:\\\\') 'Windows' >>> os.path.relpath('C:\\\\Windows', 'C:\\\\spam\\\\eggs') '..\\\\..\\\\Windows'\n\nWhen the relative path is within the same parent folder as the path, but is within subfolders of a different path, such as 'C:\\\\Windows' and 'C:\\\\spam\\\\eggs' , you can use the \u201cdot-dot\u201d notation to return to the parent folder.\n\n#### Getting the Parts of a File Path\n\nGiven a Path object, you can extract the file path\u2019s different parts as strings using several Path object attributes. These can be useful for constructing new file paths based on existing ones. The attributes are diagrammed in Figure 9-4.\n\nFigure 9-4: The parts of a Windows (top) and macOS/Linux (bottom) file path\n\nThe parts of a file path include the following:\n\n- The anchor , which is the root folder of the filesystem\n- On Windows, the drive , which is the single letter that often denotes a physical hard drive or other storage device\n- The parent , which is the folder that contains the file\n- The name of the file, made up of the stem (or base name ) and the suffix (or extension )\n\nNote that Windows Path objects have a drive attribute, but macOS and Linux Path objects don\u2019t. The drive attribute doesn\u2019t include the first backslash.\n\nTo extract each attribute from the file path, enter the following into the interactive shell:\n\n>>> p = Path('C:/Users/Al/spam.txt') >>> p.anchor 'C:\\\\' >>> p.parent # This is a Path object, not a string. WindowsPath('C:/Users/Al') >>> p.name 'spam.txt' >>> p.stem 'spam' >>> p.suffix '.txt' >>> p.drive 'C:'\n\nThese attributes evaluate to simple string values, except for parent , which evaluates to another Path object.\n\nThe parents attribute (which is different from the parent attribute) evaluates to the ancestor folders of a Path object with an integer index:\n\n>>> Path.cwd() WindowsPath('C:/Users/Al/AppData/Local/Programs/Python/Python37') >>> Path.cwd().parents[0] WindowsPath('C:/Users/Al/AppData/Local/Programs/Python') >>> Path.cwd().parents[1] WindowsPath('C:/Users/Al/AppData/Local/Programs') >>> Path.cwd().parents[2] WindowsPath('C:/Users/Al/AppData/Local') >>> Path.cwd().parents[3] WindowsPath('C:/Users/Al/AppData') >>> Path.cwd().parents[4] WindowsPath('C:/Users/Al') >>> Path.cwd().parents[5] WindowsPath('C:/Users') >>> Path.cwd().parents[6] WindowsPath('C:/')\n\nThe older os.path module also has similar functions for getting the different parts of a path written in a string value. Calling os.path.dirname( path ) will return a string of everything that comes before the last slash in the path argument. Calling os.path.basename( path ) will return a string of everything that comes after the last slash in the path argument. The directory (or dir) name and base name of a path are outlined in Figure 9-5.\n\nFigure 9-5: The base name follows the last slash in a path and is the same as the filename. The dir name is everything before the last slash.\n\nFor example, enter the following into the interactive shell:\n\n>>> calcFilePath = 'C:\\\\Windows\\\\System32\\\\calc.exe' >>> os.path.basename(calcFilePath) 'calc.exe' >>> os.path.dirname(calcFilePath) 'C:\\\\Windows\\\\System32'\n\nIf you need a path\u2019s dir name and base name together, you can just call os.path.split() to get a tuple value with these two strings, like so:\n\n>>> calcFilePath = 'C:\\\\Windows\\\\System32\\\\calc.exe' >>> os.path.split(calcFilePath) ('C:\\\\Windows\\\\System32', 'calc.exe')\n\nNotice that you could create the same tuple by calling os.path.dirname() and os.path.basename() and placing their return values in a tuple:\n\n>>> (os.path.dirname(calcFilePath), os.path.basename(calcFilePath)) ('C:\\\\Windows\\\\System32', 'calc.exe')\n\nBut os.path.split() is a nice shortcut if you need both values.\n\nAlso, note that os.path.split() does not take a file path and return a list of strings of each folder. For that, use the split() string method and split on the string in os.sep . (Note that sep is in os , not os.path .) The os.sep variable is set to the correct folder-separating slash for the computer running the program, '\\\\' on Windows and '/' on macOS and Linux, and splitting on it will return a list of the individual folders.\n\nFor example, enter the following into the interactive shell:\n\n>>> calcFilePath.split(os.sep) ['C:', 'Windows', 'System32', 'calc.exe']\n\nThis returns all the parts of the path as strings.\n\nOn macOS and Linux systems, the returned list of folders will begin with a blank string, like this:\n\n>>> '/usr/bin'.split(os. sep) ['', 'usr', 'bin']\n\nThe split() string method will work to return a list of each part of the path.\n\n#### Finding File Sizes and Folder Contents\n\nOnce you have ways of handling file paths, you can then start gathering information about specific files and folders. The os.path module provides functions for finding the size of a file in bytes and the files and folders inside a given folder.\n\n- Calling os.path.getsize( path ) will return the size in bytes of the file in the path argument.\n- Calling os.listdir( path ) will return a list of filename strings for each file in the path argument. (Note that this function is in the os module, not os.path .)\n\nHere\u2019s what I get when I try these functions in the interactive shell:\n\n>>> os.path.getsize('C:\\\\Windows\\\\System32\\\\calc.exe') 27648 >>> os.listdir('C:\\\\Windows\\\\System32') ['0409', '12520437.cpx', '12520850.cpx', '5U877.ax', 'aaclient.dll', -- snip -- 'xwtpdui.dll', 'xwtpw32.dll', 'zh-CN', 'zh-HK', 'zh-TW', 'zipfldr.dll']\n\nAs you can see, the calc.exe program on my computer is 27,648 bytes in size, and I have a lot of files in C:\\Windows\\system32 . If I want to find the total size of all the files in this directory, I can use os.path.getsize() and os.listdir() together.\n\n>>> totalSize = 0 >>> for filename in os.listdir('C:\\\\Windows\\\\System32'): totalSize = totalSize + os.path.getsize(os.path.join('C:\\\\Windows\\\\System32', filename)) >>> print(totalSize) 2559970473\n\nAs I loop over each filename in the C:\\Windows\\System32 folder, the totalSize variable is incremented by the size of each file. Notice how when I call os.path.getsize() , I use os.path.join() to join the folder name with the current filename. The integer that os.path.getsize() returns is added to the value of totalSize . After looping through all the files, I print totalSize to see the total size of the C:\\Windows\\System32 folder.\n\n#### Modifying a List of Files Using Glob Patterns\n\nIf you want to work on specific files, the glob() method is simpler to use than listdir() . Path objects have a glob() method for listing the contents of a folder according to a glob pattern . Glob patterns are like a simplified form of regular expressions often used in command line commands. The glob() method returns a generator object (which are beyond the scope of this book) that you\u2019ll need to pass to list() to easily view in the interactive shell:\n\n>>> p = Path('C:/Users/Al/Desktop') >>> p.glob('*') <generator object Path.glob at 0x000002A6E389DED0> >>> list(p.glob('*')) # Make a list from the generator. [WindowsPath('C:/Users/Al/Desktop/1.png'), WindowsPath('C:/Users/Al/ Desktop/22-ap.pdf'), WindowsPath('C:/Users/Al/Desktop/cat.jpg'), --snip-- WindowsPath('C:/Users/Al/Desktop/zzz.txt')]\n\nThe asterisk ( * ) stands for \u201cmultiple of any characters,\u201d so p.glob('*') returns a generator of all files in the path stored in p .\n\nLike with regexes, you can create complex expressions:\n\n>>> list(p.glob('*.txt') # Lists all text files. [WindowsPath('C:/Users/Al/Desktop/foo.txt'), --snip-- WindowsPath('C:/Users/Al/Desktop/zzz.txt')]\n\nThe glob pattern '*.txt' will return files that start with any combination of characters as long as it ends with the string '.txt' , which is the text file extension.\n\nIn contrast with the asterisk, the question mark ( ? ) stands for any single character:\n\n>>> list(p.glob('project?.docx') [WindowsPath('C:/Users/Al/Desktop/project1.docx'), WindowsPath('C:/Users/Al/ Desktop/project2.docx'), --snip-- WindowsPath('C:/Users/Al/Desktop/project9.docx')]\n\nThe glob expression 'project?.docx' will return 'project1.docx' or 'project5.docx' , but it will not return 'project10.docx' , because ? only matches to one character\u2014so it will not match to the two-character string '10' .\n\nFinally, you can also combine the asterisk and question mark to create even more complex glob expressions, like this:\n\n>>> list(p.glob('*.?x?') [WindowsPath('C:/Users/Al/Desktop/calc.exe'), WindowsPath('C:/Users/Al/ Desktop/foo.txt'), --snip-- WindowsPath('C:/Users/Al/Desktop/zzz.txt')]\n\nThe glob expression '*.?x?' will return files with any name and any three-character extension where the middle character is an 'x' .\n\nBy picking out files with specific attributes, the glob() method lets you easily specify the files in a directory you want to perform some operation on. You can use a for loop to iterate over the generator that glob() returns:\n\n>>> p = Path('C:/Users/Al/Desktop') >>> for textFilePathObj in p.glob('*.txt'): ... print(textFilePathObj) # Prints the Path object as a string. ... # Do something with the text file. ... C:\\Users\\Al\\Desktop\\foo.txt C:\\Users\\Al\\Desktop\\spam.txt C:\\Users\\Al\\Desktop\\zzz.txt\n\nIf you want to perform some operation on every file in a directory, you can use either os.listdir(p) or p.glob('*') .\n\n#### Checking Path Validity\n\nMany Python functions will crash with an error if you supply them with a path that does not exist. Luckily, Path objects have methods to check whether a given path exists and whether it is a file or folder. Assuming that a variable p holds a Path object, you could expect the following:\n\n- Calling p.exists() returns True if the path exists or returns False if it doesn\u2019t exist.\n- Calling p.is_file() returns True if the path exists and is a file, or returns False otherwise.\n- Calling p.is_dir() returns True if the path exists and is a directory, or returns False otherwise.\n\nOn my computer, here\u2019s what I get when I try these methods in the interactive shell:\n\n>>> winDir = Path('C:/Windows') >>> notExistsDir = Path('C:/This/Folder/Does/Not/Exist') >>> calcFile = Path('C:/Windows /System32/calc.exe') >>> winDir.exists() True >>> winDir.is_dir() True >>> notExistsDir.exists() False >>> calcFile.is_file() True >>> calcFile.is_dir() False\n\nYou can determine whether there is a DVD or flash drive currently attached to the computer by checking for it with the exists() method. For instance, if I wanted to check for a flash drive with the volume named D:\\ on my Windows computer, I could do that with the following:\n\n>>> dDrive = Path('D:/') >>> dDrive.exists() False\n\nOops! It looks like I forgot to plug in my flash drive.\n\nThe older os.path module can accomplish the same task with the os.path.exists( path ) , os.path.isfile( path ) , and os.path.isdir( path ) functions, which act just like their Path function counterparts. As of Python 3.6, these functions can accept Path objects as well as strings of the file paths.\n\n### The File Reading/Writing Process\n\nOnce you are comfortable working with folders and relative paths, you\u2019ll be able to specify the location of files to read and write. The functions covered in the next few sections will apply to plaintext files. Plaintext files contain only basic text characters and do not include font, size, or color information. Text files with the .txt extension or Python script files with the .py extension are examples of plaintext files. These can be opened with Windows\u2019s Notepad or macOS\u2019s TextEdit application. Your programs can easily read the contents of plaintext files and treat them as an ordinary string value.\n\nBinary files are all other file types, such as word processing documents, PDFs, images, spreadsheets, and executable programs. If you open a binary file in Notepad or TextEdit, it will look like scrambled nonsense, like in Figure 9-6.\n\nFigure 9-6: The Windows calc.exe program opened in Notepad\n\nSince every different type of binary file must be handled in its own way, this book will not go into reading and writing raw binary files directly. Fortunately, many modules make working with binary files easier\u2014you will explore one of them, the shelve module, later in this chapter. The pathlib module\u2019s read_text() method returns a string of the full contents of a text file. Its write_text() method creates a new text file (or overwrites an existing one) with the string passed to it. Enter the following into the interactive shell:\n\n>>> from pathlib import Path >>> p = Path('spam.txt') >>> p.write_text('Hello, world!') 13 >>> p.read_text() 'Hello, world!'\n\nThese method calls create a spam.txt file with the content 'Hello, world!' . The 13 that write_text() returns indicates that 13 characters were written to the file. (You can often disregard this information.) The read_text() call reads and returns the contents of our new file as a string: 'Hello, world!' .\n\nKeep in mind that these Path object methods only provide basic interactions with files. The more common way of writing to a file involves using the open() function and file objects. There are three steps to reading or writing files in Python:\n\n- Call the open() function to return a File object.\n- Call the read() or write() method on the File object.\n- Close the file by calling the close() method on the File object.\n\nWe\u2019ll go over these steps in the following sections.\n\n#### Opening Files with the open() Function\n\nTo open a file with the open() function, you pass it a string path indicating the file you want to open; it can be either an absolute or relative path. The open() function returns a File object.\n\nTry it by creating a text file named hello.txt using Notepad or TextEdit. Type Hello, world! as the content of this text file and save it in your user home folder. Then enter the following into the interactive shell:\n\n>>> helloFile = open(Path.home() / 'hello.txt')\n\nThe open() function can also accept strings. If you\u2019re using Windows, enter the following into the interactive shell:\n\n>>> helloFile = open('C:\\\\Users\\\\ your_home_folder \\\\hello.txt')\n\nIf you\u2019re using macOS, enter the following into the interactive shell instead:\n\n>>> helloFile = open('/Users/ your_home_folder /hello.txt')\n\nMake sure to replace your_home_folder with your computer username. For example, my username is Al , so I\u2019d enter 'C:\\\\Users\\\\Al\\\\hello.txt' on Windows. Note that the open() function only accepts Path objects as of Python 3.6. In previous versions, you always need to pass a string to open() .\n\nBoth these commands will open the file in \u201creading plaintext\u201d mode, or read mode for short. When a file is opened in read mode, Python lets you only read data from the file; you can\u2019t write or modify it in any way. Read mode is the default mode for files you open in Python. But if you don\u2019t want to rely on Python\u2019s defaults, you can explicitly specify the mode by passing the string value 'r' as a second argument to open() . So open('/Users/Al/hello.txt', 'r') and open('/Users/Al/hello.txt') do the same thing.\n\nThe call to open() returns a File object. A File object represents a file on your computer; it is simply another type of value in Python, much like the lists and dictionaries you\u2019re already familiar with. In the previous example, you stored the File object in the variable helloFile . Now, whenever you want to read from or write to the file, you can do so by calling methods on the File object in helloFile .\n\n#### Reading the Contents of Files\n\nNow that you have a File object, you can start reading from it. If you want to read the entire contents of a file as a string value, use the File object\u2019s read() method. Let\u2019s continue with the hello.txt File object you stored in helloFile . Enter the following into the interactive shell:\n\n>>> helloContent = helloFile.read() >>> helloContent 'Hello, world!'\n\nIf you think of the contents of a file as a single large string value, the read() method returns the string that is stored in the file.\n\nAlternatively, you can use the readlines() method to get a list of string values from the file, one string for each line of text. For example, create a file named sonnet29.txt in the same directory as hello.txt and write the following text in it:\n\nWhen, in disgrace with fortune and men's eyes, I all alone beweep my outcast state, And trouble deaf heaven with my bootless cries, And look upon myself and curse my fate,\n\nMake sure to separate the four lines with line breaks. Then enter the following into the interactive shell:\n\n>>> sonnetFile = open(Path.home() / 'sonnet29.txt') >>> sonnetFile.readlines() [When, in disgrace with fortune and men's eyes,\\n', ' I all alone beweep my outcast state,\\n', And trouble deaf heaven with my bootless cries,\\n', And look upon myself and curse my fate,']\n\nNote that, except for the last line of the file, each of the string values ends with a newline character \\n . A list of strings is often easier to work with than a single large string value.\n\n#### Writing to Files\n\nPython allows you to write content to a file in a way similar to how the print() function \u201cwrites\u201d strings to the screen. You can\u2019t write to a file you\u2019ve opened in read mode, though. Instead, you need to open it in \u201cwrite plaintext\u201d mode or \u201cappend plaintext\u201d mode, or write mode and append mode for short.\n\nWrite mode will overwrite the existing file and start from scratch, just like when you overwrite a variable\u2019s value with a new value. Pass 'w' as the second argument to open() to open the file in write mode. Append mode, on the other hand, will append text to the end of the existing file. You can think of this as appending to a list in a variable, rather than overwriting the variable altogether. Pass 'a' as the second argument to open() to open the file in append mode.\n\nIf the filename passed to open() does not exist, both write and append mode will create a new, blank file. After reading or writing a file, call the close() method before opening the file again.\n\nLet\u2019s put these concepts together. Enter the following into the interactive shell:\n\n>>> baconFile = open('bacon.txt', 'w') >>> baconFile.write('Hello, world!\\n') 13 >>> baconFile.close() >>> baconFile = open('bacon.txt', 'a') >>> baconFile.write('Bacon is not a vegetable.') 25 >>> baconFile.close() >>> baconFile = open('bacon.txt') >>> content = baconFile.read() >>> baconFile.close() >>> print(content) Hello, world! Bacon is not a vegetable.\n\nFirst, we open bacon.txt in write mode. Since there isn\u2019t a bacon.txt yet, Python creates one. Calling write() on the opened file and passing write() the string argument 'Hello, world! /n' writes the string to the file and returns the number of characters written, including the newline. Then we close the file.\n\nTo add text to the existing contents of the file instead of replacing the string we just wrote, we open the file in append mode. We write 'Bacon is not a vegetable.' to the file and close it. Finally, to print the file contents to the screen, we open the file in its default read mode, call read() , store the resulting File object in content , close the file, and print content .\n\nNote that the write() method does not automatically add a newline character to the end of the string like the print() function does. You will have to add this character yourself.\n\nAs of Python 3.6, you can also pass a Path object to the open() function instead of a string for the filename.\n\n### Saving Variables with the shelve Module\n\nYou can save variables in your Python programs to binary shelf files using the shelve module. This way, your program can restore data to variables from the hard drive. The shelve module will let you add Save and Open features to your program. For example, if you ran a program and entered some configuration settings, you could save those settings to a shelf file and then have the program load them the next time it is run.\n\nEnter the following into the interactive shell:\n\n>>> import shelve >>> shelfFile = shelve.open('mydata') >>> cats = ['Zophie', 'Pooka', 'Simon'] >>> shelfFile['cats'] = cats >>> shelfFile.close()\n\nTo read and write data using the shelve module, you first import shelve . Call shelve.open() and pass it a filename, and then store the returned shelf value in a variable. You can make changes to the shelf value as if it were a dictionary. When you\u2019re done, call close() on the shelf value. Here, our shelf value is stored in shelfFile . We create a list cats and write shelfFile['cats'] = cats to store the list in shelfFile as a value associated with the key 'cats' (like in a dictionary). Then we call close() on shelfFile . Note that as of Python 3.7, you have to pass the open() shelf method filenames as strings. You can\u2019t pass it Path object.\n\nAfter running the previous code on Windows, you will see three new files in the current working directory: mydata.bak , mydata.dat , and mydata.dir . On macOS, only a single mydata.db file will be created.\n\nThese binary files contain the data you stored in your shelf. The format of these binary files is not important; you only need to know what the shelve module does, not how it does it. The module frees you from worrying about how to store your program\u2019s data to a file.\n\nYour programs can use the shelve module to later reopen and retrieve the data from these shelf files. Shelf values don\u2019t have to be opened in read or write mode\u2014they can do both once opened. Enter the following into the interactive shell:\n\n>>> shelfFile = shelve.open('mydata') >>> type(shelfFile) <class 'shelve.DbfilenameShelf'> >>> shelfFile['cats'] ['Zophie', 'Pooka', 'Simon'] >>> shelfFile.close()\n\nHere, we open the shelf files to check that our data was stored correctly. Entering shelfFile['cats'] returns the same list that we stored earlier, so we know that the list is correctly stored, and we call close() .\n\nJust like dictionaries, shelf values have keys() and values() methods that will return list-like values of the keys and values in the shelf. Since these methods return list-like values instead of true lists, you should pass them to the list() function to get them in list form. Enter the following into the interactive shell:\n\n>>> shelfFile = shelve.open('mydata') >>> list(shelfFile.keys()) ['cats'] >>> list(shelfFile.values()) [['Zophie', 'Pooka', 'Simon']] >>> shelfFile.close()\n\nPlaintext is useful for creating files that you\u2019ll read in a text editor such as Notepad or TextEdit, but if you want to save data from your Python programs, use the shelve module.\n\n### Saving Variables with the pprint.pformat() Function\n\nRecall from \u201cPretty Printing\u201d on page 118 that the pprint.pprint() function will \u201cpretty print\u201d the contents of a list or dictionary to the screen, while the pprint.pformat() function will return this same text as a string instead of printing it. Not only is this string formatted to be easy to read, but it is also syntactically correct Python code. Say you have a dictionary stored in a variable and you want to save this variable and its contents for future use. Using pprint.pformat() will give you a string that you can write to a .py file. This file will be your very own module that you can import whenever you want to use the variable stored in it.\n\nFor example, enter the following into the interactive shell:\n\n>>> import pprint >>> cats = [{'name': 'Zophie', 'desc': 'chubby'}, {'name': 'Pooka', 'desc': 'fluffy'}] >>> pprint.pformat(cats) \"[{'desc': 'chubby', 'name': 'Zophie'}, {'desc': 'fluffy', 'name': 'Pooka'}]\" >>> fileObj = open('myCats.py', 'w') >>> fileObj.write('cats = ' + pprint.pformat(cats) + '\\n') 83 >>> fileObj.close()\n\nHere, we import pprint to let us use pprint.pformat() . We have a list of dictionaries, stored in a variable cats . To keep the list in cats available even after we close the shell, we use pprint.pformat() to return it as a string. Once we have the data in cats as a string, it\u2019s easy to write the string to a file, which we\u2019ll call myCats.py .\n\nThe modules that an import statement imports are themselves just Python scripts. When the string from pprint.pformat() is saved to a .py file, the file is a module that can be imported just like any other.\n\nAnd since Python scripts are themselves just text files with the .py file extension, your Python programs can even generate other Python programs. You can then import these files into scripts.\n\n>>> import myCats >>> myCats.cats [{'name': 'Zophie', 'desc': 'chubby'}, {'name': 'Pooka', 'desc': 'fluffy'}] >>> myCats.cats[0] {'name': 'Zophie', 'desc': 'chubby'} >>> myCats.cats[0]['name'] 'Zophie'\n\nThe benefit of creating a .py file (as opposed to saving variables with the shelve module) is that because it is a text file, the contents of the file can be read and modified by anyone with a simple text editor. For most applications, however, saving data using the shelve module is the preferred way to save variables to a file. Only basic data types such as integers, floats, strings, lists, and dictionaries can be written to a file as simple text. File objects, for example, cannot be encoded as text.\n\n### Project: Generating Random Quiz Files\n\nSay you\u2019re a geography teacher with 35 students in your class and you want to give a pop quiz on US state capitals. Alas, your class has a few bad eggs in it, and you can\u2019t trust the students not to cheat. You\u2019d like to randomize the order of questions so that each quiz is unique, making it impossible for anyone to crib answers from anyone else. Of course, doing this by hand would be a lengthy and boring affair. Fortunately, you know some Python.\n\nHere is what the program does:\n\n- Creates 35 different quizzes\n- Creates 50 multiple-choice questions for each quiz, in random order\n- Provides the correct answer and three random wrong answers for each question, in random order\n- Writes the quizzes to 35 text files\n- Writes the answer keys to 35 text files\n\nThis means the code will need to do the following:\n\n- Store the states and their capitals in a dictionary\n- Call open() , write() , and close() for the quiz and answer key text files\n- Use random.shuffle() to randomize the order of the questions and multiple-choice options\n\n#### Step 1: Store the Quiz Data in a Dictionary\n\nThe first step is to create a skeleton script and fill it with your quiz data. Create a file named randomQuizGenerator.py , and make it look like the following:\n\n#! python3 # randomQuizGenerator.py - Creates quizzes with questions and answers in # random order, along with the answer key. \u278a import random # The quiz data. Keys are states and values are their capitals. \u278b capitals = {'Alabama': 'Montgomery', 'Alaska': 'Juneau', 'Arizona': 'Phoenix', 'Arkansas': 'Little Rock', 'California': 'Sacramento', 'Colorado': 'Denver', 'Connecticut': 'Hartford', 'Delaware': 'Dover', 'Florida': 'Tallahassee', 'Georgia': 'Atlanta', 'Hawaii': 'Honolulu', 'Idaho': 'Boise', 'Illinois': 'Springfield', 'Indiana': 'Indianapolis', 'Iowa': 'Des Moines', 'Kansas': 'Topeka', 'Kentucky': 'Frankfort', 'Louisiana': 'Baton Rouge', 'Maine': 'Augusta', 'Maryland': 'Annapolis', 'Massachusetts': 'Boston', 'Michigan': 'Lansing', 'Minnesota': 'Saint Paul', 'Mississippi': 'Jackson', 'Missouri': 'Jefferson City', 'Montana': 'Helena', 'Nebraska': 'Lincoln', 'Nevada': 'Carson City', 'New Hampshire': 'Concord', 'New Jersey': 'Trenton', 'New Mexico': 'Santa Fe', 'New York': 'Albany', 'North Carolina': 'Raleigh', 'North Dakota': 'Bismarck', 'Ohio': 'Columbus', 'Oklahoma': 'Oklahoma City', 'Oregon': 'Salem', 'Pennsylvania': 'Harrisburg', 'Rhode Island': 'Providence', 'South Carolina': 'Columbia', 'South Dakota': 'Pierre', 'Tennessee': 'Nashville', 'Texas': 'Austin', 'Utah': 'Salt Lake City', 'Vermont': 'Montpelier', 'Virginia': 'Richmond', 'Washington': 'Olympia', 'West Virginia': 'Charleston', 'Wisconsin': 'Madison', 'Wyoming': 'Cheyenne'} # Generate 35 quiz files. \u278c for quizNum in range(35): # TODO: Create the quiz and answer key files. # TODO: Write out the header for the quiz. # TODO: Shuffle the order of the states. # TODO: Loop through all 50 states, making a question for each.\n\nSince this program will be randomly ordering the questions and answers, you\u2019ll need to import the random module \u278a to make use of its functions. The capitals variable \u278b contains a dictionary with US states as keys and their capitals as values. And since you want to create 35 quizzes, the code that actually generates the quiz and answer key files (marked with TODO comments for now) will go inside a for loop that loops 35 times \u278c . (This number can be changed to generate any number of quiz files.)\n\n#### Step 2: Create the Quiz File and Shuffle the Question Order\n\nNow it\u2019s time to start filling in those TODO s.\n\nThe code in the loop will be repeated 35 times\u2014once for each quiz\u2014so you have to worry about only one quiz at a time within the loop. First you\u2019ll create the actual quiz file. It needs to have a unique filename and should also have some kind of standard header in it, with places for the student to fill in a name, date, and class period. Then you\u2019ll need to get a list of states in randomized order, which can be used later to create the questions and answers for the quiz.\n\nAdd the following lines of code to randomQuizGenerator.py :\n\n#! python3 # randomQuizGenerator.py - Creates quizzes with questions and answers in # random order, along with the answer key. -- snip -- # Generate 35 quiz files. for quizNum in range(35): # Create the quiz and answer key files. \u278a quizFile = open(f'capitalsquiz{quizNum + 1}.txt', 'w') \u278b answerKeyFile = open(f'capitalsquiz_answers{quizNum + 1}.txt', 'w') # Write out the header for the quiz. \u278c quizFile.write('Name:\\n\\nDate:\\n\\nPeriod:\\n\\n') quizFile.write((' ' * 20) + f'State Capitals Quiz (Form{quizNum + 1})') quizFile.write('\\n\\n') # Shuffle the order of the states. states = list(capitals.keys()) \u278d random.shuffle(states) # TODO: Loop through all 50 states, making a question for each.\n\nThe filenames for the quizzes will be capitalsquiz<N>.txt , where <N> is a unique number for the quiz that comes from quizNum , the for loop\u2019s counter. The answer key for capitalsquiz<N>.txt will be stored in a text file named capitalsquiz_answers<N>.txt . Each time through the loop, the {quizNum + 1} placeholder in f'capitalsquiz{quizNum + 1}.txt' and f'capitalsquiz_answers{quizNum + 1}.txt' will be replaced by the unique number, so the first quiz and answer key created will be capitalsquiz1.txt and capitalsquiz_answers1.txt . These files will be created with calls to the open() function at \u278a and \u278b , with 'w' as the second argument to open them in write mode.\n\nThe write() statements at \u278c create a quiz header for the student to fill out. Finally, a randomized list of US states is created with the help of the random.shuffle() function \u278d , which randomly reorders the values in any list that is passed to it.\n\n#### Step 3: Create the Answer Options\n\nNow you need to generate the answer options for each question, which will be multiple choice from A to D. You\u2019ll need to create another for loop\u2014this one to generate the content for each of the 50 questions on the quiz. Then there will be a third for loop nested inside to generate the multiple-choice options for each question. Make your code look like the following:\n\n#! python3 # randomQuizGenerator.py - Creates quizzes with questions and answers in # random order, along with the answer key. -- snip -- # Loop through all 50 states, making a question for each. for questionNum in range(50): # Get right and wrong answers. \u278a correctAnswer = capitals[states[questionNum]] \u278b wrongAnswers = list(capitals.values()) \u278c del wrongAnswers[wrongAnswers.index(correctAnswer)] \u278d wrongAnswers = random.sample(wrongAnswers, 3) \u278e answerOptions = wrongAnswers + [correctAnswer] \u278f random.shuffle(answerOptions) # TODO: Write the question and answer options to the quiz file. # TODO: Write the answer key to a file.\n\nThe correct answer is easy to get\u2014it\u2019s stored as a value in the capitals dictionary \u278a . This loop will loop through the states in the shuffled states list, from states[0] to states[49] , find each state in capitals , and store that state\u2019s corresponding capital in correctAnswer .\n\nThe list of possible wrong answers is trickier. You can get it by duplicating all the values in the capitals dictionary \u278b , deleting the correct answer \u278c , and selecting three random values from this list \u278d . The random.sample() function makes it easy to do this selection. Its first argument is the list you want to select from; the second argument is the number of values you want to select. The full list of answer options is the combination of these three wrong answers with the correct answers \u278e . Finally, the answers need to be randomized \u278f so that the correct response isn\u2019t always choice D.\n\n#### Step 4: Write Content to the Quiz and Answer Key Files\n\nAll that is left is to write the question to the quiz file and the answer to the answer key file. Make your code look like the following:\n\n#! python3 # randomQuizGenerator.py - Creates quizzes with questions and answers in # random order, along with the answer key. -- snip -- # Loop through all 50 states, making a question for each. for questionNum in range(50): -- snip -- # Write the question and the answer options to the quiz file. quizFile.write(f'{questionNum + 1}. What is the capital of {states[questionNum]}?\\n') \u278a for i in range(4): \u278b quizFile.write(f\"\u00a0\u00a0\u00a0\u00a0{'ABCD'[i]}. { answerOptions[i]}\\n\") quizFile.write('\\n') # Write the answer key to a file. \u278c answerKeyFile.write(f\"{questionNum + 1}. {'ABCD'[answerOptions.index(correctAnswer)]}\") quizFile.close() answerKeyFile.close()\n\nA for loop that goes through integers 0 to 3 will write the answer options in the answerOptions list \u278a . The expression 'ABCD'[i] at \u278b treats the string 'ABCD' as an array and will evaluate to 'A' , 'B' , 'C' , and then 'D' on each respective iteration through the loop.\n\nIn the final line \u278c , the expression answerOptions.index(correctAnswer) will find the integer index of the correct answer in the randomly ordered answer options, and 'ABCD'[answerOptions.index(correctAnswer)] will evaluate to the correct answer\u2019s letter to be written to the answer key file.\n\nAfter you run the program, this is how your capitalsquiz1.txt file will look, though of course your questions and answer options may be different from those shown here, depending on the outcome of your random.shuffle() calls:\n\nName: Date: Period: State Capitals Quiz (Form 1) 1. What is the capital of West Virginia? A. Hartford B. Santa Fe C. Harrisburg D. Charleston 2. What is the capital of Colorado? A. Raleigh B. Harrisburg C. Denver D. Lincoln -- snip --\n\nThe corresponding capitalsquiz_answers1.txt text file will look like this:\n\n1. D 2. C 3. A 4. C -- snip --\n\n### Project: Updatable Multi-Clipboard\n\nLet\u2019s rewrite the \u201cmulti-clipboard\u201d program from Chapter 6 so that it uses the shelve module. The user will now be able to save new strings to load to the clipboard without having to modify the source code. We\u2019ll name this new program mcb.pyw (since \u201cmcb\u201d is shorter to type than \u201cmulti-clipboard\u201d). The .pyw extension means that Python won\u2019t show a Terminal window when it runs this program. (See Appendix B for more details.)\n\nThe program will save each piece of clipboard text under a keyword. For example, when you run py mcb.pyw save spam , the current contents of the clipboard will be saved with the keyword spam . This text can later be loaded to the clipboard again by running py mcb.pyw spam . And if the user forgets what keywords they have, they can run py mcb.pyw list to copy a list of all keywords to the clipboard.\n\nHere\u2019s what the program does:\n\n- The command line argument for the keyword is checked.\n- If the argument is save , then the clipboard contents are saved to the keyword.\n- If the argument is list , then all the keywords are copied to the clipboard.\n- Otherwise, the text for the keyword is copied to the clipboard.\n\nThis means the code will need to do the following:\n\n- Read the command line arguments from sys.argv .\n- Read and write to the clipboard.\n- Save and load to a shelf file.\n\nIf you use Windows, you can easily run this script from the Run... window by creating a batch file named mcb.bat with the following content:\n\n@pyw.exe C:\\Python34\\mcb.pyw %*\n\n#### Step 1: Comments and Shelf Setup\n\nLet\u2019s start by making a skeleton script with some comments and basic setup. Make your code look like the following:\n\n#! python3 # mcb.pyw - Saves and loads pieces of text to the clipboard. \u278a # Usage: py.exe mcb.pyw save <keyword> - Saves clipboard to keyword. #\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0py.exe mcb.pyw <keyword> - Loads keyword to clipboard. #\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0py.exe mcb.pyw list - Loads all keywords to clipboard. \u278b import shelve, pyperclip, sys \u278c mcbShelf = shelve.open('mcb') # TODO: Save clipboard content. # TODO: List keywords and load content. mcbShelf.close()\n\nIt\u2019s common practice to put general usage information in comments at the top of the file \u278a . If you ever forget how to run your script, you can always look at these comments for a reminder. Then you import your modules \u278b . Copying and pasting will require the pyperclip module, and reading the command line arguments will require the sys module. The shelve module will also come in handy: Whenever the user wants to save a new piece of clipboard text, you\u2019ll save it to a shelf file. Then, when the user wants to paste the text back to their clipboard, you\u2019ll open the shelf file and load it back into your program. The shelf file will be named with the prefix mcb \u278c .\n\n#### Step 2: Save Clipboard Content with a Keyword\n\nThe program does different things depending on whether the user wants to save text to a keyword, load text into the clipboard, or list all the existing keywords. Let\u2019s deal with that first case. Make your code look like the following:\n\n#! python3 # mcb.pyw - Saves and loads pieces of text to the clipboard. -- snip -- # Save clipboard content. \u278a if len(sys.argv) == 3 and sys.argv[1].lower() == 'save': \u278b mcbShelf[sys.argv[2]] = pyperclip.paste() elif len(sys.argv) == 2: \u278c # TODO: List keywords and load content. mcbShelf.close()\n\nIf the first command line argument (which will always be at index 1 of the sys.argv list) is 'save' \u278a , the second command line argument is the keyword for the current content of the clipboard. The keyword will be used as the key for mcbShelf , and the value will be the text currently on the clipboard \u278b .\n\nIf there is only one command line argument, you will assume it is either 'list' or a keyword to load content onto the clipboard. You will implement that code later. For now, just put a TODO comment there \u278c .\n\n#### Step 3: List Keywords and Load a Keyword\u2019s Content\n\nFinally, let\u2019s implement the two remaining cases: the user wants to load clipboard text in from a keyword, or they want a list of all available keywords. Make your code look like the following:\n\n#! python3 # mcb.pyw - Saves and loads pieces of text to the clipboard. -- snip -- # Save clipboard content. if len(sys.argv) == 3 and sys.argv[1].lower() == 'save': mcbShelf[sys.argv[2]] = pyperclip.paste() elif len(sys.argv) == 2: # List keywords and load content. \u278a if sys.argv[1].lower() == 'list': \u278b pyperclip.copy(str(list(mcbShelf.keys()))) elif sys.argv[1] in mcbShelf: \u278c pyperclip.copy(mcbShelf[sys.argv[1]]) mcbShelf.close()\n\nIf there is only one command line argument, first let\u2019s check whether it\u2019s 'list' \u278a . If so, a string representation of the list of shelf keys will be copied to the clipboard \u278b . The user can paste this list into an open text editor to read it.\n\nOtherwise, you can assume the command line argument is a keyword. If this keyword exists in the mcbShelf shelf as a key, you can load the value onto the clipboard \u278c .\n\nAnd that\u2019s it! Launching this program has different steps depending on what operating system your computer uses. See Appendix B for details.\n\nRecall the password locker program you created in Chapter 6 that stored the passwords in a dictionary. Updating the passwords required changing the source code of the program. This isn\u2019t ideal, because average users don\u2019t feel comfortable changing source code to update their software. Also, every time you modify the source code to a program, you run the risk of accidentally introducing new bugs. By storing the data for a program in a different place than the code, you can make your programs easier for others to use and more resistant to bugs.\n\n### Summary\n\nFiles are organized into folders (also called directories), and a path describes the location of a file. Every program running on your computer has a current working directory, which allows you to specify file paths relative to the current location instead of always typing the full (or absolute) path. The pathlib and os.path modules have many functions for manipulating file paths.\n\nYour programs can also directly interact with the contents of text files. The open() function can open these files to read in their contents as one large string (with the read() method) or as a list of strings (with the readlines() method). The open() function can open files in write or append mode to create new text files or add to existing text files, respectively.\n\nIn previous chapters, you used the clipboard as a way of getting large amounts of text into a program, rather than typing it all in. Now you can have your programs read files directly from the hard drive, which is a big improvement, since files are much less volatile than the clipboard.\n\nIn the next chapter, you will learn how to handle the files themselves, by copying them, deleting them, renaming them, moving them, and more.\n\n### Practice Questions\n\n1. What is a relative path relative to?\n\n2. What does an absolute path start with?\n\n3. What does Path('C:/Users') / 'Al' evaluate to on Windows?\n\n4. What does 'C:/Users' / 'Al' evaluate to on Windows?\n\n5. What do the os.getcwd() and os.chdir() functions do?\n\n6. What are the . and .. folders?\n\n7. In C:\\bacon\\eggs\\spam.txt , which part is the dir name, and which part is the base name?\n\n8. What are the three \u201cmode\u201d arguments that can be passed to the open() function?\n\n9. What happens if an existing file is opened in write mode?\n\n10. What is the difference between the read() and readlines() methods?\n\n11. What data structure does a shelf value resemble?\n\n### Practice Projects\n\nFor practice, design and write the following programs.\n\n#### Extending the Multi-Clipboard\n\nExtend the multi-clipboard program in this chapter so that it has a delete <keyword> command line argument that will delete a keyword from the shelf. Then add a delete command line argument that will delete all keywords.\n\n#### Mad Libs\n\nCreate a Mad Libs program that reads in text files and lets the user add their own text anywhere the word ADJECTIVE , NOUN , ADVERB , or VERB appears in the text file. For example, a text file may look like this:\n\nThe ADJECTIVE panda walked to the NOUN and then VERB. A nearby NOUN was unaffected by these events.\n\nThe program would find these occurrences and prompt the user to replace them.\n\nEnter an adjective: silly Enter a noun: chandelier Enter a verb: screamed Enter a noun: pickup truck\n\nThe following text file would then be created:\n\nThe silly panda walked to the chandelier and then screamed. A nearby pickup truck was unaffected by these events.\n\nThe results should be printed to the screen and saved to a new text file.\n\n#### Regex Search\n\nWrite a program that opens all . txt files in a folder and searches for any line that matches a user-supplied regular expression. The results should be printed to the screen.",
      "difficulty": "intro",
      "doc_id": "doc-9reading-and-writing-files-715d325b82",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-NC-SA 3.0",
        "source_file": "data/corpus_raw/scraped/2e_chapter9_0b8baa.json",
        "url": "https://automatetheboringstuff.com/2e/chapter9/"
      },
      "title": "9READING AND WRITING FILES",
      "type": "tutorial"
    },
    {
      "ai_generated": true,
      "concept_tags": [
        "input",
        "print",
        "reassignment",
        "type-conversion",
        "unpacking",
        "variables"
      ],
      "content": "This walkthrough is intentionally written with clear steps and intermediate variables.\n\n```python\n# Step 1: read a name (string)\nname = input(\"Name: \").strip()\n\n# Step 2: read age as text, then convert\nage_text = input(\"Age: \").strip()\n\n# Step 3: validate and convert\nif age_text.isdigit():\n    age = int(age_text)\nelse:\n    age = 0\n\n# Step 4: compute derived variables\nnext_year_age = age + 1\n\n# Step 5: build messages\nif age > 0:\n    msg = f\"Hi {name}, next year you will be {next_year_age}.\"\nelse:\n    msg = f\"Hi {name}, I couldn't read your age as a number.\"\n\nprint(msg)\n\n# Step 6: show how reassignment works\ncount = 0\ncount = count + 1\ncount = count + 1\nprint(\"count =\", count)\n\n# Step 7: multiple assignment and swapping\nx, y = 10, 20\nprint(\"before\", x, y)\n\nx, y = y, x\nprint(\"after\", x, y)\n```python\n\nNotes:\n- `strip()` removes extra spaces\n- `.isdigit()` is a simple integer check for non-negative whole numbers\n- f-strings make readable output",
      "difficulty": "intro",
      "doc_id": "doc-a-beginner-walkthrough-script-variables-input-conversions-and-simple-validation-f3e8aaa124",
      "provenance": {
        "author": "",
        "date": "",
        "license": "",
        "source_file": "data/corpus_raw/variables_easy_5.json",
        "url": ""
      },
      "title": "A beginner walkthrough script: variables, input, conversions, and simple validation",
      "type": "code_sample"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "all",
        "any",
        "boolean-ops",
        "bugs",
        "conditionals",
        "precedence",
        "short-circuit",
        "truthiness"
      ],
      "content": "At hard difficulty, conditionals become tricky because `and`/`or` do more than produce True/False: they can **return one of their operands**, and they **short-circuit** evaluation.\n\n---\n## 1) and/or return values\n\n```python\nprint(0 and 99)        # 0\nprint(5 and 99)        # 99\n\nprint(\"hi\" or \"bye\")  # hi\nprint(\"\" or \"bye\")    # bye\n```python\n\nThis is why \u201cdefaulting\u201d works:\n\n```python\nname = \"\"\ndisplay = name or \"(anonymous)\"\nprint(display)\n```python\n\nBut be careful: `0` is falsy, so it will also fall back.\n\n```python\nn = 0\nprint(n or 123)  # 123 (maybe not desired)\n```python\n\nIf 0 is valid, be explicit:\n\n```python\nn = 0\nfallback = 123\nprint(fallback if n is None else n)\n```python\n\n---\n## 2) Short-circuit prevents errors (guard patterns)\n\n```python\nobj = None\n\n# safe: second part runs only if first part is True\nif obj is not None and obj.get(\"k\") == 1:\n    print(\"match\")\nelse:\n    print(\"no\")\n```python\n\n---\n## 3) Precedence and parentheses\nWhen conditions get long, parentheses improve clarity.\n\n```python\nage = 19\nhas_ticket = True\nvip = False\n\nif (age >= 18 and has_ticket) or vip:\n    print(\"enter\")\nelse:\n    print(\"no\")\n```python\n\n---\n## 4) any/all: make complex checks readable\n\n```python\npassword = \"Abc123\"\n\nrules = [\n    len(password) >= 6,\n    any(ch.isdigit() for ch in password),\n    any(ch.isupper() for ch in password),\n]\n\nif all(rules):\n    print(\"ok\")\nelse:\n    print(\"try again\")\n```python\n\n---\n## 5) A larger example: choose a safe default without losing information\n\n```python\ndef display_name(user):\n    # user may be None, or a dict with optional fields\n    if user is None:\n        return \"(missing user)\"\n\n    # prefer nickname, then name, then id\n    nick = user.get(\"nickname\")\n    name = user.get(\"name\")\n    uid = user.get(\"id\")\n\n    # careful: nick/name could be empty strings and that might matter\n    if nick is not None and nick != \"\":\n        return nick\n    if name is not None and name != \"\":\n        return name\n    return f\"user-{uid}\" if uid is not None else \"(unknown)\"\n\nprint(display_name({\"nickname\": \"\", \"name\": \"Ana\", \"id\": 7}))\nprint(display_name({\"name\": \"\", \"id\": 7}))\nprint(display_name(None))\n```",
      "difficulty": "hard",
      "doc_id": "doc-advanced-boolean-behavior-and-or-return-operands-evaluation-order-and-subtle-conditional-bugs-ad6a34ada1",
      "provenance": {
        "author": "",
        "date": "",
        "license": "PSF Documentation License (Python docs)",
        "source_file": "data/corpus_raw/conditionals_hard_3.json",
        "url": "https://docs.python.org/3/reference/expressions.html"
      },
      "title": "Advanced boolean behavior: and/or return operands, evaluation order, and subtle conditional bugs",
      "type": "reference"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "assignment",
        "attributes",
        "dicts",
        "lists",
        "unpacking",
        "variables"
      ],
      "content": "Python assignment is more flexible than \u201cname = value\u201d. The language reference describes different assignment target forms and their behavior.\n\n---\n## 1) One value to multiple names\n\n```python\nx = y = z = 0\nprint(x, y, z)  # 0 0 0\n```python\n\n---\n## 2) Unpacking assignment (tuple/list)\n\n```python\npoint = (10, 20)\nx, y = point\nprint(x, y)      # 10 20\n\nrgb = [255, 128, 0]\nr, g, b = rgb\nprint(r, g, b)\n```python\n\nCommon error case:\n\n```python\n# a, b = (1, 2, 3)  # ValueError: too many values to unpack\n```python\n\n---\n## 3) Assignment targets are not only names\nYou can assign to:\n- names\n- attributes (`obj.attr`)\n- items (`obj[index]` or `obj[key]`)\n\n### Attribute assignment\n\n```python\nclass Box:\n    pass\n\nb = Box()\nb.value = 99\nprint(b.value)\n```python\n\n### Item assignment (list/dict)\n\n```python\nnums = [1, 2, 3]\nnums[0] = 100\nprint(nums)  # [100, 2, 3]\n\nm = {\"count\": 1}\nm[\"count\"] = m[\"count\"] + 1\nprint(m)     # {'count': 2}\n```python\n\n---\n## 4) A compact \u201cmany forms\u201d practice block\n\n```python\nx = 1\nx = x + 1\n\n(a, b) = (10, 20)\n\nnums = [0, 1, 2]\nnums[2] = 99\n\nclass C:\n    pass\nobj = C()\nobj.name = \"Ada\"\n\nprint(x, a, b)\nprint(nums)\nprint(obj.name)\n```",
      "difficulty": "intro",
      "doc_id": "doc-assignment-basics-beyond-multiple-targets-unpacking-and-what-can-be-assigned-to-5caa9f3196",
      "provenance": {
        "author": "",
        "date": "",
        "license": "PSF Documentation License (Python docs)",
        "source_file": "data/corpus_raw/variables_easy_3.json",
        "url": "https://docs.python.org/3/reference/simple_stmts.html"
      },
      "title": "Assignment basics beyond '=': multiple targets, unpacking, and what can be assigned to",
      "type": "reference"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "assignment-expression",
        "conditionals",
        "parsing",
        "readability",
        "walrus",
        "while"
      ],
      "content": "Hard-level conditional code often tries to balance readability with avoiding repeated work. Python\u2019s **assignment expression** operator `:=` (sometimes called the \u201cwalrus operator\u201d) helps when you want to compute a value once and use it immediately in an `if` or `while`.\n\n---\n## 1) The basic idea\nInstead of computing something twice:\n\n```python\ns = \" 42 \"\nif s.strip().isdigit():\n    n = int(s.strip())\n    print(n)\n```python\n\nYou can compute once and reuse:\n\n```python\ns = \" 42 \"\nif (t := s.strip()).isdigit():\n    n = int(t)\n    print(n)\n```python\n\n---\n## 2) While loops with assignment expressions (read/process pattern)\nA classic use is reading items until a sentinel.\n\n```python\n# conceptually similar to: line = input(); while line != \"\": ...; line = input()\nlines = [\"a\", \"bb\", \"\", \"ccc\"]\ni = 0\n\nwhile (line := lines[i]) != \"\":\n    print(\"got\", line)\n    i += 1\n```python\n\n---\n## 3) Avoid repeated expensive work\n\n```python\nimport time\n\ndef expensive(x):\n    time.sleep(0.05)\n    return x * 2\n\nx = 10\n\n# without := you'd likely call expensive(x) twice if you need the value\nif (y := expensive(x)) > 10:\n    print(\"big\", y)\nelse:\n    print(\"small\", y)\n```python\n\n---\n## 4) Parsing with := in a readable way\n\n```python\ntext = \"key=value\"\nif (parts := text.split(\"=\", 1)) and len(parts) == 2:\n    k, v = parts\n    print(k, v)\n```python\n\n---\n## 5) A larger example: parse numeric tokens with a single pass\n\n```python\ndata = [\"10\", \"x\", \"5\", \"-\", \"7\", \" 3 \"]\nnums = []\n\nfor raw in data:\n    if (t := raw.strip()).isdigit():\n        nums.append(int(t))\n\nprint(nums)\nprint(\"sum\", sum(nums))\nprint(\"max\", max(nums) if nums else None)\n```python\n\n---\n## 6) Practical guidance\n- Use `:=` when it **removes repetition** and stays readable.\n- If it makes the condition too dense, compute the value on a separate line.",
      "difficulty": "hard",
      "doc_id": "doc-assignment-expressions-in-conditionals-compact-patterns-without-losing-clarity-2c1f405af6",
      "provenance": {
        "author": "",
        "date": "",
        "license": "Public domain (PEP text)",
        "source_file": "data/corpus_raw/conditionals_hard_1.json",
        "url": "https://peps.python.org/pep-0572/"
      },
      "title": "Assignment expressions (:=) in conditionals: compact patterns without losing clarity",
      "type": "reference"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "aliasing",
        "assignment",
        "copy",
        "deepcopy",
        "dicts",
        "lists",
        "mutability",
        "shallow-copy",
        "variables"
      ],
      "content": "A moderate jump in understanding variables is realizing that **assignment does not copy objects**. It creates a binding (a reference) from a name to an object.\n\n---\n## 1) Aliasing: two names, one object\n\n```python\noriginal = {\"k\": 1}\nalias = original\n\nalias[\"k\"] = 999\nprint(original)  # {'k': 999}\nprint(alias)     # {'k': 999}\n```python\n\nBoth names refer to the same dictionary, so changing it via one name is visible through the other.\n\n---\n## 2) Shallow copy: new outer object, shared inner objects\nA shallow copy duplicates the outer container but keeps references to nested objects.\n\n```python\nouter1 = {\"nums\": [1, 2, 3], \"tag\": \"A\"}\nouter2 = outer1.copy()  # dict shallow copy\n\nouter2[\"tag\"] = \"B\"          # changes only outer2\nouter2[\"nums\"].append(4)      # changes the shared inner list\n\nprint(outer1)  # nums changed!\nprint(outer2)\n```python\n\nThis can surprise people: the dict itself is copied, but the list inside is still shared.\n\n---\n## 3) Shallow copying techniques you\u2019ll see often\n\n```python\nlst1 = [1, 2, 3]\nlst2 = lst1.copy()   # or lst1[:] or list(lst1)\n\nlst2.append(999)\nprint(lst1)  # [1, 2, 3]\nprint(lst2)  # [1, 2, 3, 999]\n```python\n\nFor nested lists, shallow copying the outer list isn\u2019t enough:\n\n```python\ngrid1 = [[0, 0], [0, 0]]\ngrid2 = grid1.copy()  # shallow\n\ngrid2[0].append(1)\nprint(grid1)  # inner list mutated (shared)\nprint(grid2)\n```python\n\n---\n## 4) Deep copy: recursively copies nested objects\nWhen you need an independent copy of a nested structure, use `copy.deepcopy`.\n\n```python\nimport copy\n\ngrid1 = [[0, 0], [0, 0]]\ngrid3 = copy.deepcopy(grid1)\n\ngrid3[0].append(1)\nprint(grid1)  # unchanged\nprint(grid3)  # changed\n```python\n\n---\n## 5) A practical mini checklist\n- If you only need a separate outer container and you are fine sharing nested objects \u2192 shallow copy is fine.\n- If you need nested objects to be independent too \u2192 deep copy.\n- If the object is immutable (like an int or string), aliasing is usually not a problem.\n\n---\n## 6) Short \u201cspot the aliasing\u201d practice block\n\n```python\nimport copy\n\na = {\"x\": [1, 2]}\nb = a\nc = a.copy()\nd = copy.deepcopy(a)\n\nb[\"x\"].append(3)\nprint(a)  # affects a\nprint(c)  # shallow copy shares inner list\nprint(d)  # deep copy independent\n```",
      "difficulty": "moderate",
      "doc_id": "doc-assignment-vs-copying-objects-aliasing-shallow-copies-and-deep-copies-174c976547",
      "provenance": {
        "author": "",
        "date": "",
        "license": "PSF Documentation License (Python docs)",
        "source_file": "data/corpus_raw/variables_moderate_2.json",
        "url": "https://docs.python.org/3/library/copy.html"
      },
      "title": "Assignment vs copying objects: aliasing, shallow copies, and deep copies",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "assignment",
        "augmented-assignment",
        "identity",
        "lists",
        "mutability",
        "strings",
        "tuples",
        "variables"
      ],
      "content": "Augmented assignment combines an operation and an assignment into one statement, like `x += 1`. It\u2019s convenient, but it also introduces a few important details that matter when variables refer to **mutable** objects.\n\n---\n## 1) The basic idea\n\n```python\nx = 10\nx += 5\nprint(x)  # 15\n```python\n\nYou can think of `x += 5` as \u201ctake the current value of `x`, add 5, then store it back into `x`.\u201d\n\n---\n## 2) The target is evaluated once\nIn augmented assignment, the *target expression* is evaluated once, then updated.\n\n```python\nitems = [10, 20, 30]\ni = 1\n\nitems[i] += 100\nprint(items)  # [10, 120, 30]\n```python\n\nThis matters when the target expression is more complex or has side effects.\n\n---\n## 3) Different operators exist\nPython supports many augmented operators.\n\n```python\nx = 7\nx *= 3\nprint(x)  # 21\n\nx //= 4\nprint(x)  # 5\n\nx **= 2\nprint(x)  # 25\n```python\n\n---\n## 4) Mutability: += may mutate in place\nA key moderate-level concept is that `+=` can behave differently depending on the type.\n\n### Lists: often mutate in place\n\n```python\nlst = [1, 2]\nalias = lst\n\nlst += [3, 4]\nprint(lst)   # [1, 2, 3, 4]\nprint(alias) # [1, 2, 3, 4]  (same object)\n```python\n\n### Tuples: cannot mutate, so a new tuple is created\n\n```python\nt = (1, 2)\nold = t\n\nt += (3,)\nprint(old)  # (1, 2)\nprint(t)    # (1, 2, 3)\n```python\n\nA quick way to see \u201csame object or new object\u201d is to compare identities:\n\n```python\nlst = [1, 2]\nprint(id(lst))\n\nlst += [3]\nprint(id(lst))  # often the same (in-place)\n\ns = \"hi\"\nprint(id(s))\n\ns += \"!\"\nprint(id(s))    # different (strings are immutable)\n```python\n\n---\n## 5) Augmented assignment on attributes and items\n\n```python\nclass Box:\n    def __init__(self, v):\n        self.v = v\n\nb = Box(10)\nb.v += 7\nprint(b.v)  # 17\n\nm = {\"count\": 1}\nm[\"count\"] += 1\nprint(m)    # {'count': 2}\n```python\n\n---\n## 6) Common confusion (good to know)\n- Augmented assignment targets cannot be unpacking targets.\n\n```python\n# a, b += (1, 2)  # not allowed\n```python\n\n---\n## 7) Mixed example to practice reading code\n\n```python\nnums = [0, 1, 2]\nnums[0] += 10\n\nx = 2\nx *= 5\n\nname = \"A\"\nname += \"B\"\n\nprint(nums)   # [10, 1, 2]\nprint(x)      # 10\nprint(name)   # AB\n```",
      "difficulty": "moderate",
      "doc_id": "doc-augmented-assignment-how-works-evaluation-order-and-mutability-effects-bd8676a13f",
      "provenance": {
        "author": "",
        "date": "",
        "license": "PSF Documentation License (Python docs)",
        "source_file": "data/corpus_raw/variables_moderate_1.json",
        "url": "https://docs.python.org/3/reference/simple_stmts.html"
      },
      "title": "Augmented assignment: how += works, evaluation order, and mutability effects",
      "type": "tutorial"
    },
    {
      "ai_generated": true,
      "concept_tags": [
        "generators",
        "itertools",
        "loops",
        "parsing",
        "pipelines",
        "single-pass"
      ],
      "content": "This mini-project shows why hard looping concepts matter: you can build a readable data-processing pipeline without deeply nested loops.\n\n---\n## 1) The data\nImagine a stream of tokens from logs or configuration lines.\n\n```python\ntokens = [\n    \"USER ana\",\n    \"SCORE 10\",\n    \"USER ben\",\n    \"SCORE 25\",\n    \"USER ana\",\n    \"SCORE 5\",\n    \"JUNK ???\",\n]\n```python\n\n---\n## 2) Parse the stream into structured events\n\n```python\ndef parse(tokens):\n    for line in tokens:\n        parts = line.split()\n        if len(parts) != 2:\n            continue\n        kind, value = parts\n        if kind not in (\"USER\", \"SCORE\"):\n            continue\n        yield (kind, value)\n\nevents = parse(tokens)\nprint(list(events))\n```python\n\nNote: `events` is now consumed because we converted it to a list. In real code, avoid consuming the stream unless you mean to.\n\n---\n## 3) Keep it streaming: compute totals in one pass\n\n```python\ndef totals_by_user(tokens):\n    current_user = None\n    totals = {}\n\n    for kind, value in parse(tokens):\n        if kind == \"USER\":\n            current_user = value\n        elif kind == \"SCORE\" and current_user is not None and value.isdigit():\n            totals[current_user] = totals.get(current_user, 0) + int(value)\n\n    return totals\n\nprint(totals_by_user(tokens))\n```python\n\n---\n## 4) Add a streaming filter + transformation layer\n\n```python\ndef only_scores(tokens):\n    for kind, value in parse(tokens):\n        if kind == \"SCORE\" and value.isdigit():\n            yield int(value)\n\nprint(sum(only_scores(tokens)))\n```python\n\n---\n## 5) Use itertools to combine streams\n\n```python\nimport itertools\n\nmore = [\"SCORE 7\", \"SCORE x\", \"SCORE 3\"]\nall_tokens = itertools.chain(tokens, more)\n\nprint(sum(only_scores(all_tokens)))  # sums digits only\n```python\n\n---\n## 6) Practice block: take only the first N numeric scores\n\n```python\nimport itertools\n\nscores = only_scores(tokens)\nprint(list(itertools.islice(scores, 2)))\n```",
      "difficulty": "hard",
      "doc_id": "doc-building-a-loop-pipeline-parse-tokens-transform-streams-and-produce-a-report-3d5ba4846e",
      "provenance": {
        "author": "",
        "date": "",
        "license": "",
        "source_file": "data/corpus_raw/loops_hard_5.json",
        "url": ""
      },
      "title": "Building a loop pipeline: parse tokens, transform streams, and produce a report",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "debugging",
        "error_handling",
        "exceptions"
      ],
      "content": "# Built-in Exceptions\u00c2\u00b6\n\nIn Python, all exceptions must be instances of a class that derives from BaseException .  In a try statement with an except clause that mentions a particular class, that clause also handles any exception\nclasses derived from that class (but not exception classes from which it is\nderived).  Two exception classes that are not related via subclassing are never\nequivalent, even if they have the same name.\n\nThe built-in exceptions listed in this chapter can be generated by the interpreter or\nbuilt-in functions.  Except where mentioned, they have an \u00e2\u0080\u009cassociated value\u00e2\u0080\u009d\nindicating the detailed cause of the error.  This may be a string or a tuple of\nseveral items of information (e.g., an error code and a string explaining the\ncode).  The associated value is usually passed as arguments to the exception\nclass\u00e2\u0080\u0099s constructor.\n\nUser code can raise built-in exceptions.  This can be used to test an exception\nhandler or to report an error condition \u00e2\u0080\u009cjust like\u00e2\u0080\u009d the situation in which the\ninterpreter raises the same exception; but beware that there is nothing to\nprevent user code from raising an inappropriate error.\n\nThe built-in exception classes can be subclassed to define new exceptions;\nprogrammers are encouraged to derive new exceptions from the Exception class or one of its subclasses, and not from BaseException .  More\ninformation on defining exceptions is available in the Python Tutorial under User-defined Exceptions .\n\n## Exception context\u00c2\u00b6\n\nThree attributes on exception objects provide information about the context in\nwhich the exception was raised:\n\nBaseException.\n__context__\n\u00c2\u00b6\nBaseException.\n__cause__\n\u00c2\u00b6\nBaseException.\n__suppress_context__\n\u00c2\u00b6\nWhen raising a new exception while another exception\nis already being handled, the new exception\u00e2\u0080\u0099s __context__ attribute is automatically set to the handled\nexception.  An exception may be handled when an except or finally clause, or a with statement, is used.\n\nThis implicit exception context can be\nsupplemented with an explicit cause by using from with raise :\n\n```python\nraise new_exc from original_exc\n```python\n\nThe expression following from must be an exception or None . It\nwill be set as __cause__ on the raised exception. Setting __cause__ also implicitly sets the __suppress_context__ attribute to True , so that using raise new_exc from None effectively replaces the old exception with the new one for display\npurposes (e.g. converting KeyError to AttributeError ), while\nleaving the old exception available in __context__ for introspection\nwhen debugging.\n\nThe default traceback display code shows these chained exceptions in\naddition to the traceback for the exception itself. An explicitly chained\nexception in __cause__ is always shown when present. An implicitly\nchained exception in __context__ is shown only if __cause__ is None and __suppress_context__ is false.\n\nIn either case, the exception itself is always shown after any chained\nexceptions so that the final line of the traceback always shows the last\nexception that was raised.\n\n## Inheriting from built-in exceptions\u00c2\u00b6\n\nUser code can create subclasses that inherit from an exception type.\nIt\u00e2\u0080\u0099s recommended to only subclass one exception type at a time to avoid\nany possible conflicts between how the bases handle the args attribute, as well as due to possible memory layout incompatibilities.\n\nCPython implementation detail: Most built-in exceptions are implemented in C for efficiency, see: Objects/exceptions.c .  Some have custom memory layouts\nwhich makes it impossible to create a subclass that inherits from\nmultiple exception types. The memory layout of a type is an implementation\ndetail and might change between Python versions, leading to new\nconflicts in the future.  Therefore, it\u00e2\u0080\u0099s recommended to avoid\nsubclassing multiple exception types altogether.\n\n## Base classes\u00c2\u00b6\n\nThe following exceptions are used mostly as base classes for other exceptions.\n\nexception\nBaseException\n\u00c2\u00b6\nThe base class for all built-in exceptions.  It is not meant to be directly\ninherited by user-defined classes (for that, use Exception ).  If str() is called on an instance of this class, the representation of\nthe argument(s) to the instance are returned, or the empty string when\nthere were no arguments.\n\nargs\n\u00c2\u00b6\nThe tuple of arguments given to the exception constructor.  Some built-in\nexceptions (like OSError ) expect a certain number of arguments and\nassign a special meaning to the elements of this tuple, while others are\nusually called only with a single string giving an error message.\n\nwith_traceback\n(\ntb\n)\n\u00c2\u00b6\nThis method sets tb as the new traceback for the exception and returns\nthe exception object.  It was more commonly used before the exception\nchaining features of PEP 3134 became available.  The following example\nshows how we can convert an instance of SomeException into an\ninstance of OtherException while preserving the traceback.  Once\nraised, the current frame is pushed onto the traceback of the OtherException , as would have happened to the traceback of the\noriginal SomeException had we allowed it to propagate to the caller.\n\n```python\ntry:\n    ...\nexcept SomeException:\n    tb = sys.exception().__traceback__\n    raise OtherException(...).with_traceback(tb)\n```python\n\n__traceback__\n\u00c2\u00b6\nA writable field that holds the traceback object associated with this\nexception. See also: The raise statement .\n\nadd_note\n(\nnote\n)\n\u00c2\u00b6\nAdd the string note to the exception\u00e2\u0080\u0099s notes which appear in the standard\ntraceback after the exception string. A TypeError is raised if note is not a string.\n\nAdded in version 3.11.\n\n__notes__\n\u00c2\u00b6\nA list of the notes of this exception, which were added with add_note() .\nThis attribute is created when add_note() is called.\n\nAdded in version 3.11.\n\nexception\nException\n\u00c2\u00b6\nAll built-in, non-system-exiting exceptions are derived from this class.  All\nuser-defined exceptions should also be derived from this class.\n\nexception\nArithmeticError\n\u00c2\u00b6\nThe base class for those built-in exceptions that are raised for various\narithmetic errors: OverflowError , ZeroDivisionError , FloatingPointError .\n\nexception\nBufferError\n\u00c2\u00b6\nRaised when a buffer related operation cannot be\nperformed.\n\nexception\nLookupError\n\u00c2\u00b6\nThe base class for the exceptions that are raised when a key or index used on\na mapping or sequence is invalid: IndexError , KeyError .  This\ncan be raised directly by codecs.lookup() .\n\n## Concrete exceptions\u00c2\u00b6\n\nThe following exceptions are the exceptions that are usually raised.\n\nexception\nAssertionError\n\u00c2\u00b6\nRaised when an assert statement fails.\n\nexception\nAttributeError\n\u00c2\u00b6\nRaised when an attribute reference (see Attribute references ) or\nassignment fails.  (When an object does not support attribute references or\nattribute assignments at all, TypeError is raised.)\n\nThe optional name and obj keyword-only arguments\nset the corresponding attributes:\n\nname\n\u00c2\u00b6\nThe name of the attribute that was attempted to be accessed.\n\nobj\n\u00c2\u00b6\nThe object that was accessed for the named attribute.\n\nChanged in version 3.10: Added the name and obj attributes.\n\nexception\nEOFError\n\u00c2\u00b6\nRaised when the input() function hits an end-of-file condition (EOF)\nwithout reading any data. (Note: the io.IOBase.read() and io.IOBase.readline() methods return an empty string when they hit EOF.)\n\nexception\nFloatingPointError\n\u00c2\u00b6\nNot currently used.\n\nexception\nGeneratorExit\n\u00c2\u00b6\nRaised when a generator or coroutine is closed;\nsee generator.close() and coroutine.close() .  It\ndirectly inherits from BaseException instead of Exception since\nit is technically not an error.\n\nexception\nImportError\n\u00c2\u00b6\nRaised when the import statement has troubles trying to\nload a module.  Also raised when the \u00e2\u0080\u009cfrom list\u00e2\u0080\u009d in from ... import has a name that cannot be found.\n\nThe optional name and path keyword-only arguments\nset the corresponding attributes:\n\nname\n\u00c2\u00b6\nThe name of the module that was attempted to be imported.\n\npath\n\u00c2\u00b6\nThe path to any file which triggered the exception.\n\nChanged in version 3.3: Added the name and path attributes.\n\nexception\nModuleNotFoundError\n\u00c2\u00b6\nA subclass of ImportError which is raised by import when a module could not be located.  It is also raised when None is found in sys.modules .\n\nAdded in version 3.6.\n\nexception\nIndexError\n\u00c2\u00b6\nRaised when a sequence subscript is out of range.  (Slice indices are\nsilently truncated to fall in the allowed range; if an index is not an\ninteger, TypeError is raised.)\n\nexception\nKeyError\n\u00c2\u00b6\nRaised when a mapping (dictionary) key is not found in the set of existing keys.\n\nexception\nKeyboardInterrupt\n\u00c2\u00b6\nRaised when the user hits the interrupt key (normally Control - C or Delete ).  During execution, a check for interrupts is made\nregularly. The exception inherits from BaseException so as to not be\naccidentally caught by code that catches Exception and thus prevent\nthe interpreter from exiting.\n\nNote\n\nCatching a KeyboardInterrupt requires special consideration.\nBecause it can be raised at unpredictable points, it may, in some\ncircumstances, leave the running program in an inconsistent state. It is\ngenerally best to allow KeyboardInterrupt to end the program as\nquickly as possible or avoid raising it entirely. (See Note on Signal Handlers and Exceptions .)\n\nexception\nMemoryError\n\u00c2\u00b6\nRaised when an operation runs out of memory but the situation may still be\nrescued (by deleting some objects).  The associated value is a string indicating\nwhat kind of (internal) operation ran out of memory. Note that because of the\nunderlying memory management architecture (C\u00e2\u0080\u0099s malloc() function), the\ninterpreter may not always be able to completely recover from this situation; it\nnevertheless raises an exception so that a stack traceback can be printed, in\ncase a run-away program was the cause.\n\nexception\nNameError\n\u00c2\u00b6\nRaised when a local or global name is not found.  This applies only to\nunqualified names.  The associated value is an error message that includes the\nname that could not be found.\n\nThe optional name keyword-only argument sets the attribute:\n\nname\n\u00c2\u00b6\nThe name of the variable that was attempted to be accessed.\n\nChanged in version 3.10: Added the name attribute.\n\nexception\nNotImplementedError\n\u00c2\u00b6\nThis exception is derived from RuntimeError .  In user defined base\nclasses, abstract methods should raise this exception when they require\nderived classes to override the method, or while the class is being\ndeveloped to indicate that the real implementation still needs to be added.\n\nNote\n\nIt should not be used to indicate that an operator or method is not\nmeant to be supported at all \u00e2\u0080\u0093 in that case either leave the operator /\nmethod undefined or, if a subclass, set it to None .\n\nCaution\n\nNotImplementedError and NotImplemented are not\ninterchangeable. This exception should only be used as described\nabove; see NotImplemented for details on correct usage of\nthe built-in constant.\n\nexception\nOSError\n(\n[\narg\n]\n)\n\u00c2\u00b6\nexception\nOSError\n(\nerrno\n,\nstrerror\n[\n,\nfilename\n[\n,\nwinerror\n[\n,\nfilename2\n]\n]\n]\n)\nThis exception is raised when a system function returns a system-related\nerror, including I/O failures such as \u00e2\u0080\u009cfile not found\u00e2\u0080\u009d or \u00e2\u0080\u009cdisk full\u00e2\u0080\u009d\n(not for illegal argument types or other incidental errors).\n\nThe second form of the constructor sets the corresponding attributes,\ndescribed below.  The attributes default to None if not\nspecified.  For backwards compatibility, if three arguments are passed,\nthe args attribute contains only a 2-tuple\nof the first two constructor arguments.\n\nThe constructor often actually returns a subclass of OSError , as\ndescribed in OS exceptions below.  The particular subclass depends on\nthe final errno value.  This behaviour only occurs when\nconstructing OSError directly or via an alias, and is not\ninherited when subclassing.\n\nerrno\n\u00c2\u00b6\nA numeric error code from the C variable errno .\n\nwinerror\n\u00c2\u00b6\nUnder Windows, this gives you the native\nWindows error code.  The errno attribute is then an approximate\ntranslation, in POSIX terms, of that native error code.\n\nUnder Windows, if the winerror constructor argument is an integer,\nthe errno attribute is determined from the Windows error code,\nand the errno argument is ignored.  On other platforms, the winerror argument is ignored, and the winerror attribute\ndoes not exist.\n\nstrerror\n\u00c2\u00b6\nThe corresponding error message, as provided by\nthe operating system.  It is formatted by the C\nfunctions perror() under POSIX, and FormatMessage() under Windows.\n\nfilename\n\u00c2\u00b6\nfilename2\n\u00c2\u00b6\nFor exceptions that involve a file system path (such as open() or os.unlink() ), filename is the file name passed to the function.\nFor functions that involve two file system paths (such as os.rename() ), filename2 corresponds to the second\nfile name passed to the function.\n\nChanged in version 3.3: EnvironmentError , IOError , WindowsError , socket.error , select.error and mmap.error have been merged into OSError , and the\nconstructor may return a subclass.\n\nChanged in version 3.4: The filename attribute is now the original file name passed to\nthe function, instead of the name encoded to or decoded from the filesystem encoding and error handler . Also, the filename2 constructor argument and attribute was added.\n\nexception\nOverflowError\n\u00c2\u00b6\nRaised when the result of an arithmetic operation is too large to be\nrepresented.  This cannot occur for integers (which would rather raise MemoryError than give up).  However, for historical reasons,\nOverflowError is sometimes raised for integers that are outside a required\nrange.   Because of the lack of standardization of floating-point exception\nhandling in C, most floating-point operations are not checked.\n\nexception\nPythonFinalizationError\n\u00c2\u00b6\nThis exception is derived from RuntimeError .  It is raised when\nan operation is blocked during interpreter shutdown also known as Python finalization .\n\nExamples of operations which can be blocked with a PythonFinalizationError during the Python finalization:\n\n- Creating a new Python thread.\n- Joining a running daemon thread.\n- os.fork() .\n\nSee also the sys.is_finalizing() function.\n\nAdded in version 3.13: Previously, a plain RuntimeError was raised.\n\nChanged in version 3.14: threading.Thread.join() can now raise this exception.\n\nexception\nRecursionError\n\u00c2\u00b6\nThis exception is derived from RuntimeError .  It is raised when the\ninterpreter detects that the maximum recursion depth (see sys.getrecursionlimit() ) is exceeded.\n\nAdded in version 3.5: Previously, a plain RuntimeError was raised.\n\nexception\nReferenceError\n\u00c2\u00b6\nThis exception is raised when a weak reference proxy, created by the weakref.proxy() function, is used to access an attribute of the referent\nafter it has been garbage collected. For more information on weak references,\nsee the weakref module.\n\nexception\nRuntimeError\n\u00c2\u00b6\nRaised when an error is detected that doesn\u00e2\u0080\u0099t fall in any of the other\ncategories.  The associated value is a string indicating what precisely went\nwrong.\n\nexception\nStopIteration\n\u00c2\u00b6\nRaised by built-in function next() and an iterator 's __next__() method to signal that there are no further\nitems produced by the iterator.\n\nvalue\n\u00c2\u00b6\nThe exception object has a single attribute value , which is\ngiven as an argument when constructing the exception, and defaults\nto None .\n\nWhen a generator or coroutine function\nreturns, a new StopIteration instance is\nraised, and the value returned by the function is used as the value parameter to the constructor of the exception.\n\nIf a generator code directly or indirectly raises StopIteration ,\nit is converted into a RuntimeError (retaining the StopIteration as the new exception\u00e2\u0080\u0099s cause).\n\nChanged in version 3.3: Added value attribute and the ability for generator functions to\nuse it to return a value.\n\nChanged in version 3.5: Introduced the RuntimeError transformation via from __future__ import generator_stop , see PEP 479 .\n\nChanged in version 3.7: Enable PEP 479 for all code by default: a StopIteration error raised in a generator is transformed into a RuntimeError .\n\nexception\nStopAsyncIteration\n\u00c2\u00b6\nMust be raised by __anext__() method of an asynchronous iterator object to stop the iteration.\n\nAdded in version 3.5.\n\nexception\nSyntaxError\n(\nmessage\n,\ndetails\n)\n\u00c2\u00b6\nRaised when the parser encounters a syntax error.  This may occur in an import statement, in a call to the built-in functions compile() , exec() ,\nor eval() , or when reading the initial script or standard input\n(also interactively).\n\nThe str() of the exception instance returns only the error message.\nDetails is a tuple whose members are also available as separate attributes.\n\nfilename\n\u00c2\u00b6\nThe name of the file the syntax error occurred in.\n\nlineno\n\u00c2\u00b6\nWhich line number in the file the error occurred in. This is\n1-indexed: the first line in the file has a lineno of 1.\n\noffset\n\u00c2\u00b6\nThe column in the line where the error occurred. This is\n1-indexed: the first character in the line has an offset of 1.\n\ntext\n\u00c2\u00b6\nThe source code text involved in the error.\n\nend_lineno\n\u00c2\u00b6\nWhich line number in the file the error occurred ends in. This is\n1-indexed: the first line in the file has a lineno of 1.\n\nend_offset\n\u00c2\u00b6\nThe column in the end line where the error occurred finishes. This is\n1-indexed: the first character in the line has an offset of 1.\n\nFor errors in f-string fields, the message is prefixed by \u00e2\u0080\u009cf-string: \u00e2\u0080\u009d\nand the offsets are offsets in a text constructed from the replacement\nexpression.  For example, compiling f\u00e2\u0080\u0099Bad {a b} field\u00e2\u0080\u0099 results in this\nargs attribute: (\u00e2\u0080\u0098f-string: \u00e2\u0080\u00a6\u00e2\u0080\u0099, (\u00e2\u0080\u0098\u00e2\u0080\u0099, 1, 2, \u00e2\u0080\u0098(a b)n\u00e2\u0080\u0099, 1, 5)).\n\nChanged in version 3.10: Added the end_lineno and end_offset attributes.\n\nexception\nIndentationError\n\u00c2\u00b6\nBase class for syntax errors related to incorrect indentation.  This is a\nsubclass of SyntaxError .\n\nexception\nTabError\n\u00c2\u00b6\nRaised when indentation contains an inconsistent use of tabs and spaces.\nThis is a subclass of IndentationError .\n\nexception\nSystemError\n\u00c2\u00b6\nRaised when the interpreter finds an internal error, but the situation does not\nlook so serious to cause it to abandon all hope. The associated value is a\nstring indicating what went wrong (in low-level terms). In CPython ,\nthis could be raised by incorrectly using Python\u00e2\u0080\u0099s C API, such as returning\na NULL value without an exception set.\n\nIf you\u00e2\u0080\u0099re confident that this exception wasn\u00e2\u0080\u0099t your fault, or the fault of\na package you\u00e2\u0080\u0099re using, you should report this to the author or maintainer\nof your Python interpreter.\nBe sure to report the version of the Python interpreter ( sys.version ; it is\nalso printed at the start of an interactive Python session), the exact error\nmessage (the exception\u00e2\u0080\u0099s associated value) and if possible the source of the\nprogram that triggered the error.\n\nexception\nSystemExit\n\u00c2\u00b6\nThis exception is raised by the sys.exit() function.  It inherits from BaseException instead of Exception so that it is not accidentally\ncaught by code that catches Exception .  This allows the exception to\nproperly propagate up and cause the interpreter to exit.  When it is not\nhandled, the Python interpreter exits; no stack traceback is printed.  The\nconstructor accepts the same optional argument passed to sys.exit() .\nIf the value is an integer, it specifies the system exit status (passed to\nC\u00e2\u0080\u0099s exit() function); if it is None , the exit status is zero; if\nit has another type (such as a string), the object\u00e2\u0080\u0099s value is printed and\nthe exit status is one.\n\nA call to sys.exit() is translated into an exception so that clean-up\nhandlers ( finally clauses of try statements) can be\nexecuted, and so that a debugger can execute a script without running the risk\nof losing control.  The os._exit() function can be used if it is\nabsolutely positively necessary to exit immediately (for example, in the child\nprocess after a call to os.fork() ).\n\ncode\n\u00c2\u00b6\nThe exit status or error message that is passed to the constructor.\n(Defaults to None .)\n\nexception\nTypeError\n\u00c2\u00b6\nRaised when an operation or function is applied to an object of inappropriate\ntype.  The associated value is a string giving details about the type mismatch.\n\nThis exception may be raised by user code to indicate that an attempted\noperation on an object is not supported, and is not meant to be. If an object\nis meant to support a given operation but has not yet provided an\nimplementation, NotImplementedError is the proper exception to raise.\n\nPassing arguments of the wrong type (e.g. passing a list when an int is expected) should result in a TypeError , but passing\narguments with the wrong value (e.g. a number outside expected boundaries)\nshould result in a ValueError .\n\nexception\nUnboundLocalError\n\u00c2\u00b6\nRaised when a reference is made to a local variable in a function or method, but\nno value has been bound to that variable.  This is a subclass of NameError .\n\nexception\nUnicodeError\n\u00c2\u00b6\nRaised when a Unicode-related encoding or decoding error occurs.  It is a\nsubclass of ValueError .\n\nUnicodeError has attributes that describe the encoding or decoding\nerror.  For example, err.object[err.start:err.end] gives the particular\ninvalid input that the codec failed on.\n\nencoding\n\u00c2\u00b6\nThe name of the encoding that raised the error.\n\nreason\n\u00c2\u00b6\nA string describing the specific codec error.\n\nobject\n\u00c2\u00b6\nThe object the codec was attempting to encode or decode.\n\nstart\n\u00c2\u00b6\nThe first index of invalid data in object .\n\nThis value should not be negative as it is interpreted as an\nabsolute offset but this constraint is not enforced at runtime.\n\nend\n\u00c2\u00b6\nThe index after the last invalid data in object .\n\nThis value should not be negative as it is interpreted as an\nabsolute offset but this constraint is not enforced at runtime.\n\nexception\nUnicodeEncodeError\n\u00c2\u00b6\nRaised when a Unicode-related error occurs during encoding.  It is a subclass of UnicodeError .\n\nexception\nUnicodeDecodeError\n\u00c2\u00b6\nRaised when a Unicode-related error occurs during decoding.  It is a subclass of UnicodeError .\n\nexception\nUnicodeTranslateError\n\u00c2\u00b6\nRaised when a Unicode-related error occurs during translating.  It is a subclass\nof UnicodeError .\n\nexception\nValueError\n\u00c2\u00b6\nRaised when an operation or function receives an argument that has the\nright type but an inappropriate value, and the situation is not described by a\nmore precise exception such as IndexError .\n\nexception\nZeroDivisionError\n\u00c2\u00b6\nRaised when the second argument of a division or modulo operation is zero.  The\nassociated value is a string indicating the type of the operands and the\noperation.\n\nThe following exceptions are kept for compatibility with previous versions;\nstarting from Python 3.3, they are aliases of OSError .\n\nexception\nEnvironmentError\n\u00c2\u00b6\nexception\nIOError\n\u00c2\u00b6\nexception\nWindowsError\n\u00c2\u00b6\nOnly available on Windows.\n\n### OS exceptions\u00c2\u00b6\n\nThe following exceptions are subclasses of OSError , they get raised\ndepending on the system error code.\n\nexception\nBlockingIOError\n\u00c2\u00b6\nRaised when an operation would block on an object (e.g. socket) set\nfor non-blocking operation.\nCorresponds to errno EAGAIN , EALREADY , EWOULDBLOCK and EINPROGRESS .\n\nIn addition to those of OSError , BlockingIOError can have\none more attribute:\n\ncharacters_written\n\u00c2\u00b6\nAn integer containing the number of bytes written to the stream\nbefore it blocked. This attribute is available when using the\nbuffered I/O classes from the io module.\n\nexception\nChildProcessError\n\u00c2\u00b6\nRaised when an operation on a child process failed.\nCorresponds to errno ECHILD .\n\nexception\nConnectionError\n\u00c2\u00b6\nA base class for connection-related issues.\n\nSubclasses are BrokenPipeError , ConnectionAbortedError , ConnectionRefusedError and ConnectionResetError .\n\nexception\nBrokenPipeError\n\u00c2\u00b6\nA subclass of ConnectionError , raised when trying to write on a\npipe while the other end has been closed, or trying to write on a socket\nwhich has been shutdown for writing.\nCorresponds to errno EPIPE and ESHUTDOWN .\n\nexception\nConnectionAbortedError\n\u00c2\u00b6\nA subclass of ConnectionError , raised when a connection attempt\nis aborted by the peer.\nCorresponds to errno ECONNABORTED .\n\nexception\nConnectionRefusedError\n\u00c2\u00b6\nA subclass of ConnectionError , raised when a connection attempt\nis refused by the peer.\nCorresponds to errno ECONNREFUSED .\n\nexception\nConnectionResetError\n\u00c2\u00b6\nA subclass of ConnectionError , raised when a connection is\nreset by the peer.\nCorresponds to errno ECONNRESET .\n\nexception\nFileExistsError\n\u00c2\u00b6\nRaised when trying to create a file or directory which already exists.\nCorresponds to errno EEXIST .\n\nexception\nFileNotFoundError\n\u00c2\u00b6\nRaised when a file or directory is requested but doesn\u00e2\u0080\u0099t exist.\nCorresponds to errno ENOENT .\n\nexception\nInterruptedError\n\u00c2\u00b6\nRaised when a system call is interrupted by an incoming signal.\nCorresponds to errno EINTR .\n\nChanged in version 3.5: Python now retries system calls when a syscall is interrupted by a\nsignal, except if the signal handler raises an exception (see PEP 475 for the rationale), instead of raising InterruptedError .\n\nexception\nIsADirectoryError\n\u00c2\u00b6\nRaised when a file operation (such as os.remove() ) is requested\non a directory.\nCorresponds to errno EISDIR .\n\nexception\nNotADirectoryError\n\u00c2\u00b6\nRaised when a directory operation (such as os.listdir() ) is requested on\nsomething which is not a directory.  On most POSIX platforms, it may also be\nraised if an operation attempts to open or traverse a non-directory file as if\nit were a directory.\nCorresponds to errno ENOTDIR .\n\nexception\nPermissionError\n\u00c2\u00b6\nRaised when trying to run an operation without the adequate access\nrights - for example filesystem permissions.\nCorresponds to errno EACCES , EPERM , and ENOTCAPABLE .\n\nChanged in version 3.11.1: WASI\u00e2\u0080\u0099s ENOTCAPABLE is now mapped to PermissionError .\n\nexception\nProcessLookupError\n\u00c2\u00b6\nRaised when a given process doesn\u00e2\u0080\u0099t exist.\nCorresponds to errno ESRCH .\n\nexception\nTimeoutError\n\u00c2\u00b6\nRaised when a system function timed out at the system level.\nCorresponds to errno ETIMEDOUT .\n\nAdded in version 3.3: All the above OSError subclasses were added.\n\nSee also\n\nPEP 3151 - Reworking the OS and IO exception hierarchy\n\n## Warnings\u00c2\u00b6\n\nThe following exceptions are used as warning categories; see the Warning Categories documentation for more details.\n\nexception\nWarning\n\u00c2\u00b6\nBase class for warning categories.\n\nexception\nUserWarning\n\u00c2\u00b6\nBase class for warnings generated by user code.\n\nexception\nDeprecationWarning\n\u00c2\u00b6\nBase class for warnings about deprecated features when those warnings are\nintended for other Python developers.\n\nIgnored by the default warning filters, except in the __main__ module\n( PEP 565 ). Enabling the Python Development Mode shows\nthis warning.\n\nThe deprecation policy is described in PEP 387 .\n\nexception\nPendingDeprecationWarning\n\u00c2\u00b6\nBase class for warnings about features which are obsolete and\nexpected to be deprecated in the future, but are not deprecated\nat the moment.\n\nThis class is rarely used as emitting a warning about a possible\nupcoming deprecation is unusual, and DeprecationWarning is preferred for already active deprecations.\n\nIgnored by the default warning filters. Enabling the Python\nDevelopment Mode shows this warning.\n\nThe deprecation policy is described in PEP 387 .\n\nexception\nSyntaxWarning\n\u00c2\u00b6\nBase class for warnings about dubious syntax.\n\nThis warning is typically emitted when compiling Python source code, and usually won\u00e2\u0080\u0099t be reported\nwhen running already compiled code.\n\nexception\nRuntimeWarning\n\u00c2\u00b6\nBase class for warnings about dubious runtime behavior.\n\nexception\nFutureWarning\n\u00c2\u00b6\nBase class for warnings about deprecated features when those warnings are\nintended for end users of applications that are written in Python.\n\nexception\nImportWarning\n\u00c2\u00b6\nBase class for warnings about probable mistakes in module imports.\n\nIgnored by the default warning filters. Enabling the Python\nDevelopment Mode shows this warning.\n\nexception\nUnicodeWarning\n\u00c2\u00b6\nBase class for warnings related to Unicode.\n\nexception\nEncodingWarning\n\u00c2\u00b6\nBase class for warnings related to encodings.\n\nSee Opt-in EncodingWarning for details.\n\nAdded in version 3.10.\n\nexception\nBytesWarning\n\u00c2\u00b6\nBase class for warnings related to bytes and bytearray .\n\nexception\nResourceWarning\n\u00c2\u00b6\nBase class for warnings related to resource usage.\n\nIgnored by the default warning filters. Enabling the Python\nDevelopment Mode shows this warning.\n\nAdded in version 3.2.\n\n## Exception groups\u00c2\u00b6\n\nThe following are used when it is necessary to raise multiple unrelated\nexceptions. They are part of the exception hierarchy so they can be\nhandled with except like all other exceptions. In addition,\nthey are recognised by except* , which matches\ntheir subgroups based on the types of the contained exceptions.\n\nexception\nExceptionGroup\n(\nmsg\n,\nexcs\n)\n\u00c2\u00b6\nexception\nBaseExceptionGroup\n(\nmsg\n,\nexcs\n)\n\u00c2\u00b6\nBoth of these exception types wrap the exceptions in the sequence excs .\nThe msg parameter must be a string. The difference between the two\nclasses is that BaseExceptionGroup extends BaseException and\nit can wrap any exception, while ExceptionGroup extends Exception and it can only wrap subclasses of Exception . This design is so that except Exception catches an ExceptionGroup but not BaseExceptionGroup .\n\nThe BaseExceptionGroup constructor returns an ExceptionGroup rather than a BaseExceptionGroup if all contained exceptions are Exception instances, so it can be used to make the selection\nautomatic. The ExceptionGroup constructor, on the other hand,\nraises a TypeError if any contained exception is not an Exception subclass.\n\nmessage\n\u00c2\u00b6\nThe msg argument to the constructor. This is a read-only attribute.\n\nexceptions\n\u00c2\u00b6\nA tuple of the exceptions in the excs sequence given to the\nconstructor. This is a read-only attribute.\n\nsubgroup\n(\ncondition\n)\n\u00c2\u00b6\nReturns an exception group that contains only the exceptions from the\ncurrent group that match condition , or None if the result is empty.\n\nThe condition can be an exception type or tuple of exception types, in which\ncase each exception is checked for a match using the same check that is used\nin an except clause.  The condition can also be a callable (other than\na type object) that accepts an exception as its single argument and returns\ntrue for the exceptions that should be in the subgroup.\n\nThe nesting structure of the current exception is preserved in the result,\nas are the values of its message , __traceback__ , __cause__ , __context__ and __notes__ fields.\nEmpty nested groups are omitted from the result.\n\nThe condition is checked for all exceptions in the nested exception group,\nincluding the top-level and any nested exception groups. If the condition is\ntrue for such an exception group, it is included in the result in full.\n\nAdded in version 3.13: condition can be any callable which is not a type object.\n\nsplit\n(\ncondition\n)\n\u00c2\u00b6\nLike subgroup() , but returns the pair (match, rest) where match is subgroup(condition) and rest is the remaining non-matching\npart.\n\nderive\n(\nexcs\n)\n\u00c2\u00b6\nReturns an exception group with the same message , but which\nwraps the exceptions in excs .\n\nThis method is used by subgroup() and split() , which\nare used in various contexts to break up an exception group. A\nsubclass needs to override it in order to make subgroup() and split() return instances of the subclass rather\nthan ExceptionGroup .\n\nsubgroup() and split() copy the __traceback__ , __cause__ , __context__ and __notes__ fields from\nthe original exception group to the one returned by derive() , so\nthese fields do not need to be updated by derive() .\n\n```python\n>>> class MyGroup(ExceptionGroup):\n...     def derive(self, excs):\n...         return MyGroup(self.message, excs)\n...\n>>> e = MyGroup(\"eg\", [ValueError(1), TypeError(2)])\n>>> e.add_note(\"a note\")\n>>> e.__context__ = Exception(\"context\")\n>>> e.__cause__ = Exception(\"cause\")\n>>> try:\n...    raise e\n... except Exception as e:\n...    exc = e\n...\n>>> match, rest = exc.split(ValueError)\n>>> exc, exc.__context__, exc.__cause__, exc.__notes__\n(MyGroup('eg', [ValueError(1), TypeError(2)]), Exception('context'), Exception('cause'), ['a note'])\n>>> match, match.__context__, match.__cause__, match.__notes__\n(MyGroup('eg', [ValueError(1)]), Exception('context'), Exception('cause'), ['a note'])\n>>> rest, rest.__context__, rest.__cause__, rest.__notes__\n(MyGroup('eg', [TypeError(2)]), Exception('context'), Exception('cause'), ['a note'])\n>>> exc.__traceback__ is match.__traceback__ is rest.__traceback__\nTrue\n```python\n\nNote that BaseExceptionGroup defines __new__() , so\nsubclasses that need a different constructor signature need to\noverride that rather than __init__() . For example, the following\ndefines an exception group subclass which accepts an exit_code and\nconstructs the group\u00e2\u0080\u0099s message from it.\n\n```python\nclass Errors(ExceptionGroup):\n   def __new__(cls, errors, exit_code):\n      self = super().__new__(Errors, f\"exit code: {exit_code}\", errors)\n      self.exit_code = exit_code\n      return self\n\n   def derive(self, excs):\n      return Errors(excs, self.exit_code)\n```python\n\nLike ExceptionGroup , any subclass of BaseExceptionGroup which\nis also a subclass of Exception can only wrap instances of Exception .\n\nAdded in version 3.11.\n\n## Exception hierarchy\u00c2\u00b6\n\nThe class hierarchy for built-in exceptions is:\n\n```python\nBaseException\n \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 BaseExceptionGroup\n \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 GeneratorExit\n \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 KeyboardInterrupt\n \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 SystemExit\n \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 Exception\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 ArithmeticError\n      \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 FloatingPointError\n      \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 OverflowError\n      \u00e2\u0094\u0082    \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 ZeroDivisionError\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 AssertionError\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 AttributeError\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 BufferError\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 EOFError\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 ExceptionGroup [BaseExceptionGroup]\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 ImportError\n      \u00e2\u0094\u0082    \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 ModuleNotFoundError\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 LookupError\n      \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 IndexError\n      \u00e2\u0094\u0082    \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 KeyError\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 MemoryError\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 NameError\n      \u00e2\u0094\u0082    \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 UnboundLocalError\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 OSError\n      \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 BlockingIOError\n      \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 ChildProcessError\n      \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 ConnectionError\n      \u00e2\u0094\u0082    \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 BrokenPipeError\n      \u00e2\u0094\u0082    \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 ConnectionAbortedError\n      \u00e2\u0094\u0082    \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 ConnectionRefusedError\n      \u00e2\u0094\u0082    \u00e2\u0094\u0082    \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 ConnectionResetError\n      \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 FileExistsError\n      \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 FileNotFoundError\n      \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 InterruptedError\n      \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 IsADirectoryError\n      \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 NotADirectoryError\n      \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 PermissionError\n      \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 ProcessLookupError\n      \u00e2\u0094\u0082    \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 TimeoutError\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 ReferenceError\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 RuntimeError\n      \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 NotImplementedError\n      \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 PythonFinalizationError\n      \u00e2\u0094\u0082    \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 RecursionError\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 StopAsyncIteration\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 StopIteration\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 SyntaxError\n      \u00e2\u0094\u0082    \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 IndentationError\n      \u00e2\u0094\u0082         \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 TabError\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 SystemError\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 TypeError\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 ValueError\n      \u00e2\u0094\u0082    \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 UnicodeError\n      \u00e2\u0094\u0082         \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 UnicodeDecodeError\n      \u00e2\u0094\u0082         \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 UnicodeEncodeError\n      \u00e2\u0094\u0082         \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 UnicodeTranslateError\n      \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 Warning\n           \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 BytesWarning\n           \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 DeprecationWarning\n           \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 EncodingWarning\n           \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 FutureWarning\n           \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 ImportWarning\n           \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 PendingDeprecationWarning\n           \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 ResourceWarning\n           \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 RuntimeWarning\n           \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 SyntaxWarning\n           \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 UnicodeWarning\n           \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 UserWarning\n```",
      "difficulty": "intro",
      "doc_id": "doc-built-in-exceptions-2d19674db7",
      "provenance": {
        "author": "",
        "date": "",
        "license": "PSF Documentation License",
        "source_file": "data/corpus_raw/3_library_exceptions_html_ad80a0.json",
        "url": "https://docs.python.org/3/library/exceptions.html"
      },
      "title": "Built-in Exceptions\u00c2\u00b6",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "built_in_functions",
        "lists",
        "sorting",
        "strings"
      ],
      "content": "# Built-in Functions\u00c2\u00b6\n\nThe Python interpreter has a number of functions and types built into it that\nare always available.  They are listed here in alphabetical order.\n\nabs\n(\nnumber\n,\n/\n)\n\u00c2\u00b6\nReturn the absolute value of a number.  The argument may be an\ninteger, a floating-point number, or an object implementing __abs__() .\nIf the argument is a complex number, its magnitude is returned.\n\naiter\n(\nasync_iterable\n,\n/\n)\n\u00c2\u00b6\nReturn an asynchronous iterator for an asynchronous iterable .\nEquivalent to calling x.__aiter__() .\n\nNote: Unlike iter() , aiter() has no 2-argument variant.\n\nAdded in version 3.10.\n\nall\n(\niterable\n,\n/\n)\n\u00c2\u00b6\nReturn True if all elements of the iterable are true (or if the iterable\nis empty).  Equivalent to:\n\n```python\ndef all(iterable):\n    for element in iterable:\n        if not element:\n            return False\n    return True\n```python\n\nawaitable\nanext\n(\nasync_iterator\n,\n/\n)\n\u00c2\u00b6\nawaitable\nanext\n(\nasync_iterator\n,\ndefault\n,\n/\n)\nWhen awaited, return the next item from the given asynchronous\niterator , or default if given and the iterator is exhausted.\n\nThis is the async variant of the next() builtin, and behaves\nsimilarly.\n\nThis calls the __anext__() method of async_iterator ,\nreturning an awaitable . Awaiting this returns the next value of the\niterator. If default is given, it is returned if the iterator is exhausted,\notherwise StopAsyncIteration is raised.\n\nAdded in version 3.10.\n\nany\n(\niterable\n,\n/\n)\n\u00c2\u00b6\nReturn True if any element of the iterable is true.  If the iterable\nis empty, return False .  Equivalent to:\n\n```python\ndef any(iterable):\n    for element in iterable:\n        if element:\n            return True\n    return False\n```python\n\nascii\n(\nobject\n,\n/\n)\n\u00c2\u00b6\nAs repr() , return a string containing a printable representation of an\nobject, but escape the non-ASCII characters in the string returned by repr() using \\x , \\u , or \\U escapes.  This generates a string\nsimilar to that returned by repr() in Python 2.\n\nbin\n(\ninteger\n,\n/\n)\n\u00c2\u00b6\nConvert an integer number to a binary string prefixed with \u00e2\u0080\u009c0b\u00e2\u0080\u009d. The result\nis a valid Python expression. If integer is not a Python int object, it\nhas to define an __index__() method that returns an integer. Some\nexamples:\n\n```python\n>>> bin(3)\n'0b11'\n>>> bin(-10)\n'-0b1010'\n```python\n\nIf the prefix \u00e2\u0080\u009c0b\u00e2\u0080\u009d is desired or not, you can use either of the following ways.\n\n```python\n>>> format(14, '#b'), format(14, 'b')\n('0b1110', '1110')\n>>> f'{14:#b}', f'{14:b}'\n('0b1110', '1110')\n```python\n\nSee also enum.bin() to represent negative values as twos-complement.\n\nSee also format() for more information.\n\nclass\nbool\n(\nobject\n=\nFalse\n,\n/\n)\n\u00c2\u00b6\nReturn a Boolean value, i.e. one of True or False .  The argument\nis converted using the standard truth testing procedure .\nIf the argument is false\nor omitted, this returns False ; otherwise, it returns True .  The bool class is a subclass of int (see Numeric Types \u00e2\u0080\u0094 int, float, complex ).\nIt cannot be subclassed further.  Its only instances are False and True (see Boolean Type - bool ).\n\nChanged in version 3.7: The parameter is now positional-only.\n\nbreakpoint\n(\n*\nargs\n,\n**\nkws\n)\n\u00c2\u00b6\nThis function drops you into the debugger at the call site.  Specifically,\nit calls sys.breakpointhook() , passing args and kws straight\nthrough.  By default, sys.breakpointhook() calls pdb.set_trace() expecting no arguments.  In this case, it is\npurely a convenience function so you don\u00e2\u0080\u0099t have to explicitly import pdb or type as much code to enter the debugger.  However, sys.breakpointhook() can be set to some other function and breakpoint() will automatically call that, allowing you to drop into\nthe debugger of choice.\nIf sys.breakpointhook() is not accessible, this function will\nraise RuntimeError .\n\nBy default, the behavior of breakpoint() can be changed with\nthe PYTHONBREAKPOINT environment variable.\nSee sys.breakpointhook() for usage details.\n\nNote that this is not guaranteed if sys.breakpointhook() has been replaced.\n\nRaises an auditing event builtins.breakpoint with argument breakpointhook .\n\nAdded in version 3.7.\n\nclass\nbytearray\n(\nsource\n=\nb''\n)\nclass\nbytearray\n(\nsource\n,\nencoding\n,\nerrors\n=\n'strict'\n)\nReturn a new array of bytes.  The bytearray class is a mutable\nsequence of integers in the range 0 <= x < 256.  It has most of the usual\nmethods of mutable sequences, described in Mutable Sequence Types , as well\nas most methods that the bytes type has, see Bytes and Bytearray Operations .\n\nThe optional source parameter can be used to initialize the array in a few\ndifferent ways:\n\n- If it is a string , you must also give the encoding (and optionally, errors ) parameters; bytearray() then converts the string to\nbytes using str.encode() .\n- If it is an integer , the array will have that size and will be\ninitialized with null bytes.\n- If it is an object conforming to the buffer interface ,\na read-only buffer of the object will be used to initialize the bytes array.\n- If it is an iterable , it must be an iterable of integers in the range 0 <= x < 256 , which are used as the initial contents of the array.\n\nWithout an argument, an array of size 0 is created.\n\nSee also Binary Sequence Types \u00e2\u0080\u0094 bytes, bytearray, memoryview and Bytearray Objects .\n\nclass\nbytes\n(\nsource\n=\nb''\n)\nclass\nbytes\n(\nsource\n,\nencoding\n,\nerrors\n=\n'strict'\n)\nReturn a new \u00e2\u0080\u009cbytes\u00e2\u0080\u009d object which is an immutable sequence of integers in\nthe range 0 <= x < 256 . bytes is an immutable version of bytearray \u00e2\u0080\u0093 it has the same non-mutating methods and the same\nindexing and slicing behavior.\n\nAccordingly, constructor arguments are interpreted as for bytearray() .\n\nBytes objects can also be created with literals, see String and Bytes literals .\n\nSee also Binary Sequence Types \u00e2\u0080\u0094 bytes, bytearray, memoryview , Bytes Objects , and Bytes and Bytearray Operations .\n\ncallable\n(\nobject\n,\n/\n)\n\u00c2\u00b6\nReturn True if the object argument appears callable, False if not.  If this returns True , it is still possible that a\ncall fails, but if it is False , calling object will never succeed.\nNote that classes are callable (calling a class returns a new instance);\ninstances are callable if their class has a __call__() method.\n\nAdded in version 3.2: This function was first removed in Python 3.0 and then brought back\nin Python 3.2.\n\nchr\n(\ncodepoint\n,\n/\n)\n\u00c2\u00b6\nReturn the string representing a character with the specified Unicode code point.\nFor example, chr(97) returns the string 'a' , while chr(8364) returns the string '\u00e2\u0082\u00ac' . This is the inverse of ord() .\n\nThe valid range for the argument is from 0 through 1,114,111 (0x10FFFF in\nbase 16). ValueError will be raised if it is outside that range.\n\n@\nclassmethod\n\u00c2\u00b6\nTransform a method into a class method.\n\nA class method receives the class as an implicit first argument, just like an\ninstance method receives the instance. To declare a class method, use this\nidiom:\n\n```python\nclass C:\n    @classmethod\n    def f(cls, arg1, arg2): ...\n```python\n\nThe @classmethod form is a function decorator \u00e2\u0080\u0093 see Function definitions for details.\n\nA class method can be called either on the class (such as C.f() ) or on an instance (such\nas C().f() ).  The instance is ignored except for its class. If a class\nmethod is called for a derived class, the derived class object is passed as the\nimplied first argument.\n\nClass methods are different than C++ or Java static methods. If you want those,\nsee staticmethod() in this section.\nFor more information on class methods, see The standard type hierarchy .\n\nChanged in version 3.9: Class methods can now wrap other descriptors such as property() .\n\nChanged in version 3.10: Class methods now inherit the method attributes\n( __module__ , __name__ , __qualname__ , __doc__ and __annotations__ ) and have a new __wrapped__ attribute.\n\nDeprecated since version 3.11, removed in version 3.13: Class methods can no longer wrap other descriptors such as property() .\n\ncompile\n(\nsource\n,\nfilename\n,\nmode\n,\nflags\n=\n0\n,\ndont_inherit\n=\nFalse\n,\noptimize\n=\n-1\n)\n\u00c2\u00b6\nCompile the source into a code or AST object.  Code objects can be executed\nby exec() or eval() . source can either be a normal string, a\nbyte string, or an AST object.  Refer to the ast module documentation\nfor information on how to work with AST objects.\n\nThe filename argument should give the file from which the code was read;\npass some recognizable value if it wasn\u00e2\u0080\u0099t read from a file ( '<string>' is\ncommonly used).\n\nThe mode argument specifies what kind of code must be compiled; it can be 'exec' if source consists of a sequence of statements, 'eval' if it\nconsists of a single expression, or 'single' if it consists of a single\ninteractive statement (in the latter case, expression statements that\nevaluate to something other than None will be printed).\n\nThe optional arguments flags and dont_inherit control which compiler options should be activated\nand which future features should be allowed. If neither\nis present (or both are zero) the code is compiled with the same flags that\naffect the code that is calling compile() . If the flags argument is given and dont_inherit is not (or is zero) then the compiler\noptions and the future statements specified by the flags argument are used\nin addition to those that would be used anyway. If dont_inherit is a\nnon-zero integer then the flags argument is it \u00e2\u0080\u0093 the flags (future\nfeatures and compiler options) in the surrounding code are ignored.\n\nCompiler options and future statements are specified by bits which can be\nbitwise ORed together to specify multiple options. The bitfield required to\nspecify a given future feature can be found as the compiler_flag attribute on the _Feature instance in the __future__ module. Compiler flags can be found in ast module, with PyCF_ prefix.\n\nThe argument optimize specifies the optimization level of the compiler; the\ndefault value of -1 selects the optimization level of the interpreter as\ngiven by -O options.  Explicit levels are 0 (no optimization; __debug__ is true), 1 (asserts are removed, __debug__ is false)\nor 2 (docstrings are removed too).\n\nThis function raises SyntaxError or ValueError if the compiled\nsource is invalid.\n\nIf you want to parse Python code into its AST representation, see ast.parse() .\n\nRaises an auditing event compile with arguments source and filename . This event may also be raised by implicit\ncompilation.\n\nNote\n\nWhen compiling a string with multi-line code in 'single' or 'eval' mode, input must be terminated by at least one newline\ncharacter.  This is to facilitate detection of incomplete and complete\nstatements in the code module.\n\nWarning\n\nIt is possible to crash the Python interpreter with a\nsufficiently large/complex string when compiling to an AST\nobject due to stack depth limitations in Python\u00e2\u0080\u0099s AST compiler.\n\nChanged in version 3.2: Allowed use of Windows and Mac newlines.  Also, input in 'exec' mode\ndoes not have to end in a newline anymore.  Added the optimize parameter.\n\nChanged in version 3.5: Previously, TypeError was raised when null bytes were encountered\nin source .\n\nAdded in version 3.8: ast.PyCF_ALLOW_TOP_LEVEL_AWAIT can now be passed in flags to enable\nsupport for top-level await , async for , and async with .\n\nclass\ncomplex\n(\nnumber\n=\n0\n,\n/\n)\n\u00c2\u00b6\nclass\ncomplex\n(\nstring\n,\n/\n)\nclass\ncomplex\n(\nreal\n=\n0\n,\nimag\n=\n0\n)\nConvert a single string or number to a complex number, or create a\ncomplex number from real and imaginary parts.\n\nExamples:\n\n```python\n>>> complex('+1.23')\n(1.23+0j)\n>>> complex('-4.5j')\n-4.5j\n>>> complex('-1.23+4.5j')\n(-1.23+4.5j)\n>>> complex('\\t( -1.23+4.5J )\\n')\n(-1.23+4.5j)\n>>> complex('-Infinity+NaNj')\n(-inf+nanj)\n>>> complex(1.23)\n(1.23+0j)\n>>> complex(imag=-4.5)\n-4.5j\n>>> complex(-1.23, 4.5)\n(-1.23+4.5j)\n```python\n\nIf the argument is a string, it must contain either a real part (in the\nsame format as for float() ) or an imaginary part (in the same\nformat but with a 'j' or 'J' suffix), or both real and imaginary\nparts (the sign of the imaginary part is mandatory in this case).\nThe string can optionally be surrounded by whitespaces and the round\nparentheses '(' and ')' , which are ignored.\nThe string must not contain whitespace between '+' , '-' , the 'j' or 'J' suffix, and the decimal number.\nFor example, complex('1+2j') is fine, but complex('1 + 2j') raises ValueError .\nMore precisely, the input must conform to the complexvalue production rule in the following grammar, after parentheses and leading and\ntrailing whitespace characters are removed:\n\n```python\n\ncomplexvalue: floatvalue |\n              floatvalue (\"j\" | \"J\") |\n              floatvalue sign absfloatvalue (\"j\" | \"J\")\n```python\n\nIf the argument is a number, the constructor serves as a numeric\nconversion like int and float .\nFor a general Python object x , complex(x) delegates to x.__complex__() .\nIf __complex__() is not defined then it falls back\nto __float__() .\nIf __float__() is not defined then it falls back\nto __index__() .\n\nIf two arguments are provided or keyword arguments are used, each argument\nmay be any numeric type (including complex).\nIf both arguments are real numbers, return a complex number with the real\ncomponent real and the imaginary component imag .\nIf both arguments are complex numbers, return a complex number with the real\ncomponent real.real-imag.imag and the imaginary component real.imag+imag.real .\nIf one of arguments is a real number, only its real component is used in\nthe above expressions.\n\nSee also complex.from_number() which only accepts a single numeric argument.\n\nIf all arguments are omitted, returns 0j .\n\nThe complex type is described in Numeric Types \u00e2\u0080\u0094 int, float, complex .\n\nChanged in version 3.6: Grouping digits with underscores as in code literals is allowed.\n\nChanged in version 3.8: Falls back to __index__() if __complex__() and __float__() are not defined.\n\nDeprecated since version 3.14: Passing a complex number as the real or imag argument is now\ndeprecated; it should only be passed as a single positional argument.\n\ndelattr\n(\nobject\n,\nname\n,\n/\n)\n\u00c2\u00b6\nThis is a relative of setattr() .  The arguments are an object and a\nstring.  The string must be the name of one of the object\u00e2\u0080\u0099s attributes.  The\nfunction deletes the named attribute, provided the object allows it.  For\nexample, delattr(x, 'foobar') is equivalent to del x.foobar . name need not be a Python identifier (see setattr() ).\n\nclass\ndict\n(\n**\nkwargs\n)\nclass\ndict\n(\nmapping\n,\n/\n,\n**\nkwargs\n)\nclass\ndict\n(\niterable\n,\n/\n,\n**\nkwargs\n)\nCreate a new dictionary.  The dict object is the dictionary class.\nSee dict and Mapping Types \u00e2\u0080\u0094 dict for documentation about this class.\n\nFor other containers see the built-in list , set , and tuple classes, as well as the collections module.\n\ndir\n(\n)\n\u00c2\u00b6\ndir\n(\nobject\n,\n/\n)\nWithout arguments, return the list of names in the current local scope.  With an\nargument, attempt to return a list of valid attributes for that object.\n\nIf the object has a method named __dir__() ,\nthis method will be called and\nmust return the list of attributes. This allows objects that implement a custom __getattr__() or __getattribute__() function\nto customize the way dir() reports their attributes.\n\nIf the object does not provide __dir__() ,\nthe function tries its best to gather information from the object\u00e2\u0080\u0099s __dict__ attribute, if defined, and\nfrom its type object.  The resulting list is not necessarily complete and may\nbe inaccurate when the object has a custom __getattr__() .\n\nThe default dir() mechanism behaves differently with different types of\nobjects, as it attempts to produce the most relevant, rather than complete,\ninformation:\n\n- If the object is a module object, the list contains the names of the module\u00e2\u0080\u0099s\nattributes.\n- If the object is a type or class object, the list contains the names of its\nattributes, and recursively of the attributes of its bases.\n- Otherwise, the list contains the object\u00e2\u0080\u0099s attributes\u00e2\u0080\u0099 names, the names of its\nclass\u00e2\u0080\u0099s attributes, and recursively of the attributes of its class\u00e2\u0080\u0099s base\nclasses.\n\nThe resulting list is sorted alphabetically.  For example:\n\n```python\n>>> import struct\n>>> dir()   # show the names in the module namespace\n['__builtins__', '__name__', 'struct']\n>>> dir(struct)   # show the names in the struct module\n['Struct', '__all__', '__builtins__', '__cached__', '__doc__', '__file__',\n '__initializing__', '__loader__', '__name__', '__package__',\n '_clearcache', 'calcsize', 'error', 'pack', 'pack_into',\n 'unpack', 'unpack_from']\n>>> class Shape:\n...     def __dir__(self):\n...         return ['area', 'perimeter', 'location']\n...\n>>> s = Shape()\n>>> dir(s)\n['area', 'location', 'perimeter']\n```python\n\nNote\n\nBecause dir() is supplied primarily as a convenience for use at an\ninteractive prompt, it tries to supply an interesting set of names more\nthan it tries to supply a rigorously or consistently defined set of names,\nand its detailed behavior may change across releases.  For example,\nmetaclass attributes are not in the result list when the argument is a\nclass.\n\ndivmod\n(\na\n,\nb\n,\n/\n)\n\u00c2\u00b6\nTake two (non-complex) numbers as arguments and return a pair of numbers\nconsisting of their quotient and remainder when using integer division.  With\nmixed operand types, the rules for binary arithmetic operators apply.  For\nintegers, the result is the same as (a // b, a % b) . For floating-point\nnumbers the result is (q, a % b) , where q is usually math.floor(a / b) but may be 1 less than that.  In any case q * b + a % b is very\nclose to a , if a % b is non-zero it has the same sign as b , and 0 <= abs(a % b) < abs(b) .\n\nenumerate\n(\niterable\n,\nstart\n=\n0\n)\n\u00c2\u00b6\nReturn an enumerate object. iterable must be a sequence, an iterator , or some other object which supports iteration.\nThe __next__() method of the iterator returned by enumerate() returns a tuple containing a count (from start which\ndefaults to 0) and the values obtained from iterating over iterable .\n\n```python\n>>> seasons = ['Spring', 'Summer', 'Fall', 'Winter']\n>>> list(enumerate(seasons))\n[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]\n>>> list(enumerate(seasons, start=1))\n[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]\n```python\n\nEquivalent to:\n\n```python\ndef enumerate(iterable, start=0):\n    n = start\n    for elem in iterable:\n        yield n, elem\n        n += 1\n```python\n\neval\n(\nsource\n,\n/\n,\nglobals\n=\nNone\n,\nlocals\n=\nNone\n)\n\u00c2\u00b6\nParameters\n:\n- source ( str | code object ) \u00e2\u0080\u0093 A Python expression.\n- globals ( dict | None ) \u00e2\u0080\u0093 The global namespace (default: None ).\n- locals ( mapping | None ) \u00e2\u0080\u0093 The local namespace (default: None ).\n\nReturns\n:\nThe result of the evaluated expression.\n\nRaises\n:\nSyntax errors are reported as exceptions.\n\nWarning\n\nThis function executes arbitrary code. Calling it with\nuser-supplied input may lead to security vulnerabilities.\n\nThe source argument is parsed and evaluated as a Python expression\n(technically speaking, a condition list) using the globals and locals mappings as global and local namespace.  If the globals dictionary is\npresent and does not contain a value for the key __builtins__ , a\nreference to the dictionary of the built-in module builtins is\ninserted under that key before source is parsed.  That way you can\ncontrol what builtins are available to the executed code by inserting your\nown __builtins__ dictionary into globals before passing it to eval() .  If the locals mapping is omitted it defaults to the globals dictionary.  If both mappings are omitted, the source is\nexecuted with the globals and locals in the environment where eval() is called.  Note, eval() will only have access to the nested scopes (non-locals) in the enclosing\nenvironment if they are already referenced in the scope that is calling eval() (e.g. via a nonlocal statement).\n\nExample:\n\n```python\n>>> x = 1\n>>> eval('x+1')\n2\n```python\n\nThis function can also be used to execute arbitrary code objects (such as\nthose created by compile() ).  In this case, pass a code object instead\nof a string.  If the code object has been compiled with 'exec' as the mode argument, eval() 's return value will be None .\n\nHints: dynamic execution of statements is supported by the exec() function.  The globals() and locals() functions\nreturn the current global and local dictionary, respectively, which may be\nuseful to pass around for use by eval() or exec() .\n\nIf the given source is a string, then leading and trailing spaces and tabs\nare stripped.\n\nSee ast.literal_eval() for a function that can safely evaluate strings\nwith expressions containing only literals.\n\nRaises an auditing event exec with the code object\nas the argument. Code compilation events may also be raised.\n\nChanged in version 3.13: The globals and locals arguments can now be passed as keywords.\n\nChanged in version 3.13: The semantics of the default locals namespace have been adjusted as\ndescribed for the locals() builtin.\n\nexec\n(\nsource\n,\n/\n,\nglobals\n=\nNone\n,\nlocals\n=\nNone\n,\n*\n,\nclosure\n=\nNone\n)\n\u00c2\u00b6\nWarning\n\nThis function executes arbitrary code. Calling it with\nuser-supplied input may lead to security vulnerabilities.\n\nThis function supports dynamic execution of Python code. source must be\neither a string or a code object.  If it is a string, the string is parsed as\na suite of Python statements which is then executed (unless a syntax error\noccurs). [ 1 ] If it is a code object, it is simply executed.  In all cases,\nthe code that\u00e2\u0080\u0099s executed is expected to be valid as file input (see the\nsection File input in the Reference Manual). Be aware that the nonlocal , yield ,  and return statements may not be used outside of\nfunction definitions even within the context of code passed to the exec() function. The return value is None .\n\nIn all cases, if the optional parts are omitted, the code is executed in the\ncurrent scope.  If only globals is provided, it must be a dictionary\n(and not a subclass of dictionary), which\nwill be used for both the global and the local variables.  If globals and locals are given, they are used for the global and local variables,\nrespectively.  If provided, locals can be any mapping object.  Remember\nthat at the module level, globals and locals are the same dictionary.\n\nNote\n\nWhen exec gets two separate objects as globals and locals , the\ncode will be executed as if it were embedded in a class definition. This\nmeans functions and classes defined in the executed code will not be able\nto access variables assigned at the top level (as the \u00e2\u0080\u009ctop level\u00e2\u0080\u009d\nvariables are treated as class variables in a class definition).\n\nIf the globals dictionary does not contain a value for the key __builtins__ , a reference to the dictionary of the built-in module builtins is inserted under that key.  That way you can control what\nbuiltins are available to the executed code by inserting your own __builtins__ dictionary into globals before passing it to exec() .\n\nThe closure argument specifies a closure\u00e2\u0080\u0093a tuple of cellvars.\nIt\u00e2\u0080\u0099s only valid when the object is a code object containing free (closure) variables .\nThe length of the tuple must exactly match the length of the code object\u00e2\u0080\u0099s co_freevars attribute.\n\nRaises an auditing event exec with the code object\nas the argument. Code compilation events may also be raised.\n\nNote\n\nThe built-in functions globals() and locals() return the current\nglobal and local namespace, respectively, which may be useful to pass around\nfor use as the second and third argument to exec() .\n\nNote\n\nThe default locals act as described for function locals() below.\nPass an explicit locals dictionary if you need to see effects of the\ncode on locals after function exec() returns.\n\nChanged in version 3.11: Added the closure parameter.\n\nChanged in version 3.13: The globals and locals arguments can now be passed as keywords.\n\nChanged in version 3.13: The semantics of the default locals namespace have been adjusted as\ndescribed for the locals() builtin.\n\nfilter\n(\nfunction\n,\niterable\n,\n/\n)\n\u00c2\u00b6\nConstruct an iterator from those elements of iterable for which function is true. iterable may be either a sequence, a container which\nsupports iteration, or an iterator.  If function is None , the identity\nfunction is assumed, that is, all elements of iterable that are false are\nremoved.\n\nNote that filter(function, iterable) is equivalent to the generator\nexpression (item for item in iterable if function(item)) if function is\nnot None and (item for item in iterable if item) if function is None .\n\nSee itertools.filterfalse() for the complementary function that returns\nelements of iterable for which function is false.\n\nclass\nfloat\n(\nnumber\n=\n0.0\n,\n/\n)\n\u00c2\u00b6\nclass\nfloat\n(\nstring\n,\n/\n)\nReturn a floating-point number constructed from a number or a string.\n\nExamples:\n\n```python\n>>> float('+1.23')\n1.23\n>>> float('   -12345\\n')\n-12345.0\n>>> float('1e-003')\n0.001\n>>> float('+1E6')\n1000000.0\n>>> float('-Infinity')\n-inf\n```python\n\nIf the argument is a string, it should contain a decimal number, optionally\npreceded by a sign, and optionally embedded in whitespace.  The optional\nsign may be '+' or '-' ; a '+' sign has no effect on the value\nproduced.  The argument may also be a string representing a NaN\n(not-a-number), or positive or negative infinity.\nMore precisely, the input must conform to the floatvalue production rule in the following grammar, after leading and trailing\nwhitespace characters are removed:\n\n```python\n\nsign:          \"+\" | \"-\"\ninfinity:      \"Infinity\" | \"inf\"\nnan:           \"nan\"\ndigit:         <a Unicode decimal digit, i.e. characters in Unicode general category Nd>\ndigitpart:     digit ([\"_\"] digit)*\nnumber:        [digitpart] \".\" digitpart | digitpart [\".\"]\nexponent:      (\"e\" | \"E\") [sign] digitpart\nfloatnumber:   number [exponent]\nabsfloatvalue: floatnumber | infinity | nan\nfloatvalue:    [sign] absfloatvalue\n```python\n\nCase is not significant, so, for example, \u00e2\u0080\u009cinf\u00e2\u0080\u009d, \u00e2\u0080\u009cInf\u00e2\u0080\u009d, \u00e2\u0080\u009cINFINITY\u00e2\u0080\u009d, and\n\u00e2\u0080\u009ciNfINity\u00e2\u0080\u009d are all acceptable spellings for positive infinity.\n\nOtherwise, if the argument is an integer or a floating-point number, a\nfloating-point number with the same value (within Python\u00e2\u0080\u0099s floating-point\nprecision) is returned.  If the argument is outside the range of a Python\nfloat, an OverflowError will be raised.\n\nFor a general Python object x , float(x) delegates to x.__float__() .  If __float__() is not defined then it falls back\nto __index__() .\n\nSee also float.from_number() which only accepts a numeric argument.\n\nIf no argument is given, 0.0 is returned.\n\nThe float type is described in Numeric Types \u00e2\u0080\u0094 int, float, complex .\n\nChanged in version 3.6: Grouping digits with underscores as in code literals is allowed.\n\nChanged in version 3.7: The parameter is now positional-only.\n\nChanged in version 3.8: Falls back to __index__() if __float__() is not defined.\n\nformat\n(\nvalue\n,\nformat_spec\n=\n''\n,\n/\n)\n\u00c2\u00b6\nConvert a value to a \u00e2\u0080\u009cformatted\u00e2\u0080\u009d representation, as controlled by format_spec .  The interpretation of format_spec will depend on the type\nof the value argument; however, there is a standard formatting syntax that\nis used by most built-in types: Format Specification Mini-Language .\n\nThe default format_spec is an empty string which usually gives the same\neffect as calling str(value) .\n\nA call to format(value, format_spec) is translated to type(value).__format__(value, format_spec) which bypasses the instance\ndictionary when searching for the value\u00e2\u0080\u0099s __format__() method.\nA TypeError exception is raised if the method search reaches object and the format_spec is non-empty, or if either the format_spec or the return value are not strings.\n\nChanged in version 3.4: object().__format__(format_spec) raises TypeError if format_spec is not an empty string.\n\nclass\nfrozenset\n(\niterable\n=\n()\n,\n/\n)\nReturn a new frozenset object, optionally with elements taken from iterable . frozenset is a built-in class.  See frozenset and Set Types \u00e2\u0080\u0094 set, frozenset for documentation about this class.\n\nFor other containers see the built-in set , list , tuple , and dict classes, as well as the collections module.\n\ngetattr\n(\nobject\n,\nname\n,\n/\n)\n\u00c2\u00b6\ngetattr\n(\nobject\n,\nname\n,\ndefault\n,\n/\n)\nReturn the value of the named attribute of object . name must be a string.\nIf the string is the name of one of the object\u00e2\u0080\u0099s attributes, the result is the\nvalue of that attribute.  For example, getattr(x, 'foobar') is equivalent to x.foobar .  If the named attribute does not exist, default is returned if\nprovided, otherwise AttributeError is raised. name need not be a Python identifier (see setattr() ).\n\nNote\n\nSince private name mangling happens at\ncompilation time, one must manually mangle a private attribute\u00e2\u0080\u0099s\n(attributes with two leading underscores) name in order to retrieve it with getattr() .\n\nglobals\n(\n)\n\u00c2\u00b6\nReturn the dictionary implementing the current module namespace. For code within\nfunctions, this is set when the function is defined and remains the same\nregardless of where the function is called.\n\nhasattr\n(\nobject\n,\nname\n,\n/\n)\n\u00c2\u00b6\nThe arguments are an object and a string.  The result is True if the\nstring is the name of one of the object\u00e2\u0080\u0099s attributes, False if not. (This\nis implemented by calling getattr(object, name) and seeing whether it\nraises an AttributeError or not.)\n\nhash\n(\nobject\n,\n/\n)\n\u00c2\u00b6\nReturn the hash value of the object (if it has one).  Hash values are\nintegers.  They are used to quickly compare dictionary keys during a\ndictionary lookup.  Numeric values that compare equal have the same hash\nvalue (even if they are of different types, as is the case for 1 and 1.0).\n\nNote\n\nFor objects with custom __hash__() methods,\nnote that hash() truncates the return value based on the bit width of the host machine.\n\nhelp\n(\n)\n\u00c2\u00b6\nhelp\n(\nrequest\n)\nInvoke the built-in help system.  (This function is intended for interactive\nuse.)  If no argument is given, the interactive help system starts on the\ninterpreter console.  If the argument is a string, then the string is looked up\nas the name of a module, function, class, method, keyword, or documentation\ntopic, and a help page is printed on the console.  If the argument is any other\nkind of object, a help page on the object is generated.\n\nNote that if a slash(/) appears in the parameter list of a function when\ninvoking help() , it means that the parameters prior to the slash are\npositional-only. For more info, see the FAQ entry on positional-only parameters .\n\nThis function is added to the built-in namespace by the site module.\n\nChanged in version 3.4: Changes to pydoc and inspect mean that the reported\nsignatures for callables are now more comprehensive and consistent.\n\nhex\n(\ninteger\n,\n/\n)\n\u00c2\u00b6\nConvert an integer number to a lowercase hexadecimal string prefixed with\n\u00e2\u0080\u009c0x\u00e2\u0080\u009d. If integer is not a Python int object, it has to define an __index__() method that returns an integer. Some examples:\n\n```python\n>>> hex(255)\n'0xff'\n>>> hex(-42)\n'-0x2a'\n```python\n\nIf you want to convert an integer number to an uppercase or lower hexadecimal\nstring with prefix or not, you can use either of the following ways:\n\n```python\n>>> '%#x' % 255, '%x' % 255, '%X' % 255\n('0xff', 'ff', 'FF')\n>>> format(255, '#x'), format(255, 'x'), format(255, 'X')\n('0xff', 'ff', 'FF')\n>>> f'{255:#x}', f'{255:x}', f'{255:X}'\n('0xff', 'ff', 'FF')\n```python\n\nSee also format() for more information.\n\nSee also int() for converting a hexadecimal string to an\ninteger using a base of 16.\n\nNote\n\nTo obtain a hexadecimal string representation for a float, use the float.hex() method.\n\nid\n(\nobject\n,\n/\n)\n\u00c2\u00b6\nReturn the \u00e2\u0080\u009cidentity\u00e2\u0080\u009d of an object.  This is an integer which\nis guaranteed to be unique and constant for this object during its lifetime.\nTwo objects with non-overlapping lifetimes may have the same id() value.\n\nCPython implementation detail: This is the address of the object in memory.\n\nRaises an auditing event builtins.id with argument id .\n\ninput\n(\n)\n\u00c2\u00b6\ninput\n(\nprompt\n,\n/\n)\nIf the prompt argument is present, it is written to standard output without\na trailing newline.  The function then reads a line from input, converts it\nto a string (stripping a trailing newline), and returns that.  When EOF is\nread, EOFError is raised.  Example:\n\n```python\n>>> s = input('--> ')\n--> Monty Python's Flying Circus\n>>> s\n\"Monty Python's Flying Circus\"\n```python\n\nIf the readline module was loaded, then input() will use it\nto provide elaborate line editing and history features.\n\nRaises an auditing event builtins.input with\nargument prompt before reading input\n\nRaises an auditing event builtins.input/result with the result after successfully reading input.\n\nclass\nint\n(\nnumber\n=\n0\n,\n/\n)\n\u00c2\u00b6\nclass\nint\n(\nstring\n,\n/\n,\nbase\n=\n10\n)\nReturn an integer object constructed from a number or a string, or return 0 if no arguments are given.\n\nExamples:\n\n```python\n>>> int(123.45)\n123\n>>> int('123')\n123\n>>> int('   -12_345\\n')\n-12345\n>>> int('FACE', 16)\n64206\n>>> int('0xface', 0)\n64206\n>>> int('01110011', base=2)\n115\n```python\n\nIf the argument defines __int__() , int(x) returns x.__int__() .  If the argument defines __index__() , it returns x.__index__() .\nFor floating-point numbers, this truncates towards zero.\n\nIf the argument is not a number or if base is given, then it must be a string, bytes , or bytearray instance representing an integer\nin radix base .  Optionally, the string can be preceded by + or - (with no space in between), have leading zeros, be surrounded by whitespace,\nand have single underscores interspersed between digits.\n\nA base-n integer string contains digits, each representing a value from 0 to\nn-1. The values 0\u00e2\u0080\u00939 can be represented by any Unicode decimal digit. The\nvalues 10\u00e2\u0080\u009335 can be represented by a to z (or A to Z ). The\ndefault base is 10. The allowed bases are 0 and 2\u00e2\u0080\u009336. Base-2, -8, and -16\nstrings can be optionally prefixed with 0b / 0B , 0o / 0O , or 0x / 0X , as with integer literals in code.  For base 0, the string is\ninterpreted in a similar way to an integer literal in code ,\nin that the actual base is 2, 8, 10, or 16 as determined by the prefix. Base\n0 also disallows leading zeros: int('010', 0) is not legal, while int('010') and int('010', 8) are.\n\nThe integer type is described in Numeric Types \u00e2\u0080\u0094 int, float, complex .\n\nChanged in version 3.4: If base is not an instance of int and the base object has a base.__index__ method, that method is called\nto obtain an integer for the base.  Previous versions used base.__int__ instead of base.__index__ .\n\nChanged in version 3.6: Grouping digits with underscores as in code literals is allowed.\n\nChanged in version 3.7: The first parameter is now positional-only.\n\nChanged in version 3.8: Falls back to __index__() if __int__() is not defined.\n\nChanged in version 3.11: int string inputs and string representations can be limited to\nhelp avoid denial of service attacks. A ValueError is raised when\nthe limit is exceeded while converting a string to an int or\nwhen converting an int into a string would exceed the limit.\nSee the integer string conversion length limitation documentation.\n\nChanged in version 3.14: int() no longer delegates to the __trunc__() method.\n\nisinstance\n(\nobject\n,\nclassinfo\n,\n/\n)\n\u00c2\u00b6\nReturn True if the object argument is an instance of the classinfo argument, or of a (direct, indirect, or virtual ) subclass thereof.  If object is not\nan object of the given type, the function always returns False .\nIf classinfo is a tuple of type objects (or recursively, other such\ntuples) or a Union Type of multiple types, return True if object is an instance of any of the types.\nIf classinfo is not a type or tuple of types and such tuples,\na TypeError exception is raised. TypeError may not be\nraised for an invalid type if an earlier check succeeds.\n\nChanged in version 3.10: classinfo can be a Union Type .\n\nissubclass\n(\nclass\n,\nclassinfo\n,\n/\n)\n\u00c2\u00b6\nReturn True if class is a subclass (direct, indirect, or virtual ) of classinfo .  A\nclass is considered a subclass of itself. classinfo may be a tuple of class\nobjects (or recursively, other such tuples)\nor a Union Type , in which case return True if class is a\nsubclass of any entry in classinfo .  In any other case, a TypeError exception is raised.\n\nChanged in version 3.10: classinfo can be a Union Type .\n\niter\n(\niterable\n,\n/\n)\n\u00c2\u00b6\niter\n(\ncallable\n,\nsentinel\n,\n/\n)\nReturn an iterator object.  The first argument is interpreted very\ndifferently depending on the presence of the second argument. Without a\nsecond argument, the single argument must be a collection object which supports the iterable protocol (the __iter__() method),\nor it must support\nthe sequence protocol (the __getitem__() method with integer arguments\nstarting at 0 ).  If it does not support either of those protocols, TypeError is raised. If the second argument, sentinel , is given,\nthen the first argument must be a callable object.  The iterator created in this case\nwill call callable with no arguments for each call to its __next__() method; if the value returned is equal to sentinel , StopIteration will be raised, otherwise the value will\nbe returned.\n\nSee also Iterator Types .\n\nOne useful application of the second form of iter() is to build a\nblock-reader. For example, reading fixed-width blocks from a binary\ndatabase file until the end of file is reached:\n\n```python\nfrom functools import partial\nwith open('mydata.db', 'rb') as f:\n    for block in iter(partial(f.read, 64), b''):\n        process_block(block)\n```python\n\nlen\n(\nobject\n,\n/\n)\n\u00c2\u00b6\nReturn the length (the number of items) of an object.  The argument may be a\nsequence (such as a string, bytes, tuple, list, or range) or a collection\n(such as a dictionary, set, or frozen set).\n\nCPython implementation detail: len raises OverflowError on lengths larger than sys.maxsize , such as range(2 ** 100) .\n\nclass\nlist\n(\niterable\n=\n()\n,\n/\n)\nRather than being a function, list is actually a mutable\nsequence type, as documented in Lists and Sequence Types \u00e2\u0080\u0094 list, tuple, range .\n\nlocals\n(\n)\n\u00c2\u00b6\nReturn a mapping object representing the current local symbol table, with\nvariable names as the keys, and their currently bound references as the\nvalues.\n\nAt module scope, as well as when using exec() or eval() with\na single namespace, this function returns the same namespace as globals() .\n\nAt class scope, it returns the namespace that will be passed to the\nmetaclass constructor.\n\nWhen using exec() or eval() with separate local and global\narguments, it returns the local namespace passed in to the function call.\n\nIn all of the above cases, each call to locals() in a given frame of\nexecution will return the same mapping object. Changes made through\nthe mapping object returned from locals() will be visible as assigned,\nreassigned, or deleted local variables, and assigning, reassigning, or\ndeleting local variables will immediately affect the contents of the\nreturned mapping object.\n\nIn an optimized scope (including functions, generators, and\ncoroutines), each call to locals() instead returns a fresh dictionary\ncontaining the current bindings of the function\u00e2\u0080\u0099s local variables and any\nnonlocal cell references. In this case, name binding changes made via the\nreturned dict are not written back to the corresponding local variables\nor nonlocal cell references, and assigning, reassigning, or deleting local\nvariables and nonlocal cell references does not affect the contents\nof previously returned dictionaries.\n\nCalling locals() as part of a comprehension in a function, generator, or\ncoroutine is equivalent to calling it in the containing scope, except that\nthe comprehension\u00e2\u0080\u0099s initialised iteration variables will be included. In\nother scopes, it behaves as if the comprehension were running as a nested\nfunction.\n\nCalling locals() as part of a generator expression is equivalent to\ncalling it in a nested generator function.\n\nChanged in version 3.12: The behaviour of locals() in a comprehension has been updated as\ndescribed in PEP 709 .\n\nChanged in version 3.13: As part of PEP 667 , the semantics of mutating the mapping objects\nreturned from this function are now defined. The behavior in optimized scopes is now as described above.\nAside from being defined, the behaviour in other scopes remains\nunchanged from previous versions.\n\nmap\n(\nfunction\n,\niterable\n,\n/\n,\n*\niterables\n,\nstrict\n=\nFalse\n)\n\u00c2\u00b6\nReturn an iterator that applies function to every item of iterable ,\nyielding the results.  If additional iterables arguments are passed, function must take that many arguments and is applied to the items from all\niterables in parallel.  With multiple iterables, the iterator stops when the\nshortest iterable is exhausted.  If strict is True and one of the\niterables is exhausted before the others, a ValueError is raised. For\ncases where the function inputs are already arranged into argument tuples,\nsee itertools.starmap() .\n\nChanged in version 3.14: Added the strict parameter.\n\nmax\n(\niterable\n,\n/\n,\n*\n,\nkey\n=\nNone\n)\n\u00c2\u00b6\nmax\n(\niterable\n,\n/\n,\n*\n,\ndefault\n,\nkey\n=\nNone\n)\nmax\n(\narg1\n,\narg2\n,\n/\n,\n*\nargs\n,\nkey\n=\nNone\n)\nReturn the largest item in an iterable or the largest of two or more\narguments.\n\nIf one positional argument is provided, it should be an iterable .\nThe largest item in the iterable is returned.  If two or more positional\narguments are provided, the largest of the positional arguments is\nreturned.\n\nThere are two optional keyword-only arguments. The key argument specifies\na one-argument ordering function like that used for list.sort() . The default argument specifies an object to return if the provided iterable is\nempty. If the iterable is empty and default is not provided, a ValueError is raised.\n\nIf multiple items are maximal, the function returns the first one\nencountered.  This is consistent with other sort-stability preserving tools\nsuch as sorted(iterable, key=keyfunc, reverse=True)[0] and heapq.nlargest(1, iterable, key=keyfunc) .\n\nChanged in version 3.4: Added the default keyword-only parameter.\n\nChanged in version 3.8: The key can be None .\n\nclass\nmemoryview\n(\nobject\n)\nReturn a \u00e2\u0080\u009cmemory view\u00e2\u0080\u009d object created from the given argument.  See Memory Views for more information.\n\nmin\n(\niterable\n,\n/\n,\n*\n,\nkey\n=\nNone\n)\n\u00c2\u00b6\nmin\n(\niterable\n,\n/\n,\n*\n,\ndefault\n,\nkey\n=\nNone\n)\nmin\n(\narg1\n,\narg2\n,\n/\n,\n*\nargs\n,\nkey\n=\nNone\n)\nReturn the smallest item in an iterable or the smallest of two or more\narguments.\n\nIf one positional argument is provided, it should be an iterable .\nThe smallest item in the iterable is returned.  If two or more positional\narguments are provided, the smallest of the positional arguments is\nreturned.\n\nThere are two optional keyword-only arguments. The key argument specifies\na one-argument ordering function like that used for list.sort() . The default argument specifies an object to return if the provided iterable is\nempty. If the iterable is empty and default is not provided, a ValueError is raised.\n\nIf multiple items are minimal, the function returns the first one\nencountered.  This is consistent with other sort-stability preserving tools\nsuch as sorted(iterable, key=keyfunc)[0] and heapq.nsmallest(1, iterable, key=keyfunc) .\n\nChanged in version 3.4: Added the default keyword-only parameter.\n\nChanged in version 3.8: The key can be None .\n\n(\niterator\n,\n/\n)\n\u00c2\u00b6\n(\niterator\n,\ndefault\n,\n/\n)\nRetrieve the next item from the iterator by calling its __next__() method.  If default is given, it is returned\nif the iterator is exhausted, otherwise StopIteration is raised.\n\nclass\nobject\n\u00c2\u00b6\nThis is the ultimate base class of all other classes. It has methods\nthat are common to all instances of Python classes. When the constructor\nis called, it returns a new featureless object. The constructor does not\naccept any arguments.\n\nNote\n\nobject instances do not have __dict__ attributes, so you can\u00e2\u0080\u0099t assign arbitrary attributes to an instance of object .\n\noct\n(\ninteger\n,\n/\n)\n\u00c2\u00b6\nConvert an integer number to an octal string prefixed with \u00e2\u0080\u009c0o\u00e2\u0080\u009d.  The result\nis a valid Python expression. If integer is not a Python int object, it\nhas to define an __index__() method that returns an integer. For\nexample:\n\n```python\n>>> oct(8)\n'0o10'\n>>> oct(-56)\n'-0o70'\n```python\n\nIf you want to convert an integer number to an octal string either with the prefix\n\u00e2\u0080\u009c0o\u00e2\u0080\u009d or not, you can use either of the following ways.\n\n```python\n>>> '%#o' % 10, '%o' % 10\n('0o12', '12')\n>>> format(10, '#o'), format(10, 'o')\n('0o12', '12')\n>>> f'{10:#o}', f'{10:o}'\n('0o12', '12')\n```python\n\nSee also format() for more information.\n\nopen\n(\nfile\n,\nmode\n=\n'r'\n,\nbuffering\n=\n-1\n,\nencoding\n=\nNone\n,\nerrors\n=\nNone\n,\nnewline\n=\nNone\n,\nclosefd\n=\nTrue\n,\nopener\n=\nNone\n)\n\u00c2\u00b6\nOpen file and return a corresponding file object .  If the file\ncannot be opened, an OSError is raised. See Reading and Writing Files for more examples of how to use this function.\n\nfile is a path-like object giving the pathname (absolute or\nrelative to the current working directory) of the file to be opened or an\ninteger file descriptor of the file to be wrapped.  (If a file descriptor is\ngiven, it is closed when the returned I/O object is closed unless closefd is set to False .)\n\nmode is an optional string that specifies the mode in which the file is\nopened.  It defaults to 'r' which means open for reading in text mode.\nOther common values are 'w' for writing (truncating the file if it\nalready exists), 'x' for exclusive creation, and 'a' for appending\n(which on some Unix systems, means that all writes append to the end of\nthe file regardless of the current seek position).  In text mode, if encoding is not specified the encoding used is platform-dependent: locale.getencoding() is called to get the current locale encoding.\n(For reading and writing raw bytes use binary mode and leave encoding unspecified.)  The available modes are:\n\nThe default mode is 'r' (open for reading text, a synonym of 'rt' ).\nModes 'w+' and 'w+b' open and truncate the file.  Modes 'r+' and 'r+b' open the file with no truncation.\n\nAs mentioned in the Overview , Python distinguishes between binary\nand text I/O.  Files opened in binary mode (including 'b' in the mode argument) return contents as bytes objects without any decoding.  In\ntext mode (the default, or when 't' is included in the mode argument),\nthe contents of the file are returned as str , the bytes having been\nfirst decoded using a platform-dependent encoding or using the specified encoding if given.\n\nNote\n\nPython doesn\u00e2\u0080\u0099t depend on the underlying operating system\u00e2\u0080\u0099s notion of text\nfiles; all the processing is done by Python itself, and is therefore\nplatform-independent.\n\nbuffering is an optional integer used to set the buffering policy.  Pass 0\nto switch buffering off (only allowed in binary mode), 1 to select line\nbuffering (only usable when writing in text mode), and an integer > 1 to indicate the size\nin bytes of a fixed-size chunk buffer. Note that specifying a buffer size this\nway applies for binary buffered I/O, but TextIOWrapper (i.e., files opened\nwith mode='r+' ) would have another buffering. To disable buffering in TextIOWrapper , consider using the write_through flag for io.TextIOWrapper.reconfigure() . When no buffering argument is\ngiven, the default buffering policy works as follows:\n\n- Binary files are buffered in fixed-size chunks; the size of the buffer\nis max(min(blocksize, 8 MiB), DEFAULT_BUFFER_SIZE) when the device block size is available.\nOn most systems, the buffer will typically be 128 kilobytes long.\n- \u00e2\u0080\u009cInteractive\u00e2\u0080\u009d text files (files for which isatty() returns True ) use line buffering.  Other text files use the policy\ndescribed above for binary files.\n\nencoding is the name of the encoding used to decode or encode the file.\nThis should only be used in text mode.  The default encoding is platform\ndependent (whatever locale.getencoding() returns), but any text encoding supported by Python can be used.\nSee the codecs module for the list of supported encodings.\n\nerrors is an optional string that specifies how encoding and decoding\nerrors are to be handled\u00e2\u0080\u0094this cannot be used in binary mode.\nA variety of standard error handlers are available\n(listed under Error Handlers ), though any\nerror handling name that has been registered with codecs.register_error() is also valid.  The standard names\ninclude:\n\n- 'strict' to raise a ValueError exception if there is\nan encoding error.  The default value of None has the same\neffect.\n- 'ignore' ignores errors.  Note that ignoring encoding errors\ncan lead to data loss.\n- 'replace' causes a replacement marker (such as '?' ) to be inserted\nwhere there is malformed data.\n- 'surrogateescape' will represent any incorrect bytes as low\nsurrogate code units ranging from U+DC80 to U+DCFF.\nThese surrogate code units will then be turned back into\nthe same bytes when the surrogateescape error handler is used\nwhen writing data.  This is useful for processing files in an\nunknown encoding.\n- 'xmlcharrefreplace' is only supported when writing to a file.\nCharacters not supported by the encoding are replaced with the\nappropriate XML character reference &# nnn ; .\n- 'backslashreplace' replaces malformed data by Python\u00e2\u0080\u0099s backslashed\nescape sequences.\n- 'namereplace' (also only supported when writing)\nreplaces unsupported characters with \\N{...} escape sequences.\n\nnewline determines how to parse newline characters from the stream.\nIt can be None , '' , '\\n' , '\\r' , and '\\r\\n' .  It works as follows:\n\n- When reading input from the stream, if newline is None , universal\nnewlines mode is enabled.  Lines in the input can end in '\\n' , '\\r' , or '\\r\\n' , and these are translated into '\\n' before\nbeing returned to the caller.  If it is '' , universal newlines mode is\nenabled, but line endings are returned to the caller untranslated.  If it\nhas any of the other legal values, input lines are only terminated by the\ngiven string, and the line ending is returned to the caller untranslated.\n- When writing output to the stream, if newline is None , any '\\n' characters written are translated to the system default line separator, os.linesep .  If newline is '' or '\\n' , no translation\ntakes place.  If newline is any of the other legal values, any '\\n' characters written are translated to the given string.\n\nIf closefd is False and a file descriptor rather than a filename was\ngiven, the underlying file descriptor will be kept open when the file is\nclosed.  If a filename is given closefd must be True (the default);\notherwise, an error will be raised.\n\nA custom opener can be used by passing a callable as opener . The underlying\nfile descriptor for the file object is then obtained by calling opener with\n( file , flags ). opener must return an open file descriptor (passing os.open as opener results in functionality similar to passing None ).\n\nThe newly created file is non-inheritable .\n\nThe following example uses the dir_fd parameter of the os.open() function to open a file relative to a given directory:\n\n```python\n>>> import os\n>>> dir_fd = os.open('somedir', os.O_RDONLY)\n>>> def opener(path, flags):\n...     return os.open(path, flags, dir_fd=dir_fd)\n...\n>>> with open('spamspam.txt', 'w', opener=opener) as f:\n...     print('This will be written to somedir/spamspam.txt', file=f)\n...\n>>> os.close(dir_fd)  # don't leak a file descriptor\n```python\n\nThe type of file object returned by the open() function\ndepends on the mode.  When open() is used to open a file in a text\nmode ( 'w' , 'r' , 'wt' , 'rt' , etc.), it returns a subclass of io.TextIOBase (specifically io.TextIOWrapper ).  When used\nto open a file in a binary mode with buffering, the returned class is a\nsubclass of io.BufferedIOBase .  The exact class varies: in read\nbinary mode, it returns an io.BufferedReader ; in write binary and\nappend binary modes, it returns an io.BufferedWriter , and in\nread/write mode, it returns an io.BufferedRandom .  When buffering is\ndisabled, the raw stream, a subclass of io.RawIOBase , io.FileIO , is returned.\n\nSee also the file handling modules, such as fileinput , io (where open() is declared), os , os.path , tempfile ,\nand shutil .\n\nRaises an auditing event open with arguments path , mode , flags .\n\nThe mode and flags arguments may have been modified or inferred from\nthe original call.\n\nChanged in version 3.3:\n\n- The opener parameter was added.\n- The 'x' mode was added.\n- IOError used to be raised, it is now an alias of OSError .\n- FileExistsError is now raised if the file opened in exclusive\ncreation mode ( 'x' ) already exists.\n\nChanged in version 3.4:\n\n- The file is now non-inheritable.\n\nChanged in version 3.5:\n\n- If the system call is interrupted and the signal handler does not raise an\nexception, the function now retries the system call instead of raising an InterruptedError exception (see PEP 475 for the rationale).\n- The 'namereplace' error handler was added.\n\nChanged in version 3.6:\n\n- Support added to accept objects implementing os.PathLike .\n- On Windows, opening a console buffer may return a subclass of io.RawIOBase other than io.FileIO .\n\nChanged in version 3.11: The 'U' mode has been removed.\n\nord\n(\ncharacter\n,\n/\n)\n\u00c2\u00b6\nReturn the ordinal value of a character.\n\nIf the argument is a one-character string, return the Unicode code point\nof that character.  For example, ord('a') returns the integer 97 and ord('\u00e2\u0082\u00ac') (Euro sign)\nreturns 8364 .  This is the inverse of chr() .\n\nIf the argument is a bytes or bytearray object of\nlength 1, return its single byte value.\nFor example, ord(b'a') returns the integer 97 .\n\npow\n(\nbase\n,\nexp\n,\nmod\n=\nNone\n)\n\u00c2\u00b6\nReturn base to the power exp ; if mod is present, return base to the\npower exp , modulo mod (computed more efficiently than pow(base, exp) % mod ). The two-argument form pow(base, exp) is\nequivalent to using the power operator: base**exp .\n\nWhen arguments are builtin numeric types with mixed operand types, the\ncoercion rules for binary arithmetic operators apply.  For int operands, the result has the same type as the operands (after coercion)\nunless the second argument is negative; in that case, all arguments are\nconverted to float and a float result is delivered.  For example, pow(10, 2) returns 100 , but pow(10, -2) returns 0.01 .  For a negative base of\ntype int or float and a non-integral exponent, a complex\nresult is delivered.  For example, pow(-9, 0.5) returns a value close\nto 3j . Whereas, for a negative base of type int or float with an integral exponent, a float result is delivered. For example, pow(-9, 2.0) returns 81.0 .\n\nFor int operands base and exp , if mod is present, mod must\nalso be of integer type and mod must be nonzero. If mod is present and exp is negative, base must be relatively prime to mod . In that case, pow(inv_base, -exp, mod) is returned, where inv_base is an inverse to base modulo mod .\n\nHere\u00e2\u0080\u0099s an example of computing an inverse for 38 modulo 97 :\n\n```python\n>>> pow(38, -1, mod=97)\n23\n>>> 23 * 38 % 97 == 1\nTrue\n```python\n\nChanged in version 3.8: For int operands, the three-argument form of pow now allows\nthe second argument to be negative, permitting computation of modular\ninverses.\n\nChanged in version 3.8: Allow keyword arguments.  Formerly, only positional arguments were\nsupported.\n\nprint\n(\n*\nobjects\n,\nsep\n=\n'\n'\n,\nend\n=\n'\\n'\n,\nfile\n=\nNone\n,\nflush\n=\nFalse\n)\n\u00c2\u00b6\nPrint objects to the text stream file , separated by sep and followed\nby end . sep , end , file , and flush , if present, must be given as keyword\narguments.\n\nAll non-keyword arguments are converted to strings like str() does and\nwritten to the stream, separated by sep and followed by end .  Both sep and end must be strings; they can also be None , which means to use the\ndefault values.  If no objects are given, print() will just write end .\n\nThe file argument must be an object with a write(string) method; if it\nis not present or None , sys.stdout will be used.  Since printed\narguments are converted to text strings, print() cannot be used with\nbinary mode file objects.  For these, use file.write(...) instead.\n\nOutput buffering is usually determined by file .\nHowever, if flush is true, the stream is forcibly flushed.\n\nChanged in version 3.3: Added the flush keyword argument.\n\nclass\nproperty\n(\nfget\n=\nNone\n,\nfset\n=\nNone\n,\nfdel\n=\nNone\n,\ndoc\n=\nNone\n)\n\u00c2\u00b6\nReturn a property attribute.\n\nfget is a function for getting an attribute value. fset is a function\nfor setting an attribute value. fdel is a function for deleting an attribute\nvalue.  And doc creates a docstring for the attribute.\n\nA typical use is to define a managed attribute x :\n\n```python\nclass C:\n    def __init__(self):\n        self._x = None\n\n    def getx(self):\n        return self._x\n\n    def setx(self, value):\n        self._x = value\n\n    def delx(self):\n        del self._x\n\n    x = property(getx, setx, delx, \"I'm the 'x' property.\")\n```python\n\nIf c is an instance of C , c.x will invoke the getter, c.x = value will invoke the setter, and del c.x the deleter.\n\nIf given, doc will be the docstring of the property attribute. Otherwise, the\nproperty will copy fget \u00e2\u0080\u0099s docstring (if it exists).  This makes it possible to\ncreate read-only properties easily using property() as a decorator :\n\n```python\nclass Parrot:\n    def __init__(self):\n        self._voltage = 100000\n\n    @property\n    def voltage(self):\n        \"\"\"Get the current voltage.\"\"\"\n        return self._voltage\n```python\n\nThe @property decorator turns the voltage() method into a \u00e2\u0080\u009cgetter\u00e2\u0080\u009d\nfor a read-only attribute with the same name, and it sets the docstring for voltage to \u00e2\u0080\u009cGet the current voltage.\u00e2\u0080\u009d\n\n@\ngetter\n\u00c2\u00b6\n@\nsetter\n\u00c2\u00b6\n@\ndeleter\n\u00c2\u00b6\nA property object has getter , setter ,\nand deleter methods usable as decorators that create a\ncopy of the property with the corresponding accessor function set to the\ndecorated function.  This is best explained with an example:\n\n```python\nclass C:\n    def __init__(self):\n        self._x = None\n\n    @property\n    def x(self):\n        \"\"\"I'm the 'x' property.\"\"\"\n        return self._x\n\n    @x.setter\n    def x(self, value):\n        self._x = value\n\n    @x.deleter\n    def x(self):\n        del self._x\n```python\n\nThis code is exactly equivalent to the first example.  Be sure to give the\nadditional functions the same name as the original property ( x in this\ncase.)\n\nThe returned property object also has the attributes fget , fset , and fdel corresponding to the constructor arguments.\n\nChanged in version 3.5: The docstrings of property objects are now writeable.\n\n__name__\n\u00c2\u00b6\nAttribute holding the name of the property. The name of the property\ncan be changed at runtime.\n\nAdded in version 3.13.\n\nclass\nrange\n(\nstop\n,\n/\n)\nclass\nrange\n(\nstart\n,\nstop\n,\nstep\n=\n1\n,\n/\n)\nRather than being a function, range is actually an immutable\nsequence type, as documented in Ranges and Sequence Types \u00e2\u0080\u0094 list, tuple, range .\n\nrepr\n(\nobject\n,\n/\n)\n\u00c2\u00b6\nReturn a string containing a printable representation of an object.  For many\ntypes, this function makes an attempt to return a string that would yield an\nobject with the same value when passed to eval() ; otherwise, the\nrepresentation is a string enclosed in angle brackets that contains the name\nof the type of the object together with additional information often\nincluding the name and address of the object.  A class can control what this\nfunction returns for its instances\nby defining a __repr__() method.\nIf sys.displayhook() is not accessible, this function will raise RuntimeError .\n\nThis class has a custom representation that can be evaluated:\n\n```python\nclass Person:\n   def __init__(self, name, age):\n      self.name = name\n      self.age = age\n\n   def __repr__(self):\n      return f\"Person('{self.name}', {self.age})\"\n```python\n\nreversed\n(\nobject\n,\n/\n)\n\u00c2\u00b6\nReturn a reverse iterator .  The argument must be an object which has\na __reversed__() method or supports the sequence protocol (the __len__() method and the __getitem__() method\nwith integer arguments starting at 0 ).\n\nround\n(\nnumber\n,\nndigits\n=\nNone\n)\n\u00c2\u00b6\nReturn number rounded to ndigits precision after the decimal\npoint.  If ndigits is omitted or is None , it returns the\nnearest integer to its input.\n\nFor the built-in types supporting round() , values are rounded to the\nclosest multiple of 10 to the power minus ndigits ; if two multiples are\nequally close, rounding is done toward the even choice (so, for example,\nboth round(0.5) and round(-0.5) are 0 , and round(1.5) is 2 ).  Any integer value is valid for ndigits (positive, zero, or\nnegative).  The return value is an integer if ndigits is omitted or None .\nOtherwise, the return value has the same type as number .\n\nFor a general Python object number , round delegates to number.__round__ .\n\nNote\n\nThe behavior of round() for floats can be surprising: for example, round(2.675, 2) gives 2.67 instead of the expected 2.68 .\nThis is not a bug: it\u00e2\u0080\u0099s a result of the fact that most decimal fractions\ncan\u00e2\u0080\u0099t be represented exactly as a float.  See Floating-Point Arithmetic:  Issues and Limitations for\nmore information.\n\nclass\nset\n(\niterable\n=\n()\n,\n/\n)\nReturn a new set object, optionally with elements taken from iterable . set is a built-in class.  See set and Set Types \u00e2\u0080\u0094 set, frozenset for documentation about this class.\n\nFor other containers see the built-in frozenset , list , tuple , and dict classes, as well as the collections module.\n\nsetattr\n(\nobject\n,\nname\n,\nvalue\n,\n/\n)\n\u00c2\u00b6\nThis is the counterpart of getattr() .  The arguments are an object, a\nstring, and an arbitrary value.  The string may name an existing attribute or a\nnew attribute.  The function assigns the value to the attribute, provided the\nobject allows it.  For example, setattr(x, 'foobar', 123) is equivalent to x.foobar = 123 .\n\nname need not be a Python identifier as defined in Names (identifiers and keywords) unless the object chooses to enforce that, for example in a custom __getattribute__() or via __slots__ .\nAn attribute whose name is not an identifier will not be accessible using\nthe dot notation, but is accessible through getattr() etc..\n\nNote\n\nSince private name mangling happens at\ncompilation time, one must manually mangle a private attribute\u00e2\u0080\u0099s\n(attributes with two leading underscores) name in order to set it with setattr() .\n\nclass\nslice\n(\nstop\n,\n/\n)\n\u00c2\u00b6\nclass\nslice\n(\nstart\n,\nstop\n,\nstep\n=\nNone\n,\n/\n)\nReturn a slice object representing the set of indices specified by range(start, stop, step) .  The start and step arguments default to None .\n\nSlice objects are also generated when slicing syntax is used.  For example: a[start:stop:step] or a[start:stop, i] .\n\nSee itertools.islice() for an alternate version that returns an iterator .\n\nstart\n\u00c2\u00b6\nstop\n\u00c2\u00b6\nstep\n\u00c2\u00b6\nThese read-only attributes are set to the argument values\n(or their default).  They have no other explicit functionality;\nhowever, they are used by NumPy and other third-party packages.\n\nChanged in version 3.12: Slice objects are now hashable (provided start , stop , and step are hashable).\n\nsorted\n(\niterable\n,\n/\n,\n*\n,\nkey\n=\nNone\n,\nreverse\n=\nFalse\n)\n\u00c2\u00b6\nReturn a new sorted list from the items in iterable .\n\nHas two optional arguments which must be specified as keyword arguments.\n\nkey specifies a function of one argument that is used to extract a comparison\nkey from each element in iterable (for example, key=str.lower ).  The\ndefault value is None (compare the elements directly).\n\nreverse is a boolean value.  If set to True , then the list elements are\nsorted as if each comparison were reversed.\n\nUse functools.cmp_to_key() to convert an old-style cmp function to a key function.\n\nThe built-in sorted() function is guaranteed to be stable. A sort is\nstable if it guarantees not to change the relative order of elements that\ncompare equal \u00e2\u0080\u0094 this is helpful for sorting in multiple passes (for\nexample, sort by department, then by salary grade).\n\nThe sort algorithm uses only < comparisons between items.  While\ndefining an __lt__() method will suffice for sorting, PEP 8 recommends that all six rich comparisons be implemented.  This will help avoid bugs when using\nthe same data with other ordering tools such as max() that rely\non a different underlying method.  Implementing all six comparisons\nalso helps avoid confusion for mixed type comparisons which can call\nthe reflected __gt__() method.\n\nFor sorting examples and a brief sorting tutorial, see Sorting Techniques .\n\n@\nstaticmethod\n\u00c2\u00b6\nTransform a method into a static method.\n\nA static method does not receive an implicit first argument. To declare a static\nmethod, use this idiom:\n\n```python\nclass C:\n    @staticmethod\n    def f(arg1, arg2, argN): ...\n```python\n\nThe @staticmethod form is a function decorator \u00e2\u0080\u0093 see Function definitions for details.\n\nA static method can be called either on the class (such as C.f() ) or on\nan instance (such as C().f() ).\nMoreover, the static method descriptor is also callable, so it can\nbe used in the class definition (such as f() ).\n\nStatic methods in Python are similar to those found in Java or C++. Also, see classmethod() for a variant that is useful for creating alternate class\nconstructors.\n\nLike all decorators, it is also possible to call staticmethod as\na regular function and do something with its result.  This is needed\nin some cases where you need a reference to a function from a class\nbody and you want to avoid the automatic transformation to instance\nmethod.  For these cases, use this idiom:\n\n```python\ndef regular_function():\n    ...\n\nclass C:\n    method = staticmethod(regular_function)\n```python\n\nFor more information on static methods, see The standard type hierarchy .\n\nChanged in version 3.10: Static methods now inherit the method attributes\n( __module__ , __name__ , __qualname__ , __doc__ and __annotations__ ), have a new __wrapped__ attribute,\nand are now callable as regular functions.\n\nclass\nstr\n(\n*\n,\nencoding\n=\n'utf-8'\n,\nerrors\n=\n'strict'\n)\nclass\nstr\n(\nobject\n)\nclass\nstr\n(\nobject\n,\nencoding\n,\nerrors\n=\n'strict'\n)\nclass\nstr\n(\nobject\n,\n*\n,\nerrors\n)\nReturn a str version of object .  See str() for details.\n\nstr is the built-in string class .  For general information\nabout strings, see Text Sequence Type \u00e2\u0080\u0094 str .\n\nsum\n(\niterable\n,\n/\n,\nstart\n=\n0\n)\n\u00c2\u00b6\nSums start and the items of an iterable from left to right and returns the\ntotal.  The iterable \u00e2\u0080\u0099s items are normally numbers, and the start value is not\nallowed to be a string.\n\nFor some use cases, there are good alternatives to sum() .\nThe preferred, fast way to concatenate a sequence of strings is by calling ''.join(sequence) .  To add floating-point values with extended precision,\nsee math.fsum() .  To concatenate a series of iterables, consider using itertools.chain() .\n\nChanged in version 3.8: The start parameter can be specified as a keyword argument.\n\nChanged in version 3.12: Summation of floats switched to an algorithm\nthat gives higher accuracy and better commutativity on most builds.\n\nChanged in version 3.14: Added specialization for summation of complexes,\nusing same algorithm as for summation of floats.\n\nclass\nsuper\n\u00c2\u00b6\nclass\nsuper\n(\ntype\n,\nobject_or_type\n=\nNone\n,\n/\n)\nReturn a proxy object that delegates method calls to a parent or sibling\nclass of type .  This is useful for accessing inherited methods that have\nbeen overridden in a class.\n\nThe object_or_type determines the method resolution order to be searched.  The search starts from the class right after the type .\n\nFor example, if __mro__ of object_or_type is D -> B -> C -> A -> object and the value of type is B ,\nthen super() searches C -> A -> object .\n\nThe __mro__ attribute of the class corresponding to object_or_type lists the method resolution search order used by both getattr() and super() .  The attribute is dynamic and can change\nwhenever the inheritance hierarchy is updated.\n\nIf the second argument is omitted, the super object returned is unbound.  If\nthe second argument is an object, isinstance(obj, type) must be true.  If\nthe second argument is a type, issubclass(type2, type) must be true (this\nis useful for classmethods).\n\nWhen called directly within an ordinary method of a class, both arguments may\nbe omitted (\u00e2\u0080\u009czero-argument super() \u00e2\u0080\u009d). In this case, type will be the\nenclosing class, and obj will be the first argument of the immediately\nenclosing function (typically self ). (This means that zero-argument super() will not work as expected within nested functions, including\ngenerator expressions, which implicitly create nested functions.)\n\nThere are two typical use cases for super .  In a class hierarchy with\nsingle inheritance, super can be used to refer to parent classes without\nnaming them explicitly, thus making the code more maintainable.  This use\nclosely parallels the use of super in other programming languages.\n\nThe second use case is to support cooperative multiple inheritance in a\ndynamic execution environment.  This use case is unique to Python and is\nnot found in statically compiled languages or languages that only support\nsingle inheritance.  This makes it possible to implement \u00e2\u0080\u009cdiamond diagrams\u00e2\u0080\u009d\nwhere multiple base classes implement the same method.  Good design dictates\nthat such implementations have the same calling signature in every case (because the\norder of calls is determined at runtime, because that order adapts\nto changes in the class hierarchy, and because that order can include\nsibling classes that are unknown prior to runtime).\n\nFor both use cases, a typical superclass call looks like this:\n\n```python\nclass C(B):\n    def method(self, arg):\n        super().method(arg)    # This does the same thing as:\n                               # super(C, self).method(arg)\n```python\n\nIn addition to method lookups, super() also works for attribute\nlookups.  One possible use case for this is calling descriptors in a parent or sibling class.\n\nNote that super() is implemented as part of the binding process for\nexplicit dotted attribute lookups such as super().__getitem__(name) .\nIt does so by implementing its own __getattribute__() method\nfor searching\nclasses in a predictable order that supports cooperative multiple inheritance.\nAccordingly, super() is undefined for implicit lookups using statements or\noperators such as super()[name] .\n\nAlso note that, aside from the zero argument form, super() is not\nlimited to use inside methods.  The two argument form specifies the\narguments exactly and makes the appropriate references.  The zero\nargument form only works inside a class definition, as the compiler fills\nin the necessary details to correctly retrieve the class being defined,\nas well as accessing the current instance for ordinary methods.\n\nFor practical suggestions on how to design cooperative classes using super() , see guide to using super() .\n\nChanged in version 3.14: super objects are now pickleable and copyable .\n\nclass\ntuple\n(\niterable\n=\n()\n,\n/\n)\nRather than being a function, tuple is actually an immutable\nsequence type, as documented in Tuples and Sequence Types \u00e2\u0080\u0094 list, tuple, range .\n\nclass\ntype\n(\nobject\n,\n/\n)\n\u00c2\u00b6\nclass\ntype\n(\nname\n,\nbases\n,\ndict\n,\n/\n,\n**\nkwargs\n)\nWith one argument, return the type of an object .  The return value is a\ntype object and generally the same object as returned by object.__class__ .\n\nThe isinstance() built-in function is recommended for testing the type\nof an object, because it takes subclasses into account.\n\nWith three arguments, return a new type object.  This is essentially a\ndynamic form of the class statement. The name string is\nthe class name and becomes the __name__ attribute.\nThe bases tuple contains the base classes and becomes the __bases__ attribute; if empty, object , the\nultimate base of all classes, is added.  The dict dictionary contains\nattribute and method definitions for the class body; it may be copied\nor wrapped before becoming the __dict__ attribute.\nThe following two statements create identical type objects:\n\n```python\n>>> class X:\n...     a = 1\n...\n>>> X = type('X', (), dict(a=1))\n```python\n\nSee also:\n\n- Documentation on attributes and methods on classes .\n- Type Objects\n\nKeyword arguments provided to the three argument form are passed to the\nappropriate metaclass machinery (usually __init_subclass__() )\nin the same way that keywords in a class\ndefinition (besides metaclass ) would.\n\nSee also Customizing class creation .\n\nChanged in version 3.6: Subclasses of type which don\u00e2\u0080\u0099t override type.__new__ may no\nlonger use the one-argument form to get the type of an object.\n\nvars\n(\n)\n\u00c2\u00b6\nvars\n(\nobject\n,\n/\n)\nReturn the __dict__ attribute for a module, class, instance,\nor any other object with a __dict__ attribute.\n\nObjects such as modules and instances have an updateable __dict__ attribute; however, other objects may have write restrictions on their __dict__ attributes (for example, classes use a types.MappingProxyType to prevent direct dictionary updates).\n\nWithout an argument, vars() acts like locals() .\n\nA TypeError exception is raised if an object is specified but\nit doesn\u00e2\u0080\u0099t have a __dict__ attribute (for example, if\nits class defines the __slots__ attribute).\n\nChanged in version 3.13: The result of calling this function without an argument has been\nupdated as described for the locals() builtin.\n\nzip\n(\n*\niterables\n,\nstrict\n=\nFalse\n)\n\u00c2\u00b6\nIterate over several iterables in parallel, producing tuples with an item\nfrom each one.\n\nExample:\n\n```python\n>>> for item in zip([1, 2, 3], ['sugar', 'spice', 'everything nice']):\n...     print(item)\n...\n(1, 'sugar')\n(2, 'spice')\n(3, 'everything nice')\n```python\n\nMore formally: zip() returns an iterator of tuples, where the i -th\ntuple contains the i -th element from each of the argument iterables.\n\nAnother way to think of zip() is that it turns rows into columns, and\ncolumns into rows.  This is similar to transposing a matrix .\n\nzip() is lazy: The elements won\u00e2\u0080\u0099t be processed until the iterable is\niterated on, e.g. by a for loop or by wrapping in a list .\n\nOne thing to consider is that the iterables passed to zip() could have\ndifferent lengths; sometimes by design, and sometimes because of a bug in\nthe code that prepared these iterables.  Python offers three different\napproaches to dealing with this issue:\n\n- By default, zip() stops when the shortest iterable is exhausted.\nIt will ignore the remaining items in the longer iterables, cutting off\nthe result to the length of the shortest iterable: >>> list ( zip ( range ( 3 ), [ 'fee' , 'fi' , 'fo' , 'fum' ])) [(0, 'fee'), (1, 'fi'), (2, 'fo')]\n- zip() is often used in cases where the iterables are assumed to be\nof equal length.  In such cases, it\u00e2\u0080\u0099s recommended to use the strict=True option. Its output is the same as regular zip() : >>> list ( zip (( 'a' , 'b' , 'c' ), ( 1 , 2 , 3 ), strict = True )) [('a', 1), ('b', 2), ('c', 3)] Unlike the default behavior, it raises a ValueError if one iterable\nis exhausted before the others: >>> for item in zip ( range ( 3 ), [ 'fee' , 'fi' , 'fo' , 'fum' ], strict = True ): ... print ( item ) ... (0, 'fee') (1, 'fi') (2, 'fo') Traceback (most recent call last): ... ValueError : zip() argument 2 is longer than argument 1 Without the strict=True argument, any bug that results in iterables of\ndifferent lengths will be silenced, possibly manifesting as a hard-to-find\nbug in another part of the program.\n- Shorter iterables can be padded with a constant value to make all the\niterables have the same length.  This is done by itertools.zip_longest() .\n\nEdge cases: With a single iterable argument, zip() returns an\niterator of 1-tuples.  With no arguments, it returns an empty iterator.\n\nTips and tricks:\n\n- The left-to-right evaluation order of the iterables is guaranteed. This\nmakes possible an idiom for clustering a data series into n-length groups\nusing zip(*[iter(s)]*n, strict=True) .  This repeats the same iterator n times so that each output tuple has the result of n calls to the\niterator. This has the effect of dividing the input into n-length chunks.\n- zip() in conjunction with the * operator can be used to unzip a\nlist: >>> x = [ 1 , 2 , 3 ] >>> y = [ 4 , 5 , 6 ] >>> list ( zip ( x , y )) [(1, 4), (2, 5), (3, 6)] >>> x2 , y2 = zip ( * zip ( x , y )) >>> x == list ( x2 ) and y == list ( y2 ) True\n\nChanged in version 3.10: Added the strict argument.\n\n__import__\n(\nname\n,\nglobals\n=\nNone\n,\nlocals\n=\nNone\n,\nfromlist\n=\n()\n,\nlevel\n=\n0\n)\n\u00c2\u00b6\nNote\n\nThis is an advanced function that is not needed in everyday Python\nprogramming, unlike importlib.import_module() .\n\nThis function is invoked by the import statement.  It can be\nreplaced (by importing the builtins module and assigning to builtins.__import__ ) in order to change semantics of the import statement, but doing so is strongly discouraged as it\nis usually simpler to use import hooks (see PEP 302 ) to attain the same\ngoals and does not cause issues with code which assumes the default import\nimplementation is in use.  Direct use of __import__() is also\ndiscouraged in favor of importlib.import_module() .\n\nThe function imports the module name , potentially using the given globals and locals to determine how to interpret the name in a package context.\nThe fromlist gives the names of objects or submodules that should be\nimported from the module given by name .  The standard implementation does\nnot use its locals argument at all and uses its globals only to\ndetermine the package context of the import statement.\n\nlevel specifies whether to use absolute or relative imports. 0 (the\ndefault) means only perform absolute imports.  Positive values for level indicate the number of parent directories to search relative to the\ndirectory of the module calling __import__() (see PEP 328 for the\ndetails).\n\nWhen the name variable is of the form package.module , normally, the\ntop-level package (the name up till the first dot) is returned, not the\nmodule named by name .  However, when a non-empty fromlist argument is\ngiven, the module named by name is returned.\n\nFor example, the statement import spam results in bytecode resembling the\nfollowing code:\n\n```python\nspam = __import__('spam', globals(), locals(), [], 0)\n```python\n\nThe statement import spam.ham results in this call:\n\n```python\nspam = __import__('spam.ham', globals(), locals(), [], 0)\n```python\n\nNote how __import__() returns the toplevel module here because this is\nthe object that is bound to a name by the import statement.\n\nOn the other hand, the statement from spam.ham import eggs, sausage as saus results in\n\n```python\n_temp = __import__('spam.ham', globals(), locals(), ['eggs', 'sausage'], 0)\neggs = _temp.eggs\nsaus = _temp.sausage\n```python\n\nHere, the spam.ham module is returned from __import__() .  From this\nobject, the names to import are retrieved and assigned to their respective\nnames.\n\nIf you simply want to import a module (potentially within a package) by name,\nuse importlib.import_module() .\n\nChanged in version 3.3: Negative values for level are no longer supported (which also changes\nthe default value to 0).\n\nChanged in version 3.9: When the command line options -E or -I are being used,\nthe environment variable PYTHONCASEOK is now ignored.\n\nFootnotes",
      "difficulty": "intro",
      "doc_id": "doc-built-in-functions-5009a63261",
      "provenance": {
        "author": "",
        "date": "",
        "license": "PSF Documentation License",
        "source_file": "data/corpus_raw/scraped/3_library_functions_html_af4c85.json",
        "url": "https://docs.python.org/3/library/functions.html"
      },
      "title": "Built-in Functions\u00c2\u00b6",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "data_types",
        "dictionaries",
        "lists",
        "sets",
        "strings",
        "tuples"
      ],
      "content": "# Built-in Types\u00c2\u00b6\n\nThe following sections describe the standard types that are built into the\ninterpreter.\n\nThe principal built-in types are numerics, sequences, mappings, classes,\ninstances and exceptions.\n\nSome collection classes are mutable.  The methods that add, subtract, or\nrearrange their members in place, and don\u00e2\u0080\u0099t return a specific item, never return\nthe collection instance itself but None .\n\nSome operations are supported by several object types; in particular,\npractically all objects can be compared for equality, tested for truth\nvalue, and converted to a string (with the repr() function or the\nslightly different str() function).  The latter function is implicitly\nused when an object is written by the print() function.\n\n## Truth Value Testing\u00c2\u00b6\n\nAny object can be tested for truth value, for use in an if or while condition or as operand of the Boolean operations below.\n\nBy default, an object is considered true unless its class defines either a __bool__() method that returns False or a __len__() method that\nreturns zero, when called with the object. [ 1 ] If one of the methods raises an\nexception when called, the exception is propagated and the object does\nnot have a truth value (for example, NotImplemented ).\nHere are most of the built-in objects considered false:\n\n- constants defined to be false: None and False\n- zero of any numeric type: 0 , 0.0 , 0j , Decimal(0) , Fraction(0, 1)\n- empty sequences and collections: '' , () , [] , {} , set() , range(0)\n\nOperations and built-in functions that have a Boolean result always return 0 or False for false and 1 or True for true, unless otherwise stated.\n(Important exception: the Boolean operations or and and always return\none of their operands.)\n\n## Boolean Operations \u00e2\u0080\u0094and,or,not\u00c2\u00b6\n\nThese are the Boolean operations, ordered by ascending priority:\n\nNotes:\n\n- This is a short-circuit operator, so it only evaluates the second\nargument if the first one is false.\n- This is a short-circuit operator, so it only evaluates the second\nargument if the first one is true.\n- not has a lower priority than non-Boolean operators, so not a == b is\ninterpreted as not (a == b) , and a == not b is a syntax error.\n\n## Comparisons\u00c2\u00b6\n\nThere are eight comparison operations in Python.  They all have the same\npriority (which is higher than that of the Boolean operations).  Comparisons can\nbe chained arbitrarily; for example, x < y <= z is equivalent to x < y and y <= z , except that y is evaluated only once (but in both cases z is not\nevaluated at all when x < y is found to be false).\n\nThis table summarizes the comparison operations:\n\nUnless stated otherwise, objects of different types never compare equal.\nThe == operator is always defined but for some object types (for example,\nclass objects) is equivalent to is . The < , <= , > and >= operators are only defined where they make sense; for example, they raise a TypeError exception when one of the arguments is a complex number.\n\nNon-identical instances of a class normally compare as non-equal unless the\nclass defines the __eq__() method.\n\nInstances of a class cannot be ordered with respect to other instances of the\nsame class, or other types of object, unless the class defines enough of the\nmethods __lt__() , __le__() , __gt__() , and __ge__() (in general, __lt__() and __eq__() are sufficient, if you want the conventional meanings of the\ncomparison operators).\n\nThe behavior of the is and is not operators cannot be\ncustomized; also they can be applied to any two objects and never raise an\nexception.\n\nTwo more operations with the same syntactic priority, in and not in , are supported by types that are iterable or\nimplement the __contains__() method.\n\n## Numeric Types \u00e2\u0080\u0094int,float,complex\u00c2\u00b6\n\nThere are three distinct numeric types: integers , floating-point\nnumbers , and complex numbers .  In addition, Booleans are a\nsubtype of integers.  Integers have unlimited precision.  Floating-point\nnumbers are usually implemented using double in C; information\nabout the precision and internal representation of floating-point\nnumbers for the machine on which your program is running is available\nin sys.float_info .  Complex numbers have a real and imaginary\npart, which are each a floating-point number.  To extract these parts\nfrom a complex number z , use z.real and z.imag . (The standard\nlibrary includes the additional numeric types fractions.Fraction , for\nrationals, and decimal.Decimal , for floating-point numbers with\nuser-definable precision.)\n\nNumbers are created by numeric literals or as the result of built-in functions\nand operators.  Unadorned integer literals (including hex, octal and binary\nnumbers) yield integers.  Numeric literals containing a decimal point or an\nexponent sign yield floating-point numbers.  Appending 'j' or 'J' to a\nnumeric literal yields an imaginary number (a complex number with a zero real\npart) which you can add to an integer or float to get a complex number with real\nand imaginary parts.\n\nThe constructors int() , float() , and complex() can be used to produce numbers of a specific type.\n\nPython fully supports mixed arithmetic: when a binary arithmetic operator has\noperands of different built-in numeric types, the operand with the \u00e2\u0080\u009cnarrower\u00e2\u0080\u009d\ntype is widened to that of the other:\n\n- If both arguments are complex numbers, no conversion is performed;\n- if either argument is a complex or a floating-point number, the other is\nconverted to a floating-point number;\n- otherwise, both must be integers and no conversion is necessary.\n\nArithmetic with complex and real operands is defined by the usual mathematical\nformula, for example:\n\n```python\nx + complex(u, v) = complex(x + u, v)\nx * complex(u, v) = complex(x * u, x * v)\n```python\n\nA comparison between numbers of different types behaves as though the exact\nvalues of those numbers were being compared. [ 2 ]\n\nAll numeric types (except complex) support the following operations (for priorities of\nthe operations, see Operator precedence ):\n\nNotes:\n\n- Also referred to as integer division.  For operands of type int ,\nthe result has type int .  For operands of type float ,\nthe result has type float .  In general, the result is a whole\ninteger, though the result\u00e2\u0080\u0099s type is not necessarily int .  The result is\nalways rounded towards minus infinity: 1//2 is 0 , (-1)//2 is -1 , 1//(-2) is -1 , and (-1)//(-2) is 0 .\n- Not for complex numbers.  Instead convert to floats using abs() if\nappropriate.\n- Conversion from float to int truncates, discarding the\nfractional part. See functions math.floor() and math.ceil() for\nalternative conversions.\n- float also accepts the strings \u00e2\u0080\u009cnan\u00e2\u0080\u009d and \u00e2\u0080\u009cinf\u00e2\u0080\u009d with an optional prefix \u00e2\u0080\u009c+\u00e2\u0080\u009d\nor \u00e2\u0080\u009c-\u00e2\u0080\u009d for Not a Number (NaN) and positive or negative infinity.\n- Python defines pow(0, 0) and 0 ** 0 to be 1 , as is common for\nprogramming languages.\n- The numeric literals accepted include the digits 0 to 9 or any\nUnicode equivalent (code points with the Nd property). See the Unicode Standard for a complete list of code points with the Nd property.\n\nAll numbers.Real types ( int and float ) also include\nthe following operations:\n\nFor additional numeric operations see the math and cmath modules.\n\n### Bitwise Operations on Integer Types\u00c2\u00b6\n\nBitwise operations only make sense for integers. The result of bitwise\noperations is calculated as though carried out in two\u00e2\u0080\u0099s complement with an\ninfinite number of sign bits.\n\nThe priorities of the binary bitwise operations are all lower than the numeric\noperations and higher than the comparisons; the unary operation ~ has the\nsame priority as the other unary numeric operations ( + and - ).\n\nThis table lists the bitwise operations sorted in ascending priority:\n\nNotes:\n\n- Negative shift counts are illegal and cause a ValueError to be raised.\n- A left shift by n bits is equivalent to multiplication by pow(2, n) .\n- A right shift by n bits is equivalent to floor division by pow(2, n) .\n- Performing these calculations with at least one extra sign extension bit in\na finite two\u00e2\u0080\u0099s complement representation (a working bit-width of 1 + max(x.bit_length(), y.bit_length()) or more) is sufficient to get the\nsame result as if there were an infinite number of sign bits.\n\n### Additional Methods on Integer Types\u00c2\u00b6\n\nThe int type implements the numbers.Integral abstract base\nclass . In addition, it provides a few more methods:\n\nint.\nbit_length\n(\n)\n\u00c2\u00b6\nReturn the number of bits necessary to represent an integer in binary,\nexcluding the sign and leading zeros:\n\n```python\n>>> n = -37\n>>> bin(n)\n'-0b100101'\n>>> n.bit_length()\n6\n```python\n\nMore precisely, if x is nonzero, then x.bit_length() is the\nunique positive integer k such that 2**(k-1) <= abs(x) < 2**k .\nEquivalently, when abs(x) is small enough to have a correctly\nrounded logarithm, then k = 1 + int(log(abs(x), 2)) .\nIf x is zero, then x.bit_length() returns 0 .\n\nEquivalent to:\n\n```python\ndef bit_length(self):\n    s = bin(self)       # binary representation:  bin(-37) --> '-0b100101'\n    s = s.lstrip('-0b') # remove leading zeros and minus sign\n    return len(s)       # len('100101') --> 6\n```python\n\nAdded in version 3.1.\n\nint.\nbit_count\n(\n)\n\u00c2\u00b6\nReturn the number of ones in the binary representation of the absolute\nvalue of the integer. This is also known as the population count.\nExample:\n\n```python\n>>> n = 19\n>>> bin(n)\n'0b10011'\n>>> n.bit_count()\n3\n>>> (-n).bit_count()\n3\n```python\n\nEquivalent to:\n\n```python\ndef bit_count(self):\n    return bin(self).count(\"1\")\n```python\n\nAdded in version 3.10.\n\nint.\nto_bytes\n(\nlength\n=\n1\n,\nbyteorder\n=\n'big'\n,\n*\n,\nsigned\n=\nFalse\n)\n\u00c2\u00b6\nReturn an array of bytes representing an integer.\n\n```python\n>>> (1024).to_bytes(2, byteorder='big')\nb'\\x04\\x00'\n>>> (1024).to_bytes(10, byteorder='big')\nb'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00'\n>>> (-1024).to_bytes(10, byteorder='big', signed=True)\nb'\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\x00'\n>>> x = 1000\n>>> x.to_bytes((x.bit_length() + 7) // 8, byteorder='little')\nb'\\xe8\\x03'\n```python\n\nThe integer is represented using length bytes, and defaults to 1.  An OverflowError is raised if the integer is not representable with\nthe given number of bytes.\n\nThe byteorder argument determines the byte order used to represent the\ninteger, and defaults to \"big\" .  If byteorder is \"big\" , the most significant byte is at the beginning of the byte\narray.  If byteorder is \"little\" , the most significant byte is at\nthe end of the byte array.\n\nThe signed argument determines whether two\u00e2\u0080\u0099s complement is used to\nrepresent the integer.  If signed is False and a negative integer is\ngiven, an OverflowError is raised. The default value for signed is False .\n\nThe default values can be used to conveniently turn an integer into a\nsingle byte object:\n\n```python\n>>> (65).to_bytes()\nb'A'\n```python\n\nHowever, when using the default arguments, don\u00e2\u0080\u0099t try\nto convert a value greater than 255 or you\u00e2\u0080\u0099ll get an OverflowError .\n\nEquivalent to:\n\n```python\ndef to_bytes(n, length=1, byteorder='big', signed=False):\n    if byteorder == 'little':\n        order = range(length)\n    elif byteorder == 'big':\n        order = reversed(range(length))\n    else:\n        raise ValueError(\"byteorder must be either 'little' or 'big'\")\n\n    return bytes((n >> i*8) & 0xff for i in order)\n```python\n\nAdded in version 3.2.\n\nChanged in version 3.11: Added default argument values for length and byteorder .\n\nclassmethod\nint.\nfrom_bytes\n(\nbytes\n,\nbyteorder\n=\n'big'\n,\n*\n,\nsigned\n=\nFalse\n)\n\u00c2\u00b6\nReturn the integer represented by the given array of bytes.\n\n```python\n>>> int.from_bytes(b'\\x00\\x10', byteorder='big')\n16\n>>> int.from_bytes(b'\\x00\\x10', byteorder='little')\n4096\n>>> int.from_bytes(b'\\xfc\\x00', byteorder='big', signed=True)\n-1024\n>>> int.from_bytes(b'\\xfc\\x00', byteorder='big', signed=False)\n64512\n>>> int.from_bytes([255, 0, 0], byteorder='big')\n16711680\n```python\n\nThe argument bytes must either be a bytes-like object or an\niterable producing bytes.\n\nThe byteorder argument determines the byte order used to represent the\ninteger, and defaults to \"big\" .  If byteorder is \"big\" , the most significant byte is at the beginning of the byte\narray.  If byteorder is \"little\" , the most significant byte is at\nthe end of the byte array.  To request the native byte order of the host\nsystem, use sys.byteorder as the byte order value.\n\nThe signed argument indicates whether two\u00e2\u0080\u0099s complement is used to\nrepresent the integer.\n\nEquivalent to:\n\n```python\ndef from_bytes(bytes, byteorder='big', signed=False):\n    if byteorder == 'little':\n        little_ordered = list(bytes)\n    elif byteorder == 'big':\n        little_ordered = list(reversed(bytes))\n    else:\n        raise ValueError(\"byteorder must be either 'little' or 'big'\")\n\n    n = sum(b << i*8 for i, b in enumerate(little_ordered))\n    if signed and little_ordered and (little_ordered[-1] & 0x80):\n        n -= 1 << 8*len(little_ordered)\n\n    return n\n```python\n\nAdded in version 3.2.\n\nChanged in version 3.11: Added default argument value for byteorder .\n\nint.\nas_integer_ratio\n(\n)\n\u00c2\u00b6\nReturn a pair of integers whose ratio is equal to the original\ninteger and has a positive denominator.  The integer ratio of integers\n(whole numbers) is always the integer as the numerator and 1 as the\ndenominator.\n\nAdded in version 3.8.\n\nint.\nis_integer\n(\n)\n\u00c2\u00b6\nReturns True . Exists for duck type compatibility with float.is_integer() .\n\nAdded in version 3.12.\n\n### Additional Methods on Float\u00c2\u00b6\n\nThe float type implements the numbers.Real abstract base\nclass . float also has the following additional methods.\n\nclassmethod\nfloat.\nfrom_number\n(\nx\n)\n\u00c2\u00b6\nClass method to return a floating-point number constructed from a number x .\n\nIf the argument is an integer or a floating-point number, a\nfloating-point number with the same value (within Python\u00e2\u0080\u0099s floating-point\nprecision) is returned.  If the argument is outside the range of a Python\nfloat, an OverflowError will be raised.\n\nFor a general Python object x , float.from_number(x) delegates to x.__float__() .\nIf __float__() is not defined then it falls back\nto __index__() .\n\nAdded in version 3.14.\n\nfloat.\nas_integer_ratio\n(\n)\n\u00c2\u00b6\nReturn a pair of integers whose ratio is exactly equal to the\noriginal float. The ratio is in lowest terms and has a positive denominator.  Raises OverflowError on infinities and a ValueError on\nNaNs.\n\nfloat.\nis_integer\n(\n)\n\u00c2\u00b6\nReturn True if the float instance is finite with integral\nvalue, and False otherwise:\n\n```python\n>>> (-2.0).is_integer()\nTrue\n>>> (3.2).is_integer()\nFalse\n```python\n\nTwo methods support conversion to\nand from hexadecimal strings.  Since Python\u00e2\u0080\u0099s floats are stored\ninternally as binary numbers, converting a float to or from a decimal string usually involves a small rounding error.  In\ncontrast, hexadecimal strings allow exact representation and\nspecification of floating-point numbers.  This can be useful when\ndebugging, and in numerical work.\n\nfloat.\nhex\n(\n)\n\u00c2\u00b6\nReturn a representation of a floating-point number as a hexadecimal\nstring.  For finite floating-point numbers, this representation\nwill always include a leading 0x and a trailing p and\nexponent.\n\nclassmethod\nfloat.\nfromhex\n(\ns\n)\n\u00c2\u00b6\nClass method to return the float represented by a hexadecimal\nstring s .  The string s may have leading and trailing\nwhitespace.\n\nNote that float.hex() is an instance method, while float.fromhex() is a class method.\n\nA hexadecimal string takes the form:\n\n```python\n[sign] ['0x'] integer ['.' fraction] ['p' exponent]\n```python\n\nwhere the optional sign may by either + or - , integer and fraction are strings of hexadecimal digits, and exponent is a decimal integer with an optional leading sign.  Case is not\nsignificant, and there must be at least one hexadecimal digit in\neither the integer or the fraction.  This syntax is similar to the\nsyntax specified in section 6.4.4.2 of the C99 standard, and also to\nthe syntax used in Java 1.5 onwards.  In particular, the output of float.hex() is usable as a hexadecimal floating-point literal in\nC or Java code, and hexadecimal strings produced by C\u00e2\u0080\u0099s %a format\ncharacter or Java\u00e2\u0080\u0099s Double.toHexString are accepted by float.fromhex() .\n\nNote that the exponent is written in decimal rather than hexadecimal,\nand that it gives the power of 2 by which to multiply the coefficient.\nFor example, the hexadecimal string 0x3.a7p10 represents the\nfloating-point number (3 + 10./16 + 7./16**2) * 2.0**10 , or 3740.0 :\n\n```python\n>>> float.fromhex('0x3.a7p10')\n3740.0\n```python\n\nApplying the reverse conversion to 3740.0 gives a different\nhexadecimal string representing the same number:\n\n```python\n>>> float.hex(3740.0)\n'0x1.d380000000000p+11'\n```python\n\n### Additional Methods on Complex\u00c2\u00b6\n\nThe complex type implements the numbers.Complex abstract base class . complex also has the following additional methods.\n\nclassmethod\ncomplex.\nfrom_number\n(\nx\n)\n\u00c2\u00b6\nClass method to convert a number to a complex number.\n\nFor a general Python object x , complex.from_number(x) delegates to x.__complex__() .  If __complex__() is not defined then it falls back\nto __float__() .  If __float__() is not defined then it falls back\nto __index__() .\n\nAdded in version 3.14.\n\n### Hashing of numeric types\u00c2\u00b6\n\nFor numbers x and y , possibly of different types, it\u00e2\u0080\u0099s a requirement\nthat hash(x) == hash(y) whenever x == y (see the __hash__() method documentation for more details).  For ease of implementation and\nefficiency across a variety of numeric types (including int , float , decimal.Decimal and fractions.Fraction )\nPython\u00e2\u0080\u0099s hash for numeric types is based on a single mathematical function\nthat\u00e2\u0080\u0099s defined for any rational number, and hence applies to all instances of int and fractions.Fraction , and all finite instances of float and decimal.Decimal .  Essentially, this function is\ngiven by reduction modulo P for a fixed prime P .  The value of P is\nmade available to Python as the modulus attribute of sys.hash_info .\n\nCPython implementation detail: Currently, the prime used is P = 2**31 - 1 on machines with 32-bit C\nlongs and P = 2**61 - 1 on machines with 64-bit C longs.\n\nHere are the rules in detail:\n\n- If x = m / n is a nonnegative rational number and n is not divisible\nby P , define hash(x) as m * invmod(n, P) % P , where invmod(n, P) gives the inverse of n modulo P .\n- If x = m / n is a nonnegative rational number and n is\ndivisible by P (but m is not) then n has no inverse\nmodulo P and the rule above doesn\u00e2\u0080\u0099t apply; in this case define hash(x) to be the constant value sys.hash_info.inf .\n- If x = m / n is a negative rational number define hash(x) as -hash(-x) .  If the resulting hash is -1 , replace it with -2 .\n- The particular values sys.hash_info.inf and -sys.hash_info.inf are used as hash values for positive\ninfinity or negative infinity (respectively).\n- For a complex number z , the hash values of the real\nand imaginary parts are combined by computing hash(z.real) + sys.hash_info.imag * hash(z.imag) , reduced modulo 2**sys.hash_info.width so that it lies in range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1)) .  Again, if the result is -1 , it\u00e2\u0080\u0099s replaced with -2 .\n\nTo clarify the above rules, here\u00e2\u0080\u0099s some example Python code,\nequivalent to the built-in hash, for computing the hash of a rational\nnumber, float , or complex :\n\n```python\nimport sys, math\n\ndef hash_fraction(m, n):\n    \"\"\"Compute the hash of a rational number m / n.\n\n    Assumes m and n are integers, with n positive.\n    Equivalent to hash(fractions.Fraction(m, n)).\n\n    \"\"\"\n    P = sys.hash_info.modulus\n    # Remove common factors of P.  (Unnecessary if m and n already coprime.)\n    while m % P == n % P == 0:\n        m, n = m // P, n // P\n\n    if n % P == 0:\n        hash_value = sys.hash_info.inf\n    else:\n        # Fermat's Little Theorem: pow(n, P-1, P) is 1, so\n        # pow(n, P-2, P) gives the inverse of n modulo P.\n        hash_value = (abs(m) % P) * pow(n, P - 2, P) % P\n    if m < 0:\n        hash_value = -hash_value\n    if hash_value == -1:\n        hash_value = -2\n    return hash_value\n\ndef hash_float(x):\n    \"\"\"Compute the hash of a float x.\"\"\"\n\n    if math.isnan(x):\n        return object.__hash__(x)\n    elif math.isinf(x):\n        return sys.hash_info.inf if x > 0 else -sys.hash_info.inf\n    else:\n        return hash_fraction(*x.as_integer_ratio())\n\ndef hash_complex(z):\n    \"\"\"Compute the hash of a complex number z.\"\"\"\n\n    hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag)\n    # do a signed reduction modulo 2**sys.hash_info.width\n    M = 2**(sys.hash_info.width - 1)\n    hash_value = (hash_value & (M - 1)) - (hash_value & M)\n    if hash_value == -1:\n        hash_value = -2\n    return hash_value\n```python\n\n## Boolean Type -bool\u00c2\u00b6\n\nBooleans represent truth values. The bool type has exactly two\nconstant instances: True and False .\n\nThe built-in function bool() converts any value to a boolean, if the\nvalue can be interpreted as a truth value (see section Truth Value Testing above).\n\nFor logical operations, use the boolean operators and , or and not .\nWhen applying the bitwise operators & , | , ^ to two booleans, they\nreturn a bool equivalent to the logical operations \u00e2\u0080\u009cand\u00e2\u0080\u009d, \u00e2\u0080\u009cor\u00e2\u0080\u009d, \u00e2\u0080\u009cxor\u00e2\u0080\u009d. However,\nthe logical operators and , or and != should be preferred\nover & , | and ^ .\n\nDeprecated since version 3.12: The use of the bitwise inversion operator ~ is deprecated and will\nraise an error in Python 3.16.\n\nbool is a subclass of int (see Numeric Types \u00e2\u0080\u0094 int, float, complex ). In\nmany numeric contexts, False and True behave like the integers 0 and 1, respectively.\nHowever, relying on this is discouraged; explicitly convert using int() instead.\n\n## Iterator Types\u00c2\u00b6\n\nPython supports a concept of iteration over containers.  This is implemented\nusing two distinct methods; these are used to allow user-defined classes to\nsupport iteration.  Sequences, described below in more detail, always support\nthe iteration methods.\n\nOne method needs to be defined for container objects to provide iterable support:\n\ncontainer.\n__iter__\n(\n)\n\u00c2\u00b6\nReturn an iterator object.  The object is required to support the\niterator protocol described below.  If a container supports different types\nof iteration, additional methods can be provided to specifically request\niterators for those iteration types.  (An example of an object supporting\nmultiple forms of iteration would be a tree structure which supports both\nbreadth-first and depth-first traversal.)  This method corresponds to the tp_iter slot of the type structure for Python\nobjects in the Python/C API.\n\nThe iterator objects themselves are required to support the following two\nmethods, which together form the iterator protocol :\n\niterator.\n__iter__\n(\n)\n\u00c2\u00b6\nReturn the iterator object itself.  This is required to allow both\ncontainers and iterators to be used with the for and in statements.  This method corresponds to the tp_iter slot of the type structure for Python\nobjects in the Python/C API.\n\niterator.\n__next__\n(\n)\n\u00c2\u00b6\nReturn the next item from the iterator .  If there are no further\nitems, raise the StopIteration exception.  This method corresponds to\nthe tp_iternext slot of the type structure for\nPython objects in the Python/C API.\n\nPython defines several iterator objects to support iteration over general and\nspecific sequence types, dictionaries, and other more specialized forms.  The\nspecific types are not important beyond their implementation of the iterator\nprotocol.\n\nOnce an iterator\u00e2\u0080\u0099s __next__() method raises StopIteration , it must continue to do so on subsequent calls.\nImplementations that do not obey this property are deemed broken.\n\n### Generator Types\u00c2\u00b6\n\nPython\u00e2\u0080\u0099s generator s provide a convenient way to implement the iterator\nprotocol.  If a container object\u00e2\u0080\u0099s __iter__() method is implemented as a\ngenerator, it will automatically return an iterator object (technically, a\ngenerator object) supplying the __iter__() and __next__() methods.\nMore information about generators can be found in the documentation for\nthe yield expression .\n\n## Sequence Types \u00e2\u0080\u0094list,tuple,range\u00c2\u00b6\n\nThere are three basic sequence types: lists, tuples, and range objects.\nAdditional sequence types tailored for processing of binary data and text strings are\ndescribed in dedicated sections.\n\n### Common Sequence Operations\u00c2\u00b6\n\nThe operations in the following table are supported by most sequence types,\nboth mutable and immutable. The collections.abc.Sequence ABC is\nprovided to make it easier to correctly implement these operations on\ncustom sequence types.\n\nThis table lists the sequence operations sorted in ascending priority.  In the\ntable, s and t are sequences of the same type, n , i , j and k are\nintegers and x is an arbitrary object that meets any type and value\nrestrictions imposed by s .\n\nThe in and not in operations have the same priorities as the\ncomparison operations. The + (concatenation) and * (repetition)\noperations have the same priority as the corresponding numeric operations. [ 3 ]\n\nSequences of the same type also support comparisons.  In particular, tuples\nand lists are compared lexicographically by comparing corresponding elements.\nThis means that to compare equal, every element must compare equal and the\ntwo sequences must be of the same type and have the same length.  (For full\ndetails see Comparisons in the language reference.)\n\nForward and reversed iterators over mutable sequences access values using an\nindex.  That index will continue to march forward (or backward) even if the\nunderlying sequence is mutated.  The iterator terminates only when an IndexError or a StopIteration is encountered (or when the index\ndrops below zero).\n\nNotes:\n\n- While the in and not in operations are used only for simple\ncontainment testing in the general case, some specialised sequences\n(such as str , bytes and bytearray ) also use\nthem for subsequence testing: >>> \"gg\" in \"eggs\" True\n- Values of n less than 0 are treated as 0 (which yields an empty\nsequence of the same type as s ).  Note that items in the sequence s are not copied; they are referenced multiple times.  This often haunts\nnew Python programmers; consider: >>> lists = [[]] * 3 >>> lists [[], [], []] >>> lists [ 0 ] . append ( 3 ) >>> lists [[3], [3], [3]] What has happened is that [[]] is a one-element list containing an empty\nlist, so all three elements of [[]] * 3 are references to this single empty\nlist.  Modifying any of the elements of lists modifies this single list.\nYou can create a list of different lists this way: >>> lists = [[] for i in range ( 3 )] >>> lists [ 0 ] . append ( 3 ) >>> lists [ 1 ] . append ( 5 ) >>> lists [ 2 ] . append ( 7 ) >>> lists [[3], [5], [7]] Further explanation is available in the FAQ entry How do I create a multidimensional list? .\n- If i or j is negative, the index is relative to the end of sequence s : len(s) + i or len(s) + j is substituted.  But note that -0 is\nstill 0 .\n- The slice of s from i to j is defined as the sequence of items with\nindex k such that i <= k < j . If i is omitted or None , use 0 . If j is omitted or None , use len(s) . If i or j is less than -len(s) , use 0 . If i or j is greater than len(s) , use len(s) . If i is greater than or equal to j , the slice is empty.\n- The slice of s from i to j with step k is defined as the sequence of\nitems with index x = i + n*k such that 0 <= n < (j-i)/k .  In other words,\nthe indices are i , i+k , i+2*k , i+3*k and so on, stopping when j is reached (but never including j ).  When k is positive, i and j are reduced to len(s) if they are greater.\nWhen k is negative, i and j are reduced to len(s) - 1 if\nthey are greater.  If i or j are omitted or None , they become\n\u00e2\u0080\u009cend\u00e2\u0080\u009d values (which end depends on the sign of k ).  Note, k cannot be zero.\nIf k is None , it is treated like 1 .\n- Concatenating immutable sequences always results in a new object.  This\nmeans that building up a sequence by repeated concatenation will have a\nquadratic runtime cost in the total sequence length.  To get a linear\nruntime cost, you must switch to one of the alternatives below: if concatenating str objects, you can build a list and use str.join() at the end or else write to an io.StringIO instance and retrieve its value when complete if concatenating bytes objects, you can similarly use bytes.join() or io.BytesIO , or you can do in-place\nconcatenation with a bytearray object. bytearray objects are mutable and have an efficient overallocation mechanism if concatenating tuple objects, extend a list instead for other types, investigate the relevant class documentation\n- Some sequence types (such as range ) only support item sequences\nthat follow specific patterns, and hence don\u00e2\u0080\u0099t support sequence\nconcatenation or repetition.\n- An IndexError is raised if i is outside the sequence range.\n\nSequence Methods\n\nSequence types also support the following methods:\n\nsequence.\ncount\n(\nvalue\n,\n/\n)\n\u00c2\u00b6\nReturn the total number of occurrences of value in sequence .\n\nsequence.\nindex\n(\nvalue[,\nstart[,\nstop]\n)\n\u00c2\u00b6\nReturn the index of the first occurrence of value in sequence .\n\nRaises ValueError if value is not found in sequence .\n\nThe start or stop arguments allow for efficient searching\nof subsections of the sequence, beginning at start and ending at stop .\nThis is roughly equivalent to start + sequence[start:stop].index(value) ,\nonly without copying any data.\n\nCaution\n\nNot all sequence types support passing the start and stop arguments.\n\n### Immutable Sequence Types\u00c2\u00b6\n\nThe only operation that immutable sequence types generally implement that is\nnot also implemented by mutable sequence types is support for the hash() built-in.\n\nThis support allows immutable sequences, such as tuple instances, to\nbe used as dict keys and stored in set and frozenset instances.\n\nAttempting to hash an immutable sequence that contains unhashable values will\nresult in TypeError .\n\n### Mutable Sequence Types\u00c2\u00b6\n\nThe operations in the following table are defined on mutable sequence types.\nThe collections.abc.MutableSequence ABC is provided to make it\neasier to correctly implement these operations on custom sequence types.\n\nIn the table s is an instance of a mutable sequence type, t is any\niterable object and x is an arbitrary object that meets any type\nand value restrictions imposed by s (for example, bytearray only\naccepts integers that meet the value restriction 0 <= x <= 255 ).\n\nNotes:\n\n- If k is not equal to 1 , t must have the same length as the slice it is replacing.\n- The value n is an integer, or an object implementing __index__() .  Zero and negative values of n clear\nthe sequence.  Items in the sequence are not copied; they are referenced\nmultiple times, as explained for s * n under Common Sequence Operations .\n\nMutable Sequence Methods\n\nMutable sequence types also support the following methods:\n\nsequence.\nappend\n(\nvalue\n,\n/\n)\n\u00c2\u00b6\nAppend value to the end of the sequence\nThis is equivalent to writing seq[len(seq):len(seq)] = [value] .\n\nsequence.\nclear\n(\n)\n\u00c2\u00b6\nAdded in version 3.3.\n\nRemove all items from sequence .\nThis is equivalent to writing del sequence[:] .\n\nsequence.\ncopy\n(\n)\n\u00c2\u00b6\nAdded in version 3.3.\n\nCreate a shallow copy of sequence .\nThis is equivalent to writing sequence[:] .\n\nHint\n\nThe copy() method is not part of the MutableSequence ABC ,\nbut most concrete mutable sequence types provide it.\n\nsequence.\nextend\n(\niterable\n,\n/\n)\n\u00c2\u00b6\nExtend sequence with the contents of iterable .\nFor the most part, this is the same as writing seq[len(seq):len(seq)] = iterable .\n\nsequence.\ninsert\n(\nindex\n,\nvalue\n,\n/\n)\n\u00c2\u00b6\nInsert value into sequence at the given index .\nThis is equivalent to writing sequence[index:index] = [value] .\n\nsequence.\npop\n(\nindex\n=\n-1\n,\n/\n)\n\u00c2\u00b6\nRetrieve the item at index and also removes it from sequence .\nBy default, the last item in sequence is removed and returned.\n\nsequence.\nremove\n(\nvalue\n,\n/\n)\n\u00c2\u00b6\nRemove the first item from sequence where sequence[i] == value .\n\nRaises ValueError if value is not found in sequence .\n\nsequence.\nreverse\n(\n)\n\u00c2\u00b6\nReverse the items of sequence in place.\nThis method maintains economy of space when reversing a large sequence.\nTo remind users that it operates by side-effect, it returns None .\n\n### Lists\u00c2\u00b6\n\nLists are mutable sequences, typically used to store collections of\nhomogeneous items (where the precise degree of similarity will vary by\napplication).\n\nclass\nlist\n(\niterable\n=\n()\n,\n/\n)\n\u00c2\u00b6\nLists may be constructed in several ways:\n\n- Using a pair of square brackets to denote the empty list: []\n- Using square brackets, separating items with commas: [a] , [a, b, c]\n- Using a list comprehension: [x for x in iterable]\n- Using the type constructor: list() or list(iterable)\n\nThe constructor builds a list whose items are the same and in the same\norder as iterable \u00e2\u0080\u0099s items. iterable may be either a sequence, a\ncontainer that supports iteration, or an iterator object.  If iterable is already a list, a copy is made and returned, similar to iterable[:] .\nFor example, list('abc') returns ['a', 'b', 'c'] and list( (1, 2, 3) ) returns [1, 2, 3] .\nIf no argument is given, the constructor creates a new empty list, [] .\n\nMany other operations also produce lists, including the sorted() built-in.\n\nLists implement all of the common and mutable sequence operations. Lists also provide the\nfollowing additional method:\n\nsort\n(\n*\n,\nkey\n=\nNone\n,\nreverse\n=\nFalse\n)\n\u00c2\u00b6\nThis method sorts the list in place, using only < comparisons\nbetween items. Exceptions are not suppressed - if any comparison operations\nfail, the entire sort operation will fail (and the list will likely be left\nin a partially modified state).\n\nsort() accepts two arguments that can only be passed by keyword\n( keyword-only arguments ):\n\nkey specifies a function of one argument that is used to extract a\ncomparison key from each list element (for example, key=str.lower ).\nThe key corresponding to each item in the list is calculated once and\nthen used for the entire sorting process. The default value of None means that list items are sorted directly without calculating a separate\nkey value.\n\nThe functools.cmp_to_key() utility is available to convert a 2.x\nstyle cmp function to a key function.\n\nreverse is a boolean value.  If set to True , then the list elements\nare sorted as if each comparison were reversed.\n\nThis method modifies the sequence in place for economy of space when\nsorting a large sequence.  To remind users that it operates by side\neffect, it does not return the sorted sequence (use sorted() to\nexplicitly request a new sorted list instance).\n\nThe sort() method is guaranteed to be stable.  A sort is stable if it\nguarantees not to change the relative order of elements that compare equal\n\u00e2\u0080\u0094 this is helpful for sorting in multiple passes (for example, sort by\ndepartment, then by salary grade).\n\nFor sorting examples and a brief sorting tutorial, see Sorting Techniques .\n\nCPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even\ninspect, the list is undefined.  The C implementation of Python makes the\nlist appear empty for the duration, and raises ValueError if it can\ndetect that the list has been mutated during a sort.\n\nThread safety for list objects\n\nReading a single element from a list is atomic :\n\n```python\nlst[i]   # list.__getitem__\n```python\n\nThe following methods traverse the list and use atomic reads of each item to perform their function. That means that they may\nreturn results affected by concurrent modifications:\n\n```python\nitem in lst\nlst.index(item)\nlst.count(item)\n```python\n\nAll of the above operations avoid acquiring per-object locks . They do not block concurrent modifications. Other\noperations that hold a lock will not block these from observing intermediate\nstates.\n\nAll other operations from here on block using the per-object lock .\n\nWriting a single item via lst[i] = x is safe to call from multiple\nthreads and will not corrupt the list.\n\nThe following operations return new objects and appear atomic to other threads:\n\n```python\nlst1 + lst2    # concatenates two lists into a new list\nx * lst        # repeats lst x times into a new list\nlst.copy()     # returns a shallow copy of the list\n```python\n\nThe following methods that only operate on a single element with no shifting\nrequired are atomic :\n\n```python\nlst.append(x)  # append to the end of the list, no shifting required\nlst.pop()      # pop element from the end of the list, no shifting required\n```python\n\nThe clear() method is also atomic .\nOther threads cannot observe elements being removed.\n\nThe sort() method is not atomic .\nOther threads cannot observe intermediate states during sorting, but the\nlist appears empty for the duration of the sort.\n\nThe following operations may allow lock-free operations to observe\nintermediate states since they modify multiple elements in place:\n\n```python\nlst.insert(idx, item)  # shifts elements\nlst.pop(idx)           # idx not at the end of the list, shifts elements\nlst *= x               # copies elements in place\n```python\n\nThe remove() method may allow concurrent modifications since\nelement comparison may execute arbitrary Python code (via __eq__() ).\n\nextend() is safe to call from multiple threads.  However, its\nguarantees depend on the iterable passed to it. If it is a list , a tuple , a set , a frozenset , a dict or a dictionary view object (but not their subclasses), the extend operation is safe from concurrent modifications to the iterable.\nOtherwise, an iterator is created which can be concurrently modified by\nanother thread.  The same applies to inplace concatenation of a list with\nother iterables when using lst += iterable .\n\nSimilarly, assigning to a list slice with lst[i:j] = iterable is safe\nto call from multiple threads, but iterable is only locked when it is\nalso a list (but not its subclasses).\n\nOperations that involve multiple accesses, as well as iteration, are never\natomic. For example:\n\n```python\n# NOT atomic: read-modify-write\nlst[i] = lst[i] + 1\n\n# NOT atomic: check-then-act\nif lst:\n      item = lst.pop()\n\n# NOT thread-safe: iteration while modifying\nfor item in lst:\n      process(item)  # another thread may modify lst\n```python\n\nConsider external synchronization when sharing list instances\nacross threads.  See Python support for free threading for more information.\n\n### Tuples\u00c2\u00b6\n\nTuples are immutable sequences, typically used to store collections of\nheterogeneous data (such as the 2-tuples produced by the enumerate() built-in). Tuples are also used for cases where an immutable sequence of\nhomogeneous data is needed (such as allowing storage in a set or dict instance).\n\nclass\ntuple\n(\niterable\n=\n()\n,\n/\n)\n\u00c2\u00b6\nTuples may be constructed in a number of ways:\n\n- Using a pair of parentheses to denote the empty tuple: ()\n- Using a trailing comma for a singleton tuple: a, or (a,)\n- Separating items with commas: a, b, c or (a, b, c)\n- Using the tuple() built-in: tuple() or tuple(iterable)\n\nThe constructor builds a tuple whose items are the same and in the same\norder as iterable \u00e2\u0080\u0099s items. iterable may be either a sequence, a\ncontainer that supports iteration, or an iterator object.  If iterable is already a tuple, it is returned unchanged. For example, tuple('abc') returns ('a', 'b', 'c') and tuple( [1, 2, 3] ) returns (1, 2, 3) .\nIf no argument is given, the constructor creates a new empty tuple, () .\n\nNote that it is actually the comma which makes a tuple, not the parentheses.\nThe parentheses are optional, except in the empty tuple case, or\nwhen they are needed to avoid syntactic ambiguity. For example, f(a, b, c) is a function call with three arguments, while f((a, b, c)) is a function call with a 3-tuple as the sole argument.\n\nTuples implement all of the common sequence\noperations.\n\nFor heterogeneous collections of data where access by name is clearer than\naccess by index, collections.namedtuple() may be a more appropriate\nchoice than a simple tuple object.\n\n### Ranges\u00c2\u00b6\n\nThe range type represents an immutable sequence of numbers and is\ncommonly used for looping a specific number of times in for loops.\n\nclass\nrange\n(\nstop\n,\n/\n)\n\u00c2\u00b6\nclass\nrange\n(\nstart\n,\nstop\n,\nstep\n=\n1\n,\n/\n)\nThe arguments to the range constructor must be integers (either built-in int or any object that implements the __index__() special\nmethod).  If the step argument is omitted, it defaults to 1 .\nIf the start argument is omitted, it defaults to 0 .\nIf step is zero, ValueError is raised.\n\nFor a positive step , the contents of a range r are determined by the\nformula r[i] = start + step*i where i >= 0 and r[i] < stop .\n\nFor a negative step , the contents of the range are still determined by\nthe formula r[i] = start + step*i , but the constraints are i >= 0 and r[i] > stop .\n\nA range object will be empty if r[0] does not meet the value\nconstraint. Ranges do support negative indices, but these are interpreted\nas indexing from the end of the sequence determined by the positive\nindices.\n\nRanges containing absolute values larger than sys.maxsize are\npermitted but some features (such as len() ) may raise OverflowError .\n\nRange examples:\n\n```python\n>>> list(range(10))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> list(range(1, 11))\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n>>> list(range(0, 30, 5))\n[0, 5, 10, 15, 20, 25]\n>>> list(range(0, 10, 3))\n[0, 3, 6, 9]\n>>> list(range(0, -10, -1))\n[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]\n>>> list(range(0))\n[]\n>>> list(range(1, 0))\n[]\n```python\n\nRanges implement all of the common sequence operations\nexcept concatenation and repetition (due to the fact that range objects can\nonly represent sequences that follow a strict pattern and repetition and\nconcatenation will usually violate that pattern).\n\nstart\n\u00c2\u00b6\nThe value of the start parameter (or 0 if the parameter was\nnot supplied)\n\nstop\n\u00c2\u00b6\nThe value of the stop parameter\n\nstep\n\u00c2\u00b6\nThe value of the step parameter (or 1 if the parameter was\nnot supplied)\n\nThe advantage of the range type over a regular list or tuple is that a range object will always take the same\n(small) amount of memory, no matter the size of the range it represents (as it\nonly stores the start , stop and step values, calculating individual\nitems and subranges as needed).\n\nRange objects implement the collections.abc.Sequence ABC, and provide\nfeatures such as containment tests, element index lookup, slicing and\nsupport for negative indices (see Sequence Types \u00e2\u0080\u0094 list, tuple, range ):\n\n```python\n>>> r = range(0, 20, 2)\n>>> r\nrange(0, 20, 2)\n>>> 11 in r\nFalse\n>>> 10 in r\nTrue\n>>> r.index(10)\n5\n>>> r[5]\n10\n>>> r[:5]\nrange(0, 10, 2)\n>>> r[-1]\n18\n```python\n\nTesting range objects for equality with == and != compares\nthem as sequences.  That is, two range objects are considered equal if\nthey represent the same sequence of values.  (Note that two range\nobjects that compare equal might have different start , stop and step attributes, for example range(0) == range(2, 1, 3) or range(0, 3, 2) == range(0, 4, 2) .)\n\nChanged in version 3.2: Implement the Sequence ABC.\nSupport slicing and negative indices.\nTest int objects for membership in constant time instead of\niterating through all items.\n\nChanged in version 3.3: Define \u00e2\u0080\u0098==\u00e2\u0080\u0099 and \u00e2\u0080\u0098!=\u00e2\u0080\u0099 to compare range objects based on the\nsequence of values they define (instead of comparing based on\nobject identity).\n\nAdded the start , stop and step attributes.\n\nSee also\n\n- The linspace recipe shows how to implement a lazy version of range suitable for floating-point\napplications.\n\n## Text and Binary Sequence Type Methods Summary\u00c2\u00b6\n\nThe following table summarizes the text and binary sequence types methods by\ncategory.\n\n## Text Sequence Type \u00e2\u0080\u0094str\u00c2\u00b6\n\nTextual data in Python is handled with str objects, or strings .\nStrings are immutable sequences of Unicode code points.  String literals are\nwritten in a variety of ways:\n\n- Single quotes: 'allows embedded \"double\" quotes'\n- Double quotes: \"allows embedded 'single' quotes\"\n- Triple quoted: '''Three single quotes''' , \"\"\"Three double quotes\"\"\"\n\nTriple quoted strings may span multiple lines - all associated whitespace will\nbe included in the string literal.\n\nString literals that are part of a single expression and have only whitespace\nbetween them will be implicitly converted to a single string literal. That\nis, (\"spam \" \"eggs\") == \"spam eggs\" .\n\nSee String and Bytes literals for more about the various forms of string literal,\nincluding supported escape sequences , and the r (\u00e2\u0080\u009craw\u00e2\u0080\u009d) prefix that\ndisables most escape sequence processing.\n\nStrings may also be created from other objects using the str constructor.\n\nSince there is no separate \u00e2\u0080\u009ccharacter\u00e2\u0080\u009d type, indexing a string produces\nstrings of length 1. That is, for a non-empty string s , s[0] == s[0:1] .\n\nThere is also no mutable string type, but str.join() or io.StringIO can be used to efficiently construct strings from\nmultiple fragments.\n\nChanged in version 3.3: For backwards compatibility with the Python 2 series, the u prefix is\nonce again permitted on string literals. It has no effect on the meaning\nof string literals and cannot be combined with the r prefix.\n\nclass\nstr\n(\n*\n,\nencoding\n=\n'utf-8'\n,\nerrors\n=\n'strict'\n)\n\u00c2\u00b6\nclass\nstr\n(\nobject\n)\nclass\nstr\n(\nobject\n,\nencoding\n,\nerrors\n=\n'strict'\n)\nclass\nstr\n(\nobject\n,\n*\n,\nerrors\n)\nReturn a string version of object .  If object is not\nprovided, returns the empty string.  Otherwise, the behavior of str() depends on whether encoding or errors is given, as follows.\n\nIf neither encoding nor errors is given, str(object) returns type(object).__str__(object) ,\nwhich is the \u00e2\u0080\u009cinformal\u00e2\u0080\u009d or nicely\nprintable string representation of object .  For string objects, this is\nthe string itself.  If object does not have a __str__() method, then str() falls back to returning repr(object) .\n\nIf at least one of encoding or errors is given, object should be a bytes-like object (e.g. bytes or bytearray ).  In\nthis case, if object is a bytes (or bytearray ) object,\nthen str(bytes, encoding, errors) is equivalent to bytes.decode(encoding, errors) .  Otherwise, the bytes\nobject underlying the buffer object is obtained before calling bytes.decode() .  See Binary Sequence Types \u00e2\u0080\u0094 bytes, bytearray, memoryview and Buffer Protocol for information on buffer objects.\n\nPassing a bytes object to str() without the encoding or errors arguments falls under the first case of returning the informal\nstring representation (see also the -b command-line option to\nPython).  For example:\n\n```python\n>>> str(b'Zoot!')\n\"b'Zoot!'\"\n```python\n\nFor more information on the str class and its methods, see Text Sequence Type \u00e2\u0080\u0094 str and the String Methods section below.  To output\nformatted strings, see the f-strings and Format String Syntax sections.  In addition, see the Text Processing Services section.\n\n### String Methods\u00c2\u00b6\n\nStrings implement all of the common sequence\noperations, along with the additional methods described below.\n\nStrings also support two styles of string formatting, one providing a large\ndegree of flexibility and customization (see str.format() , Format String Syntax and Custom String Formatting ) and the other based on C printf style formatting that handles a narrower range of types and is\nslightly harder to use correctly, but is often faster for the cases it can\nhandle ( printf-style String Formatting ).\n\nThe Text Processing Services section of the standard library covers a number of\nother modules that provide various text related utilities (including regular\nexpression support in the re module).\n\nstr.\ncapitalize\n(\n)\n\u00c2\u00b6\nReturn a copy of the string with its first character capitalized and the\nrest lowercased.\n\nChanged in version 3.8: The first character is now put into titlecase rather than uppercase.\nThis means that characters like digraphs will only have their first\nletter capitalized, instead of the full character.\n\nstr.\ncasefold\n(\n)\n\u00c2\u00b6\nReturn a casefolded copy of the string. Casefolded strings may be used for\ncaseless matching.\n\nCasefolding is similar to lowercasing but more aggressive because it is\nintended to remove all case distinctions in a string. For example, the German\nlowercase letter '\u00c3\u009f' is equivalent to \"ss\" . Since it is already\nlowercase, lower() would do nothing to '\u00c3\u009f' ; casefold() converts it to \"ss\" .\nFor example:\n\n```python\n>>> 'stra\u00c3\u009fe'.lower()\n'stra\u00c3\u009fe'\n>>> 'stra\u00c3\u009fe'.casefold()\n'strasse'\n```python\n\nThe casefolding algorithm is described in section 3.13 \u00e2\u0080\u0098Default Case Folding\u00e2\u0080\u0099 of the Unicode Standard .\n\nAdded in version 3.3.\n\nstr.\ncenter\n(\nwidth\n,\nfillchar\n=\n'\n'\n,\n/\n)\n\u00c2\u00b6\nReturn centered in a string of length width . Padding is done using the\nspecified fillchar (default is an ASCII space). The original string is\nreturned if width is less than or equal to len(s) .  For example:\n\n```python\n>>> 'Python'.center(10)\n'  Python  '\n>>> 'Python'.center(10, '-')\n'--Python--'\n>>> 'Python'.center(4)\n'Python'\n```python\n\nstr.\ncount\n(\nsub\n[\n,\nstart\n[\n,\nend\n]\n]\n)\n\u00c2\u00b6\nReturn the number of non-overlapping occurrences of substring sub in the\nrange [ start , end ].  Optional arguments start and end are\ninterpreted as in slice notation.\n\nIf sub is empty, returns the number of empty strings between characters\nwhich is the length of the string plus one. For example:\n\n```python\n>>> 'spam, spam, spam'.count('spam')\n3\n>>> 'spam, spam, spam'.count('spam', 5)\n2\n>>> 'spam, spam, spam'.count('spam', 5, 10)\n1\n>>> 'spam, spam, spam'.count('eggs')\n0\n>>> 'spam, spam, spam'.count('')\n17\n```python\n\nstr.\nencode\n(\nencoding\n=\n'utf-8'\n,\nerrors\n=\n'strict'\n)\n\u00c2\u00b6\nReturn the string encoded to bytes .\n\nencoding defaults to 'utf-8' ;\nsee Standard Encodings for possible values.\n\nerrors controls how encoding errors are handled.\nIf 'strict' (the default), a UnicodeError exception is raised.\nOther possible values are 'ignore' , 'replace' , 'xmlcharrefreplace' , 'backslashreplace' and any\nother name registered via codecs.register_error() .\nSee Error Handlers for details.\n\nFor performance reasons, the value of errors is not checked for validity\nunless an encoding error actually occurs, Python Development Mode is enabled\nor a debug build is used.\nFor example:\n\n```python\n>>> encoded_str_to_bytes = 'Python'.encode()\n>>> type(encoded_str_to_bytes)\n<class 'bytes'>\n>>> encoded_str_to_bytes\nb'Python'\n```python\n\nChanged in version 3.1: Added support for keyword arguments.\n\nChanged in version 3.9: The value of the errors argument is now checked in Python Development Mode and\nin debug mode .\n\nstr.\nendswith\n(\nsuffix\n[\n,\nstart\n[\n,\nend\n]\n]\n)\n\u00c2\u00b6\nReturn True if the string ends with the specified suffix , otherwise return False . suffix can also be a tuple of suffixes to look for.  With optional start , test beginning at that position.  With optional end , stop comparing\nat that position. Using start and end is equivalent to str[start:end].endswith(suffix) . For example:\n\n```python\n>>> 'Python'.endswith('on')\nTrue\n>>> 'a tuple of suffixes'.endswith(('at', 'in'))\nFalse\n>>> 'a tuple of suffixes'.endswith(('at', 'es'))\nTrue\n>>> 'Python is amazing'.endswith('is', 0, 9)\nTrue\n```python\n\nSee also startswith() and removesuffix() .\n\nstr.\nexpandtabs\n(\ntabsize\n=\n8\n)\n\u00c2\u00b6\nReturn a copy of the string where all tab characters are replaced by one or\nmore spaces, depending on the current column and the given tab size.  Tab\npositions occur every tabsize characters (default is 8, giving tab\npositions at columns 0, 8, 16 and so on).  To expand the string, the current\ncolumn is set to zero and the string is examined character by character.  If\nthe character is a tab ( \\t ), one or more space characters are inserted\nin the result until the current column is equal to the next tab position.\n(The tab character itself is not copied.)  If the character is a newline\n( \\n ) or return ( \\r ), it is copied and the current column is reset to\nzero.  Any other character is copied unchanged and the current column is\nincremented by one regardless of how the character is represented when\nprinted. For example:\n\n```python\n>>> '01\\t012\\t0123\\t01234'.expandtabs()\n'01      012     0123    01234'\n>>> '01\\t012\\t0123\\t01234'.expandtabs(4)\n'01  012 0123    01234'\n>>> print('01\\t012\\n0123\\t01234'.expandtabs(4))\n01  012\n0123    01234\n```python\n\nstr.\nfind\n(\nsub\n[\n,\nstart\n[\n,\nend\n]\n]\n)\n\u00c2\u00b6\nReturn the lowest index in the string where substring sub is found within\nthe slice s[start:end] .  Optional arguments start and end are\ninterpreted as in slice notation.  Return -1 if sub is not found.\nFor example:\n\n```python\n>>> 'spam, spam, spam'.find('sp')\n0\n>>> 'spam, spam, spam'.find('sp', 5)\n6\n```python\n\nSee also rfind() and index() .\n\nNote\n\nThe find() method should be used only if you need to know the\nposition of sub .  To check if sub is a substring or not, use the in operator:\n\n```python\n>>> 'Py' in 'Python'\nTrue\n```python\n\nstr.\nformat\n(\n*\nargs\n,\n**\nkwargs\n)\n\u00c2\u00b6\nPerform a string formatting operation.  The string on which this method is\ncalled can contain literal text or replacement fields delimited by braces {} .  Each replacement field contains either the numeric index of a\npositional argument, or the name of a keyword argument.  Returns a copy of\nthe string where each replacement field is replaced with the string value of\nthe corresponding argument. For example:\n\n```python\n>>> \"The sum of 1 + 2 is {0}\".format(1+2)\n'The sum of 1 + 2 is 3'\n>>> \"The sum of {a} + {b} is {answer}\".format(answer=1+2, a=1, b=2)\n'The sum of 1 + 2 is 3'\n>>> \"{1} expects the {0} Inquisition!\".format(\"Spanish\", \"Nobody\")\n'Nobody expects the Spanish Inquisition!'\n```python\n\nSee Format String Syntax for a description of the various formatting options\nthat can be specified in format strings.\n\nNote\n\nWhen formatting a number ( int , float , complex , decimal.Decimal and subclasses) with the n type\n(ex: '{:n}'.format(1234) ), the function temporarily sets the LC_CTYPE locale to the LC_NUMERIC locale to decode decimal_point and thousands_sep fields of localeconv() if\nthey are non-ASCII or longer than 1 byte, and the LC_NUMERIC locale is\ndifferent than the LC_CTYPE locale.  This temporary change affects\nother threads.\n\nChanged in version 3.7: When formatting a number with the n type, the function sets\ntemporarily the LC_CTYPE locale to the LC_NUMERIC locale in some\ncases.\n\nstr.\nformat_map\n(\nmapping\n,\n/\n)\n\u00c2\u00b6\nSimilar to str.format(**mapping) , except that mapping is\nused directly and not copied to a dict .  This is useful\nif for example mapping is a dict subclass:\n\n```python\n>>> class Default(dict):\n...     def __missing__(self, key):\n...         return key\n...\n>>> '{name} was born in {country}'.format_map(Default(name='Guido'))\n'Guido was born in country'\n```python\n\nAdded in version 3.2.\n\nstr.\nindex\n(\nsub\n[\n,\nstart\n[\n,\nend\n]\n]\n)\n\u00c2\u00b6\nLike find() , but raise ValueError when the substring is\nnot found. For example:\n\n```python\n>>> 'spam, spam, spam'.index('spam')\n0\n>>> 'spam, spam, spam'.index('eggs')\nTraceback (most recent call last):\n  File \"<python-input-0>\", line 1, in <module>\n    'spam, spam, spam'.index('eggs')\n    ~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^\nValueError: substring not found\n```python\n\nSee also rindex() .\n\nstr.\nisalnum\n(\n)\n\u00c2\u00b6\nReturn True if all characters in the string are alphanumeric and there is at\nleast one character, False otherwise.  A character c is alphanumeric if one\nof the following returns True : c.isalpha() , c.isdecimal() , c.isdigit() , or c.isnumeric() . For example:\n\n```python\n.. doctest::\n```python\n\n```python\n>>> 'abc123'.isalnum()\nTrue\n>>> 'abc123!@#'.isalnum()\nFalse\n>>> ''.isalnum()\nFalse\n>>> ' '.isalnum()\nFalse\n```python\n\nstr.\nisalpha\n(\n)\n\u00c2\u00b6\nReturn True if all characters in the string are alphabetic and there is at least\none character, False otherwise.  Alphabetic characters are those characters defined\nin the Unicode character database as \u00e2\u0080\u009cLetter\u00e2\u0080\u009d, i.e., those with general category\nproperty being one of \u00e2\u0080\u009cLm\u00e2\u0080\u009d, \u00e2\u0080\u009cLt\u00e2\u0080\u009d, \u00e2\u0080\u009cLu\u00e2\u0080\u009d, \u00e2\u0080\u009cLl\u00e2\u0080\u009d, or \u00e2\u0080\u009cLo\u00e2\u0080\u009d.  Note that this is different\nfrom the Alphabetic property defined in the section 4.10 \u00e2\u0080\u0098Letters, Alphabetic, and\nIdeographic\u00e2\u0080\u0099 of the Unicode Standard .\nFor example:\n\n```python\n>>> 'Letters and spaces'.isalpha()\nFalse\n>>> 'LettersOnly'.isalpha()\nTrue\n>>> '\u00c2\u00b5'.isalpha()  # non-ASCII characters can be considered alphabetical too\nTrue\n```python\n\nSee Unicode Properties .\n\nstr.\nisascii\n(\n)\n\u00c2\u00b6\nReturn True if the string is empty or all characters in the string are ASCII, False otherwise.\nASCII characters have code points in the range U+0000-U+007F. For example:\n\n```python\n>>> 'ASCII characters'.isascii()\nTrue\n>>> '\u00c2\u00b5'.isascii()\nFalse\n```python\n\nAdded in version 3.7.\n\nstr.\nisdecimal\n(\n)\n\u00c2\u00b6\nReturn True if all characters in the string are decimal\ncharacters and there is at least one character, False otherwise. Decimal characters are those that can be used to form\nnumbers in base 10, such as U+0660, ARABIC-INDIC DIGIT\nZERO.  Formally a decimal character is a character in the Unicode\nGeneral Category \u00e2\u0080\u009cNd\u00e2\u0080\u009d. For example:\n\n```python\n>>> '0123456789'.isdecimal()\nTrue\n>>> '\u00d9\u00a0\u00d9\u00a1\u00d9\u00a2\u00d9\u00a3\u00d9\u00a4\u00d9\u00a5\u00d9\u00a6\u00d9\u00a7\u00d9\u00a8\u00d9\u00a9'.isdecimal()  # Arabic-Indic digits zero to nine\nTrue\n>>> 'alphabetic'.isdecimal()\nFalse\n```python\n\nstr.\nisdigit\n(\n)\n\u00c2\u00b6\nReturn True if all characters in the string are digits and there is at least one\ncharacter, False otherwise.  Digits include decimal characters and digits that need\nspecial handling, such as the compatibility superscript digits.\nThis covers digits which cannot be used to form numbers in base 10,\nlike the Kharosthi numbers.  Formally, a digit is a character that has the\nproperty value Numeric_Type=Digit or Numeric_Type=Decimal.\n\nstr.\nisidentifier\n(\n)\n\u00c2\u00b6\nReturn True if the string is a valid identifier according to the language\ndefinition, section Names (identifiers and keywords) .\n\nkeyword.iskeyword() can be used to test whether string s is a reserved\nidentifier, such as def and class .\n\nExample:\n\n```python\n>>> from keyword import iskeyword\n\n>>> 'hello'.isidentifier(), iskeyword('hello')\n(True, False)\n>>> 'def'.isidentifier(), iskeyword('def')\n(True, True)\n```python\n\nstr.\nislower\n(\n)\n\u00c2\u00b6\nReturn True if all cased characters [ 4 ] in the string are lowercase and\nthere is at least one cased character, False otherwise.\n\nstr.\nisnumeric\n(\n)\n\u00c2\u00b6\nReturn True if all characters in the string are numeric\ncharacters, and there is at least one character, False otherwise. Numeric characters include digit characters, and all characters\nthat have the Unicode numeric value property, e.g. U+2155,\nVULGAR FRACTION ONE FIFTH.  Formally, numeric characters are those with the property\nvalue Numeric_Type=Digit, Numeric_Type=Decimal or Numeric_Type=Numeric.\nFor example:\n\n```python\n>>> '0123456789'.isnumeric()\nTrue\n>>> '\u00d9\u00a0\u00d9\u00a1\u00d9\u00a2\u00d9\u00a3\u00d9\u00a4\u00d9\u00a5\u00d9\u00a6\u00d9\u00a7\u00d9\u00a8\u00d9\u00a9'.isnumeric()  # Arabic-indic digit zero to nine\nTrue\n>>> '\u00e2\n\u0095'.isnumeric()  # Vulgar fraction one fifth\nTrue\n>>> '\u00c2\u00b2'.isdecimal(), '\u00c2\u00b2'.isdigit(),  '\u00c2\u00b2'.isnumeric()\n(False, True, True)\n```python\n\nSee also isdecimal() and isdigit() . Numeric characters are\na superset of decimal numbers.\n\nstr.\nisprintable\n(\n)\n\u00c2\u00b6\nReturn True if all characters in the string are printable, False if it\ncontains at least one non-printable character.\n\nHere \u00e2\u0080\u009cprintable\u00e2\u0080\u009d means the character is suitable for repr() to use in\nits output; \u00e2\u0080\u009cnon-printable\u00e2\u0080\u009d means that repr() on built-in types will\nhex-escape the character.  It has no bearing on the handling of strings\nwritten to sys.stdout or sys.stderr .\n\nThe printable characters are those which in the Unicode character database\n(see unicodedata ) have a general category in group Letter, Mark,\nNumber, Punctuation, or Symbol (L, M, N, P, or S); plus the ASCII space 0x20.\nNonprintable characters are those in group Separator or Other (Z or C),\nexcept the ASCII space.\n\nFor example:\n\n```python\n>>> ''.isprintable(), ' '.isprintable()\n(True, True)\n>>> '\\t'.isprintable(), '\\n'.isprintable()\n(False, False)\n```python\n\nstr.\nisspace\n(\n)\n\u00c2\u00b6\nReturn True if there are only whitespace characters in the string and there is\nat least one character, False otherwise.\n\nA character is whitespace if in the Unicode character database\n(see unicodedata ), either its general category is Zs (\u00e2\u0080\u009cSeparator, space\u00e2\u0080\u009d), or its bidirectional class is one of WS , B , or S .\n\nstr.\nistitle\n(\n)\n\u00c2\u00b6\nReturn True if the string is a titlecased string and there is at least one\ncharacter, for example uppercase characters may only follow uncased characters\nand lowercase characters only cased ones.  Return False otherwise.\n\nFor example:\n\n```python\n>>> 'Spam, Spam, Spam'.istitle()\nTrue\n>>> 'spam, spam, spam'.istitle()\nFalse\n>>> 'SPAM, SPAM, SPAM'.istitle()\nFalse\n```python\n\nSee also title() .\n\nstr.\nisupper\n(\n)\n\u00c2\u00b6\nReturn True if all cased characters [ 4 ] in the string are uppercase and\nthere is at least one cased character, False otherwise.\n\n```python\n>>> 'BANANA'.isupper()\nTrue\n>>> 'banana'.isupper()\nFalse\n>>> 'baNana'.isupper()\nFalse\n>>> ' '.isupper()\nFalse\n```python\n\nstr.\njoin\n(\niterable\n,\n/\n)\n\u00c2\u00b6\nReturn a string which is the concatenation of the strings in iterable .\nA TypeError will be raised if there are any non-string values in iterable , including bytes objects.  The separator between\nelements is the string providing this method. For example:\n\n```python\n>>> ', '.join(['spam', 'spam', 'spam'])\n'spam, spam, spam'\n>>> '-'.join('Python')\n'P-y-t-h-o-n'\n```python\n\nSee also split() .\n\nstr.\nljust\n(\nwidth\n,\nfillchar\n=\n'\n'\n,\n/\n)\n\u00c2\u00b6\nReturn the string left justified in a string of length width . Padding is\ndone using the specified fillchar (default is an ASCII space). The\noriginal string is returned if width is less than or equal to len(s) .\n\nFor example:\n\n```python\n>>> 'Python'.ljust(10)\n'Python    '\n>>> 'Python'.ljust(10, '.')\n'Python....'\n>>> 'Monty Python'.ljust(10, '.')\n'Monty Python'\n```python\n\nSee also rjust() .\n\nstr.\nlower\n(\n)\n\u00c2\u00b6\nReturn a copy of the string with all the cased characters [ 4 ] converted to\nlowercase. For example:\n\n```python\n>>> 'Lower Method Example'.lower()\n'lower method example'\n```python\n\nThe lowercasing algorithm used is described in section 3.13 \u00e2\u0080\u0098Default Case Folding\u00e2\u0080\u0099 of the Unicode Standard .\n\nstr.\nlstrip\n(\nchars\n=\nNone\n,\n/\n)\n\u00c2\u00b6\nReturn a copy of the string with leading characters removed.  The chars argument is a string specifying the set of characters to be removed.  If omitted\nor None , the chars argument defaults to removing whitespace.  The chars argument is not a prefix; rather, all combinations of its values are stripped:\n\n```python\n>>> '   spacious   '.lstrip()\n'spacious   '\n>>> 'www.example.com'.lstrip('cmowz.')\n'example.com'\n```python\n\nSee str.removeprefix() for a method that will remove a single prefix\nstring rather than all of a set of characters.  For example:\n\n```python\n>>> 'Arthur: three!'.lstrip('Arthur: ')\n'ee!'\n>>> 'Arthur: three!'.removeprefix('Arthur: ')\n'three!'\n```python\n\nstatic\nstr.\nmaketrans\n(\ndict\n,\n/\n)\n\u00c2\u00b6\nstatic\nstr.\nmaketrans\n(\nfrom\n,\nto\n,\nremove=''\n,\n/\n)\nThis static method returns a translation table usable for str.translate() .\n\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters (strings of length 1) to Unicode ordinals,\nstrings (of arbitrary lengths) or None .  Character keys will then be\nconverted to ordinals.\n\nIf there are two arguments, they must be strings of equal length, and in the\nresulting dictionary, each character in from will be mapped to the character at\nthe same position in to .  If there is a third argument, it must be a string,\nwhose characters will be mapped to None in the result.\n\nstr.\npartition\n(\nsep\n,\n/\n)\n\u00c2\u00b6\nSplit the string at the first occurrence of sep , and return a 3-tuple\ncontaining the part before the separator, the separator itself, and the part\nafter the separator.  If the separator is not found, return a 3-tuple containing\nthe string itself, followed by two empty strings.\n\nFor example:\n\n```python\n>>> 'Monty Python'.partition(' ')\n('Monty', ' ', 'Python')\n>>> \"Monty Python's Flying Circus\".partition(' ')\n('Monty', ' ', \"Python's Flying Circus\")\n>>> 'Monty Python'.partition('-')\n('Monty Python', '', '')\n```python\n\nSee also rpartition() .\n\nstr.\nremoveprefix\n(\nprefix\n,\n/\n)\n\u00c2\u00b6\nIf the string starts with the prefix string, return string[len(prefix):] . Otherwise, return a copy of the original\nstring:\n\n```python\n>>> 'TestHook'.removeprefix('Test')\n'Hook'\n>>> 'BaseTestCase'.removeprefix('Test')\n'BaseTestCase'\n```python\n\nAdded in version 3.9.\n\nSee also removesuffix() and startswith() .\n\nstr.\nremovesuffix\n(\nsuffix\n,\n/\n)\n\u00c2\u00b6\nIf the string ends with the suffix string and that suffix is not empty,\nreturn string[:-len(suffix)] . Otherwise, return a copy of the\noriginal string:\n\n```python\n>>> 'MiscTests'.removesuffix('Tests')\n'Misc'\n>>> 'TmpDirMixin'.removesuffix('Tests')\n'TmpDirMixin'\n```python\n\nAdded in version 3.9.\n\nSee also removeprefix() and endswith() .\n\nstr.\nreplace\n(\nold\n,\nnew\n,\n/\n,\ncount\n=\n-1\n)\n\u00c2\u00b6\nReturn a copy of the string with all occurrences of substring old replaced by new .  If count is given, only the first count occurrences are replaced.\nIf count is not specified or -1 , then all occurrences are replaced.\nFor example:\n\n```python\n>>> 'spam, spam, spam'.replace('spam', 'eggs')\n'eggs, eggs, eggs'\n>>> 'spam, spam, spam'.replace('spam', 'eggs', 1)\n'eggs, spam, spam'\n```python\n\nChanged in version 3.13: count is now supported as a keyword argument.\n\nstr.\nrfind\n(\nsub\n[\n,\nstart\n[\n,\nend\n]\n]\n)\n\u00c2\u00b6\nReturn the highest index in the string where substring sub is found, such\nthat sub is contained within s[start:end] .  Optional arguments start and end are interpreted as in slice notation.  Return -1 on failure.\nFor example:\n\n```python\n>>> 'spam, spam, spam'.rfind('sp')\n12\n>>> 'spam, spam, spam'.rfind('sp', 0, 10)\n6\n```python\n\nSee also find() and rindex() .\n\nstr.\nrindex\n(\nsub\n[\n,\nstart\n[\n,\nend\n]\n]\n)\n\u00c2\u00b6\nLike rfind() but raises ValueError when the substring sub is not\nfound.\nFor example:\n\n```python\n>>> 'spam, spam, spam'.rindex('spam')\n12\n>>> 'spam, spam, spam'.rindex('eggs')\nTraceback (most recent call last):\n  File \"<stdin-0>\", line 1, in <module>\n    'spam, spam, spam'.rindex('eggs')\n    ~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^\nValueError: substring not found\n```python\n\nSee also index() and find() .\n\nstr.\nrjust\n(\nwidth\n,\nfillchar\n=\n'\n'\n,\n/\n)\n\u00c2\u00b6\nReturn the string right justified in a string of length width . Padding is\ndone using the specified fillchar (default is an ASCII space). The\noriginal string is returned if width is less than or equal to len(s) .\n\nstr.\nrpartition\n(\nsep\n,\n/\n)\n\u00c2\u00b6\nSplit the string at the last occurrence of sep , and return a 3-tuple\ncontaining the part before the separator, the separator itself, and the part\nafter the separator.  If the separator is not found, return a 3-tuple containing\ntwo empty strings, followed by the string itself.\n\nFor example:\n\n```python\n>>> 'Monty Python'.rpartition(' ')\n('Monty', ' ', 'Python')\n>>> \"Monty Python's Flying Circus\".rpartition(' ')\n(\"Monty Python's Flying\", ' ', 'Circus')\n>>> 'Monty Python'.rpartition('-')\n('', '', 'Monty Python')\n```python\n\nSee also partition() .\n\nstr.\nrsplit\n(\nsep\n=\nNone\n,\nmaxsplit\n=\n-1\n)\n\u00c2\u00b6\nReturn a list of the words in the string, using sep as the delimiter string.\nIf maxsplit is given, at most maxsplit splits are done, the rightmost ones.  If sep is not specified or None , any whitespace string is a\nseparator.  Except for splitting from the right, rsplit() behaves like split() which is described in detail below.\n\nstr.\nrstrip\n(\nchars\n=\nNone\n,\n/\n)\n\u00c2\u00b6\nReturn a copy of the string with trailing characters removed.  The chars argument is a string specifying the set of characters to be removed.  If omitted\nor None , the chars argument defaults to removing whitespace.  The chars argument is not a suffix; rather, all combinations of its values are stripped.\nFor example:\n\n```python\n>>> '   spacious   '.rstrip()\n'   spacious'\n>>> 'mississippi'.rstrip('ipz')\n'mississ'\n```python\n\nSee removesuffix() for a method that will remove a single suffix\nstring rather than all of a set of characters.  For example:\n\n```python\n>>> 'Monty Python'.rstrip(' Python')\n'M'\n>>> 'Monty Python'.removesuffix(' Python')\n'Monty'\n```python\n\nSee also strip() .\n\nstr.\nsplit\n(\nsep\n=\nNone\n,\nmaxsplit\n=\n-1\n)\n\u00c2\u00b6\nReturn a list of the words in the string, using sep as the delimiter\nstring.  If maxsplit is given, at most maxsplit splits are done (thus,\nthe list will have at most maxsplit+1 elements).  If maxsplit is not\nspecified or -1 , then there is no limit on the number of splits\n(all possible splits are made).\n\nIf sep is given, consecutive delimiters are not grouped together and are\ndeemed to delimit empty strings (for example, '1,,2'.split(',') returns ['1', '', '2'] ).  The sep argument may consist of multiple characters\nas a single delimiter (to split with multiple delimiters, use re.split() ). Splitting an empty string with a specified separator\nreturns [''] .\n\nFor example:\n\n```python\n>>> '1,2,3'.split(',')\n['1', '2', '3']\n>>> '1,2,3'.split(',', maxsplit=1)\n['1', '2,3']\n>>> '1,2,,3,'.split(',')\n['1', '2', '', '3', '']\n>>> '1<>2<>3<4'.split('<>')\n['1', '2', '3<4']\n```python\n\nIf sep is not specified or is None , a different splitting algorithm is\napplied: runs of consecutive whitespace are regarded as a single separator,\nand the result will contain no empty strings at the start or end if the\nstring has leading or trailing whitespace.  Consequently, splitting an empty\nstring or a string consisting of just whitespace with a None separator\nreturns [] .\n\nFor example:\n\n```python\n>>> '1 2 3'.split()\n['1', '2', '3']\n>>> '1 2 3'.split(maxsplit=1)\n['1', '2 3']\n>>> '   1   2   3   '.split()\n['1', '2', '3']\n```python\n\nIf sep is not specified or is None and maxsplit is 0 , only\nleading runs of consecutive whitespace are considered.\n\nFor example:\n\n```python\n>>> \"\".split(None, 0)\n[]\n>>> \"   \".split(None, 0)\n[]\n>>> \"   foo   \".split(maxsplit=0)\n['foo   ']\n```python\n\nSee also join() .\n\nstr.\nsplitlines\n(\nkeepends\n=\nFalse\n)\n\u00c2\u00b6\nReturn a list of the lines in the string, breaking at line boundaries.  Line\nbreaks are not included in the resulting list unless keepends is given and\ntrue.\n\nThis method splits on the following line boundaries.  In particular, the\nboundaries are a superset of universal newlines .\n\nChanged in version 3.2: \\v and \\f added to list of line boundaries.\n\nFor example:\n\n```python\n>>> 'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines()\n['ab c', '', 'de fg', 'kl']\n>>> 'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(keepends=True)\n['ab c\\n', '\\n', 'de fg\\r', 'kl\\r\\n']\n```python\n\nUnlike split() when a delimiter string sep is given, this\nmethod returns an empty list for the empty string, and a terminal line\nbreak does not result in an extra line:\n\n```python\n>>> \"\".splitlines()\n[]\n>>> \"One line\\n\".splitlines()\n['One line']\n```python\n\nFor comparison, split('\\n') gives:\n\n```python\n>>> ''.split('\\n')\n['']\n>>> 'Two lines\\n'.split('\\n')\n['Two lines', '']\n```python\n\nstr.\nstartswith\n(\nprefix\n[\n,\nstart\n[\n,\nend\n]\n]\n)\n\u00c2\u00b6\nReturn True if string starts with the prefix , otherwise return False . prefix can also be a tuple of prefixes to look for.  With optional start ,\ntest string beginning at that position.  With optional end , stop comparing\nstring at that position.\n\nFor example:\n\n```python\n>>> 'Python'.startswith('Py')\nTrue\n>>> 'a tuple of prefixes'.startswith(('at', 'a'))\nTrue\n>>> 'Python is amazing'.startswith('is', 7)\nTrue\n```python\n\nSee also endswith() and removeprefix() .\n\nstr.\nstrip\n(\nchars\n=\nNone\n,\n/\n)\n\u00c2\u00b6\nReturn a copy of the string with the leading and trailing characters removed.\nThe chars argument is a string specifying the set of characters to be removed.\nIf omitted or None , the chars argument defaults to removing whitespace.\nThe chars argument is not a prefix or suffix; rather, all combinations of its\nvalues are stripped.\n\nFor example:\n\n```python\n>>> '   spacious   '.strip()\n'spacious'\n>>> 'www.example.com'.strip('cmowz.')\n'example'\n```python\n\nThe outermost leading and trailing chars argument values are stripped\nfrom the string. Characters are removed from the leading end until\nreaching a string character that is not contained in the set of\ncharacters in chars . A similar action takes place on the trailing end.\n\nFor example:\n\n```python\n>>> comment_string = '#....... Section 3.2.1 Issue #32 .......'\n>>> comment_string.strip('.#! ')\n'Section 3.2.1 Issue #32'\n```python\n\nSee also rstrip() .\n\nstr.\nswapcase\n(\n)\n\u00c2\u00b6\nReturn a copy of the string with uppercase characters converted to lowercase and\nvice versa. Note that it is not necessarily true that s.swapcase().swapcase() == s .\n\nstr.\ntitle\n(\n)\n\u00c2\u00b6\nReturn a titlecased version of the string where words start with an uppercase\ncharacter and the remaining characters are lowercase.\n\nFor example:\n\n```python\n>>> 'Hello world'.title()\n'Hello World'\n```python\n\nThe algorithm uses a simple language-independent definition of a word as\ngroups of consecutive letters.  The definition works in many contexts but\nit means that apostrophes in contractions and possessives form word\nboundaries, which may not be the desired result:\n\n```python\n>>> \"they're bill's friends from the UK\".title()\n\"They'Re Bill'S Friends From The Uk\"\n```python\n\nThe string.capwords() function does not have this problem, as it\nsplits words on spaces only.\n\nAlternatively, a workaround for apostrophes can be constructed using regular\nexpressions:\n\n```python\n>>> import re\n>>> def titlecase(s):\n...     return re.sub(r\"[A-Za-z]+('[A-Za-z]+)?\",\n...                   lambda mo: mo.group(0).capitalize(),\n...                   s)\n...\n>>> titlecase(\"they're bill's friends.\")\n\"They're Bill's Friends.\"\n```python\n\nSee also istitle() .\n\nstr.\ntranslate\n(\ntable\n,\n/\n)\n\u00c2\u00b6\nReturn a copy of the string in which each character has been mapped through\nthe given translation table.  The table must be an object that implements\nindexing via __getitem__() , typically a mapping or sequence .  When indexed by a Unicode ordinal (an integer), the\ntable object can do any of the following: return a Unicode ordinal or a\nstring, to map the character to one or more other characters; return None , to delete the character from the return string; or raise a LookupError exception, to map the character to itself.\n\nYou can use str.maketrans() to create a translation map from\ncharacter-to-character mappings in different formats.\n\nSee also the codecs module for a more flexible approach to custom\ncharacter mappings.\n\nstr.\nupper\n(\n)\n\u00c2\u00b6\nReturn a copy of the string with all the cased characters [ 4 ] converted to\nuppercase.  Note that s.upper().isupper() might be False if s contains uncased characters or if the Unicode category of the resulting\ncharacter(s) is not \u00e2\u0080\u009cLu\u00e2\u0080\u009d (Letter, uppercase), but e.g. \u00e2\u0080\u009cLt\u00e2\u0080\u009d (Letter,\ntitlecase).\n\nThe uppercasing algorithm used is described in section 3.13 \u00e2\u0080\u0098Default Case Folding\u00e2\u0080\u0099 of the Unicode Standard .\n\nstr.\nzfill\n(\nwidth\n,\n/\n)\n\u00c2\u00b6\nReturn a copy of the string left filled with ASCII '0' digits to\nmake a string of length width . A leading sign prefix ( '+' / '-' )\nis handled by inserting the padding after the sign character rather\nthan before. The original string is returned if width is less than\nor equal to len(s) .\n\nFor example:\n\n```python\n>>> \"42\".zfill(5)\n'00042'\n>>> \"-42\".zfill(5)\n'-0042'\n```python\n\n### Formatted String Literals (f-strings)\u00c2\u00b6\n\nAdded in version 3.6.\n\nChanged in version 3.7: The await and async for can be used in expressions\nwithin f-strings.\n\nChanged in version 3.8: Added the debug specifier ( = )\n\nChanged in version 3.12: Many restrictions on expressions within f-strings have been removed.\nNotably, nested strings, comments, and backslashes are now permitted.\n\nAn f-string (formally a formatted string literal ) is\na string literal that is prefixed with f or F .\nThis type of string literal allows embedding the results of arbitrary Python\nexpressions within replacement fields , which are delimited by curly\nbrackets ( {} ).\nEach replacement field must contain an expression, optionally followed by:\n\n- a debug specifier \u00e2\u0080\u0093 an equal sign ( = );\n- a conversion specifier \u00e2\u0080\u0093 !s , !r or !a ; and/or\n- a format specifier prefixed with a colon ( : ).\n\nSee the Lexical Analysis section on f-strings for details\non the syntax of these fields.\n\n#### Debug specifier\u00c2\u00b6\n\nAdded in version 3.8.\n\nIf a debug specifier \u00e2\u0080\u0093 an equal sign ( = ) \u00e2\u0080\u0093 appears after the replacement\nfield expression, the resulting f-string will contain the expression\u00e2\u0080\u0099s source,\nthe equal sign, and the value of the expression.\nThis is often useful for debugging:\n\n```python\n>>> number = 14.3\n>>> f'{number=}'\n'number=14.3'\n```python\n\nWhitespace before, inside and after the expression, as well as whitespace\nafter the equal sign, is significant \u00e2\u0080\u0094 it is retained in the result:\n\n```python\n>>> f'{ number  -  4  = }'\n' number  -  4  = 10.3'\n```python\n\n#### Conversion specifier\u00c2\u00b6\n\nBy default, the value of a replacement field expression is converted to\na string using str() :\n\n```python\n>>> from fractions import Fraction\n>>> one_third = Fraction(1, 3)\n>>> f'{one_third}'\n'1/3'\n```python\n\nWhen a debug specifier but no format specifier is used, the default conversion\ninstead uses repr() :\n\n```python\n>>> f'{one_third = }'\n'one_third = Fraction(1, 3)'\n```python\n\nThe conversion can be specified explicitly using one of these specifiers:\n\n- !s for str()\n- !r for repr()\n- !a for ascii()\n\nFor example:\n\n```python\n>>> str(one_third)\n'1/3'\n>>> repr(one_third)\n'Fraction(1, 3)'\n\n>>> f'{one_third!s} is {one_third!r}'\n'1/3 is Fraction(1, 3)'\n\n>>> string = \"\u00c2\u00a1ko\u00c4\u008dka \u00f0\u009f\u0098\u00b8!\"\n>>> ascii(string)\n\"'\\\\xa1ko\\\\u010dka \\\\U0001f638!'\"\n\n>>> f'{string = !a}'\n\"string = '\\\\xa1ko\\\\u010dka \\\\U0001f638!'\"\n```python\n\n#### Format specifier\u00c2\u00b6\n\nAfter the expression has been evaluated, and possibly converted using an\nexplicit conversion specifier, it is formatted using the format() function.\nIf the replacement field includes a format specifier introduced by a colon\n( : ), the specifier is passed to format() as the second argument.\nThe result of format() is then used as the final value for the\nreplacement field. For example:\n\n```python\n>>> from fractions import Fraction\n>>> one_third = Fraction(1, 3)\n>>> f'{one_third:.6f}'\n'0.333333'\n>>> f'{one_third:_^+10}'\n'___+1/3___'\n>>> >>> f'{one_third!r:_^20}'\n'___Fraction(1, 3)___'\n>>> f'{one_third = :~>10}~'\n'one_third = ~~~~~~~1/3~'\n```python\n\n### Template String Literals (t-strings)\u00c2\u00b6\n\nAn t-string (formally a template string literal ) is\na string literal that is prefixed with t or T .\n\nThese strings follow the same syntax and evaluation rules as formatted string literals ,\nwith for the following differences:\n\n- Rather than evaluating to a str object, template string literals evaluate\nto a string.templatelib.Template object.\n- The format() protocol is not used.\nInstead, the format specifier and conversions (if any) are passed to\na new Interpolation object that is created\nfor each evaluated expression.\nIt is up to code that processes the resulting Template object to decide how to handle format specifiers and conversions.\n- Format specifiers containing nested replacement fields are evaluated eagerly,\nprior to being passed to the Interpolation object.\nFor instance, an interpolation of the form {amount:.{precision}f} will\nevaluate the inner expression {precision} to determine the value of the format_spec attribute.\nIf precision were to be 2 , the resulting format specifier\nwould be '.2f' .\n- When the equals sign '=' is provided in an interpolation expression,\nthe text of the expression is appended to the literal string that precedes\nthe relevant interpolation.\nThis includes the equals sign and any surrounding whitespace.\nThe Interpolation instance for the expression will be created as\nnormal, except that conversion will\nbe set to \u00e2\u0080\u0098 r \u00e2\u0080\u0099 ( repr() ) by default.\nIf an explicit conversion or format specifier are provided,\nthis will override the default behaviour.\n\n### printf-style String Formatting\u00c2\u00b6\n\nNote\n\nThe formatting operations described here exhibit a variety of quirks that\nlead to a number of common errors (such as failing to display tuples and\ndictionaries correctly).\n\nUsing formatted string literals , the str.format() interface, or string.Template may help avoid these errors.\nEach of these alternatives provides their own trade-offs and benefits of\nsimplicity, flexibility, and/or extensibility.\n\nString objects have one unique built-in operation: the % operator (modulo).\nThis is also known as the string formatting or interpolation operator.\nGiven format % values (where format is a string), % conversion\nspecifications in format are replaced with zero or more elements of values .\nThe effect is similar to using the sprintf() function in the C language.\nFor example:\n\n```python\n>>> print('%s has %d quote types.' % ('Python', 2))\nPython has 2 quote types.\n```python\n\nIf format requires a single argument, values may be a single non-tuple\nobject. [ 5 ] Otherwise, values must be a tuple with exactly the number of\nitems specified by the format string, or a single mapping object (for example, a\ndictionary).\n\nA conversion specifier contains two or more characters and has the following\ncomponents, which must occur in this order:\n\n- The '%' character, which marks the start of the specifier.\n- Mapping key (optional), consisting of a parenthesised sequence of characters\n(for example, (somename) ).\n- Conversion flags (optional), which affect the result of some conversion\ntypes.\n- Minimum field width (optional).  If specified as an '*' (asterisk), the\nactual width is read from the next element of the tuple in values , and the\nobject to convert comes after the minimum field width and optional precision.\n- Precision (optional), given as a '.' (dot) followed by the precision.  If\nspecified as '*' (an asterisk), the actual precision is read from the next\nelement of the tuple in values , and the value to convert comes after the\nprecision.\n- Length modifier (optional).\n- Conversion type.\n\nWhen the right argument is a dictionary (or other mapping type), then the\nformats in the string must include a parenthesised mapping key into that\ndictionary inserted immediately after the '%' character. The mapping key\nselects the value to be formatted from the mapping.  For example:\n\n```python\n>>> print('%(language)s has %(number)03d quote types.' %\n...       {'language': \"Python\", \"number\": 2})\nPython has 002 quote types.\n```python\n\nIn this case no * specifiers may occur in a format (since they require a\nsequential parameter list).\n\nThe conversion flag characters are:\n\nA length modifier ( h , l , or L ) may be present, but is ignored as it\nis not necessary for Python \u00e2\u0080\u0093 so e.g. %ld is identical to %d .\n\nThe conversion types are:\n\nNotes:\n\n- The alternate form causes a leading octal specifier ( '0o' ) to be\ninserted before the first digit.\n- The alternate form causes a leading '0x' or '0X' (depending on whether\nthe 'x' or 'X' format was used) to be inserted before the first digit.\n- The alternate form causes the result to always contain a decimal point, even if\nno digits follow it. The precision determines the number of digits after the decimal point and\ndefaults to 6.\n- The alternate form causes the result to always contain a decimal point, and\ntrailing zeroes are not removed as they would otherwise be. The precision determines the number of significant digits before and after the\ndecimal point and defaults to 6.\n- If precision is N , the output is truncated to N characters.\n- See PEP 237 .\n\nSince Python strings have an explicit length, %s conversions do not assume\nthat '\\0' is the end of the string.\n\nChanged in version 3.1: %f conversions for numbers whose absolute value is over 1e50 are no\nlonger replaced by %g conversions.\n\n## Binary Sequence Types \u00e2\u0080\u0094bytes,bytearray,memoryview\u00c2\u00b6\n\nThe core built-in types for manipulating binary data are bytes and bytearray . They are supported by memoryview which uses\nthe buffer protocol to access the memory of other\nbinary objects without needing to make a copy.\n\nThe array module supports efficient storage of basic data types like\n32-bit integers and IEEE754 double-precision floating values.\n\n### Bytes Objects\u00c2\u00b6\n\nBytes objects are immutable sequences of single bytes. Since many major\nbinary protocols are based on the ASCII text encoding, bytes objects offer\nseveral methods that are only valid when working with ASCII compatible\ndata and are closely related to string objects in a variety of other ways.\n\nclass\nbytes\n(\nsource\n=\nb''\n)\n\u00c2\u00b6\nclass\nbytes\n(\nsource\n,\nencoding\n,\nerrors\n=\n'strict'\n)\nFirstly, the syntax for bytes literals is largely the same as that for string\nliterals, except that a b prefix is added:\n\n- Single quotes: b'still allows embedded \"double\" quotes'\n- Double quotes: b\"still allows embedded 'single' quotes\"\n- Triple quoted: b'''3 single quotes''' , b\"\"\"3 double quotes\"\"\"\n\nOnly ASCII characters are permitted in bytes literals (regardless of the\ndeclared source code encoding). Any binary values over 127 must be entered\ninto bytes literals using the appropriate escape sequence.\n\nAs with string literals, bytes literals may also use a r prefix to disable\nprocessing of escape sequences. See String and Bytes literals for more about the various\nforms of bytes literal, including supported escape sequences.\n\nWhile bytes literals and representations are based on ASCII text, bytes\nobjects actually behave like immutable sequences of integers, with each\nvalue in the sequence restricted such that 0 <= x < 256 (attempts to\nviolate this restriction will trigger ValueError ). This is done\ndeliberately to emphasise that while many binary formats include ASCII based\nelements and can be usefully manipulated with some text-oriented algorithms,\nthis is not generally the case for arbitrary binary data (blindly applying\ntext processing algorithms to binary data formats that are not ASCII\ncompatible will usually lead to data corruption).\n\nIn addition to the literal forms, bytes objects can be created in a number of\nother ways:\n\n- A zero-filled bytes object of a specified length: bytes(10)\n- From an iterable of integers: bytes(range(20))\n- Copying existing binary data via the buffer protocol: bytes(obj)\n\nAlso see the bytes built-in.\n\nSince 2 hexadecimal digits correspond precisely to a single byte, hexadecimal\nnumbers are a commonly used format for describing binary data. Accordingly,\nthe bytes type has an additional class method to read data in that format:\n\nclassmethod\nfromhex\n(\nstring\n,\n/\n)\n\u00c2\u00b6\nThis bytes class method returns a bytes object, decoding the\ngiven string object.  The string must contain two hexadecimal digits per\nbyte, with ASCII whitespace being ignored.\n\n```python\n>>> bytes.fromhex('2Ef0 F1f2  ')\nb'.\\xf0\\xf1\\xf2'\n```python\n\nChanged in version 3.7: bytes.fromhex() now skips all ASCII whitespace in the string,\nnot just spaces.\n\nChanged in version 3.14: bytes.fromhex() now accepts ASCII bytes and bytes-like objects as input.\n\nA reverse conversion function exists to transform a bytes object into its\nhexadecimal representation.\n\nhex\n(\n*\n,\nbytes_per_sep\n=\n1\n)\n\u00c2\u00b6\nhex\n(\nsep\n,\nbytes_per_sep\n=\n1\n)\nReturn a string object containing two hexadecimal digits for each\nbyte in the instance.\n\n```python\n>>> b'\\xf0\\xf1\\xf2'.hex()\n'f0f1f2'\n```python\n\nIf you want to make the hex string easier to read, you can specify a\nsingle character separator sep parameter to include in the output.\nBy default, this separator will be included between each byte.\nA second optional bytes_per_sep parameter controls the spacing.\nPositive values calculate the separator position from the right,\nnegative values from the left.\n\n```python\n>>> value = b'\\xf0\\xf1\\xf2'\n>>> value.hex('-')\n'f0-f1-f2'\n>>> value.hex('_', 2)\n'f0_f1f2'\n>>> b'UUDDLRLRAB'.hex(' ', -4)\n'55554444 4c524c52 4142'\n```python\n\nAdded in version 3.5.\n\nChanged in version 3.8: bytes.hex() now supports optional sep and bytes_per_sep parameters to insert separators between bytes in the hex output.\n\nSince bytes objects are sequences of integers (akin to a tuple), for a bytes\nobject b , b[0] will be an integer, while b[0:1] will be a bytes\nobject of length 1.  (This contrasts with text strings, where both indexing\nand slicing will produce a string of length 1)\n\nThe representation of bytes objects uses the literal format ( b'...' )\nsince it is often more useful than e.g. bytes([46, 46, 46]) .  You can\nalways convert a bytes object into a list of integers using list(b) .\n\n### Bytearray Objects\u00c2\u00b6\n\nbytearray objects are a mutable counterpart to bytes objects.\n\nclass\nbytearray\n(\nsource\n=\nb''\n)\n\u00c2\u00b6\nclass\nbytearray\n(\nsource\n,\nencoding\n,\nerrors\n=\n'strict'\n)\nThere is no dedicated literal syntax for bytearray objects, instead\nthey are always created by calling the constructor:\n\n- Creating an empty instance: bytearray()\n- Creating a zero-filled instance with a given length: bytearray(10)\n- From an iterable of integers: bytearray(range(20))\n- Copying existing binary data via the buffer protocol: bytearray(b'Hi!')\n\nAs bytearray objects are mutable, they support the mutable sequence operations in addition to the\ncommon bytes and bytearray operations described in Bytes and Bytearray Operations .\n\nAlso see the bytearray built-in.\n\nSince 2 hexadecimal digits correspond precisely to a single byte, hexadecimal\nnumbers are a commonly used format for describing binary data. Accordingly,\nthe bytearray type has an additional class method to read data in that format:\n\nclassmethod\nfromhex\n(\nstring\n,\n/\n)\n\u00c2\u00b6\nThis bytearray class method returns bytearray object, decoding\nthe given string object.  The string must contain two hexadecimal digits\nper byte, with ASCII whitespace being ignored.\n\n```python\n>>> bytearray.fromhex('2Ef0 F1f2  ')\nbytearray(b'.\\xf0\\xf1\\xf2')\n```python\n\nChanged in version 3.7: bytearray.fromhex() now skips all ASCII whitespace in the string,\nnot just spaces.\n\nChanged in version 3.14: bytearray.fromhex() now accepts ASCII bytes and bytes-like objects as input.\n\nA reverse conversion function exists to transform a bytearray object into its\nhexadecimal representation.\n\nhex\n(\n*\n,\nbytes_per_sep\n=\n1\n)\n\u00c2\u00b6\nhex\n(\nsep\n,\nbytes_per_sep\n=\n1\n)\nReturn a string object containing two hexadecimal digits for each\nbyte in the instance.\n\n```python\n>>> bytearray(b'\\xf0\\xf1\\xf2').hex()\n'f0f1f2'\n```python\n\nAdded in version 3.5.\n\nChanged in version 3.8: Similar to bytes.hex() , bytearray.hex() now supports\noptional sep and bytes_per_sep parameters to insert separators\nbetween bytes in the hex output.\n\nresize\n(\nsize\n,\n/\n)\n\u00c2\u00b6\nResize the bytearray to contain size bytes. size must be\ngreater than or equal to 0.\n\nIf the bytearray needs to shrink, bytes beyond size are truncated.\n\nIf the bytearray needs to grow, all new bytes, those beyond size ,\nwill be set to null bytes.\n\nThis is equivalent to:\n\n```python\n>>> def resize(ba, size):\n...     if len(ba) > size:\n...         del ba[size:]\n...     else:\n...         ba += b'\\0' * (size - len(ba))\n```python\n\nExamples:\n\n```python\n>>> shrink = bytearray(b'abc')\n>>> shrink.resize(1)\n>>> (shrink, len(shrink))\n(bytearray(b'a'), 1)\n>>> grow = bytearray(b'abc')\n>>> grow.resize(5)\n>>> (grow, len(grow))\n(bytearray(b'abc\\x00\\x00'), 5)\n```python\n\nAdded in version 3.14.\n\nSince bytearray objects are sequences of integers (akin to a list), for a\nbytearray object b , b[0] will be an integer, while b[0:1] will be\na bytearray object of length 1.  (This contrasts with text strings, where\nboth indexing and slicing will produce a string of length 1)\n\nThe representation of bytearray objects uses the bytes literal format\n( bytearray(b'...') ) since it is often more useful than e.g. bytearray([46, 46, 46]) .  You can always convert a bytearray object into\na list of integers using list(b) .\n\n### Bytes and Bytearray Operations\u00c2\u00b6\n\nBoth bytes and bytearray objects support the common sequence operations. They interoperate not just with operands of the same\ntype, but with any bytes-like object . Due to this flexibility, they can be\nfreely mixed in operations without causing errors. However, the return type\nof the result may depend on the order of operands.\n\nNote\n\nThe methods on bytes and bytearray objects don\u00e2\u0080\u0099t accept strings as their\narguments, just as the methods on strings don\u00e2\u0080\u0099t accept bytes as their\narguments.  For example, you have to write:\n\n```python\na = \"abc\"\nb = a.replace(\"a\", \"f\")\n```python\n\nand:\n\n```python\na = b\"abc\"\nb = a.replace(b\"a\", b\"f\")\n```python\n\nSome bytes and bytearray operations assume the use of ASCII compatible\nbinary formats, and hence should be avoided when working with arbitrary\nbinary data. These restrictions are covered below.\n\nNote\n\nUsing these ASCII based operations to manipulate binary data that is not\nstored in an ASCII based format may lead to data corruption.\n\nThe following methods on bytes and bytearray objects can be used with\narbitrary binary data.\n\nbytes.\ncount\n(\nsub\n[\n,\nstart\n[\n,\nend\n]\n]\n)\n\u00c2\u00b6\nbytearray.\ncount\n(\nsub\n[\n,\nstart\n[\n,\nend\n]\n]\n)\n\u00c2\u00b6\nReturn the number of non-overlapping occurrences of subsequence sub in\nthe range [ start , end ].  Optional arguments start and end are\ninterpreted as in slice notation.\n\nThe subsequence to search for may be any bytes-like object or an\ninteger in the range 0 to 255.\n\nIf sub is empty, returns the number of empty slices between characters\nwhich is the length of the bytes object plus one.\n\nChanged in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.\n\nbytes.\nremoveprefix\n(\nprefix\n,\n/\n)\n\u00c2\u00b6\nbytearray.\nremoveprefix\n(\nprefix\n,\n/\n)\n\u00c2\u00b6\nIf the binary data starts with the prefix string, return bytes[len(prefix):] . Otherwise, return a copy of the original\nbinary data:\n\n```python\n>>> b'TestHook'.removeprefix(b'Test')\nb'Hook'\n>>> b'BaseTestCase'.removeprefix(b'Test')\nb'BaseTestCase'\n```python\n\nThe prefix may be any bytes-like object .\n\nNote\n\nThe bytearray version of this method does not operate in place -\nit always produces a new object, even if no changes were made.\n\nAdded in version 3.9.\n\nbytes.\nremovesuffix\n(\nsuffix\n,\n/\n)\n\u00c2\u00b6\nbytearray.\nremovesuffix\n(\nsuffix\n,\n/\n)\n\u00c2\u00b6\nIf the binary data ends with the suffix string and that suffix is\nnot empty, return bytes[:-len(suffix)] .  Otherwise, return a copy of\nthe original binary data:\n\n```python\n>>> b'MiscTests'.removesuffix(b'Tests')\nb'Misc'\n>>> b'TmpDirMixin'.removesuffix(b'Tests')\nb'TmpDirMixin'\n```python\n\nThe suffix may be any bytes-like object .\n\nNote\n\nThe bytearray version of this method does not operate in place -\nit always produces a new object, even if no changes were made.\n\nAdded in version 3.9.\n\nbytes.\ndecode\n(\nencoding\n=\n'utf-8'\n,\nerrors\n=\n'strict'\n)\n\u00c2\u00b6\nbytearray.\ndecode\n(\nencoding\n=\n'utf-8'\n,\nerrors\n=\n'strict'\n)\n\u00c2\u00b6\nReturn the bytes decoded to a str .\n\nencoding defaults to 'utf-8' ;\nsee Standard Encodings for possible values.\n\nerrors controls how decoding errors are handled.\nIf 'strict' (the default), a UnicodeError exception is raised.\nOther possible values are 'ignore' , 'replace' ,\nand any other name registered via codecs.register_error() .\nSee Error Handlers for details.\n\nFor performance reasons, the value of errors is not checked for validity\nunless a decoding error actually occurs, Python Development Mode is enabled or a debug build is used.\n\nNote\n\nPassing the encoding argument to str allows decoding any bytes-like object directly, without needing to make a temporary bytes or bytearray object.\n\nChanged in version 3.1: Added support for keyword arguments.\n\nChanged in version 3.9: The value of the errors argument is now checked in Python Development Mode and\nin debug mode .\n\nbytes.\nendswith\n(\nsuffix\n[\n,\nstart\n[\n,\nend\n]\n]\n)\n\u00c2\u00b6\nbytearray.\nendswith\n(\nsuffix\n[\n,\nstart\n[\n,\nend\n]\n]\n)\n\u00c2\u00b6\nReturn True if the binary data ends with the specified suffix ,\notherwise return False . suffix can also be a tuple of suffixes to\nlook for.  With optional start , test beginning at that position.  With\noptional end , stop comparing at that position.\n\nThe suffix(es) to search for may be any bytes-like object .\n\nbytes.\nfind\n(\nsub\n[\n,\nstart\n[\n,\nend\n]\n]\n)\n\u00c2\u00b6\nbytearray.\nfind\n(\nsub\n[\n,\nstart\n[\n,\nend\n]\n]\n)\n\u00c2\u00b6\nReturn the lowest index in the data where the subsequence sub is found,\nsuch that sub is contained in the slice s[start:end] .  Optional\narguments start and end are interpreted as in slice notation.  Return -1 if sub is not found.\n\nThe subsequence to search for may be any bytes-like object or an\ninteger in the range 0 to 255.\n\nNote\n\nThe find() method should be used only if you need to know the\nposition of sub .  To check if sub is a substring or not, use the in operator:\n\n```python\n>>> b'Py' in b'Python'\nTrue\n```python\n\nChanged in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.\n\nbytes.\nindex\n(\nsub\n[\n,\nstart\n[\n,\nend\n]\n]\n)\n\u00c2\u00b6\nbytearray.\nindex\n(\nsub\n[\n,\nstart\n[\n,\nend\n]\n]\n)\n\u00c2\u00b6\nLike find() , but raise ValueError when the\nsubsequence is not found.\n\nThe subsequence to search for may be any bytes-like object or an\ninteger in the range 0 to 255.\n\nChanged in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.\n\nbytes.\njoin\n(\niterable\n,\n/\n)\n\u00c2\u00b6\nbytearray.\njoin\n(\niterable\n,\n/\n)\n\u00c2\u00b6\nReturn a bytes or bytearray object which is the concatenation of the\nbinary data sequences in iterable .  A TypeError will be raised\nif there are any values in iterable that are not bytes-like\nobjects , including str objects.  The\nseparator between elements is the contents of the bytes or\nbytearray object providing this method.\n\nstatic\nbytes.\nmaketrans\n(\nfrom\n,\nto\n,\n/\n)\n\u00c2\u00b6\nstatic\nbytearray.\nmaketrans\n(\nfrom\n,\nto\n,\n/\n)\n\u00c2\u00b6\nThis static method returns a translation table usable for bytes.translate() that will map each character in from into the\ncharacter at the same position in to ; from and to must both be bytes-like objects and have the same length.\n\nAdded in version 3.1.\n\nbytes.\npartition\n(\nsep\n,\n/\n)\n\u00c2\u00b6\nbytearray.\npartition\n(\nsep\n,\n/\n)\n\u00c2\u00b6\nSplit the sequence at the first occurrence of sep , and return a 3-tuple\ncontaining the part before the separator, the separator itself or its\nbytearray copy, and the part after the separator.\nIf the separator is not found, return a 3-tuple\ncontaining a copy of the original sequence, followed by two empty bytes or\nbytearray objects.\n\nThe separator to search for may be any bytes-like object .\n\nbytes.\nreplace\n(\nold\n,\nnew\n,\ncount\n=\n-1\n,\n/\n)\n\u00c2\u00b6\nbytearray.\nreplace\n(\nold\n,\nnew\n,\ncount\n=\n-1\n,\n/\n)\n\u00c2\u00b6\nReturn a copy of the sequence with all occurrences of subsequence old replaced by new .  If the optional argument count is given, only the\nfirst count occurrences are replaced.\n\nThe subsequence to search for and its replacement may be any bytes-like object .\n\nNote\n\nThe bytearray version of this method does not operate in place - it\nalways produces a new object, even if no changes were made.\n\nbytes.\nrfind\n(\nsub\n[\n,\nstart\n[\n,\nend\n]\n]\n)\n\u00c2\u00b6\nbytearray.\nrfind\n(\nsub\n[\n,\nstart\n[\n,\nend\n]\n]\n)\n\u00c2\u00b6\nReturn the highest index in the sequence where the subsequence sub is\nfound, such that sub is contained within s[start:end] .  Optional\narguments start and end are interpreted as in slice notation. Return -1 on failure.\n\nThe subsequence to search for may be any bytes-like object or an\ninteger in the range 0 to 255.\n\nChanged in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.\n\nbytes.\nrindex\n(\nsub\n[\n,\nstart\n[\n,\nend\n]\n]\n)\n\u00c2\u00b6\nbytearray.\nrindex\n(\nsub\n[\n,\nstart\n[\n,\nend\n]\n]\n)\n\u00c2\u00b6\nLike rfind() but raises ValueError when the\nsubsequence sub is not found.\n\nThe subsequence to search for may be any bytes-like object or an\ninteger in the range 0 to 255.\n\nChanged in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.\n\nbytes.\nrpartition\n(\nsep\n,\n/\n)\n\u00c2\u00b6\nbytearray.\nrpartition\n(\nsep\n,\n/\n)\n\u00c2\u00b6\nSplit the sequence at the last occurrence of sep , and return a 3-tuple\ncontaining the part before the separator, the separator itself or its\nbytearray copy, and the part after the separator.\nIf the separator is not found, return a 3-tuple\ncontaining two empty bytes or bytearray objects, followed by a copy of the\noriginal sequence.\n\nThe separator to search for may be any bytes-like object .\n\nbytes.\nstartswith\n(\nprefix\n[\n,\nstart\n[\n,\nend\n]\n]\n)\n\u00c2\u00b6\nbytearray.\nstartswith\n(\nprefix\n[\n,\nstart\n[\n,\nend\n]\n]\n)\n\u00c2\u00b6\nReturn True if the binary data starts with the specified prefix ,\notherwise return False . prefix can also be a tuple of prefixes to\nlook for.  With optional start , test beginning at that position.  With\noptional end , stop comparing at that position.\n\nThe prefix(es) to search for may be any bytes-like object .\n\nbytes.\ntranslate\n(\ntable\n,\n/\n,\ndelete\n=\nb''\n)\n\u00c2\u00b6\nbytearray.\ntranslate\n(\ntable\n,\n/\n,\ndelete\n=\nb''\n)\n\u00c2\u00b6\nReturn a copy of the bytes or bytearray object where all bytes occurring in\nthe optional argument delete are removed, and the remaining bytes have\nbeen mapped through the given translation table, which must be a bytes\nobject of length 256.\n\nYou can use the bytes.maketrans() method to create a translation\ntable.\n\nSet the table argument to None for translations that only delete\ncharacters:\n\n```python\n>>> b'read this short text'.translate(None, b'aeiou')\nb'rd ths shrt txt'\n```python\n\nChanged in version 3.6: delete is now supported as a keyword argument.\n\nThe following methods on bytes and bytearray objects have default behaviours\nthat assume the use of ASCII compatible binary formats, but can still be used\nwith arbitrary binary data by passing appropriate arguments. Note that all of\nthe bytearray methods in this section do not operate in place, and instead\nproduce new objects.\n\nbytes.\ncenter\n(\nwidth\n,\nfillbyte\n=\nb'\n'\n,\n/\n)\n\u00c2\u00b6\nbytearray.\ncenter\n(\nwidth\n,\nfillbyte\n=\nb'\n'\n,\n/\n)\n\u00c2\u00b6\nReturn a copy of the object centered in a sequence of length width .\nPadding is done using the specified fillbyte (default is an ASCII\nspace). For bytes objects, the original sequence is returned if width is less than or equal to len(s) .\n\nNote\n\nThe bytearray version of this method does not operate in place -\nit always produces a new object, even if no changes were made.\n\nbytes.\nljust\n(\nwidth\n,\nfillbyte\n=\nb'\n'\n,\n/\n)\n\u00c2\u00b6\nbytearray.\nljust\n(\nwidth\n,\nfillbyte\n=\nb'\n'\n,\n/\n)\n\u00c2\u00b6\nReturn a copy of the object left justified in a sequence of length width .\nPadding is done using the specified fillbyte (default is an ASCII\nspace). For bytes objects, the original sequence is returned if width is less than or equal to len(s) .\n\nNote\n\nThe bytearray version of this method does not operate in place -\nit always produces a new object, even if no changes were made.\n\nbytes.\nlstrip\n(\nbytes\n=\nNone\n,\n/\n)\n\u00c2\u00b6\nbytearray.\nlstrip\n(\nbytes\n=\nNone\n,\n/\n)\n\u00c2\u00b6\nReturn a copy of the sequence with specified leading bytes removed.  The bytes argument is a binary sequence specifying the set of byte values to\nbe removed.  If omitted or None , the bytes argument defaults\nto removing ASCII whitespace.  The bytes argument is not a prefix;\nrather, all combinations of its values are stripped:\n\n```python\n>>> b'   spacious   '.lstrip()\nb'spacious   '\n>>> b'www.example.com'.lstrip(b'cmowz.')\nb'example.com'\n```python\n\nThe binary sequence of byte values to remove may be any bytes-like object . See removeprefix() for a method\nthat will remove a single prefix string rather than all of a set of\ncharacters.  For example:\n\n```python\n>>> b'Arthur: three!'.lstrip(b'Arthur: ')\nb'ee!'\n>>> b'Arthur: three!'.removeprefix(b'Arthur: ')\nb'three!'\n```python\n\nNote\n\nThe bytearray version of this method does not operate in place -\nit always produces a new object, even if no changes were made.\n\nbytes.\nrjust\n(\nwidth\n,\nfillbyte\n=\nb'\n'\n,\n/\n)\n\u00c2\u00b6\nbytearray.\nrjust\n(\nwidth\n,\nfillbyte\n=\nb'\n'\n,\n/\n)\n\u00c2\u00b6\nReturn a copy of the object right justified in a sequence of length width .\nPadding is done using the specified fillbyte (default is an ASCII\nspace). For bytes objects, the original sequence is returned if width is less than or equal to len(s) .\n\nNote\n\nThe bytearray version of this method does not operate in place -\nit always produces a new object, even if no changes were made.\n\nbytes.\nrsplit\n(\nsep\n=\nNone\n,\nmaxsplit\n=\n-1\n)\n\u00c2\u00b6\nbytearray.\nrsplit\n(\nsep\n=\nNone\n,\nmaxsplit\n=\n-1\n)\n\u00c2\u00b6\nSplit the binary sequence into subsequences of the same type, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits\nare done, the rightmost ones.  If sep is not specified or None ,\nany subsequence consisting solely of ASCII whitespace is a separator.\nExcept for splitting from the right, rsplit() behaves like split() which is described in detail below.\n\nbytes.\nrstrip\n(\nbytes\n=\nNone\n,\n/\n)\n\u00c2\u00b6\nbytearray.\nrstrip\n(\nbytes\n=\nNone\n,\n/\n)\n\u00c2\u00b6\nReturn a copy of the sequence with specified trailing bytes removed.  The bytes argument is a binary sequence specifying the set of byte values to\nbe removed.  If omitted or None , the bytes argument defaults to\nremoving ASCII whitespace.  The bytes argument is not a suffix; rather,\nall combinations of its values are stripped:\n\n```python\n>>> b'   spacious   '.rstrip()\nb'   spacious'\n>>> b'mississippi'.rstrip(b'ipz')\nb'mississ'\n```python\n\nThe binary sequence of byte values to remove may be any bytes-like object . See removesuffix() for a method\nthat will remove a single suffix string rather than all of a set of\ncharacters.  For example:\n\n```python\n>>> b'Monty Python'.rstrip(b' Python')\nb'M'\n>>> b'Monty Python'.removesuffix(b' Python')\nb'Monty'\n```python\n\nNote\n\nThe bytearray version of this method does not operate in place -\nit always produces a new object, even if no changes were made.\n\nbytes.\nsplit\n(\nsep\n=\nNone\n,\nmaxsplit\n=\n-1\n)\n\u00c2\u00b6\nbytearray.\nsplit\n(\nsep\n=\nNone\n,\nmaxsplit\n=\n-1\n)\n\u00c2\u00b6\nSplit the binary sequence into subsequences of the same type, using sep as the delimiter string. If maxsplit is given and non-negative, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements).  If maxsplit is not specified or is -1 , then there is no\nlimit on the number of splits (all possible splits are made).\n\nIf sep is given, consecutive delimiters are not grouped together and are\ndeemed to delimit empty subsequences (for example, b'1,,2'.split(b',') returns [b'1', b'', b'2'] ).  The sep argument may consist of a\nmultibyte sequence as a single delimiter. Splitting an empty sequence with\na specified separator returns [b''] or [bytearray(b'')] depending\non the type of object being split.  The sep argument may be any bytes-like object .\n\nFor example:\n\n```python\n>>> b'1,2,3'.split(b',')\n[b'1', b'2', b'3']\n>>> b'1,2,3'.split(b',', maxsplit=1)\n[b'1', b'2,3']\n>>> b'1,2,,3,'.split(b',')\n[b'1', b'2', b'', b'3', b'']\n>>> b'1<>2<>3<4'.split(b'<>')\n[b'1', b'2', b'3<4']\n```python\n\nIf sep is not specified or is None , a different splitting algorithm\nis applied: runs of consecutive ASCII whitespace are regarded as a single\nseparator, and the result will contain no empty strings at the start or\nend if the sequence has leading or trailing whitespace.  Consequently,\nsplitting an empty sequence or a sequence consisting solely of ASCII\nwhitespace without a specified separator returns [] .\n\nFor example:\n\n```python\n>>> b'1 2 3'.split()\n[b'1', b'2', b'3']\n>>> b'1 2 3'.split(maxsplit=1)\n[b'1', b'2 3']\n>>> b'   1   2   3   '.split()\n[b'1', b'2', b'3']\n```python\n\nbytes.\nstrip\n(\nbytes\n=\nNone\n,\n/\n)\n\u00c2\u00b6\nbytearray.\nstrip\n(\nbytes\n=\nNone\n,\n/\n)\n\u00c2\u00b6\nReturn a copy of the sequence with specified leading and trailing bytes\nremoved. The bytes argument is a binary sequence specifying the set of\nbyte values to be removed.  If omitted or None , the bytes argument defaults to removing ASCII whitespace. The bytes argument is\nnot a prefix or suffix; rather, all combinations of its values are\nstripped:\n\n```python\n>>> b'   spacious   '.strip()\nb'spacious'\n>>> b'www.example.com'.strip(b'cmowz.')\nb'example'\n```python\n\nThe binary sequence of byte values to remove may be any bytes-like object .\n\nNote\n\nThe bytearray version of this method does not operate in place -\nit always produces a new object, even if no changes were made.\n\nThe following methods on bytes and bytearray objects assume the use of ASCII\ncompatible binary formats and should not be applied to arbitrary binary data.\nNote that all of the bytearray methods in this section do not operate in\nplace, and instead produce new objects.\n\nbytes.\ncapitalize\n(\n)\n\u00c2\u00b6\nbytearray.\ncapitalize\n(\n)\n\u00c2\u00b6\nReturn a copy of the sequence with each byte interpreted as an ASCII\ncharacter, and the first byte capitalized and the rest lowercased.\nNon-ASCII byte values are passed through unchanged.\n\nNote\n\nThe bytearray version of this method does not operate in place - it\nalways produces a new object, even if no changes were made.\n\nbytes.\nexpandtabs\n(\ntabsize\n=\n8\n)\n\u00c2\u00b6\nbytearray.\nexpandtabs\n(\ntabsize\n=\n8\n)\n\u00c2\u00b6\nReturn a copy of the sequence where all ASCII tab characters are replaced\nby one or more ASCII spaces, depending on the current column and the given\ntab size.  Tab positions occur every tabsize bytes (default is 8,\ngiving tab positions at columns 0, 8, 16 and so on).  To expand the\nsequence, the current column is set to zero and the sequence is examined\nbyte by byte.  If the byte is an ASCII tab character ( b'\\t' ), one or\nmore space characters are inserted in the result until the current column\nis equal to the next tab position. (The tab character itself is not\ncopied.)  If the current byte is an ASCII newline ( b'\\n' ) or\ncarriage return ( b'\\r' ), it is copied and the current column is reset\nto zero.  Any other byte value is copied unchanged and the current column\nis incremented by one regardless of how the byte value is represented when\nprinted:\n\n```python\n>>> b'01\\t012\\t0123\\t01234'.expandtabs()\nb'01      012     0123    01234'\n>>> b'01\\t012\\t0123\\t01234'.expandtabs(4)\nb'01  012 0123    01234'\n```python\n\nNote\n\nThe bytearray version of this method does not operate in place - it\nalways produces a new object, even if no changes were made.\n\nbytes.\nisalnum\n(\n)\n\u00c2\u00b6\nbytearray.\nisalnum\n(\n)\n\u00c2\u00b6\nReturn True if all bytes in the sequence are alphabetical ASCII characters\nor ASCII decimal digits and the sequence is not empty, False otherwise.\nAlphabetic ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' . ASCII decimal\ndigits are those byte values in the sequence b'0123456789' .\n\nFor example:\n\n```python\n>>> b'ABCabc1'.isalnum()\nTrue\n>>> b'ABC abc1'.isalnum()\nFalse\n```python\n\nbytes.\nisalpha\n(\n)\n\u00c2\u00b6\nbytearray.\nisalpha\n(\n)\n\u00c2\u00b6\nReturn True if all bytes in the sequence are alphabetic ASCII characters\nand the sequence is not empty, False otherwise.  Alphabetic ASCII\ncharacters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' .\n\nFor example:\n\n```python\n>>> b'ABCabc'.isalpha()\nTrue\n>>> b'ABCabc1'.isalpha()\nFalse\n```python\n\nbytes.\nisascii\n(\n)\n\u00c2\u00b6\nbytearray.\nisascii\n(\n)\n\u00c2\u00b6\nReturn True if the sequence is empty or all bytes in the sequence are ASCII, False otherwise.\nASCII bytes are in the range 0-0x7F.\n\nAdded in version 3.7.\n\nbytes.\nisdigit\n(\n)\n\u00c2\u00b6\nbytearray.\nisdigit\n(\n)\n\u00c2\u00b6\nReturn True if all bytes in the sequence are ASCII decimal digits\nand the sequence is not empty, False otherwise. ASCII decimal digits are\nthose byte values in the sequence b'0123456789' .\n\nFor example:\n\n```python\n>>> b'1234'.isdigit()\nTrue\n>>> b'1.23'.isdigit()\nFalse\n```python\n\nbytes.\nislower\n(\n)\n\u00c2\u00b6\nbytearray.\nislower\n(\n)\n\u00c2\u00b6\nReturn True if there is at least one lowercase ASCII character\nin the sequence and no uppercase ASCII characters, False otherwise.\n\nFor example:\n\n```python\n>>> b'hello world'.islower()\nTrue\n>>> b'Hello world'.islower()\nFalse\n```python\n\nLowercase ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyz' . Uppercase ASCII characters\nare those byte values in the sequence b'ABCDEFGHIJKLMNOPQRSTUVWXYZ' .\n\nbytes.\nisspace\n(\n)\n\u00c2\u00b6\nbytearray.\nisspace\n(\n)\n\u00c2\u00b6\nReturn True if all bytes in the sequence are ASCII whitespace and the\nsequence is not empty, False otherwise.  ASCII whitespace characters are\nthose byte values in the sequence b' \\t\\n\\r\\x0b\\f' (space, tab, newline,\ncarriage return, vertical tab, form feed).\n\nbytes.\nistitle\n(\n)\n\u00c2\u00b6\nbytearray.\nistitle\n(\n)\n\u00c2\u00b6\nReturn True if the sequence is ASCII titlecase and the sequence is not\nempty, False otherwise. See bytes.title() for more details on the\ndefinition of \u00e2\u0080\u009ctitlecase\u00e2\u0080\u009d.\n\nFor example:\n\n```python\n>>> b'Hello World'.istitle()\nTrue\n>>> b'Hello world'.istitle()\nFalse\n```python\n\nbytes.\nisupper\n(\n)\n\u00c2\u00b6\nbytearray.\nisupper\n(\n)\n\u00c2\u00b6\nReturn True if there is at least one uppercase alphabetic ASCII character\nin the sequence and no lowercase ASCII characters, False otherwise.\n\nFor example:\n\n```python\n>>> b'HELLO WORLD'.isupper()\nTrue\n>>> b'Hello world'.isupper()\nFalse\n```python\n\nLowercase ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyz' . Uppercase ASCII characters\nare those byte values in the sequence b'ABCDEFGHIJKLMNOPQRSTUVWXYZ' .\n\nbytes.\nlower\n(\n)\n\u00c2\u00b6\nbytearray.\nlower\n(\n)\n\u00c2\u00b6\nReturn a copy of the sequence with all the uppercase ASCII characters\nconverted to their corresponding lowercase counterpart.\n\nFor example:\n\n```python\n>>> b'Hello World'.lower()\nb'hello world'\n```python\n\nLowercase ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyz' . Uppercase ASCII characters\nare those byte values in the sequence b'ABCDEFGHIJKLMNOPQRSTUVWXYZ' .\n\nNote\n\nThe bytearray version of this method does not operate in place - it\nalways produces a new object, even if no changes were made.\n\nbytes.\nsplitlines\n(\nkeepends\n=\nFalse\n)\n\u00c2\u00b6\nbytearray.\nsplitlines\n(\nkeepends\n=\nFalse\n)\n\u00c2\u00b6\nReturn a list of the lines in the binary sequence, breaking at ASCII\nline boundaries. This method uses the universal newlines approach\nto splitting lines. Line breaks are not included in the resulting list\nunless keepends is given and true.\n\nFor example:\n\n```python\n>>> b'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines()\n[b'ab c', b'', b'de fg', b'kl']\n>>> b'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(keepends=True)\n[b'ab c\\n', b'\\n', b'de fg\\r', b'kl\\r\\n']\n```python\n\nUnlike split() when a delimiter string sep is given, this\nmethod returns an empty list for the empty string, and a terminal line\nbreak does not result in an extra line:\n\n```python\n>>> b\"\".split(b'\\n'), b\"Two lines\\n\".split(b'\\n')\n([b''], [b'Two lines', b''])\n>>> b\"\".splitlines(), b\"One line\\n\".splitlines()\n([], [b'One line'])\n```python\n\nbytes.\nswapcase\n(\n)\n\u00c2\u00b6\nbytearray.\nswapcase\n(\n)\n\u00c2\u00b6\nReturn a copy of the sequence with all the lowercase ASCII characters\nconverted to their corresponding uppercase counterpart and vice-versa.\n\nFor example:\n\n```python\n>>> b'Hello World'.swapcase()\nb'hELLO wORLD'\n```python\n\nLowercase ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyz' . Uppercase ASCII characters\nare those byte values in the sequence b'ABCDEFGHIJKLMNOPQRSTUVWXYZ' .\n\nUnlike str.swapcase() , it is always the case that bin.swapcase().swapcase() == bin for the binary versions. Case\nconversions are symmetrical in ASCII, even though that is not generally\ntrue for arbitrary Unicode code points.\n\nNote\n\nThe bytearray version of this method does not operate in place - it\nalways produces a new object, even if no changes were made.\n\nbytes.\ntitle\n(\n)\n\u00c2\u00b6\nbytearray.\ntitle\n(\n)\n\u00c2\u00b6\nReturn a titlecased version of the binary sequence where words start with\nan uppercase ASCII character and the remaining characters are lowercase.\nUncased byte values are left unmodified.\n\nFor example:\n\n```python\n>>> b'Hello world'.title()\nb'Hello World'\n```python\n\nLowercase ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyz' . Uppercase ASCII characters\nare those byte values in the sequence b'ABCDEFGHIJKLMNOPQRSTUVWXYZ' .\nAll other byte values are uncased.\n\nThe algorithm uses a simple language-independent definition of a word as\ngroups of consecutive letters.  The definition works in many contexts but\nit means that apostrophes in contractions and possessives form word\nboundaries, which may not be the desired result:\n\n```python\n>>> b\"they're bill's friends from the UK\".title()\nb\"They'Re Bill'S Friends From The Uk\"\n```python\n\nA workaround for apostrophes can be constructed using regular expressions:\n\n```python\n>>> import re\n>>> def titlecase(s):\n...     return re.sub(rb\"[A-Za-z]+('[A-Za-z]+)?\",\n...                   lambda mo: mo.group(0)[0:1].upper() +\n...                              mo.group(0)[1:].lower(),\n...                   s)\n...\n>>> titlecase(b\"they're bill's friends.\")\nb\"They're Bill's Friends.\"\n```python\n\nNote\n\nThe bytearray version of this method does not operate in place - it\nalways produces a new object, even if no changes were made.\n\nbytes.\nupper\n(\n)\n\u00c2\u00b6\nbytearray.\nupper\n(\n)\n\u00c2\u00b6\nReturn a copy of the sequence with all the lowercase ASCII characters\nconverted to their corresponding uppercase counterpart.\n\nFor example:\n\n```python\n>>> b'Hello World'.upper()\nb'HELLO WORLD'\n```python\n\nLowercase ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyz' . Uppercase ASCII characters\nare those byte values in the sequence b'ABCDEFGHIJKLMNOPQRSTUVWXYZ' .\n\nNote\n\nThe bytearray version of this method does not operate in place - it\nalways produces a new object, even if no changes were made.\n\nbytes.\nzfill\n(\nwidth\n,\n/\n)\n\u00c2\u00b6\nbytearray.\nzfill\n(\nwidth\n,\n/\n)\n\u00c2\u00b6\nReturn a copy of the sequence left filled with ASCII b'0' digits to\nmake a sequence of length width . A leading sign prefix ( b'+' / b'-' ) is handled by inserting the padding after the sign character\nrather than before. For bytes objects, the original sequence is\nreturned if width is less than or equal to len(seq) .\n\nFor example:\n\n```python\n>>> b\"42\".zfill(5)\nb'00042'\n>>> b\"-42\".zfill(5)\nb'-0042'\n```python\n\nNote\n\nThe bytearray version of this method does not operate in place - it\nalways produces a new object, even if no changes were made.\n\n### printf-style Bytes Formatting\u00c2\u00b6\n\nNote\n\nThe formatting operations described here exhibit a variety of quirks that\nlead to a number of common errors (such as failing to display tuples and\ndictionaries correctly).  If the value being printed may be a tuple or\ndictionary, wrap it in a tuple.\n\nBytes objects ( bytes / bytearray ) have one unique built-in operation:\nthe % operator (modulo).\nThis is also known as the bytes formatting or interpolation operator.\nGiven format % values (where format is a bytes object), % conversion\nspecifications in format are replaced with zero or more elements of values .\nThe effect is similar to using the sprintf() in the C language.\n\nIf format requires a single argument, values may be a single non-tuple\nobject. [ 5 ] Otherwise, values must be a tuple with exactly the number of\nitems specified by the format bytes object, or a single mapping object (for\nexample, a dictionary).\n\nA conversion specifier contains two or more characters and has the following\ncomponents, which must occur in this order:\n\n- The '%' character, which marks the start of the specifier.\n- Mapping key (optional), consisting of a parenthesised sequence of characters\n(for example, (somename) ).\n- Conversion flags (optional), which affect the result of some conversion\ntypes.\n- Minimum field width (optional).  If specified as an '*' (asterisk), the\nactual width is read from the next element of the tuple in values , and the\nobject to convert comes after the minimum field width and optional precision.\n- Precision (optional), given as a '.' (dot) followed by the precision.  If\nspecified as '*' (an asterisk), the actual precision is read from the next\nelement of the tuple in values , and the value to convert comes after the\nprecision.\n- Length modifier (optional).\n- Conversion type.\n\nWhen the right argument is a dictionary (or other mapping type), then the\nformats in the bytes object must include a parenthesised mapping key into that\ndictionary inserted immediately after the '%' character. The mapping key\nselects the value to be formatted from the mapping.  For example:\n\n```python\n>>> print(b'%(language)s has %(number)03d quote types.' %\n...       {b'language': b\"Python\", b\"number\": 2})\nb'Python has 002 quote types.'\n```python\n\nIn this case no * specifiers may occur in a format (since they require a\nsequential parameter list).\n\nThe conversion flag characters are:\n\nA length modifier ( h , l , or L ) may be present, but is ignored as it\nis not necessary for Python \u00e2\u0080\u0093 so e.g. %ld is identical to %d .\n\nThe conversion types are:\n\nNotes:\n\n- The alternate form causes a leading octal specifier ( '0o' ) to be\ninserted before the first digit.\n- The alternate form causes a leading '0x' or '0X' (depending on whether\nthe 'x' or 'X' format was used) to be inserted before the first digit.\n- The alternate form causes the result to always contain a decimal point, even if\nno digits follow it. The precision determines the number of digits after the decimal point and\ndefaults to 6.\n- The alternate form causes the result to always contain a decimal point, and\ntrailing zeroes are not removed as they would otherwise be. The precision determines the number of significant digits before and after the\ndecimal point and defaults to 6.\n- If precision is N , the output is truncated to N characters.\n- b'%s' is deprecated, but will not be removed during the 3.x series.\n- b'%r' is deprecated, but will not be removed during the 3.x series.\n- See PEP 237 .\n\nNote\n\nThe bytearray version of this method does not operate in place - it\nalways produces a new object, even if no changes were made.\n\nSee also\n\nPEP 461 - Adding % formatting to bytes and bytearray\n\nAdded in version 3.5.\n\n### Memory Views\u00c2\u00b6\n\nmemoryview objects allow Python code to access the internal data\nof an object that supports the buffer protocol without\ncopying.\n\nclass\nmemoryview\n(\nobject\n)\n\u00c2\u00b6\nCreate a memoryview that references object . object must\nsupport the buffer protocol.  Built-in objects that support the buffer\nprotocol include bytes and bytearray .\n\nA memoryview has the notion of an element , which is the\natomic memory unit handled by the originating object .  For many simple\ntypes such as bytes and bytearray , an element is a single\nbyte, but other types such as array.array may have bigger elements.\n\nlen(view) is equal to the length of tolist , which\nis the nested list representation of the view. If view.ndim = 1 ,\nthis is equal to the number of elements in the view.\n\nChanged in version 3.12: If view.ndim == 0 , len(view) now raises TypeError instead of returning 1.\n\nThe itemsize attribute will give you the number of\nbytes in a single element.\n\nA memoryview supports slicing and indexing to expose its data.\nOne-dimensional slicing will result in a subview:\n\n```python\n>>> v = memoryview(b'abcefg')\n>>> v[1]\n98\n>>> v[-1]\n103\n>>> v[1:4]\n<memory at 0x7f3ddc9f4350>\n>>> bytes(v[1:4])\nb'bce'\n```python\n\nIf format is one of the native format specifiers\nfrom the struct module, indexing with an integer or a tuple of\nintegers is also supported and returns a single element with\nthe correct type.  One-dimensional memoryviews can be indexed\nwith an integer or a one-integer tuple.  Multi-dimensional memoryviews\ncan be indexed with tuples of exactly ndim integers where ndim is\nthe number of dimensions.  Zero-dimensional memoryviews can be indexed\nwith the empty tuple.\n\nHere is an example with a non-byte format:\n\n```python\n>>> import array\n>>> a = array.array('l', [-11111111, 22222222, -33333333, 44444444])\n>>> m = memoryview(a)\n>>> m[0]\n-11111111\n>>> m[-1]\n44444444\n>>> m[::2].tolist()\n[-11111111, -33333333]\n```python\n\nIf the underlying object is writable, the memoryview supports\none-dimensional slice assignment. Resizing is not allowed:\n\n```python\n>>> data = bytearray(b'abcefg')\n>>> v = memoryview(data)\n>>> v.readonly\nFalse\n>>> v[0] = ord(b'z')\n>>> data\nbytearray(b'zbcefg')\n>>> v[1:4] = b'123'\n>>> data\nbytearray(b'z123fg')\n>>> v[2:3] = b'spam'\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: memoryview assignment: lvalue and rvalue have different structures\n>>> v[2:6] = b'spam'\n>>> data\nbytearray(b'z1spam')\n```python\n\nOne-dimensional memoryviews of hashable (read-only) types with formats\n\u00e2\u0080\u0098B\u00e2\u0080\u0099, \u00e2\u0080\u0098b\u00e2\u0080\u0099 or \u00e2\u0080\u0098c\u00e2\u0080\u0099 are also hashable. The hash is defined as hash(m) == hash(m.tobytes()) :\n\n```python\n>>> v = memoryview(b'abcefg')\n>>> hash(v) == hash(b'abcefg')\nTrue\n>>> hash(v[2:4]) == hash(b'ce')\nTrue\n>>> hash(v[::-2]) == hash(b'abcefg'[::-2])\nTrue\n```python\n\nChanged in version 3.3: One-dimensional memoryviews can now be sliced.\nOne-dimensional memoryviews with formats \u00e2\u0080\u0098B\u00e2\u0080\u0099, \u00e2\u0080\u0098b\u00e2\u0080\u0099 or \u00e2\u0080\u0098c\u00e2\u0080\u0099 are now hashable .\n\nChanged in version 3.4: memoryview is now registered automatically with collections.abc.Sequence\n\nChanged in version 3.5: memoryviews can now be indexed with tuple of integers.\n\nChanged in version 3.14: memoryview is now a generic type .\n\nmemoryview has several methods:\n\n__eq__\n(\nexporter\n)\n\u00c2\u00b6\nA memoryview and a PEP 3118 exporter are equal if their shapes are\nequivalent and if all corresponding values are equal when the operands\u00e2\u0080\u0099\nrespective format codes are interpreted using struct syntax.\n\nFor the subset of struct format strings currently supported by tolist() , v and w are equal if v.tolist() == w.tolist() :\n\n```python\n>>> import array\n>>> a = array.array('I', [1, 2, 3, 4, 5])\n>>> b = array.array('d', [1.0, 2.0, 3.0, 4.0, 5.0])\n>>> c = array.array('b', [5, 3, 1])\n>>> x = memoryview(a)\n>>> y = memoryview(b)\n>>> x == a == y == b\nTrue\n>>> x.tolist() == a.tolist() == y.tolist() == b.tolist()\nTrue\n>>> z = y[::-2]\n>>> z == c\nTrue\n>>> z.tolist() == c.tolist()\nTrue\n```python\n\nIf either format string is not supported by the struct module,\nthen the objects will always compare as unequal (even if the format\nstrings and buffer contents are identical):\n\n```python\n>>> from ctypes import BigEndianStructure, c_long\n>>> class BEPoint(BigEndianStructure):\n...     _fields_ = [(\"x\", c_long), (\"y\", c_long)]\n...\n>>> point = BEPoint(100, 200)\n>>> a = memoryview(point)\n>>> b = memoryview(point)\n>>> a == point\nFalse\n>>> a == b\nFalse\n```python\n\nNote that, as with floating-point numbers, v is w does not imply v == w for memoryview objects.\n\nChanged in version 3.3: Previous versions compared the raw memory disregarding the item format\nand the logical array structure.\n\ntobytes\n(\norder\n=\n'C'\n)\n\u00c2\u00b6\nReturn the data in the buffer as a bytestring.  This is equivalent to\ncalling the bytes constructor on the memoryview.\n\n```python\n>>> m = memoryview(b\"abc\")\n>>> m.tobytes()\nb'abc'\n>>> bytes(m)\nb'abc'\n```python\n\nFor non-contiguous arrays the result is equal to the flattened list\nrepresentation with all elements converted to bytes. tobytes() supports all format strings, including those that are not in struct module syntax.\n\nAdded in version 3.8: order can be {\u00e2\u0080\u0098C\u00e2\u0080\u0099, \u00e2\u0080\u0098F\u00e2\u0080\u0099, \u00e2\u0080\u0098A\u00e2\u0080\u0099}.  When order is \u00e2\u0080\u0098C\u00e2\u0080\u0099 or \u00e2\u0080\u0098F\u00e2\u0080\u0099, the data\nof the original array is converted to C or Fortran order. For contiguous\nviews, \u00e2\u0080\u0098A\u00e2\u0080\u0099 returns an exact copy of the physical memory. In particular,\nin-memory Fortran order is preserved. For non-contiguous views, the\ndata is converted to C first. order=None is the same as order=\u00e2\u0080\u0099C\u00e2\u0080\u0099 .\n\nhex\n(\n*\n,\nbytes_per_sep\n=\n1\n)\n\u00c2\u00b6\nhex\n(\nsep\n,\nbytes_per_sep\n=\n1\n)\nReturn a string object containing two hexadecimal digits for each\nbyte in the buffer.\n\n```python\n>>> m = memoryview(b\"abc\")\n>>> m.hex()\n'616263'\n```python\n\nAdded in version 3.5.\n\nChanged in version 3.8: Similar to bytes.hex() , memoryview.hex() now supports\noptional sep and bytes_per_sep parameters to insert separators\nbetween bytes in the hex output.\n\ntolist\n(\n)\n\u00c2\u00b6\nReturn the data in the buffer as a list of elements.\n\n```python\n>>> memoryview(b'abc').tolist()\n[97, 98, 99]\n>>> import array\n>>> a = array.array('d', [1.1, 2.2, 3.3])\n>>> m = memoryview(a)\n>>> m.tolist()\n[1.1, 2.2, 3.3]\n```python\n\nChanged in version 3.3: tolist() now supports all single character native formats in struct module syntax as well as multi-dimensional\nrepresentations.\n\ntoreadonly\n(\n)\n\u00c2\u00b6\nReturn a readonly version of the memoryview object.  The original\nmemoryview object is unchanged.\n\n```python\n>>> m = memoryview(bytearray(b'abc'))\n>>> mm = m.toreadonly()\n>>> mm.tolist()\n[97, 98, 99]\n>>> mm[0] = 42\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: cannot modify read-only memory\n>>> m[0] = 43\n>>> mm.tolist()\n[43, 98, 99]\n```python\n\nAdded in version 3.8.\n\nrelease\n(\n)\n\u00c2\u00b6\nRelease the underlying buffer exposed by the memoryview object.  Many\nobjects take special actions when a view is held on them (for example,\na bytearray would temporarily forbid resizing); therefore,\ncalling release() is handy to remove these restrictions (and free any\ndangling resources) as soon as possible.\n\nAfter this method has been called, any further operation on the view\nraises a ValueError (except release() itself which can\nbe called multiple times):\n\n```python\n>>> m = memoryview(b'abc')\n>>> m.release()\n>>> m[0]\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: operation forbidden on released memoryview object\n```python\n\nThe context management protocol can be used for a similar effect,\nusing the with statement:\n\n```python\n>>> with memoryview(b'abc') as m:\n...     m[0]\n...\n97\n>>> m[0]\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: operation forbidden on released memoryview object\n```python\n\nAdded in version 3.2.\n\ncast\n(\nformat\n,\n/\n)\n\u00c2\u00b6\ncast\n(\nformat\n,\nshape\n,\n/\n)\nCast a memoryview to a new format or shape. shape defaults to [byte_length//new_itemsize] , which means that the result view\nwill be one-dimensional. The return value is a new memoryview, but\nthe buffer itself is not copied. Supported casts are 1D -> C- contiguous and C-contiguous -> 1D.\n\nThe destination format is restricted to a single element native format in struct syntax. One of the formats must be a byte format\n(\u00e2\u0080\u0098B\u00e2\u0080\u0099, \u00e2\u0080\u0098b\u00e2\u0080\u0099 or \u00e2\u0080\u0098c\u00e2\u0080\u0099). The byte length of the result must be the same\nas the original length.\nNote that all byte lengths may depend on the operating system.\n\nCast 1D/long to 1D/unsigned bytes:\n\n```python\n>>> import array\n>>> a = array.array('l', [1,2,3])\n>>> x = memoryview(a)\n>>> x.format\n'l'\n>>> x.itemsize\n8\n>>> len(x)\n3\n>>> x.nbytes\n24\n>>> y = x.cast('B')\n>>> y.format\n'B'\n>>> y.itemsize\n1\n>>> len(y)\n24\n>>> y.nbytes\n24\n```python\n\nCast 1D/unsigned bytes to 1D/char:\n\n```python\n>>> b = bytearray(b'zyz')\n>>> x = memoryview(b)\n>>> x[0] = b'a'\nTraceback (most recent call last):\n  ...\nTypeError: memoryview: invalid type for format 'B'\n>>> y = x.cast('c')\n>>> y[0] = b'a'\n>>> b\nbytearray(b'ayz')\n```python\n\nCast 1D/bytes to 3D/ints to 1D/signed char:\n\n```python\n>>> import struct\n>>> buf = struct.pack(\"i\"*12, *list(range(12)))\n>>> x = memoryview(buf)\n>>> y = x.cast('i', shape=[2,2,3])\n>>> y.tolist()\n[[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]\n>>> y.format\n'i'\n>>> y.itemsize\n4\n>>> len(y)\n2\n>>> y.nbytes\n48\n>>> z = y.cast('b')\n>>> z.format\n'b'\n>>> z.itemsize\n1\n>>> len(z)\n48\n>>> z.nbytes\n48\n```python\n\nCast 1D/unsigned long to 2D/unsigned long:\n\n```python\n>>> buf = struct.pack(\"L\"*6, *list(range(6)))\n>>> x = memoryview(buf)\n>>> y = x.cast('L', shape=[2,3])\n>>> len(y)\n2\n>>> y.nbytes\n48\n>>> y.tolist()\n[[0, 1, 2], [3, 4, 5]]\n```python\n\nAdded in version 3.3.\n\nChanged in version 3.5: The source format is no longer restricted when casting to a byte view.\n\ncount\n(\nvalue\n,\n/\n)\n\u00c2\u00b6\nCount the number of occurrences of value .\n\nAdded in version 3.14.\n\nindex\n(\nvalue\n,\nstart\n=\n0\n,\nstop\n=\nsys.maxsize\n,\n/\n)\n\u00c2\u00b6\nReturn the index of the first occurrence of value (at or after\nindex start and before index stop ).\n\nRaises a ValueError if value cannot be found.\n\nAdded in version 3.14.\n\nThere are also several readonly attributes available:\n\nobj\n\u00c2\u00b6\nThe underlying object of the memoryview:\n\n```python\n>>> b  = bytearray(b'xyz')\n>>> m = memoryview(b)\n>>> m.obj is b\nTrue\n```python\n\nAdded in version 3.3.\n\nnbytes\n\u00c2\u00b6\nnbytes == product(shape) * itemsize == len(m.tobytes()) . This is\nthe amount of space in bytes that the array would use in a contiguous\nrepresentation. It is not necessarily equal to len(m) :\n\n```python\n>>> import array\n>>> a = array.array('i', [1,2,3,4,5])\n>>> m = memoryview(a)\n>>> len(m)\n5\n>>> m.nbytes\n20\n>>> y = m[::2]\n>>> len(y)\n3\n>>> y.nbytes\n12\n>>> len(y.tobytes())\n12\n```python\n\nMulti-dimensional arrays:\n\n```python\n>>> import struct\n>>> buf = struct.pack(\"d\"*12, *[1.5*x for x in range(12)])\n>>> x = memoryview(buf)\n>>> y = x.cast('d', shape=[3,4])\n>>> y.tolist()\n[[0.0, 1.5, 3.0, 4.5], [6.0, 7.5, 9.0, 10.5], [12.0, 13.5, 15.0, 16.5]]\n>>> len(y)\n3\n>>> y.nbytes\n96\n```python\n\nAdded in version 3.3.\n\nreadonly\n\u00c2\u00b6\nA bool indicating whether the memory is read only.\n\nformat\n\u00c2\u00b6\nA string containing the format (in struct module style) for each\nelement in the view. A memoryview can be created from exporters with\narbitrary format strings, but some methods (e.g. tolist() ) are\nrestricted to native single element formats.\n\nChanged in version 3.3: format 'B' is now handled according to the struct module syntax.\nThis means that memoryview(b'abc')[0] == b'abc'[0] == 97 .\n\nitemsize\n\u00c2\u00b6\nThe size in bytes of each element of the memoryview:\n\n```python\n>>> import array, struct\n>>> m = memoryview(array.array('H', [32000, 32001, 32002]))\n>>> m.itemsize\n2\n>>> m[0]\n32000\n>>> struct.calcsize('H') == m.itemsize\nTrue\n```python\n\nndim\n\u00c2\u00b6\nAn integer indicating how many dimensions of a multi-dimensional array the\nmemory represents.\n\nshape\n\u00c2\u00b6\nA tuple of integers the length of ndim giving the shape of the\nmemory as an N-dimensional array.\n\nChanged in version 3.3: An empty tuple instead of None when ndim = 0.\n\nstrides\n\u00c2\u00b6\nA tuple of integers the length of ndim giving the size in bytes to\naccess each element for each dimension of the array.\n\nChanged in version 3.3: An empty tuple instead of None when ndim = 0.\n\nsuboffsets\n\u00c2\u00b6\nUsed internally for PIL-style arrays. The value is informational only.\n\nc_contiguous\n\u00c2\u00b6\nA bool indicating whether the memory is C- contiguous .\n\nAdded in version 3.3.\n\nf_contiguous\n\u00c2\u00b6\nA bool indicating whether the memory is Fortran contiguous .\n\nAdded in version 3.3.\n\ncontiguous\n\u00c2\u00b6\nA bool indicating whether the memory is contiguous .\n\nAdded in version 3.3.\n\n## Set Types \u00e2\u0080\u0094set,frozenset\u00c2\u00b6\n\nA set object is an unordered collection of distinct hashable objects.\nCommon uses include membership testing, removing duplicates from a sequence, and\ncomputing mathematical operations such as intersection, union, difference, and\nsymmetric difference.\n(For other containers see the built-in dict , list ,\nand tuple classes, and the collections module.)\n\nLike other collections, sets support x in set , len(set) , and for x in set .  Being an unordered collection, sets do not record element position or\norder of insertion.  Accordingly, sets do not support indexing, slicing, or\nother sequence-like behavior.\n\nThere are currently two built-in set types, set and frozenset .\nThe set type is mutable \u00e2\u0080\u0094 the contents can be changed using methods\nlike add() and remove() .\nSince it is mutable, it has no hash value and cannot be used as\neither a dictionary key or as an element of another set.\nThe frozenset type is immutable and hashable \u00e2\u0080\u0094\nits contents cannot be altered after it is created;\nit can therefore be used as a dictionary key or as an element of another set.\n\nNon-empty sets (not frozensets) can be created by placing a comma-separated list\nof elements within braces, for example: {'jack', 'sjoerd'} , in addition to the set constructor.\n\nThe constructors for both classes work the same:\n\nclass\nset\n(\niterable\n=\n()\n,\n/\n)\n\u00c2\u00b6\nclass\nfrozenset\n(\niterable\n=\n()\n,\n/\n)\n\u00c2\u00b6\nReturn a new set or frozenset object whose elements are taken from iterable .  The elements of a set must be hashable .  To\nrepresent sets of sets, the inner sets must be frozenset objects.  If iterable is not specified, a new empty set is\nreturned.\n\nSets can be created by several means:\n\n- Use a comma-separated list of elements within braces: {'jack', 'sjoerd'}\n- Use a set comprehension: {c for c in 'abracadabra' if c not in 'abc'}\n- Use the type constructor: set() , set('foobar') , set(['a', 'b', 'foo'])\n\nInstances of set and frozenset provide the following\noperations:\n\nlen(s)\nReturn the number of elements in set s (cardinality of s ).\n\nx\nin\ns\nTest x for membership in s .\n\nx\nnot\nin\ns\nTest x for non-membership in s .\n\nfrozenset.\nisdisjoint\n(\nother\n,\n/\n)\n\u00c2\u00b6\nset.\nisdisjoint\n(\nother\n,\n/\n)\n\u00c2\u00b6\nReturn True if the set has no elements in common with other .  Sets are\ndisjoint if and only if their intersection is the empty set.\n\nfrozenset.\nissubset\n(\nother\n,\n/\n)\n\u00c2\u00b6\nset.\nissubset\n(\nother\n,\n/\n)\n\u00c2\u00b6\nset\n<=\nother\nTest whether every element in the set is in other .\n\nset\n<\nother\nTest whether the set is a proper subset of other , that is, set <= other and set != other .\n\nfrozenset.\nissuperset\n(\nother\n,\n/\n)\n\u00c2\u00b6\nset.\nissuperset\n(\nother\n,\n/\n)\n\u00c2\u00b6\nset\n>=\nother\nTest whether every element in other is in the set.\n\nset\n>\nother\nTest whether the set is a proper superset of other , that is, set >= other and set != other .\n\nfrozenset.\nunion\n(\n*\nothers\n)\n\u00c2\u00b6\nset.\nunion\n(\n*\nothers\n)\n\u00c2\u00b6\nset\n|\nother\n|\n...\nReturn a new set with elements from the set and all others.\n\nfrozenset.\nintersection\n(\n*\nothers\n)\n\u00c2\u00b6\nset.\nintersection\n(\n*\nothers\n)\n\u00c2\u00b6\nset\n&\nother\n&\n...\nReturn a new set with elements common to the set and all others.\n\nfrozenset.\ndifference\n(\n*\nothers\n)\n\u00c2\u00b6\nset.\ndifference\n(\n*\nothers\n)\n\u00c2\u00b6\nset\n-\nother\n-\n...\nReturn a new set with elements in the set that are not in the others.\n\nfrozenset.\nsymmetric_difference\n(\nother\n,\n/\n)\n\u00c2\u00b6\nset.\nsymmetric_difference\n(\nother\n,\n/\n)\n\u00c2\u00b6\nset\n^\nother\nReturn a new set with elements in either the set or other but not both.\n\nfrozenset.\ncopy\n(\n)\n\u00c2\u00b6\nset.\ncopy\n(\n)\n\u00c2\u00b6\nReturn a shallow copy of the set.\n\nNote, the non-operator versions of union() , intersection() , difference() , symmetric_difference() , issubset() , and issuperset() methods will accept any iterable as an argument.  In\ncontrast, their operator based counterparts require their arguments to be\nsets.  This precludes error-prone constructions like set('abc') & 'cbs' in favor of the more readable set('abc').intersection('cbs') .\n\nBoth set and frozenset support set to set comparisons. Two\nsets are equal if and only if every element of each set is contained in the\nother (each is a subset of the other). A set is less than another set if and\nonly if the first set is a proper subset of the second set (is a subset, but\nis not equal). A set is greater than another set if and only if the first set\nis a proper superset of the second set (is a superset, but is not equal).\n\nInstances of set are compared to instances of frozenset based on their members.  For example, set('abc') == frozenset('abc') returns True and so does set('abc') in set([frozenset('abc')]) .\n\nThe subset and equality comparisons do not generalize to a total ordering\nfunction.  For example, any two nonempty disjoint sets are not equal and are not\nsubsets of each other, so all of the following return False : a<b , a==b , or a>b .\n\nSince sets only define partial ordering (subset relationships), the output of\nthe list.sort() method is undefined for lists of sets.\n\nSet elements, like dictionary keys, must be hashable .\n\nBinary operations that mix set instances with frozenset return the type of the first operand.  For example: frozenset('ab') | set('bc') returns an instance of frozenset .\n\nThe following table lists operations available for set that do not\napply to immutable instances of frozenset :\n\nset.\nupdate\n(\n*\nothers\n)\n\u00c2\u00b6\nset\n|=\nother\n|\n...\nUpdate the set, adding elements from all others.\n\nset.\nintersection_update\n(\n*\nothers\n)\n\u00c2\u00b6\nset\n&=\nother\n&\n...\nUpdate the set, keeping only elements found in it and all others.\n\nset.\ndifference_update\n(\n*\nothers\n)\n\u00c2\u00b6\nset\n-=\nother\n|\n...\nUpdate the set, removing elements found in others.\n\nset.\nsymmetric_difference_update\n(\nother\n,\n/\n)\n\u00c2\u00b6\nset\n^=\nother\nUpdate the set, keeping only elements found in either set, but not in both.\n\nset.\nadd\n(\nelem\n,\n/\n)\n\u00c2\u00b6\nAdd element elem to the set.\n\nset.\nremove\n(\nelem\n,\n/\n)\n\u00c2\u00b6\nRemove element elem from the set.  Raises KeyError if elem is\nnot contained in the set.\n\nset.\ndiscard\n(\nelem\n,\n/\n)\n\u00c2\u00b6\nRemove element elem from the set if it is present.\n\nset.\npop\n(\n)\n\u00c2\u00b6\nRemove and return an arbitrary element from the set.  Raises KeyError if the set is empty.\n\nset.\nclear\n(\n)\n\u00c2\u00b6\nRemove all elements from the set.\n\nNote, the non-operator versions of the update() , intersection_update() , difference_update() , and symmetric_difference_update() methods will accept any iterable as an\nargument.\n\nNote, the elem argument to the __contains__() , remove() , and discard() methods may be a set.  To support searching for an equivalent\nfrozenset, a temporary one is created from elem .\n\n## Mapping Types \u00e2\u0080\u0094dict\u00c2\u00b6\n\nA mapping object maps hashable values to arbitrary objects.\nMappings are mutable objects.  There is currently only one standard mapping\ntype, the dictionary .  (For other containers see the built-in list , set , and tuple classes, and the collections module.)\n\nA dictionary\u00e2\u0080\u0099s keys are almost arbitrary values.  Values that are not hashable , that is, values containing lists, dictionaries or other\nmutable types (that are compared by value rather than by object identity) may\nnot be used as keys.\nValues that compare equal (such as 1 , 1.0 , and True )\ncan be used interchangeably to index the same dictionary entry.\n\nclass\ndict\n(\n**\nkwargs\n)\n\u00c2\u00b6\nclass\ndict\n(\nmapping\n,\n/\n,\n**\nkwargs\n)\nclass\ndict\n(\niterable\n,\n/\n,\n**\nkwargs\n)\nReturn a new dictionary initialized from an optional positional argument\nand a possibly empty set of keyword arguments.\n\nDictionaries can be created by several means:\n\n- Use a comma-separated list of key: value pairs within braces: {'jack': 4098, 'sjoerd': 4127} or {4098: 'jack', 4127: 'sjoerd'}\n- Use a dict comprehension: {} , {x: x ** 2 for x in range(10)}\n- Use the type constructor: dict() , dict([('foo', 100), ('bar', 200)]) , dict(foo=100, bar=200)\n\nIf no positional argument is given, an empty dictionary is created.\nIf a positional argument is given and it defines a keys() method, a\ndictionary is created by calling __getitem__() on the argument with\neach returned key from the method.  Otherwise, the positional argument must be an iterable object.  Each item in the iterable must itself be an iterable\nwith exactly two elements.  The first element of each item becomes a key in the\nnew dictionary, and the second element the corresponding value.  If a key occurs\nmore than once, the last value for that key becomes the corresponding value in\nthe new dictionary.\n\nIf keyword arguments are given, the keyword arguments and their values are\nadded to the dictionary created from the positional argument.  If a key\nbeing added is already present, the value from the keyword argument\nreplaces the value from the positional argument.\n\nDictionaries compare equal if and only if they have the same (key, value) pairs (regardless of ordering). Order comparisons (\u00e2\u0080\u0098<\u00e2\u0080\u0099, \u00e2\u0080\u0098<=\u00e2\u0080\u0099, \u00e2\u0080\u0098>=\u00e2\u0080\u0099, \u00e2\u0080\u0098>\u00e2\u0080\u0099) raise TypeError .  To illustrate dictionary creation and equality,\nthe following examples all return a dictionary equal to {\"one\": 1, \"two\": 2, \"three\": 3} :\n\n```python\n>>> a = dict(one=1, two=2, three=3)\n>>> b = {'one': 1, 'two': 2, 'three': 3}\n>>> c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))\n>>> d = dict([('two', 2), ('one', 1), ('three', 3)])\n>>> e = dict({'three': 3, 'one': 1, 'two': 2})\n>>> f = dict({'one': 1, 'three': 3}, two=2)\n>>> a == b == c == d == e == f\nTrue\n```python\n\nProviding keyword arguments as in the first example only works for keys that\nare valid Python identifiers.  Otherwise, any valid keys can be used.\n\nDictionaries preserve insertion order.  Note that updating a key does not\naffect the order.  Keys added after deletion are inserted at the end.\n\n```python\n>>> d = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4}\n>>> d\n{'one': 1, 'two': 2, 'three': 3, 'four': 4}\n>>> list(d)\n['one', 'two', 'three', 'four']\n>>> list(d.values())\n[1, 2, 3, 4]\n>>> d[\"one\"] = 42\n>>> d\n{'one': 42, 'two': 2, 'three': 3, 'four': 4}\n>>> del d[\"two\"]\n>>> d[\"two\"] = None\n>>> d\n{'one': 42, 'three': 3, 'four': 4, 'two': None}\n```python\n\nChanged in version 3.7: Dictionary order is guaranteed to be insertion order.  This behavior was\nan implementation detail of CPython from 3.6.\n\nThese are the operations that dictionaries support (and therefore, custom\nmapping types should support too):\n\nlist(d)\nReturn a list of all the keys used in the dictionary d .\n\nlen(d)\nReturn the number of items in the dictionary d .\n\nd[key]\nReturn the item of d with key key .  Raises a KeyError if key is\nnot in the map.\n\nIf a subclass of dict defines a method __missing__() and key is not present, the d[key] operation calls that method with the key key as argument.  The d[key] operation then returns or raises whatever is\nreturned or raised by the __missing__(key) call.\nNo other operations or methods invoke __missing__() . If __missing__() is not defined, KeyError is raised. __missing__() must be a method; it cannot be an instance variable:\n\n```python\n>>> class Counter(dict):\n...     def __missing__(self, key):\n...         return 0\n...\n>>> c = Counter()\n>>> c['red']\n0\n>>> c['red'] += 1\n>>> c['red']\n1\n```python\n\nThe example above shows part of the implementation of collections.Counter .\nA different __missing__() method is used\nby collections.defaultdict .\n\nd[key]\n=\nvalue\nSet d[key] to value .\n\ndel\nd[key]\nRemove d[key] from d .  Raises a KeyError if key is not in the\nmap.\n\nkey\nin\nd\nReturn True if d has a key key , else False .\n\nkey\nnot\nin\nd\nEquivalent to not key in d .\n\niter(d)\nReturn an iterator over the keys of the dictionary.  This is a shortcut\nfor iter(d.keys()) .\n\nclear\n(\n)\n\u00c2\u00b6\nRemove all items from the dictionary.\n\ncopy\n(\n)\n\u00c2\u00b6\nReturn a shallow copy of the dictionary.\n\nclassmethod\nfromkeys\n(\niterable\n,\nvalue\n=\nNone\n,\n/\n)\n\u00c2\u00b6\nCreate a new dictionary with keys from iterable and values set to value .\n\nfromkeys() is a class method that returns a new dictionary. value defaults to None .  All of the values refer to just a single instance,\nso it generally doesn\u00e2\u0080\u0099t make sense for value to be a mutable object\nsuch as an empty list.  To get distinct values, use a dict\ncomprehension instead.\n\nget\n(\nkey\n,\ndefault\n=\nNone\n,\n/\n)\n\u00c2\u00b6\nReturn the value for key if key is in the dictionary, else default .\nIf default is not given, it defaults to None , so that this method\nnever raises a KeyError .\n\nitems\n(\n)\n\u00c2\u00b6\nReturn a new view of the dictionary\u00e2\u0080\u0099s items ( (key, value) pairs).\nSee the documentation of view objects .\n\nkeys\n(\n)\n\u00c2\u00b6\nReturn a new view of the dictionary\u00e2\u0080\u0099s keys.  See the documentation\nof view objects .\n\npop\n(\nkey\n,\n/\n)\n\u00c2\u00b6\npop\n(\nkey\n,\ndefault\n,\n/\n)\nIf key is in the dictionary, remove it and return its value, else return default .  If default is not given and key is not in the dictionary,\na KeyError is raised.\n\npopitem\n(\n)\n\u00c2\u00b6\nRemove and return a (key, value) pair from the dictionary.\nPairs are returned in LIFO order.\n\npopitem() is useful to destructively iterate over a dictionary, as\noften used in set algorithms.  If the dictionary is empty, calling popitem() raises a KeyError .\n\nChanged in version 3.7: LIFO order is now guaranteed. In prior versions, popitem() would\nreturn an arbitrary key/value pair.\n\nreversed(d)\nReturn a reverse iterator over the keys of the dictionary. This is a\nshortcut for reversed(d.keys()) .\n\nAdded in version 3.8.\n\nsetdefault\n(\nkey\n,\ndefault\n=\nNone\n,\n/\n)\n\u00c2\u00b6\nIf key is in the dictionary, return its value.  If not, insert key with a value of default and return default . default defaults to None .\n\nupdate\n(\n**\nkwargs\n)\n\u00c2\u00b6\nupdate\n(\nmapping\n,\n/\n,\n**\nkwargs\n)\nupdate\n(\niterable\n,\n/\n,\n**\nkwargs\n)\nUpdate the dictionary with the key/value pairs from mapping or iterable and kwargs , overwriting\nexisting keys.  Return None .\n\nupdate() accepts either another object with a keys() method (in\nwhich case __getitem__() is called with every key returned from\nthe method) or an iterable of key/value pairs (as tuples or other iterables\nof length two). If keyword arguments are specified, the dictionary is then\nupdated with those key/value pairs: d.update(red=1, blue=2) .\n\nvalues\n(\n)\n\u00c2\u00b6\nReturn a new view of the dictionary\u00e2\u0080\u0099s values.  See the documentation of view objects .\n\nAn equality comparison between one dict.values() view and another\nwill always return False . This also applies when comparing dict.values() to itself:\n\n```python\n>>> d = {'a': 1}\n>>> d.values() == d.values()\nFalse\n```python\n\nd\n|\nother\nCreate a new dictionary with the merged keys and values of d and other , which must both be dictionaries. The values of other take\npriority when d and other share keys.\n\nAdded in version 3.9.\n\nd\n|=\nother\nUpdate the dictionary d with keys and values from other , which may be\neither a mapping or an iterable of key/value pairs. The\nvalues of other take priority when d and other share keys.\n\nAdded in version 3.9.\n\nDictionaries and dictionary views are reversible.\n\n```python\n>>> d = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4}\n>>> d\n{'one': 1, 'two': 2, 'three': 3, 'four': 4}\n>>> list(reversed(d))\n['four', 'three', 'two', 'one']\n>>> list(reversed(d.values()))\n[4, 3, 2, 1]\n>>> list(reversed(d.items()))\n[('four', 4), ('three', 3), ('two', 2), ('one', 1)]\n```python\n\nChanged in version 3.8: Dictionaries are now reversible.\n\nSee also\n\ntypes.MappingProxyType can be used to create a read-only view\nof a dict .\n\nThread safety for dict objects\n\nCreating a dictionary with the dict constructor is atomic when the\nargument to it is a dict or a tuple . When using the dict.fromkeys() method, dictionary creation is atomic when the\nargument is a dict , tuple , set or frozenset .\n\nThe following operations and functions are lock-free and atomic .\n\n```python\nd[key]       # dict.__getitem__\nd.get(key)   # dict.get\nkey in d     # dict.__contains__\nlen(d)       # dict.__len__\n```python\n\nAll other operations from here on hold the per-object lock .\n\nWriting or removing a single item is safe to call from multiple threads\nand will not corrupt the dictionary:\n\n```python\nd[key] = value        # write\ndel d[key]            # delete\nd.pop(key)            # remove and return\nd.popitem()           # remove and return last item\nd.setdefault(key, v)  # insert if missing\n```python\n\nThese operations may compare keys using __eq__() , which can\nexecute arbitrary Python code. During such comparisons, the dictionary may\nbe modified by another thread. For built-in types like str , int , and float , that implement __eq__() in C,\nthe underlying lock is not released during comparisons and this is not a\nconcern.\n\nThe following operations return new objects and hold the per-object lock for the duration of the operation:\n\n```python\nd.copy()      # returns a shallow copy of the dictionary\nd | other     # merges two dicts into a new dict\nd.keys()      # returns a new dict_keys view object\nd.values()    # returns a new dict_values view object\nd.items()     # returns a new dict_items view object\n```python\n\nThe clear() method holds the lock for its duration. Other\nthreads cannot observe elements being removed.\n\nThe following operations lock both dictionaries. For update() and |= , this applies only when the other operand is a dict that uses the standard dict iterator (but not subclasses that override\niteration). For equality comparison, this applies to dict and\nits subclasses:\n\n```python\nd.update(other_dict)  # both locked when other_dict is a dict\nd |= other_dict       # both locked when other_dict is a dict\nd == other_dict       # both locked for dict and subclasses\n```python\n\nAll comparison operations also compare values using __eq__() ,\nso for non-built-in types the lock may be released during comparison.\n\nfromkeys() locks both the new dictionary and the iterable\nwhen the iterable is exactly a dict , set , or frozenset (not subclasses):\n\n```python\ndict.fromkeys(a_dict)      # locks both\ndict.fromkeys(a_set)       # locks both\ndict.fromkeys(a_frozenset) # locks both\n```python\n\nWhen updating from a non-dict iterable, only the target dictionary is\nlocked. The iterable may be concurrently modified by another thread:\n\n```python\nd.update(iterable)        # iterable is not a dict: only d locked\nd |= iterable             # iterable is not a dict: only d locked\ndict.fromkeys(iterable)   # iterable is not a dict/set/frozenset: only result locked\n```python\n\nOperations that involve multiple accesses, as well as iteration, are never\natomic:\n\n```python\n# NOT atomic: read-modify-write\nd[key] = d[key] + 1\n\n# NOT atomic: check-then-act (TOCTOU)\nif key in d:\n      del d[key]\n\n# NOT thread-safe: iteration while modifying\nfor key, value in d.items():\n      process(key)  # another thread may modify d\n```python\n\nTo avoid time-of-check to time-of-use (TOCTOU) issues, use atomic\noperations or handle exceptions:\n\n```python\n# Use pop() with default instead of check-then-delete\nd.pop(key, None)\n\n# Or handle the exception\ntry:\n      del d[key]\nexcept KeyError:\n      pass\n```python\n\nTo safely iterate over a dictionary that may be modified by another\nthread, iterate over a copy:\n\n```python\n# Make a copy to iterate safely\nfor key, value in d.copy().items():\n      process(key)\n```python\n\nConsider external synchronization when sharing dict instances\nacross threads. See Python support for free threading for more information.\n\n### Dictionary view objects\u00c2\u00b6\n\nThe objects returned by dict.keys() , dict.values() and dict.items() are view objects .  They provide a dynamic view on the\ndictionary\u00e2\u0080\u0099s entries, which means that when the dictionary changes, the view\nreflects these changes.\n\nDictionary views can be iterated over to yield their respective data, and\nsupport membership tests:\n\nlen(dictview)\nReturn the number of entries in the dictionary.\n\niter(dictview)\nReturn an iterator over the keys, values or items (represented as tuples of (key, value) ) in the dictionary.\n\nKeys and values are iterated over in insertion order.\nThis allows the creation of (value, key) pairs\nusing zip() : pairs = zip(d.values(), d.keys()) .  Another way to\ncreate the same list is pairs = [(v, k) for (k, v) in d.items()] .\n\nIterating views while adding or deleting entries in the dictionary may raise\na RuntimeError or fail to iterate over all entries.\n\nChanged in version 3.7: Dictionary order is guaranteed to be insertion order.\n\nx\nin\ndictview\nReturn True if x is in the underlying dictionary\u00e2\u0080\u0099s keys, values or\nitems (in the latter case, x should be a (key, value) tuple).\n\nreversed(dictview)\nReturn a reverse iterator over the keys, values or items of the dictionary.\nThe view will be iterated in reverse order of the insertion.\n\nChanged in version 3.8: Dictionary views are now reversible.\n\ndictview.mapping\nReturn a types.MappingProxyType that wraps the original\ndictionary to which the view refers.\n\nAdded in version 3.10.\n\nKeys views are set-like since their entries are unique and hashable .\nItems views also have set-like operations since the (key, value) pairs\nare unique and the keys are hashable.\nIf all values in an items view are hashable as well,\nthen the items view can interoperate with other sets.\n(Values views are not treated as set-like\nsince the entries are generally not unique.)  For set-like views, all of the\noperations defined for the abstract base class collections.abc.Set are\navailable (for example, == , < , or ^ ).  While using set operators,\nset-like views accept any iterable as the other operand,\nunlike sets which only accept sets as the input.\n\nAn example of dictionary view usage:\n\n```python\n>>> dishes = {'eggs': 2, 'sausage': 1, 'bacon': 1, 'spam': 500}\n>>> keys = dishes.keys()\n>>> values = dishes.values()\n\n>>> # iteration\n>>> n = 0\n>>> for val in values:\n...     n += val\n...\n>>> print(n)\n504\n\n>>> # keys and values are iterated over in the same order (insertion order)\n>>> list(keys)\n['eggs', 'sausage', 'bacon', 'spam']\n>>> list(values)\n[2, 1, 1, 500]\n\n>>> # view objects are dynamic and reflect dict changes\n>>> del dishes['eggs']\n>>> del dishes['sausage']\n>>> list(keys)\n['bacon', 'spam']\n\n>>> # set operations\n>>> keys & {'eggs', 'bacon', 'salad'}\n{'bacon'}\n>>> keys ^ {'sausage', 'juice'} == {'juice', 'sausage', 'bacon', 'spam'}\nTrue\n>>> keys | ['juice', 'juice', 'juice'] == {'bacon', 'spam', 'juice'}\nTrue\n\n>>> # get back a read-only proxy for the original dictionary\n>>> values.mapping\nmappingproxy({'bacon': 1, 'spam': 500})\n>>> values.mapping['spam']\n500\n```python\n\n## Context Manager Types\u00c2\u00b6\n\nPython\u00e2\u0080\u0099s with statement supports the concept of a runtime context\ndefined by a context manager.  This is implemented using a pair of methods\nthat allow user-defined classes to define a runtime context that is entered\nbefore the statement body is executed and exited when the statement ends:\n\ncontextmanager.\n__enter__\n(\n)\n\u00c2\u00b6\nEnter the runtime context and return either this object or another object\nrelated to the runtime context. The value returned by this method is bound to\nthe identifier in the as clause of with statements using\nthis context manager.\n\nAn example of a context manager that returns itself is a file object .\nFile objects return themselves from __enter__() to allow open() to be\nused as the context expression in a with statement.\n\nAn example of a context manager that returns a related object is the one\nreturned by decimal.localcontext() . These managers set the active\ndecimal context to a copy of the original decimal context and then return the\ncopy. This allows changes to be made to the current decimal context in the body\nof the with statement without affecting code outside the with statement.\n\ncontextmanager.\n__exit__\n(\nexc_type\n,\nexc_val\n,\nexc_tb\n)\n\u00c2\u00b6\nExit the runtime context and return a Boolean flag indicating if any exception\nthat occurred should be suppressed. If an exception occurred while executing the\nbody of the with statement, the arguments contain the exception type,\nvalue and traceback information. Otherwise, all three arguments are None .\n\nReturning a true value from this method will cause the with statement\nto suppress the exception and continue execution with the statement immediately\nfollowing the with statement. Otherwise the exception continues\npropagating after this method has finished executing.\n\nIf this method raises an exception while handling an earlier exception from the with block, the new exception is raised, and the original exception\nis stored in its __context__ attribute.\n\nThe exception passed in should never be reraised explicitly - instead, this\nmethod should return a false value to indicate that the method completed\nsuccessfully and does not want to suppress the raised exception. This allows\ncontext management code to easily detect whether or not an __exit__() method has actually failed.\n\nPython defines several context managers to support easy thread synchronisation,\nprompt closure of files or other objects, and simpler manipulation of the active\ndecimal arithmetic context. The specific types are not treated specially beyond\ntheir implementation of the context management protocol. See the contextlib module for some examples.\n\nPython\u00e2\u0080\u0099s generator s and the contextlib.contextmanager decorator\nprovide a convenient way to implement these protocols.  If a generator function is\ndecorated with the contextlib.contextmanager decorator, it will return a\ncontext manager implementing the necessary __enter__() and __exit__() methods, rather than the iterator produced by an\nundecorated generator function.\n\nNote that there is no specific slot for any of these methods in the type\nstructure for Python objects in the Python/C API. Extension types wanting to\ndefine these methods must provide them as a normal Python accessible method.\nCompared to the overhead of setting up the runtime context, the overhead of a\nsingle class dictionary lookup is negligible.\n\n## Type Annotation Types \u00e2\u0080\u0094Generic Alias,Union\u00c2\u00b6\n\nThe core built-in types for type annotations are Generic Alias and Union .\n\n### Generic Alias Type\u00c2\u00b6\n\nGenericAlias objects are generally created by subscripting a class. They are most often used with container classes , such as list or dict . For example, list[int] is a GenericAlias object created\nby subscripting the list class with the argument int . GenericAlias objects are intended primarily for use with type annotations .\n\nNote\n\nIt is generally only possible to subscript a class if the class implements\nthe special method __class_getitem__() .\n\nA GenericAlias object acts as a proxy for a generic type ,\nimplementing parameterized generics .\n\nFor a container class, the\nargument(s) supplied to a subscription of the class may\nindicate the type(s) of the elements an object contains. For example, set[bytes] can be used in type annotations to signify a set in\nwhich all the elements are of type bytes .\n\nFor a class which defines __class_getitem__() but is not a\ncontainer, the argument(s) supplied to a subscription of the class will often\nindicate the return type(s) of one or more methods defined on an object. For\nexample, regular expressions can be used on both the str data\ntype and the bytes data type:\n\n- If x = re.search('foo', 'foo') , x will be a re.Match object where the return values of x.group(0) and x[0] will both be of type str . We can\nrepresent this kind of object in type annotations with the GenericAlias re.Match[str] .\n- If y = re.search(b'bar', b'bar') , (note the b for bytes ), y will also be an instance of re.Match , but the return\nvalues of y.group(0) and y[0] will both be of type bytes . In type annotations, we would represent this\nvariety of re.Match objects with re.Match[bytes] .\n\nGenericAlias objects are instances of the class types.GenericAlias , which can also be used to create GenericAlias objects directly.\n\nT[X,\nY,\n...]\nCreates a GenericAlias representing a type T parameterized by types X , Y , and more depending on the T used.\nFor example, a function expecting a list containing float elements:\n\n```python\ndef average(values: list[float]) -> float:\n    return sum(values) / len(values)\n```python\n\nAnother example for mapping objects, using a dict , which\nis a generic type expecting two type parameters representing the key type\nand the value type.  In this example, the function expects a dict with\nkeys of type str and values of type int :\n\n```python\ndef send_post_request(url: str, body: dict[str, int]) -> None:\n    ...\n```python\n\nThe builtin functions isinstance() and issubclass() do not accept GenericAlias types for their second argument:\n\n```python\n>>> isinstance([1, 2], list[str])\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: isinstance() argument 2 cannot be a parameterized generic\n```python\n\nThe Python runtime does not enforce type annotations .\nThis extends to generic types and their type parameters. When creating\na container object from a GenericAlias , the elements in the container are not checked\nagainst their type. For example, the following code is discouraged, but will\nrun without errors:\n\n```python\n>>> t = list[str]\n>>> t([1, 2, 3])\n[1, 2, 3]\n```python\n\nFurthermore, parameterized generics erase type parameters during object\ncreation:\n\n```python\n>>> t = list[str]\n>>> type(t)\n<class 'types.GenericAlias'>\n\n>>> l = t()\n>>> type(l)\n<class 'list'>\n```python\n\nCalling repr() or str() on a generic shows the parameterized type:\n\n```python\n>>> repr(list[int])\n'list[int]'\n\n>>> str(list[int])\n'list[int]'\n```python\n\nThe __getitem__() method of generic containers will raise an\nexception to disallow mistakes like dict[str][str] :\n\n```python\n>>> dict[str][str]\nTraceback (most recent call last):\n  ...\nTypeError: dict[str] is not a generic class\n```python\n\nHowever, such expressions are valid when type variables are\nused.  The index must have as many elements as there are type variable items\nin the GenericAlias object\u00e2\u0080\u0099s __args__ .\n\n```python\n>>> from typing import TypeVar\n>>> Y = TypeVar('Y')\n>>> dict[str, Y][int]\ndict[str, int]\n```python\n\n#### Standard Generic Classes\u00c2\u00b6\n\nThe following standard library classes support parameterized generics. This\nlist is non-exhaustive.\n\n- tuple\n- list\n- dict\n- set\n- frozenset\n- type\n- asyncio.Future\n- asyncio.Task\n- collections.deque\n- collections.defaultdict\n- collections.OrderedDict\n- collections.Counter\n- collections.ChainMap\n- collections.abc.Awaitable\n- collections.abc.Coroutine\n- collections.abc.AsyncIterable\n- collections.abc.AsyncIterator\n- collections.abc.AsyncGenerator\n- collections.abc.Iterable\n- collections.abc.Iterator\n- collections.abc.Generator\n- collections.abc.Reversible\n- collections.abc.Container\n- collections.abc.Collection\n- collections.abc.Callable\n- collections.abc.Set\n- collections.abc.MutableSet\n- collections.abc.Mapping\n- collections.abc.MutableMapping\n- collections.abc.Sequence\n- collections.abc.MutableSequence\n- collections.abc.ByteString\n- collections.abc.MappingView\n- collections.abc.KeysView\n- collections.abc.ItemsView\n- collections.abc.ValuesView\n- contextlib.AbstractContextManager\n- contextlib.AbstractAsyncContextManager\n- dataclasses.Field\n- functools.cached_property\n- functools.partialmethod\n- os.PathLike\n- queue.LifoQueue\n- queue.Queue\n- queue.PriorityQueue\n- queue.SimpleQueue\n- re.Pattern\n- re.Match\n- shelve.BsdDbShelf\n- shelve.DbfilenameShelf\n- shelve.Shelf\n- types.MappingProxyType\n- weakref.WeakKeyDictionary\n- weakref.WeakMethod\n- weakref.WeakSet\n- weakref.WeakValueDictionary\n\n#### Special Attributes ofGenericAliasobjects\u00c2\u00b6\n\nAll parameterized generics implement special read-only attributes.\n\ngenericalias.\n__origin__\n\u00c2\u00b6\nThis attribute points at the non-parameterized generic class:\n\n```python\n>>> list[int].__origin__\n<class 'list'>\n```python\n\ngenericalias.\n__args__\n\u00c2\u00b6\nThis attribute is a tuple (possibly of length 1) of generic\ntypes passed to the original __class_getitem__() of the\ngeneric class:\n\n```python\n>>> dict[str, list[int]].__args__\n(<class 'str'>, list[int])\n```python\n\ngenericalias.\n__parameters__\n\u00c2\u00b6\nThis attribute is a lazily computed tuple (possibly empty) of unique type\nvariables found in __args__ :\n\n```python\n>>> from typing import TypeVar\n\n>>> T = TypeVar('T')\n>>> list[T].__parameters__\n(~T,)\n```python\n\nNote\n\nA GenericAlias object with typing.ParamSpec parameters may not\nhave correct __parameters__ after substitution because typing.ParamSpec is intended primarily for static type checking.\n\ngenericalias.\n__unpacked__\n\u00c2\u00b6\nA boolean that is true if the alias has been unpacked using the * operator (see TypeVarTuple ).\n\nAdded in version 3.11.\n\nSee also\n\nPEP 484\n- Type Hints\nIntroducing Python\u00e2\u0080\u0099s framework for type annotations.\n\nPEP 585\n- Type Hinting Generics In Standard Collections\nIntroducing the ability to natively parameterize standard-library\nclasses, provided they implement the special class method __class_getitem__() .\n\nGenerics\n,\nuser-defined generics\nand\n`typing.Generic`\nDocumentation on how to implement generic classes that can be\nparameterized at runtime and understood by static type-checkers.\n\nAdded in version 3.9.\n\n### Union Type\u00c2\u00b6\n\nA union object holds the value of the | (bitwise or) operation on\nmultiple type objects .  These types are intended\nprimarily for type annotations . The union type expression\nenables cleaner type hinting syntax compared to subscripting typing.Union .\n\nX\n|\nY\n|\n...\nDefines a union object which holds types X , Y , and so forth. X | Y means either X or Y.  It is equivalent to typing.Union[X, Y] .\nFor example, the following function expects an argument of type int or float :\n\n```python\ndef square(number: int | float) -> int | float:\n    return number ** 2\n```python\n\nNote\n\nThe | operand cannot be used at runtime to define unions where one or\nmore members is a forward reference. For example, int | \"Foo\" , where \"Foo\" is a reference to a class not yet defined, will fail at\nruntime. For unions which include forward references, present the\nwhole expression as a string, e.g. \"int | Foo\" .\n\nunion_object\n==\nother\nUnion objects can be tested for equality with other union objects.  Details:\n\n- Unions of unions are flattened: ( int | str ) | float == int | str | float\n- Redundant types are removed: int | str | int == int | str\n- When comparing unions, the order is ignored: int | str == str | int\n- It creates instances of typing.Union : int | str == typing . Union [ int , str ] type ( int | str ) is typing . Union\n- Optional types can be spelled as a union with None : str | None == typing . Optional [ str ]\n\nisinstance(obj,\nunion_object)\nissubclass(obj,\nunion_object)\nCalls to isinstance() and issubclass() are also supported with a\nunion object:\n\n```python\n>>> isinstance(\"\", int | str)\nTrue\n```python\n\nHowever, parameterized generics in\nunion objects cannot be checked:\n\n```python\n>>> isinstance(1, int | list[int])  # short-circuit evaluation\nTrue\n>>> isinstance([1], int | list[int])\nTraceback (most recent call last):\n  ...\nTypeError: isinstance() argument 2 cannot be a parameterized generic\n```python\n\nThe user-exposed type for the union object can be accessed from typing.Union and used for isinstance() checks:\n\n```python\n>>> import typing\n>>> isinstance(int | str, typing.Union)\nTrue\n>>> typing.Union()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: cannot create 'typing.Union' instances\n```python\n\nNote\n\nThe __or__() method for type objects was added to support the syntax X | Y .  If a metaclass implements __or__() , the Union may\noverride it:\n\n```python\n>>> class M(type):\n...     def __or__(self, other):\n...         return \"Hello\"\n...\n>>> class C(metaclass=M):\n...     pass\n...\n>>> C | int\n'Hello'\n>>> int | C\nint | C\n```python\n\nSee also\n\nPEP 604 \u00e2\u0080\u0093 PEP proposing the X | Y syntax and the Union type.\n\nAdded in version 3.10.\n\nChanged in version 3.14: Union objects are now instances of typing.Union . Previously, they were instances\nof types.UnionType , which remains an alias for typing.Union .\n\n## Other Built-in Types\u00c2\u00b6\n\nThe interpreter supports several other kinds of objects. Most of these support\nonly one or two operations.\n\n### Modules\u00c2\u00b6\n\nThe only special operation on a module is attribute access: m.name , where m is a module and name accesses a name defined in m \u00e2\u0080\u0099s symbol table.\nModule attributes can be assigned to.  (Note that the import statement is not, strictly speaking, an operation on a module object; import foo does not require a module object named foo to exist, rather it requires\nan (external) definition for a module named foo somewhere.)\n\nA special attribute of every module is __dict__ . This is the\ndictionary containing the module\u00e2\u0080\u0099s symbol table. Modifying this dictionary will\nactually change the module\u00e2\u0080\u0099s symbol table, but direct assignment to the __dict__ attribute is not possible (you can write m.__dict__['a'] = 1 , which defines m.a to be 1 , but you can\u00e2\u0080\u0099t write m.__dict__ = {} ).  Modifying __dict__ directly is\nnot recommended.\n\nModules built into the interpreter are written like this: <module 'sys' (built-in)> .  If loaded from a file, they are written as <module 'os' from '/usr/local/lib/pythonX.Y/os.pyc'> .\n\n### Classes and Class Instances\u00c2\u00b6\n\nSee Objects, values and types and Class definitions for these.\n\n### Functions\u00c2\u00b6\n\nFunction objects are created by function definitions.  The only operation on a\nfunction object is to call it: func(argument-list) .\n\nThere are really two flavors of function objects: built-in functions and\nuser-defined functions.  Both support the same operation (to call the function),\nbut the implementation is different, hence the different object types.\n\nSee Function definitions for more information.\n\n### Methods\u00c2\u00b6\n\nMethods are functions that are called using the attribute notation.\nThere are two flavors: built-in methods (such as append() on lists)\nand class instance method .\nBuilt-in methods are described with the types that support them.\n\nIf you access a method (a function defined in a class namespace) through an\ninstance, you get a special object: a bound method (also called instance method ) object. When called, it will add\nthe self argument\nto the argument list.  Bound methods have two special read-only attributes: m.__self__ is the object on which the method\noperates, and m.__func__ is\nthe function implementing the method.  Calling m(arg-1, arg-2, ..., arg-n) is completely equivalent to calling m.__func__(m.__self__, arg-1, arg-2, ..., arg-n) .\n\nLike function objects , bound method objects support\ngetting arbitrary\nattributes.  However, since method attributes are actually stored on the\nunderlying function object ( method.__func__ ), setting method attributes on\nbound methods is disallowed.  Attempting to set an attribute on a method\nresults in an AttributeError being raised.  In order to set a method\nattribute, you need to explicitly set it on the underlying function object:\n\n```python\n>>> class C:\n...     def method(self):\n...         pass\n...\n>>> c = C()\n>>> c.method.whoami = 'my name is method'  # can't set on the method\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAttributeError: 'method' object has no attribute 'whoami'\n>>> c.method.__func__.whoami = 'my name is method'\n>>> c.method.whoami\n'my name is method'\n```python\n\nSee Instance methods for more information.\n\n### Code Objects\u00c2\u00b6\n\nCode objects are used by the implementation to represent \u00e2\u0080\u009cpseudo-compiled\u00e2\u0080\u009d\nexecutable Python code such as a function body. They differ from function\nobjects because they don\u00e2\u0080\u0099t contain a reference to their global execution\nenvironment.  Code objects are returned by the built-in compile() function\nand can be extracted from function objects through their __code__ attribute. See also the code module.\n\nAccessing __code__ raises an auditing event object.__getattr__ with arguments obj and \"__code__\" .\n\nA code object can be executed or evaluated by passing it (instead of a source\nstring) to the exec() or eval() built-in functions.\n\nSee The standard type hierarchy for more information.\n\n### Type Objects\u00c2\u00b6\n\nType objects represent the various object types.  An object\u00e2\u0080\u0099s type is accessed\nby the built-in function type() .  There are no special operations on\ntypes.  The standard module types defines names for all standard built-in\ntypes.\n\nTypes are written like this: <class 'int'> .\n\n### The Null Object\u00c2\u00b6\n\nThis object is returned by functions that don\u00e2\u0080\u0099t explicitly return a value.  It\nsupports no special operations.  There is exactly one null object, named None (a built-in name). type(None)() produces the same singleton.\n\nIt is written as None .\n\n### The Ellipsis Object\u00c2\u00b6\n\nThis object is commonly used to indicate that something is omitted.\nIt supports no special operations.  There is exactly one ellipsis object, named Ellipsis (a built-in name). type(Ellipsis)() produces the Ellipsis singleton.\n\nIt is written as Ellipsis or ... .\n\nIn typical use, ... as the Ellipsis object appears in a few different\nplaces, for instance:\n\n- In type annotations, such as callable arguments or tuple elements .\n- As the body of a function instead of a pass statement .\n- In third-party libraries, such as Numpy\u00e2\u0080\u0099s slicing and striding .\n\nPython also uses three dots in ways that are not Ellipsis objects, for instance:\n\n- Doctest\u00e2\u0080\u0099s ELLIPSIS , as a pattern for missing content.\n- The default Python prompt of the interactive shell when partial input is incomplete.\n\nLastly, the Python documentation often uses three dots in conventional English\nusage to mean omitted content, even in code examples that also use them as the Ellipsis .\n\n### The NotImplemented Object\u00c2\u00b6\n\nThis object is returned from comparisons and binary operations when they are\nasked to operate on types they don\u00e2\u0080\u0099t support. See Comparisons for more\ninformation.  There is exactly one NotImplemented object. type(NotImplemented)() produces the singleton instance.\n\nIt is written as NotImplemented .\n\n### Internal Objects\u00c2\u00b6\n\nSee The standard type hierarchy for this information.  It describes stack frame objects , traceback objects , and slice objects.\n\n## Special Attributes\u00c2\u00b6\n\nThe implementation adds a few special read-only attributes to several object\ntypes, where they are relevant.  Some of these are not reported by the dir() built-in function.\n\ndefinition.\n__name__\n\u00c2\u00b6\nThe name of the class, function, method, descriptor, or\ngenerator instance.\n\ndefinition.\n__qualname__\n\u00c2\u00b6\nThe qualified name of the class, function, method, descriptor,\nor generator instance.\n\nAdded in version 3.3.\n\ndefinition.\n__module__\n\u00c2\u00b6\nThe name of the module in which a class or function was defined.\n\ndefinition.\n__doc__\n\u00c2\u00b6\nThe documentation string of a class or function, or None if undefined.\n\ndefinition.\n__type_params__\n\u00c2\u00b6\nThe type parameters of generic classes, functions,\nand type aliases . For classes and functions that\nare not generic, this will be an empty tuple.\n\nAdded in version 3.12.\n\n## Integer string conversion length limitation\u00c2\u00b6\n\nCPython has a global limit for converting between int and str to mitigate denial of service attacks. This limit only applies to decimal or\nother non-power-of-two number bases. Hexadecimal, octal, and binary conversions\nare unlimited. The limit can be configured.\n\nThe int type in CPython is an arbitrary length number stored in binary\nform (commonly known as a \u00e2\u0080\u009cbignum\u00e2\u0080\u009d). There exists no algorithm that can convert\na string to a binary integer or a binary integer to a string in linear time, unless the base is a power of 2. Even the best known algorithms for base 10\nhave sub-quadratic complexity. Converting a large value such as int('1' * 500_000) can take over a second on a fast CPU.\n\nLimiting conversion size offers a practical way to avoid CVE 2020-10735 .\n\nThe limit is applied to the number of digit characters in the input or output\nstring when a non-linear conversion algorithm would be involved.  Underscores\nand the sign are not counted towards the limit.\n\nWhen an operation would exceed the limit, a ValueError is raised:\n\n```python\n>>> import sys\n>>> sys.set_int_max_str_digits(4300)  # Illustrative, this is the default.\n>>> _ = int('2' * 5432)\nTraceback (most recent call last):\n...\nValueError: Exceeds the limit (4300 digits) for integer string conversion: value has 5432 digits; use sys.set_int_max_str_digits() to increase the limit\n>>> i = int('2' * 4300)\n>>> len(str(i))\n4300\n>>> i_squared = i*i\n>>> len(str(i_squared))\nTraceback (most recent call last):\n...\nValueError: Exceeds the limit (4300 digits) for integer string conversion; use sys.set_int_max_str_digits() to increase the limit\n>>> len(hex(i_squared))\n7144\n>>> assert int(hex(i_squared), base=16) == i*i  # Hexadecimal is unlimited.\n```python\n\nThe default limit is 4300 digits as provided in sys.int_info.default_max_str_digits .\nThe lowest limit that can be configured is 640 digits as provided in sys.int_info.str_digits_check_threshold .\n\nVerification:\n\n```python\n>>> import sys\n>>> assert sys.int_info.default_max_str_digits == 4300, sys.int_info\n>>> assert sys.int_info.str_digits_check_threshold == 640, sys.int_info\n>>> msg = int('578966293710682886880994035146873798396722250538762761564'\n...           '9252925514383915483333812743580549779436104706260696366600'\n...           '571186405732').to_bytes(53, 'big')\n...\n```python\n\nAdded in version 3.11.\n\n### Affected APIs\u00c2\u00b6\n\nThe limitation only applies to potentially slow conversions between int and str or bytes :\n\n- int(string) with default base 10.\n- int(string, base) for all bases that are not a power of 2.\n- str(integer) .\n- repr(integer) .\n- any other string conversion to base 10, for example f\"{integer}\" , \"{}\".format(integer) , or b\"%d\" % integer .\n\nThe limitations do not apply to functions with a linear algorithm:\n\n- int(string, base) with base 2, 4, 8, 16, or 32.\n- int.from_bytes() and int.to_bytes() .\n- hex() , oct() , bin() .\n- Format Specification Mini-Language for hex, octal, and binary numbers.\n- str to float .\n- str to decimal.Decimal .\n\n### Configuring the limit\u00c2\u00b6\n\nBefore Python starts up you can use an environment variable or an interpreter\ncommand line flag to configure the limit:\n\n- PYTHONINTMAXSTRDIGITS , e.g. PYTHONINTMAXSTRDIGITS=640 python3 to set the limit to 640 or PYTHONINTMAXSTRDIGITS=0 python3 to disable the limitation.\n- -X int_max_str_digits , e.g. python3 -X int_max_str_digits=640\n- sys.flags.int_max_str_digits contains the value of PYTHONINTMAXSTRDIGITS or -X int_max_str_digits .\nIf both the env var and the -X option are set, the -X option takes\nprecedence. A value of -1 indicates that both were unset, thus a value of sys.int_info.default_max_str_digits was used during initialization.\n\nFrom code, you can inspect the current limit and set a new one using these sys APIs:\n\n- sys.get_int_max_str_digits() and sys.set_int_max_str_digits() are\na getter and setter for the interpreter-wide limit. Subinterpreters have\ntheir own limit.\n\nInformation about the default and minimum can be found in sys.int_info :\n\n- sys.int_info.default_max_str_digits is the compiled-in\ndefault limit.\n- sys.int_info.str_digits_check_threshold is the lowest\naccepted value for the limit (other than 0 which disables it).\n\nAdded in version 3.11.\n\nCaution\n\nSetting a low limit can lead to problems. While rare, code exists that\ncontains integer constants in decimal in their source that exceed the\nminimum threshold. A consequence of setting the limit is that Python source\ncode containing decimal integer literals longer than the limit will\nencounter an error during parsing, usually at startup time or import time or\neven at installation time - anytime an up to date .pyc does not already\nexist for the code. A workaround for source that contains such large\nconstants is to convert them to 0x hexadecimal form as it has no limit.\n\nTest your application thoroughly if you use a low limit. Ensure your tests\nrun with the limit set early via the environment or flag so that it applies\nduring startup and even during any installation step that may invoke Python\nto precompile .py sources to .pyc files.\n\n### Recommended configuration\u00c2\u00b6\n\nThe default sys.int_info.default_max_str_digits is expected to be\nreasonable for most applications. If your application requires a different\nlimit, set it from your main entry point using Python version agnostic code as\nthese APIs were added in security patch releases in versions before 3.12.\n\nExample:\n\n```python\n>>> import sys\n>>> if hasattr(sys, \"set_int_max_str_digits\"):\n...     upper_bound = 68000\n...     lower_bound = 4004\n...     current_limit = sys.get_int_max_str_digits()\n...     if current_limit == 0 or current_limit > upper_bound:\n...         sys.set_int_max_str_digits(upper_bound)\n...     elif current_limit < lower_bound:\n...         sys.set_int_max_str_digits(lower_bound)\n```python\n\nIf you need to disable it entirely, set it to 0 .\n\nFootnotes",
      "difficulty": "intro",
      "doc_id": "doc-built-in-types-10cf62e085",
      "provenance": {
        "author": "",
        "date": "",
        "license": "PSF Documentation License",
        "source_file": "data/corpus_raw/3_library_stdtypes_html_2451f7.json",
        "url": "https://docs.python.org/3/library/stdtypes.html"
      },
      "title": "Built-in Types\u00c2\u00b6",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "data_types",
        "expressions",
        "operators",
        "variables"
      ],
      "content": "Buy this book at Amazon.com Chapter\u00a01\u00a0\u00a0The way of the program The goal of this book is to teach you to think like a computer\nscientist. This way of thinking combines some of the best features of\nmathematics, engineering, and natural science. Like mathematicians,\ncomputer scientists use formal languages to denote ideas (specifically\ncomputations). Like engineers, they design things, assembling\ncomponents into systems and evaluating tradeoffs among alternatives.\nLike scientists, they observe the behavior of complex systems, form\nhypotheses, and test predictions. The single most important skill for a computer scientist is problem solving . Problem solving means the ability to formulate\nproblems, think creatively about solutions, and express a solution\nclearly and accurately. As it turns out, the process of learning to\nprogram is an excellent opportunity to practice problem-solving\nskills. That\u2019s why this chapter is called, \u201cThe way of the\nprogram\u201d. On one level, you will be learning to program, a useful skill by\nitself. On another level, you will use programming as a means to an\nend. As we go along, that end will become clearer. 1.1\u00a0\u00a0What is a program? A program is a sequence of instructions that specifies how to\nperform a computation. The computation might be something\nmathematical, such as solving a system of equations or finding the\nroots of a polynomial, but it can also be a symbolic computation, such\nas searching and replacing text in a document or something\ngraphical, like processing an image or playing a video. The details look different in different languages, but a few basic\ninstructions appear in just about every language: input: Get data from the keyboard, a file, the network, or some\nother device. output: Display data on the screen, save it in a\nfile, send it over the network, etc. math: Perform basic mathematical operations like addition and\nmultiplication. conditional execution: Check for certain conditions and\nrun the appropriate code. repetition: Perform some action repeatedly, usually with\nsome variation. Believe it or not, that\u2019s pretty much all there is to it. Every\nprogram you\u2019ve ever used, no matter how complicated, is made up of\ninstructions that look pretty much like these. So you can think of\nprogramming as the process of breaking a large, complex task\ninto smaller and smaller subtasks until the subtasks are\nsimple enough to be performed with one of these basic instructions. 1.2\u00a0\u00a0Running Python One of the challenges of getting started with Python is that you\nmight have to install Python and related software on your computer.\nIf you are familiar with your operating system, and especially\nif you are comfortable with the command-line interface, you will\nhave no trouble installing Python. But for beginners, it can be\npainful to learn about system administration and programming at the\nsame time. To avoid that problem, I recommend that you start out running Python\nin a browser. Later, when you are comfortable with Python, I\u2019ll\nmake suggestions for installing Python on your computer. There are a number of web pages you can use to run Python. If you\nalready have a favorite, go ahead and use it. Otherwise I recommend\nPythonAnywhere. I provide detailed instructions for getting started\nat http://tinyurl.com/thinkpython2e . There are two versions of Python, called Python 2 and Python 3.\nThey are very similar, so if you learn one, it is easy to switch\nto the other. In fact, there are only a few differences you will\nencounter as a beginner.\nThis book is written for Python 3, but I include some notes\nabout Python 2. The Python interpreter is a program that reads and executes\nPython code. Depending on your environment, you might start the\ninterpreter by clicking on an icon, or by typing python on\na command line.\nWhen it starts, you should see output like this: Python 3.4.0 (default, Jun 19 2015, 14:20:21)\n[GCC 4.8.2] on linux\n>>> The first three lines contain information about the interpreter\nand the operating system it\u2019s running on, so it might be different for\nyou. But you should check that the version number, which is 3.4.0 in this example, begins with 3, which indicates that\nyou are running Python 3. If it begins with 2, you are running\n(you guessed it) Python 2. The last line is a prompt that indicates that the interpreter is\nready for you to enter code.\nIf you type a line of code and hit Enter, the interpreter displays the\nresult: >>> 1 + 1\n2 Now you\u2019re ready to get started.\nFrom here on, I assume that you know how to start the Python\ninterpreter and run code. 1.3\u00a0\u00a0The first program Traditionally, the first program you write in a new language\nis called \u201cHello, World!\u201d because all it does is display the\nwords \u201cHello, World!\u201d. In Python, it looks like this: >>> print('Hello, World!') This is an example of a print statement , although it\ndoesn\u2019t actually print anything on paper. It displays a result on the\nscreen. In this case, the result is the words Hello, World! The quotation marks in the program mark the beginning and end\nof the text to be displayed; they don\u2019t appear in the result. The parentheses indicate that print is a function. We\u2019ll get\nto functions in Chapter 3 . In Python 2, the print statement is slightly different; it is not\na function, so it doesn\u2019t use parentheses. >>> print 'Hello, World!' This distinction will make more sense soon, but that\u2019s enough to\nget started. 1.4\u00a0\u00a0Arithmetic operators After \u201cHello, World\u201d, the next step is arithmetic. Python provides operators , which are special symbols that represent computations\nlike addition and multiplication. The operators + , - , and * perform addition,\nsubtraction, and multiplication, as in the following examples: >>> 40 + 2\n42\n>>> 43 - 1\n42\n>>> 6 * 7\n42 The operator / performs division: >>> 84 / 2\n42.0 You might wonder why the result is 42.0 instead of 42 .\nI\u2019ll explain in the next section. Finally, the operator ** performs exponentiation; that is,\nit raises a number to a power: >>> 6**2 + 6\n42 In some other languages, ^ is used for exponentiation, but\nin Python it is a bitwise operator called XOR. If you are not\nfamiliar with bitwise operators, the result will surprise you: >>> 6 ^ 2\n4 I won\u2019t cover\nbitwise operators in this book, but you can read about\nthem at http://wiki.python.org/moin/BitwiseOperators . 1.5\u00a0\u00a0Values and types A value is one of the basic things a program works with, like a\nletter or a number. Some values we have seen so far are 2 , 42.0 , and 'Hello, World!' . These values belong to different types : 2 is an integer , 42.0 is a floating-point number ,\nand 'Hello, World!' is a string ,\nso-called because the letters it contains are strung together. If you are not sure what type a value has, the interpreter can\ntell you: >>> type(2)\n<class 'int'>\n>>> type(42.0)\n<class 'float'>\n>>> type('Hello, World!')\n<class 'str'> In these results, the word \u201cclass\u201d is used in the sense of\na category; a type is a category of values. Not surprisingly, integers belong to the type int ,\nstrings belong to str and floating-point\nnumbers belong to float . What about values like '2' and '42.0' ?\nThey look like numbers, but they are in quotation marks like\nstrings. >>> type('2')\n<class 'str'>\n>>> type('42.0')\n<class 'str'> They\u2019re strings. When you type a large integer, you might be tempted to use commas\nbetween groups of digits, as in 1,000,000 . This is not a\nlegal integer in Python, but it is legal: >>> 1,000,000\n(1, 0, 0) That\u2019s not what we expected at all! Python interprets 1,000,000 as a comma-separated sequence of integers. We\u2019ll learn\nmore about this kind of sequence later. 1.6\u00a0\u00a0Formal and natural languages Natural languages are the languages people speak,\nsuch as English, Spanish, and French. They were not designed\nby people (although people try to impose some order on them);\nthey evolved naturally. Formal languages are languages that are designed by people for\nspecific applications. For example, the notation that mathematicians\nuse is a formal language that is particularly good at denoting\nrelationships among numbers and symbols. Chemists use a formal\nlanguage to represent the chemical structure of molecules. And\nmost importantly: Programming languages are formal languages that have been\ndesigned to express computations. Formal languages tend to have strict syntax rules that\ngovern the structure of statements.\nFor example, in mathematics the statement\n3 + 3 = 6 has correct syntax, but\n3 + = 3 $ 6 does not. In chemistry H 2 O is a syntactically correct formula, but 2 Zz is not. Syntax rules come in two flavors, pertaining to tokens and\nstructure. Tokens are the basic elements of the language, such as\nwords, numbers, and chemical elements. One of the problems with\n3 += 3 $ 6 is that  $  is not a legal token in mathematics\n(at least as far as I know). Similarly, 2 Zz is not legal because\nthere is no element with the abbreviation Zz . The second type of syntax rule pertains to the way tokens are\ncombined. The equation 3 +/ 3 is illegal because even though +\nand / are legal tokens, you can\u2019t have one right after the other.\nSimilarly, in a chemical formula the subscript comes after the element\nname, not before. This is @ well-structured Engli$h\nsentence with invalid t*kens in it. This sentence all valid tokens\nhas, but invalid structure with. When you read a sentence in English or a statement in a formal\nlanguage, you have to figure out the structure\n(although in a natural language you do this subconsciously). This\nprocess is called parsing . Although formal and natural languages have many features in\ncommon\u2014tokens, structure, and syntax\u2014there are some\ndifferences: ambiguity: Natural languages are full of ambiguity, which\npeople deal with by using contextual clues and other information.\nFormal languages are designed to be nearly or completely unambiguous,\nwhich means that any statement has exactly one meaning,\nregardless of context. redundancy: In order to make up for ambiguity and reduce\nmisunderstandings, natural languages employ lots of\nredundancy. As a result, they are often verbose. Formal languages\nare less redundant and more concise. literalness: Natural languages are full of idiom and metaphor.\nIf I say, \u201cThe penny dropped\u201d, there is probably no penny and\nnothing dropping (this idiom means that someone understood something\nafter a period of confusion). Formal languages\nmean exactly what they say. Because we all grow up speaking natural languages, it is sometimes\nhard to adjust to formal languages. The difference between formal and\nnatural language is like the difference between poetry and prose, but\nmore so: Poetry: Words are used for their sounds as well as for\ntheir meaning, and the whole poem together creates an effect or\nemotional response. Ambiguity is not only common but often\ndeliberate. Prose: The literal meaning of words is more important,\nand the structure contributes more meaning. Prose is more amenable to\nanalysis than poetry but still often ambiguous. Programs: The meaning of a computer program is unambiguous\nand literal, and can be understood entirely by analysis of the\ntokens and structure. Formal languages are more dense\nthan natural languages, so it takes longer to read them. Also, the\nstructure is important, so it is not always best to read\nfrom top to bottom, left to right. Instead, learn to parse the\nprogram in your head, identifying the tokens and interpreting the\nstructure. Finally, the details matter. Small errors in\nspelling and punctuation, which you can get away\nwith in natural languages, can make a big difference in a formal\nlanguage. 1.7\u00a0\u00a0Debugging Programmers make mistakes. For whimsical reasons, programming errors\nare called bugs and the process of tracking them down is called debugging . Programming, and especially debugging, sometimes brings out strong\nemotions. If you are struggling with a difficult bug, you might\nfeel angry, despondent, or embarrassed. There is evidence that people naturally respond to computers as if\nthey were people. When they work well, we think\nof them as teammates, and when they are obstinate or rude, we\nrespond to them the same way we respond to rude,\nobstinate people (Reeves and Nass, The Media\nEquation: How People Treat Computers, Television, and New Media\nLike Real People and Places ). Preparing for these reactions might help you deal with them.\nOne approach is to think of the computer as an employee with\ncertain strengths, like speed and precision, and\nparticular weaknesses, like lack of empathy and inability\nto grasp the big picture. Your job is to be a good manager: find ways to take advantage\nof the strengths and mitigate the weaknesses. And find ways\nto use your emotions to engage with the problem,\nwithout letting your reactions interfere with your ability\nto work effectively. Learning to debug can be frustrating, but it is a valuable skill\nthat is useful for many activities beyond programming. At the\nend of each chapter there is a section, like this one,\nwith my suggestions for debugging. I hope they help! 1.8\u00a0\u00a0Glossary problem solving: The process of formulating a problem, finding\na solution, and expressing it. high-level language: A programming language like Python that\nis designed to be easy for humans to read and write. low-level language: A programming language that is designed\nto be easy for a computer to run; also called \u201cmachine language\u201d or\n\u201cassembly language\u201d. portability: A property of a program that can run on more\nthan one kind of computer. interpreter: A program that reads another program and executes\nit prompt: Characters displayed by the interpreter to indicate\nthat it is ready to take input from the user. program: A set of instructions that specifies a computation. print statement: An instruction that causes the Python\ninterpreter to display a value on the screen. operator: A special symbol that represents a simple computation like\naddition, multiplication, or string concatenation. value: One of the basic units of data, like a number or string,\nthat a program manipulates. type: A category of values. The types we have seen so far\nare integers (type int ), floating-point numbers (type float ), and strings (type str ). integer: A type that represents whole numbers. floating-point: A type that represents numbers with fractional\nparts. string: A type that represents sequences of characters. natural language: Any one of the languages that people speak that\nevolved naturally. formal language: Any one of the languages that people have designed\nfor specific purposes, such as representing mathematical ideas or\ncomputer programs; all programming languages are formal languages. token: One of the basic elements of the syntactic structure of\na program, analogous to a word in a natural language. syntax: The rules that govern the structure of a program. parse: To examine a program and analyze the syntactic structure. bug: An error in a program. debugging: The process of finding and correcting bugs. 1.9\u00a0\u00a0Exercises Exercise\u00a01 It is a good idea to read this book in front of a computer so you can\ntry out the examples as you go. Whenever you are experimenting with a new feature, you should try\nto make mistakes. For example, in the \u201cHello, world!\u201d program,\nwhat happens if you leave out one of the quotation marks? What\nif you leave out both? What if you spell print wrong? This kind of experiment helps you remember what you read; it also\nhelps when you are programming, because you get to know what the error\nmessages mean. It is better to make mistakes now and on purpose than\nlater and accidentally. In a print statement, what happens if you leave out one\nof the parentheses, or both? If you are trying to print a string, what happens if you\nleave out one of the quotation marks, or both? You can use a minus sign to make a negative number like -2 . What happens if you put a plus sign before a number?\nWhat about 2++2 ? In math notation, leading zeros are ok, as in 09 .\nWhat happens if you try this in Python? What about 011 ? What happens if you have two values with no operator\nbetween them? Exercise\u00a02 Start the Python interpreter and use it as a calculator. How many seconds are there in 42 minutes 42 seconds? How many miles are there in 10 kilometers? Hint: there are 1.61\nkilometers in a mile. If you run a 10 kilometer race in 42 minutes 42 seconds, what is\nyour average pace (time per mile in minutes and seconds)? What is\nyour average speed in miles per hour? Buy this book at Amazon.com\n\n#### Contribute\n\nIf you would like to make a contribution to support my books,\nyou can use the button below and pay with PayPal.  Thank you!\nPay what you want:\nSmall $1.00 USD\nMedium $5.00 USD\nLarge $10.00 USD\nX-Large $20.00 USD\nXX-Large $50.00 USD\nAre you using one of our books in a class? We'd like to know\nabout it.  Please consider filling out this short survey . Think DSP Think Java Think Bayes Think Python 2e Think Stats 2e Think Complexity",
      "difficulty": "intro",
      "doc_id": "doc-chapter-1-the-way-of-the-program-06335be0a8",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-NC 3.0",
        "source_file": "data/corpus_raw/scraped/thinkpython2_html_thinkpython2002_html_00aa1a.json",
        "url": "https://greenteapress.com/thinkpython2/html/thinkpython2002.html"
      },
      "title": "Chapter\u00a01\u00a0\u00a0The way of the program",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "data_structures",
        "lists",
        "tuples"
      ],
      "content": "Buy this book at Amazon.com Chapter\u00a010\u00a0\u00a0Lists This chapter presents one of Python\u2019s most useful built-in types, lists.\nYou will also learn more about objects and what can happen when you have\nmore than one name for the same object. 10.1\u00a0\u00a0A list is a sequence Like a string, a list is a sequence of values. In a string, the\nvalues are characters; in a list, they can be any type. The values in\na list are called elements or sometimes items . There are several ways to create a new list; the simplest is to\nenclose the elements in square brackets ( [ and ] ): [10, 20, 30, 40]\n['crunchy frog', 'ram bladder', 'lark vomit'] The first example is a list of four integers. The second is a list of\nthree strings. The elements of a list don\u2019t have to be the same type.\nThe following list contains a string, a float, an integer, and\n(lo!) another list: ['spam', 2.0, 5, [10, 20]] A list within another list is nested . A list that contains no elements is\ncalled an empty list; you can create one with empty\nbrackets, [] . As you might expect, you can assign list values to variables: >>> cheeses = ['Cheddar', 'Edam', 'Gouda']\n>>> numbers = [42, 123]\n>>> empty = []\n>>> print(cheeses, numbers, empty)\n['Cheddar', 'Edam', 'Gouda'] [42, 123] [] 10.2\u00a0\u00a0Lists are mutable The syntax for accessing the elements of a list is the same as for\naccessing the characters of a string\u2014the bracket operator. The\nexpression inside the brackets specifies the index. Remember that the\nindices start at 0: >>> cheeses[0]\n'Cheddar' Unlike strings, lists are mutable. When the bracket operator appears\non the left side of an assignment, it identifies the element of the\nlist that will be assigned. >>> numbers = [42, 123]\n>>> numbers[1] = 5\n>>> numbers\n[42, 5] The one-eth element of numbers , which\nused to be 123, is now 5. Figure 10.1 shows\nthe state diagram for cheeses , numbers and empty . Figure 10.1: State diagram. Lists are represented by boxes with the word \u201clist\u201d outside\nand the elements of the list inside. cheeses refers to\na list with three elements indexed 0, 1 and 2. numbers contains two elements; the diagram shows that the\nvalue of the second element has been reassigned from 123 to 5. empty refers to a list with no elements. List indices work the same way as string indices: Any integer expression can be used as an index. If you try to read or write an element that does not exist, you\nget an IndexError . If an index has a negative value, it counts backward from the\nend of the list. The in operator also works on lists. >>> cheeses = ['Cheddar', 'Edam', 'Gouda']\n>>> 'Edam' in cheeses\nTrue\n>>> 'Brie' in cheeses\nFalse 10.3\u00a0\u00a0Traversing a list The most common way to traverse the elements of a list is\nwith a for loop. The syntax is the same as for strings: for cheese in cheeses:\n    print(cheese) This works well if you only need to read the elements of the\nlist. But if you want to write or update the elements, you\nneed the indices. A common way to do that is to combine\nthe built-in functions range and len : for i in range(len(numbers)):\n    numbers[i] = numbers[i] * 2 This loop traverses the list and updates each element. len returns the number of elements in the list. range returns\na list of indices from 0 to n \u22121, where n is the length of\nthe list. Each time through the loop i gets the index\nof the next element. The assignment statement in the body uses i to read the old value of the element and to assign the\nnew value. A for loop over an empty list never runs the body: for x in []:\n    print('This never happens.') Although a list can contain another list, the nested\nlist still counts as a single element. The length of this list is\nfour: ['spam', 1, ['Brie', 'Roquefort', 'Pol le Veq'], [1, 2, 3]] 10.4\u00a0\u00a0List operations The + operator concatenates lists: >>> a = [1, 2, 3]\n>>> b = [4, 5, 6]\n>>> c = a + b\n>>> c\n[1, 2, 3, 4, 5, 6] The * operator repeats a list a given number of times: >>> [0] * 4\n[0, 0, 0, 0]\n>>> [1, 2, 3] * 3\n[1, 2, 3, 1, 2, 3, 1, 2, 3] The first example repeats [0] four times. The second example\nrepeats the list [1, 2, 3] three times. 10.5\u00a0\u00a0List slices The slice operator also works on lists: >>> t = ['a', 'b', 'c', 'd', 'e', 'f']\n>>> t[1:3]\n['b', 'c']\n>>> t[:4]\n['a', 'b', 'c', 'd']\n>>> t[3:]\n['d', 'e', 'f'] If you omit the first index, the slice starts at the beginning.\nIf you omit the second, the slice goes to the end. So if you\nomit both, the slice is a copy of the whole list. >>> t[:]\n['a', 'b', 'c', 'd', 'e', 'f'] Since lists are mutable, it is often useful to make a copy\nbefore performing operations that modify lists. A slice operator on the left side of an assignment\ncan update multiple elements: >>> t = ['a', 'b', 'c', 'd', 'e', 'f']\n>>> t[1:3] = ['x', 'y']\n>>> t\n['a', 'x', 'y', 'd', 'e', 'f'] 10.6\u00a0\u00a0List methods Python provides methods that operate on lists. For example, append adds a new element to the end of a list: >>> t = ['a', 'b', 'c']\n>>> t.append('d')\n>>> t\n['a', 'b', 'c', 'd'] extend takes a list as an argument and appends all of\nthe elements: >>> t1 = ['a', 'b', 'c']\n>>> t2 = ['d', 'e']\n>>> t1.extend(t2)\n>>> t1\n['a', 'b', 'c', 'd', 'e'] This example leaves t2 unmodified. sort arranges the elements of the list from low to high: >>> t = ['d', 'c', 'e', 'b', 'a']\n>>> t.sort()\n>>> t\n['a', 'b', 'c', 'd', 'e'] Most list methods are void; they modify the list and return None .\nIf you accidentally write t = t.sort() , you will be disappointed\nwith the result. 10.7\u00a0\u00a0Map, filter and reduce To add up all the numbers in a list, you can use a loop like this: def add_all(t):\n    total = 0\n    for x in t:\n        total += x\n    return total total is initialized to 0. Each time through the loop, x gets one element from the list. The += operator\nprovides a short way to update a variable. This augmented assignment statement , total += x is equivalent to total = total + x As the loop runs, total accumulates the sum of the\nelements; a variable used this way is sometimes called an accumulator . Adding up the elements of a list is such a common operation\nthat Python provides it as a built-in function, sum : >>> t = [1, 2, 3]\n>>> sum(t)\n6 An operation like this that combines a sequence of elements into\na single value is sometimes called reduce . Sometimes you want to traverse one list while building\nanother. For example, the following function takes a list of strings\nand returns a new list that contains capitalized strings: def capitalize_all(t):\n    res = []\n    for s in t:\n        res.append(s.capitalize())\n    return res res is initialized with an empty list; each time through\nthe loop, we append the next element. So res is another\nkind of accumulator. An operation like capitalize_all is sometimes called a map because it \u201cmaps\u201d a function (in this case the method capitalize ) onto each of the elements in a sequence. Another common operation is to select some of the elements from\na list and return a sublist. For example, the following\nfunction takes a list of strings and returns a list that contains\nonly the uppercase strings: def only_upper(t):\n    res = []\n    for s in t:\n        if s.isupper():\n            res.append(s)\n    return res isupper is a string method that returns True if\nthe string contains only upper case letters. An operation like only_upper is called a filter because\nit selects some of the elements and filters out the others. Most common list operations can be expressed as a combination\nof map, filter and reduce. 10.8\u00a0\u00a0Deleting elements There are several ways to delete elements from a list. If you\nknow the index of the element you want, you can use pop : >>> t = ['a', 'b', 'c']\n>>> x = t.pop(1)\n>>> t\n['a', 'c']\n>>> x\n'b' pop modifies the list and returns the element that was removed.\nIf you don\u2019t provide an index, it deletes and returns the\nlast element. If you don\u2019t need the removed value, you can use the del operator: >>> t = ['a', 'b', 'c']\n>>> del t[1]\n>>> t\n['a', 'c'] If you know the element you want to remove (but not the index), you\ncan use remove : >>> t = ['a', 'b', 'c']\n>>> t.remove('b')\n>>> t\n['a', 'c'] The return value from remove is None . To remove more than one element, you can use del with\na slice index: >>> t = ['a', 'b', 'c', 'd', 'e', 'f']\n>>> del t[1:5]\n>>> t\n['a', 'f'] As usual, the slice selects all the elements up to but not\nincluding the second index. 10.9\u00a0\u00a0Lists and strings A string is a sequence of characters and a list is a sequence\nof values, but a list of characters is not the same as a\nstring. To convert from a string to a list of characters,\nyou can use list : >>> s = 'spam'\n>>> t = list(s)\n>>> t\n['s', 'p', 'a', 'm'] Because list is the name of a built-in function, you should\navoid using it as a variable name. I also avoid l because\nit looks too much like 1 . So that\u2019s why I use t . The list function breaks a string into individual letters. If\nyou want to break a string into words, you can use the split method: >>> s = 'pining for the fjords'\n>>> t = s.split()\n>>> t\n['pining', 'for', 'the', 'fjords'] An optional argument called a delimiter specifies which\ncharacters to use as word boundaries.\nThe following example\nuses a hyphen as a delimiter: >>> s = 'spam-spam-spam'\n>>> delimiter = '-'\n>>> t = s.split(delimiter)\n>>> t\n['spam', 'spam', 'spam'] join is the inverse of split . It\ntakes a list of strings and\nconcatenates the elements. join is a string method,\nso you have to invoke it on the delimiter and pass the\nlist as a parameter: >>> t = ['pining', 'for', 'the', 'fjords']\n>>> delimiter = ' '\n>>> s = delimiter.join(t)\n>>> s\n'pining for the fjords' In this case the delimiter is a space character, so join puts a space between words. To concatenate\nstrings without spaces, you can use the empty string, '' , as a delimiter. 10.10\u00a0\u00a0Objects and values If we run these assignment statements: a = 'banana'\nb = 'banana' We know that a and b both refer to a\nstring, but we don\u2019t\nknow whether they refer to the same string.\nThere are two possible states, shown in Figure 10.2 . Figure 10.2: State diagram. In one case, a and b refer to two different objects that\nhave the same value. In the second case, they refer to the same\nobject. To check whether two variables refer to the same object, you can\nuse the is operator. >>> a = 'banana'\n>>> b = 'banana'\n>>> a is b\nTrue In this example, Python only created one string object, and both a and b refer to it. But when you create two lists, you get\ntwo objects: >>> a = [1, 2, 3]\n>>> b = [1, 2, 3]\n>>> a is b\nFalse So the state diagram looks like Figure 10.3 . Figure 10.3: State diagram. In this case we would say that the two lists are equivalent ,\nbecause they have the same elements, but not identical , because\nthey are not the same object. If two objects are identical, they are\nalso equivalent, but if they are equivalent, they are not necessarily\nidentical. Until now, we have been using \u201cobject\u201d and \u201cvalue\u201d\ninterchangeably, but it is more precise to say that an object has a\nvalue. If you evaluate [1, 2, 3] , you get a list\nobject whose value is a sequence of integers. If another\nlist has the same elements, we say it has the same value, but\nit is not the same object. 10.11\u00a0\u00a0Aliasing If a refers to an object and you assign b = a ,\nthen both variables refer to the same object: >>> a = [1, 2, 3]\n>>> b = a\n>>> b is a\nTrue The state diagram looks like Figure 10.4 . Figure 10.4: State diagram. The association of a variable with an object is called a reference . In this example, there are two references to the same\nobject. An object with more than one reference has more\nthan one name, so we say that the object is aliased . If the aliased object is mutable, changes made with one alias affect\nthe other: >>> b[0] = 42\n>>> a\n[42, 2, 3] Although this behavior can be useful, it is error-prone. In general,\nit is safer to avoid aliasing when you are working with mutable\nobjects. For immutable objects like strings, aliasing is not as much of a\nproblem. In this example: a = 'banana'\nb = 'banana' It almost never makes a difference whether a and b refer\nto the same string or not. 10.12\u00a0\u00a0List arguments When you pass a list to a function, the function gets a reference to\nthe list. If the function modifies the list, the caller sees\nthe change. For example, delete_head removes the first element\nfrom a list: def delete_head(t):\n    del t[0] Here\u2019s how it is used: >>> letters = ['a', 'b', 'c']\n>>> delete_head(letters)\n>>> letters\n['b', 'c'] The parameter t and the variable letters are\naliases for the same object. The stack diagram looks like\nFigure 10.5 . Figure 10.5: Stack diagram. Since the list is shared by two frames, I drew\nit between them. It is important to distinguish between operations that\nmodify lists and operations that create new lists. For\nexample, the append method modifies a list, but the + operator creates a new list. Here\u2019s an example using append : >>> t1 = [1, 2]\n>>> t2 = t1.append(3)\n>>> t1\n[1, 2, 3]\n>>> t2\nNone The return value from append is None . Here\u2019s an example using the + operator: >>> t3 = t1 + [4]\n>>> t1\n[1, 2, 3]\n>>> t3\n[1, 2, 3, 4] The result of the operator is a new list, and the original list is\nunchanged. This difference is important when you write functions that\nare supposed to modify lists. For example, this function does not delete the head of a list: def bad_delete_head(t):\n    t = t[1:]              # WRONG! The slice operator creates a new list and the assignment\nmakes t refer to it, but that doesn\u2019t affect the caller. >>> t4 = [1, 2, 3]\n>>> bad_delete_head(t4)\n>>> t4\n[1, 2, 3] At the beginning of bad_delete_head , t and t4 refer to the same list. At the end, t refers to a new list,\nbut t4 still refers to the original, unmodified list. An alternative is to write a function that creates and\nreturns a new list. For\nexample, tail returns all but the first\nelement of a list: def tail(t):\n    return t[1:] This function leaves the original list unmodified.\nHere\u2019s how it is used: >>> letters = ['a', 'b', 'c']\n>>> rest = tail(letters)\n>>> rest\n['b', 'c'] 10.13\u00a0\u00a0Debugging Careless use of lists (and other mutable objects)\ncan lead to long hours of debugging. Here are some common\npitfalls and ways to avoid them: Most list methods modify the argument and\nreturn None . This is the opposite of the string methods,\nwhich return a new string and leave the original alone. If you are used to writing string code like this: word = word.strip() It is tempting to write list code like this: t = t.sort()           # WRONG! Because sort returns None , the\nnext operation you perform with t is likely to fail. Before using list methods and operators, you should read the\ndocumentation carefully and then test them in interactive mode. Pick an idiom and stick with it. Part of the problem with lists is that there are too many\nways to do things. For example, to remove an element from\na list, you can use pop , remove , del ,\nor even a slice assignment. To add an element, you can use the append method or\nthe + operator. Assuming that t is a list and x is a list element, these are correct: t.append(x)\nt = t + [x]\nt += [x] And these are wrong: t.append([x])          # WRONG!\nt = t.append(x)        # WRONG!\nt + [x]                # WRONG!\nt = t + x              # WRONG! Try out each of these examples in interactive mode to make sure\nyou understand what they do. Notice that only the last\none causes a runtime error; the other three are legal, but they\ndo the wrong thing. Make copies to avoid aliasing. If you want to use a method like sort that modifies\nthe argument, but you need to keep the original list as\nwell, you can make a copy. >>> t = [3, 1, 2]\n>>> t2 = t[:]\n>>> t2.sort()\n>>> t\n[3, 1, 2]\n>>> t2\n[1, 2, 3] In this example you could also use the built-in function sorted ,\nwhich returns a new, sorted list and leaves the original alone. >>> t2 = sorted(t)\n>>> t\n[3, 1, 2]\n>>> t2\n[1, 2, 3] 10.14\u00a0\u00a0Glossary list: A sequence of values. element: One of the values in a list (or other sequence),\nalso called items. nested list: A list that is an element of another list. accumulator: A variable used in a loop to add up or\naccumulate a result. augmented assignment: A statement that updates the value\nof a variable using an operator like += . reduce: A processing pattern that traverses a sequence\nand accumulates the elements into a single result. map: A processing pattern that traverses a sequence and\nperforms an operation on each element. filter: A processing pattern that traverses a list and\nselects the elements that satisfy some criterion. object: Something a variable can refer to. An object\nhas a type and a value. equivalent: Having the same value. identical: Being the same object (which implies equivalence). reference: The association between a variable and its value. aliasing: A circumstance where two or more variables refer to the same\nobject. delimiter: A character or string used to indicate where a\nstring should be split. 10.15\u00a0\u00a0Exercises You can download solutions to these exercises from https://thinkpython.com/code/list_exercises.py . Exercise\u00a01 Write a function called nested_sum that takes a list of lists\nof integers and adds up the elements from all of the nested lists.\nFor example: >>> t = [[1, 2], [3], [4, 5, 6]]\n>>> nested_sum(t)\n21 Exercise\u00a02 Write a function called cumsum that takes a list of numbers and\nreturns the cumulative sum; that is, a new list where the i th\nelement is the sum of the first i +1 elements from the original list.\nFor example: >>> t = [1, 2, 3]\n>>> cumsum(t)\n[1, 3, 6] Exercise\u00a03 Write a function called middle that takes a list and\nreturns a new list that contains all but the first and last\nelements. For example: >>> t = [1, 2, 3, 4]\n>>> middle(t)\n[2, 3] Exercise\u00a04 Write a function called chop that takes a list, modifies it\nby removing the first and last elements, and returns None .\nFor example: >>> t = [1, 2, 3, 4]\n>>> chop(t)\n>>> t\n[2, 3] Exercise\u00a05 Write a function called is_sorted that takes a list as a\nparameter and returns True if the list is sorted in ascending\norder and False otherwise. For example: >>> is_sorted([1, 2, 2])\nTrue\n>>> is_sorted(['b', 'a'])\nFalse Exercise\u00a06 Two words are anagrams if you can rearrange the letters from one\nto spell the other. Write a function called is_anagram that takes two strings and returns True if they are anagrams. Exercise\u00a07 Write a function called has_duplicates that takes\na list and returns True if there is any element that\nappears more than once. It should not modify the original\nlist. Exercise\u00a08 This exercise pertains to the so-called Birthday Paradox, which you\ncan read about at http://en.wikipedia.org/wiki/Birthday_paradox . If there are 23 students in your class, what are the chances\nthat two of them have the same birthday? You can estimate this\nprobability by generating random samples of 23 birthdays\nand checking for matches. Hint: you can generate random birthdays\nwith the randint function in the random module. You can download my\nsolution from https://thinkpython.com/code/birthday.py . Exercise\u00a09 Write a function that reads the file words.txt and builds\na list with one element per word. Write two versions of\nthis function, one using the append method and the\nother using the idiom t = t + [x] . Which one takes\nlonger to run? Why? Solution: https://thinkpython.com/code/wordlist.py . Exercise\u00a010 To check whether a word is in the word list, you could use\nthe in operator, but it would be slow because it searches\nthrough the words in order. Because the words are in alphabetical order, we can speed things up\nwith a bisection search (also known as binary search), which is\nsimilar to what you do when you look a word up in the dictionary (the book, not the data structure). You\nstart in the middle and check to see whether the word you are looking\nfor comes before the word in the middle of the list. If so, you\nsearch the first half of the list the same way. Otherwise you search\nthe second half. Either way, you cut the remaining search space in half. If the\nword list has 113,809 words, it will take about 17 steps to\nfind the word or conclude that it\u2019s not there. Write a function called in_bisect that takes a sorted list\nand a target value and returns True if the word is\nin the list and False if it\u2019s not. Or you could read the documentation of the bisect module\nand use that! Solution: https://thinkpython.com/code/inlist.py . Exercise\u00a011 Two words are a \u201creverse pair\u201d if each is the reverse of the\nother. Write a program that finds all the reverse pairs in the\nword list. Solution: https://thinkpython.com/code/reverse_pair.py . Exercise\u00a012 Two words \u201cinterlock\u201d if taking alternating letters from each forms\na new word. For example, \u201cshoe\u201d and \u201ccold\u201d\ninterlock to form \u201cschooled\u201d.\nSolution: https://thinkpython.com/code/interlock.py .\nCredit: This exercise is inspired by an example at http://puzzlers.org . Write a program that finds all pairs of words that interlock.\nHint: don\u2019t enumerate all pairs! Can you find any words that are three-way interlocked; that is,\nevery third letter forms a word, starting from the first, second or\nthird? Buy this book at Amazon.com\n\n#### Contribute\n\nIf you would like to make a contribution to support my books,\nyou can use the button below and pay with PayPal.  Thank you!\nPay what you want:\nSmall $1.00 USD\nMedium $5.00 USD\nLarge $10.00 USD\nX-Large $20.00 USD\nXX-Large $50.00 USD\nAre you using one of our books in a class? We'd like to know\nabout it.  Please consider filling out this short survey . Think DSP Think Java Think Bayes Think Python 2e Think Stats 2e Think Complexity",
      "difficulty": "intro",
      "doc_id": "doc-chapter-10-lists-3a00a91ee0",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-NC 3.0",
        "source_file": "data/corpus_raw/scraped/thinkpython2_html_thinkpython2011_html_51b49d.json",
        "url": "https://greenteapress.com/thinkpython2/html/thinkpython2011.html"
      },
      "title": "Chapter\u00a010\u00a0\u00a0Lists",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "OOP",
        "classes",
        "objects"
      ],
      "content": "Buy this book at Amazon.com Chapter\u00a011\u00a0\u00a0Dictionaries This chapter presents another built-in type called a dictionary.\nDictionaries are one of Python\u2019s best features; they are the\nbuilding blocks of many efficient and elegant algorithms. 11.1\u00a0\u00a0A dictionary is a mapping A dictionary is like a list, but more general. In a list,\nthe indices have to be integers; in a dictionary they can\nbe (almost) any type. A dictionary contains a collection of indices, which are called keys , and a collection of values. Each key is associated with a\nsingle value. The association of a key and a value is called a key-value pair or sometimes an item . In mathematical language, a dictionary represents a mapping from keys to values, so you can also say that each key\n\u201cmaps to\u201d a value.\nAs an example, we\u2019ll build a dictionary that maps from English\nto Spanish words, so the keys and the values are all strings. The function dict creates a new dictionary with no items.\nBecause dict is the name of a built-in function, you\nshould avoid using it as a variable name. >>> eng2sp = dict()\n>>> eng2sp\n{} The squiggly-brackets, {} , represent an empty dictionary.\nTo add items to the dictionary, you can use square brackets: >>> eng2sp['one'] = 'uno' This line creates an item that maps from the key 'one' to the value 'uno' . If we print the\ndictionary again, we see a key-value pair with a colon\nbetween the key and value: >>> eng2sp\n{'one': 'uno'} This output format is also an input format. For example,\nyou can create a new dictionary with three items: >>> eng2sp = {'one': 'uno', 'two': 'dos', 'three': 'tres'} But if you print eng2sp , you might be surprised: >>> eng2sp\n{'one': 'uno', 'three': 'tres', 'two': 'dos'} The order of the key-value pairs might not be the same. If\nyou type the same example on your computer, you might get a\ndifferent result. In general, the order of items in\na dictionary is unpredictable. But that\u2019s not a problem because\nthe elements of a dictionary are never indexed with integer indices.\nInstead, you use the keys to look up the corresponding values: >>> eng2sp['two']\n'dos' The key 'two' always maps to the value 'dos' so the order\nof the items doesn\u2019t matter. If the key isn\u2019t in the dictionary, you get an exception: >>> eng2sp['four']\nKeyError: 'four' The len function works on dictionaries; it returns the\nnumber of key-value pairs: >>> len(eng2sp)\n3 The in operator works on dictionaries, too; it tells you whether\nsomething appears as a key in the dictionary (appearing\nas a value is not good enough). >>> 'one' in eng2sp\nTrue\n>>> 'uno' in eng2sp\nFalse To see whether something appears as a value in a dictionary, you\ncan use the method values , which returns a collection of\nvalues, and then use the in operator: >>> vals = eng2sp.values()\n>>> 'uno' in vals\nTrue The in operator uses different algorithms for lists and\ndictionaries. For lists, it searches the elements of the list in\norder, as in Section 8.6 . As the list gets longer, the search\ntime gets longer in direct proportion. Python dictionaries use a data structure\ncalled a hashtable that has a remarkable property: the in operator takes about the same amount of time no matter how\nmany items are in the dictionary. I explain how that\u2019s possible\nin Section B.4 , but the explanation might not make\nsense until you\u2019ve read a few more chapters. 11.2\u00a0\u00a0Dictionary as a collection of counters Suppose you are given a string and you want to count how many\ntimes each letter appears. There are several ways you could do it: You could create 26 variables, one for each letter of the\nalphabet. Then you could traverse the string and, for each\ncharacter, increment the corresponding counter, probably using\na chained conditional. You could create a list with 26 elements. Then you could\nconvert each character to a number (using the built-in function ord ), use the number as an index into the list, and increment\nthe appropriate counter. You could create a dictionary with characters as keys\nand counters as the corresponding values. The first time you\nsee a character, you would add an item to the dictionary. After\nthat you would increment the value of an existing item. Each of these options performs the same computation, but each\nof them implements that computation in a different way. An implementation is a way of performing a computation;\nsome implementations are better than others. For example,\nan advantage of the dictionary implementation is that we don\u2019t\nhave to know ahead of time which letters appear in the string\nand we only have to make room for the letters that do appear. Here is what the code might look like: def histogram(s):\n    d = dict()\n    for c in s:\n        if c not in d:\n            d[c] = 1\n        else:\n            d[c] += 1\n    return d The name of the function is histogram , which is a statistical\nterm for a collection of counters (or frequencies). The first line of the\nfunction creates an empty dictionary. The for loop traverses\nthe string. Each time through the loop, if the character c is\nnot in the dictionary, we create a new item with key c and the\ninitial value 1 (since we have seen this letter once). If c is\nalready in the dictionary we increment d[c] . Here\u2019s how it works: >>> h = histogram('brontosaurus')\n>>> h\n{'a': 1, 'b': 1, 'o': 2, 'n': 1, 's': 2, 'r': 2, 'u': 2, 't': 1} The histogram indicates that the letters 'a' and 'b' appear once; 'o' appears twice, and so on. Dictionaries have a method called get that takes a key\nand a default value. If the key appears in the dictionary, get returns the corresponding value; otherwise it returns\nthe default value. For example: >>> h = histogram('a')\n>>> h\n{'a': 1}\n>>> h.get('a', 0)\n1\n>>> h.get('c', 0)\n0 As an exercise, use get to write histogram more concisely. You\nshould be able to eliminate the if statement. 11.3\u00a0\u00a0Looping and dictionaries If you use a dictionary in a for statement, it traverses\nthe keys of the dictionary. For example, print_hist prints each key and the corresponding value: def print_hist(h):\n    for c in h:\n        print(c, h[c]) Here\u2019s what the output looks like: >>> h = histogram('parrot')\n>>> print_hist(h)\na 1\np 1\nr 2\nt 1\no 1 Again, the keys are in no particular order. To traverse the keys\nin sorted order, you can use the built-in function sorted : >>> for key in sorted(h):\n...     print(key, h[key])\na 1\no 1\np 1\nr 2\nt 1 11.4\u00a0\u00a0Reverse lookup Given a dictionary d and a key k , it is easy to\nfind the corresponding value v = d[k] . This operation\nis called a lookup . But what if you have v and you want to find k ?\nYou have two problems: first, there might be more than one\nkey that maps to the value v . Depending on the application,\nyou might be able to pick one, or you might have to make\na list that contains all of them. Second, there is no\nsimple syntax to do a reverse lookup ; you have to search. Here is a function that takes a value and returns the first\nkey that maps to that value: def reverse_lookup(d, v):\n    for k in d:\n        if d[k] == v:\n            return k\n    raise LookupError() This function is yet another example of the search pattern, but it\nuses a feature we haven\u2019t seen before, raise . The raise statement causes an exception; in this case it causes a LookupError , which is a built-in exception used to indicate\nthat a lookup operation failed. If we get to the end of the loop, that means v doesn\u2019t appear in the dictionary as a value, so we raise an\nexception. Here is an example of a successful reverse lookup: >>> h = histogram('parrot')\n>>> key = reverse_lookup(h, 2)\n>>> key\n'r' And an unsuccessful one: >>> key = reverse_lookup(h, 3)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"<stdin>\", line 5, in reverse_lookup\nLookupError The effect when you raise an exception is the same as when\nPython raises one: it prints a traceback and an error message. When you raise an exception, you can provide a detailed error message as an optional argument. For example: >>> raise LookupError('value does not appear in the dictionary')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in ?\nLookupError: value does not appear in the dictionary A reverse lookup is much slower than a forward lookup; if you\nhave to do it often, or if the dictionary gets big, the performance\nof your program will suffer. 11.5\u00a0\u00a0Dictionaries and lists Lists can appear as values in a dictionary. For example, if you\nare given a dictionary that maps from letters to frequencies, you\nmight want to invert it; that is, create a dictionary that maps\nfrom frequencies to letters. Since there might be several letters\nwith the same frequency, each value in the inverted dictionary\nshould be a list of letters. Here is a function that inverts a dictionary: def invert_dict(d):\n    inverse = dict()\n    for key in d:\n        val = d[key]\n        if val not in inverse:\n            inverse[val] = [key]\n        else:\n            inverse[val].append(key)\n    return inverse Each time through the loop, key gets a key from d and val gets the corresponding value. If val is not in inverse , that means we haven\u2019t seen it before, so we create a new\nitem and initialize it with a singleton (a list that contains a\nsingle element). Otherwise we have seen this value before, so we\nappend the corresponding key to the list. Here is an example: >>> hist = histogram('parrot')\n>>> hist\n{'a': 1, 'p': 1, 'r': 2, 't': 1, 'o': 1}\n>>> inverse = invert_dict(hist)\n>>> inverse\n{1: ['a', 'p', 't', 'o'], 2: ['r']} Figure 11.1: State diagram. Figure 11.1 is a state diagram showing hist and inverse .\nA dictionary is represented as a box with the type dict above it\nand the key-value pairs inside. If the values are integers, floats or\nstrings, I draw them inside the box, but I usually draw lists\noutside the box, just to keep the diagram simple. Lists can be values in a dictionary, as this example shows, but they\ncannot be keys. Here\u2019s what happens if you try: >>> t = [1, 2, 3]\n>>> d = dict()\n>>> d[t] = 'oops'\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in ?\nTypeError: list objects are unhashable I mentioned earlier that a dictionary is implemented using\na hashtable and that means that the keys have to be hashable . A hash is a function that takes a value (of any kind)\nand returns an integer. Dictionaries use these integers,\ncalled hash values, to store and look up key-value pairs. This system works fine if the keys are immutable. But if the\nkeys are mutable, like lists, bad things happen. For example,\nwhen you create a key-value pair, Python hashes the key and\nstores it in the corresponding location. If you modify the\nkey and then hash it again, it would go to a different location.\nIn that case you might have two entries for the same key,\nor you might not be able to find a key. Either way, the\ndictionary wouldn\u2019t work correctly. That\u2019s why keys have to be hashable, and why mutable types like\nlists aren\u2019t. The simplest way to get around this limitation is to\nuse tuples, which we will see in the next chapter. Since dictionaries are mutable, they can\u2019t be used as keys,\nbut they can be used as values. 11.6\u00a0\u00a0Memos If you played with the fibonacci function from\nSection 6.7 , you might have noticed that the bigger\nthe argument you provide, the longer the function takes to run.\nFurthermore, the run time increases quickly. To understand why, consider Figure 11.2 , which shows\nthe call graph for fibonacci with n=4 : Figure 11.2: Call graph. A call graph shows a set of function frames, with lines connecting each\nframe to the frames of the functions it calls. At the top of the\ngraph, fibonacci with n=4 calls fibonacci with n=3 and n=2 . In turn, fibonacci with n=3 calls fibonacci with n=2 and n=1 . And so on. Count how many times fibonacci(0) and fibonacci(1) are\ncalled. This is an inefficient solution to the problem, and it gets\nworse as the argument gets bigger. One solution is to keep track of values that have already been\ncomputed by storing them in a dictionary. A previously computed value\nthat is stored for later use is called a memo . Here is a\n\u201cmemoized\u201d version of fibonacci : known = {0:0, 1:1}\n\ndef fibonacci(n):\n    if n in known:\n        return known[n]\n\n    res = fibonacci(n-1) + fibonacci(n-2)\n    known[n] = res\n    return res known is a dictionary that keeps track of the Fibonacci\nnumbers we already know. It starts with\ntwo items: 0 maps to 0 and 1 maps to 1. Whenever fibonacci is called, it checks known .\nIf the result is already there, it can return\nimmediately. Otherwise it has to\ncompute the new value, add it to the dictionary, and return it. If you run this version of fibonacci and compare it with\nthe original, you will find that it is much faster. 11.7\u00a0\u00a0Global variables In the previous example, known is created outside the function,\nso it belongs to the special frame called __main__ .\nVariables in __main__ are sometimes called global because they can be accessed from any function. Unlike local\nvariables, which disappear when their function ends, global variables\npersist from one function call to the next. It is common to use global variables for flags ; that is,\nboolean variables that indicate (\u201cflag\u201d) whether a condition\nis true. For example, some programs use\na flag named verbose to control the level of detail in the\noutput: verbose = True\n\ndef example1():\n    if verbose:\n        print('Running example1') If you try to reassign a global variable, you might be surprised.\nThe following example is supposed to keep track of whether the\nfunction has been called: been_called = False\n\ndef example2():\n    been_called = True         # WRONG But if you run it you will see that the value of been_called doesn\u2019t change. The problem is that example2 creates a new local\nvariable named been_called . The local variable goes away when\nthe function ends, and has no effect on the global variable. To reassign a global variable inside a function you have to declare the global variable before you use it: been_called = False\n\ndef example2():\n    global been_called\n    been_called = True The global statement tells the interpreter\nsomething like, \u201cIn this function, when I say been_called , I\nmean the global variable; don\u2019t create a local one.\u201d Here\u2019s an example that tries to update a global variable: count = 0\n\ndef example3():\n    count = count + 1          # WRONG If you run it you get: UnboundLocalError: local variable 'count' referenced before assignment Python assumes that count is local, and under that assumption\nyou are reading it before writing it. The solution, again,\nis to declare count global. def example3():\n    global count\n    count += 1 If a global variable refers to a mutable value, you can modify\nthe value without declaring the variable: known = {0:0, 1:1}\n\ndef example4():\n    known[2] = 1 So you can add, remove and replace elements of a global list or\ndictionary, but if you want to reassign the variable, you\nhave to declare it: def example5():\n    global known\n    known = dict() Global variables can be useful, but if you have a lot of them,\nand you modify them frequently, they can make programs\nhard to debug. 11.8\u00a0\u00a0Debugging As you work with bigger datasets it can become unwieldy to\ndebug by printing and checking the output by hand. Here are some\nsuggestions for debugging large datasets: Scale down the input: If possible, reduce the size of the\ndataset. For example if the program reads a text file, start with\njust the first 10 lines, or with the smallest example you can find.\nYou can either edit the files themselves, or (better) modify the\nprogram so it reads only the first n lines. If there is an error, you can reduce n to the smallest\nvalue that manifests the error, and then increase it gradually\nas you find and correct errors. Check summaries and types: Instead of printing and checking the\nentire dataset, consider printing summaries of the data: for example,\nthe number of items in a dictionary or the total of a list of numbers. A common cause of runtime errors is a value that is not the right\ntype. For debugging this kind of error, it is often enough to print\nthe type of a value. Write self-checks: Sometimes you can write code to check\nfor errors automatically. For example, if you are computing the\naverage of a list of numbers, you could check that the result is\nnot greater than the largest element in the list or less than\nthe smallest. This is called a \u201csanity check\u201d because it detects\nresults that are \u201cinsane\u201d. Another kind of check compares the results of two different\ncomputations to see if they are consistent. This is called a\n\u201cconsistency check\u201d. Format the output: Formatting debugging output\ncan make it easier to spot an error. We saw an example in\nSection 6.9 . Another tool you might find useful is the pprint module, which provides\na pprint function that displays built-in types in\na more human-readable format ( pprint stands for\n\u201cpretty print\u201d). Again, time you spend building scaffolding can reduce\nthe time you spend debugging. 11.9\u00a0\u00a0Glossary mapping: A relationship in which each element of one set\ncorresponds to an element of another set. dictionary: A mapping from keys to their\ncorresponding values. key-value pair: The representation of the mapping from\na key to a value. item: In a dictionary, another name for a key-value\npair. key: An object that appears in a dictionary as the\nfirst part of a key-value pair. value: An object that appears in a dictionary as the\nsecond part of a key-value pair. This is more specific than\nour previous use of the word \u201cvalue\u201d. implementation: A way of performing a computation. hashtable: The algorithm used to implement Python\ndictionaries. hash function: A function used by a hashtable to compute the\nlocation for a key. hashable: A type that has a hash function. Immutable\ntypes like integers,\nfloats and strings are hashable; mutable types like lists and\ndictionaries are not. lookup: A dictionary operation that takes a key and finds\nthe corresponding value. reverse lookup: A dictionary operation that takes a value and finds\none or more keys that map to it. raise statement: A statement that (deliberately) raises an exception. singleton: A list (or other sequence) with a single element. call graph: A diagram that shows every frame created during\nthe execution of a program, with an arrow from each caller to\neach callee. memo: A computed value stored to avoid unnecessary future\ncomputation. global variable: A variable defined outside a function. Global\nvariables can be accessed from any function. global statement: A statement that declares a variable name\nglobal. flag: A boolean variable used to indicate whether a condition\nis true. declaration: A statement like global that tells the\ninterpreter something about a variable. 11.10\u00a0\u00a0Exercises Exercise\u00a01 Write a function that reads the words in words.txt and\nstores them as keys in a dictionary. It doesn\u2019t matter what the\nvalues are. Then you can use the in operator\nas a fast way to check whether a string is in\nthe dictionary. If you did Exercise 10 , you can compare the speed\nof this implementation with the list in operator and the\nbisection search. Exercise\u00a02 Read the documentation of the dictionary method setdefault and use it to write a more concise version of invert_dict .\nSolution: https://thinkpython.com/code/invert_dict.py . Exercise\u00a03 Memoize the Ackermann function from Exercise 2 and see if\nmemoization makes it possible to evaluate the function with bigger\narguments. Hint: no.\nSolution: https://thinkpython.com/code/ackermann_memo.py . Exercise\u00a04 If you did Exercise 7 , you already have\na function named has_duplicates that takes a list\nas a parameter and returns True if there is any object\nthat appears more than once in the list. Use a dictionary to write a faster, simpler version of has_duplicates .\nSolution: https://thinkpython.com/code/has_duplicates.py . Exercise\u00a05 Two words are \u201crotate pairs\u201d if you can rotate one of them\nand get the other (see rotate_word in Exercise 5 ). Write a program that reads a wordlist and finds all the rotate\npairs. Solution: https://thinkpython.com/code/rotate_pairs.py . Exercise\u00a06 Here\u2019s another Puzzler from Car Talk ( http://www.cartalk.com/content/puzzlers ): This was sent in by a fellow named Dan O\u2019Leary. He came upon a common\none-syllable, five-letter word recently that has the following unique\nproperty. When you remove the first letter, the remaining letters form\na homophone of the original word, that is a word that sounds exactly\nthe same. Replace the first letter, that is, put it back and remove\nthe second letter and the result is yet another homophone of the\noriginal word. And the question is, what\u2019s the word? Now I\u2019m going to give you an example that doesn\u2019t work. Let\u2019s look at\nthe five-letter word, \u2018wrack.\u2019 W-R-A-C-K, you know like to \u2018wrack with\npain.\u2019 If I remove the first letter, I am left with a four-letter\nword, \u2019R-A-C-K.\u2019 As in, \u2018Holy cow, did you see the rack on that buck!\nIt must have been a nine-pointer!\u2019 It\u2019s a perfect homophone. If you\nput the \u2018w\u2019 back, and remove the \u2018r,\u2019 instead, you\u2019re left with the\nword, \u2018wack,\u2019 which is a real word, it\u2019s just not a homophone of the\nother two words. But there is, however, at least one word that Dan and we know of,\nwhich will yield two homophones if you remove either of the first two\nletters to make two, new four-letter words. The question is, what\u2019s\nthe word? You can use the dictionary from Exercise 1 to check\nwhether a string is in the word list. To check whether two words are homophones, you can use the CMU\nPronouncing Dictionary. You can download it from http://www.speech.cs.cmu.edu/cgi-bin/cmudict or from https://thinkpython.com/code/c06d and you can also download https://thinkpython.com/code/pronounce.py , which provides a function\nnamed read_dictionary that reads the pronouncing dictionary and\nreturns a Python dictionary that maps from each word to a string that\ndescribes its primary pronunciation. Write a program that lists all the words that solve the Puzzler.\nSolution: https://thinkpython.com/code/homophone.py . Buy this book at Amazon.com\n\n#### Contribute\n\nIf you would like to make a contribution to support my books,\nyou can use the button below and pay with PayPal.  Thank you!\nPay what you want:\nSmall $1.00 USD\nMedium $5.00 USD\nLarge $10.00 USD\nX-Large $20.00 USD\nXX-Large $50.00 USD\nAre you using one of our books in a class? We'd like to know\nabout it.  Please consider filling out this short survey . Think DSP Think Java Think Bayes Think Python 2e Think Stats 2e Think Complexity",
      "difficulty": "intermediate",
      "doc_id": "doc-chapter-11-dictionaries-5d588bf9ea",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-NC 3.0",
        "source_file": "data/corpus_raw/thinkpython2_html_thinkpython2012_html_5873bd.json",
        "url": "https://greenteapress.com/thinkpython2/html/thinkpython2012.html"
      },
      "title": "Chapter\u00a011\u00a0\u00a0Dictionaries",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "OOP",
        "classes",
        "inheritance"
      ],
      "content": "Buy this book at Amazon.com Chapter\u00a012\u00a0\u00a0Tuples This chapter presents one more built-in type, the tuple, and then\nshows how lists, dictionaries, and tuples work together.\nI also present a useful feature for variable-length argument lists,\nthe gather and scatter operators. One note: there is no consensus on how to pronounce \u201ctuple\u201d.\nSome people say \u201ctuh-ple\u201d, which rhymes with \u201csupple\u201d. But\nin the context of programming, most people say \u201ctoo-ple\u201d, which\nrhymes with \u201cquadruple\u201d. 12.1\u00a0\u00a0Tuples are immutable A tuple is a sequence of values. The values can be any type, and\nthey are indexed by integers, so in that respect tuples are a lot\nlike lists. The important difference is that tuples are immutable. Syntactically, a tuple is a comma-separated list of values: >>> t = 'a', 'b', 'c', 'd', 'e' Although it is not necessary, it is common to enclose tuples in\nparentheses: >>> t = ('a', 'b', 'c', 'd', 'e') To create a tuple with a single element, you have to include a final\ncomma: >>> t1 = 'a',\n>>> type(t1)\n<class 'tuple'> A value in parentheses is not a tuple: >>> t2 = ('a')\n>>> type(t2)\n<class 'str'> Another way to create a tuple is the built-in function tuple .\nWith no argument, it creates an empty tuple: >>> t = tuple()\n>>> t\n() If the argument is a sequence (string, list or tuple), the result\nis a tuple with the elements of the sequence: >>> t = tuple('lupins')\n>>> t\n('l', 'u', 'p', 'i', 'n', 's') Because tuple is the name of a built-in function, you should\navoid using it as a variable name. Most list operators also work on tuples. The bracket operator\nindexes an element: >>> t = ('a', 'b', 'c', 'd', 'e')\n>>> t[0]\n'a' And the slice operator selects a range of elements. >>> t[1:3]\n('b', 'c') But if you try to modify one of the elements of the tuple, you get\nan error: >>> t[0] = 'A'\nTypeError: object doesn't support item assignment Because tuples are immutable, you can\u2019t modify the elements. But you\ncan replace one tuple with another: >>> t = ('A',) + t[1:]\n>>> t\n('A', 'b', 'c', 'd', 'e') This statement makes a new tuple and then makes t refer to it. The relational operators work with tuples and other sequences;\nPython starts by comparing the first element from each\nsequence. If they are equal, it goes on to the next elements,\nand so on, until it finds elements that differ. Subsequent\nelements are not considered (even if they are really big). >>> (0, 1, 2) < (0, 3, 4)\nTrue\n>>> (0, 1, 2000000) < (0, 3, 4)\nTrue 12.2\u00a0\u00a0Tuple assignment It is often useful to swap the values of two variables.\nWith conventional assignments, you have to use a temporary\nvariable. For example, to swap a and b : >>> temp = a\n>>> a = b\n>>> b = temp This solution is cumbersome; tuple assignment is more elegant: >>> a, b = b, a The left side is a tuple of variables; the right side is a tuple of\nexpressions. Each value is assigned to its respective variable.\nAll the expressions on the right side are evaluated before any\nof the assignments. The number of variables on the left and the number of\nvalues on the right have to be the same: >>> a, b = 1, 2, 3\nValueError: too many values to unpack More generally, the right side can be any kind of sequence\n(string, list or tuple). For example, to split an email address\ninto a user name and a domain, you could write: >>> addr = 'monty@python.org'\n>>> uname, domain = addr.split('@') The return value from split is a list with two elements;\nthe first element is assigned to uname , the second to domain . >>> uname\n'monty'\n>>> domain\n'python.org' 12.3\u00a0\u00a0Tuples as return values Strictly speaking, a function can only return one value, but\nif the value is a tuple, the effect is the same as returning\nmultiple values. For example, if you want to divide two integers\nand compute the quotient and remainder, it is inefficient to\ncompute x//y and then x%y . It is better to compute\nthem both at the same time. The built-in function divmod takes two arguments and\nreturns a tuple of two values, the quotient and remainder.\nYou can store the result as a tuple: >>> t = divmod(7, 3)\n>>> t\n(2, 1) Or use tuple assignment to store the elements separately: >>> quot, rem = divmod(7, 3)\n>>> quot\n2\n>>> rem\n1 Here is an example of a function that returns a tuple: def min_max(t):\n    return min(t), max(t) max and min are built-in functions that find\nthe largest and smallest elements of a sequence. min_max computes both and returns a tuple of two values. 12.4\u00a0\u00a0Variable-length argument tuples Functions can take a variable number of arguments. A parameter\nname that begins with * gathers arguments into\na tuple. For example, printall takes any number of arguments and prints them: def printall(*args):\n    print(args) The gather parameter can have any name you like, but args is\nconventional. Here\u2019s how the function works: >>> printall(1, 2.0, '3')\n(1, 2.0, '3') The complement of gather is scatter . If you have a\nsequence of values and you want to pass it to a function\nas multiple arguments, you can use the * operator.\nFor example, divmod takes exactly two arguments; it\ndoesn\u2019t work with a tuple: >>> t = (7, 3)\n>>> divmod(t)\nTypeError: divmod expected 2 arguments, got 1 But if you scatter the tuple, it works: >>> divmod(*t)\n(2, 1) Many of the built-in functions use\nvariable-length argument tuples. For example, max and min can take any number of arguments: >>> max(1, 2, 3)\n3 But sum does not. >>> sum(1, 2, 3)\nTypeError: sum expected at most 2 arguments, got 3 As an exercise, write a function called sum_all that takes any number\nof arguments and returns their sum. 12.5\u00a0\u00a0Lists and tuples zip is a built-in function that takes two or more sequences and\ninterleaves them. The name of the function refers to\na zipper, which interleaves two rows of teeth. This example zips a string and a list: >>> s = 'abc'\n>>> t = [0, 1, 2]\n>>> zip(s, t)\n<zip object at 0x7f7d0a9e7c48> The result is a zip object that knows how to iterate through\nthe pairs. The most common use of zip is in a for loop: >>> for pair in zip(s, t):\n...     print(pair)\n...\n('a', 0)\n('b', 1)\n('c', 2) A zip object is a kind of iterator , which is any object\nthat iterates through a sequence. Iterators are similar to lists in some\nways, but unlike lists, you can\u2019t use an index to select an element from\nan iterator. If you want to use list operators and methods, you can\nuse a zip object to make a list: >>> list(zip(s, t))\n[('a', 0), ('b', 1), ('c', 2)] The result is a list of tuples; in this example, each tuple contains\na character from the string and the corresponding element from\nthe list. If the sequences are not the same length, the result has the\nlength of the shorter one. >>> list(zip('Anne', 'Elk'))\n[('A', 'E'), ('n', 'l'), ('n', 'k')] You can use tuple assignment in a for loop to traverse a list of\ntuples: t = [('a', 0), ('b', 1), ('c', 2)]\nfor letter, number in t:\n    print(number, letter) Each time through the loop, Python selects the next tuple in\nthe list and assigns the elements to letter and number . The output of this loop is: 0 a\n1 b\n2 c If you combine zip , for and tuple assignment, you get a\nuseful idiom for traversing two (or more) sequences at the same\ntime. For example, has_match takes two sequences, t1 and t2 , and returns True if there is an index i such that t1[i] == t2[i] : def has_match(t1, t2):\n    for x, y in zip(t1, t2):\n        if x == y:\n            return True\n    return False If you need to traverse the elements of a sequence and their\nindices, you can use the built-in function enumerate : for index, element in enumerate('abc'):\n    print(index, element) The result from enumerate is an enumerate object, which\niterates a sequence of pairs; each pair contains an index (starting\nfrom 0) and an element from the given sequence.\nIn this example, the output is 0 a\n1 b\n2 c Again. 12.6\u00a0\u00a0Dictionaries and tuples Dictionaries have a method called items that returns a sequence of\ntuples, where each tuple is a key-value pair. >>> d = {'a':0, 'b':1, 'c':2}\n>>> t = d.items()\n>>> t\ndict_items([('c', 2), ('a', 0), ('b', 1)]) The result is a dict_items object, which is an iterator that\niterates the key-value pairs. You can use it in a for loop\nlike this: >>> for key, value in d.items():\n...     print(key, value)\n...\nc 2\na 0\nb 1 As you should expect from a dictionary, the items are in no\nparticular order. Going in the other direction, you can use a list of tuples to\ninitialize a new dictionary: >>> t = [('a', 0), ('c', 2), ('b', 1)]\n>>> d = dict(t)\n>>> d\n{'a': 0, 'c': 2, 'b': 1} Combining dict with zip yields a concise way\nto create a dictionary: >>> d = dict(zip('abc', range(3)))\n>>> d\n{'a': 0, 'c': 2, 'b': 1} The dictionary method update also takes a list of tuples\nand adds them, as key-value pairs, to an existing dictionary. It is common to use tuples as keys in dictionaries (primarily because\nyou can\u2019t use lists). For example, a telephone directory might map\nfrom last-name, first-name pairs to telephone numbers. Assuming\nthat we have defined last , first and number , we\ncould write: directory[last, first] = number The expression in brackets is a tuple. We could use tuple\nassignment to traverse this dictionary. for last, first in directory:\n    print(first, last, directory[last,first]) This loop traverses the keys in directory , which are tuples. It\nassigns the elements of each tuple to last and first , then\nprints the name and corresponding telephone number. There are two ways to represent tuples in a state diagram. The more\ndetailed version shows the indices and elements just as they appear in\na list. For example, the tuple ('Cleese', 'John') would appear\nas in Figure 12.1 . Figure 12.1: State diagram. But in a larger diagram you might want to leave out the\ndetails. For example, a diagram of the telephone directory might\nappear as in Figure 12.2 . Figure 12.2: State diagram. Here the tuples are shown using Python syntax as a graphical\nshorthand. The telephone number in the diagram is the complaints line\nfor the BBC, so please don\u2019t call it. 12.7\u00a0\u00a0Sequences of sequences I have focused on lists of tuples, but almost all of the examples in\nthis chapter also work with lists of lists, tuples of tuples, and\ntuples of lists. To avoid enumerating the possible combinations, it\nis sometimes easier to talk about sequences of sequences. In many contexts, the different kinds of sequences (strings, lists and\ntuples) can be used interchangeably. So how should you choose one\nover the others? To start with the obvious, strings are more limited than other\nsequences because the elements have to be characters. They are\nalso immutable. If you need the ability to change the characters\nin a string (as opposed to creating a new string), you might\nwant to use a list of characters instead. Lists are more common than tuples, mostly because they are mutable.\nBut there are a few cases where you might prefer tuples: In some contexts, like a return statement, it is\nsyntactically simpler to create a tuple than a list. If you want to use a sequence as a dictionary key, you\nhave to use an immutable type like a tuple or string. If you are passing a sequence as an argument to a function,\nusing tuples reduces the potential for unexpected behavior\ndue to aliasing. Because tuples are immutable, they don\u2019t provide methods like sort and reverse , which modify existing lists. But Python\nprovides the built-in function sorted , which takes any sequence\nand returns a new list with the same elements in sorted order, and reversed , which takes a sequence and returns an iterator that\ntraverses the list in reverse order. 12.8\u00a0\u00a0Debugging Lists, dictionaries and tuples are examples of data\nstructures ; in this chapter we are starting to see compound data\nstructures, like lists of tuples, or dictionaries that contain tuples\nas keys and lists as values. Compound data structures are useful, but\nthey are prone to what I call shape errors ; that is, errors\ncaused when a data structure has the wrong type, size, or structure.\nFor example, if you are expecting a list with one integer and I\ngive you a plain old integer (not in a list), it won\u2019t work. To help debug these kinds of errors, I have written a module\ncalled structshape that provides a function, also called structshape , that takes any kind of data structure as\nan argument and returns a string that summarizes its shape.\nYou can download it from https://thinkpython.com/code/structshape.py Here\u2019s the result for a simple list: >>> from structshape import structshape\n>>> t = [1, 2, 3]\n>>> structshape(t)\n'list of 3 int' A fancier program might write \u201clist of 3 int s \u201d, but it\nwas easier not to deal with plurals. Here\u2019s a list of lists: >>> t2 = [[1,2], [3,4], [5,6]]\n>>> structshape(t2)\n'list of 3 list of 2 int' If the elements of the list are not the same type, structshape groups them, in order, by type: >>> t3 = [1, 2, 3, 4.0, '5', '6', [7], [8], 9]\n>>> structshape(t3)\n'list of (3 int, float, 2 str, 2 list of int, int)' Here\u2019s a list of tuples: >>> s = 'abc'\n>>> lt = list(zip(t, s))\n>>> structshape(lt)\n'list of 3 tuple of (int, str)' And here\u2019s a dictionary with 3 items that map integers to strings. >>> d = dict(lt)\n>>> structshape(d)\n'dict of 3 int->str' If you are having trouble keeping track of your data structures, structshape can help. 12.9\u00a0\u00a0Glossary tuple: An immutable sequence of elements. tuple assignment: An assignment with a sequence on the\nright side and a tuple of variables on the left. The right\nside is evaluated and then its elements are assigned to the\nvariables on the left. gather: An operation that collects multiple arguments into a tuple. scatter: An operation that makes a sequence behave like multiple arguments. zip object: The result of calling a built-in function zip ;\nan object that iterates through a sequence of tuples. iterator: An object that can iterate through a sequence, but\nwhich does not provide list operators and methods. data structure: A collection of related values, often\norganized in lists, dictionaries, tuples, etc. shape error: An error caused because a value has the\nwrong shape; that is, the wrong type or size. 12.10\u00a0\u00a0Exercises Exercise\u00a01 Write a function called most_frequent that takes a string and\nprints the letters in decreasing order of frequency. Find text\nsamples from several different languages and see how letter frequency\nvaries between languages. Compare your results with the tables at http://en.wikipedia.org/wiki/Letter_frequencies . Solution: https://thinkpython.com/code/most_frequent.py . Exercise\u00a02 More anagrams! Write a program\nthat reads a word list from a file (see Section 9.1 ) and\nprints all the sets of words that are anagrams. Here is an example of what the output might look like: ['deltas', 'desalt', 'lasted', 'salted', 'slated', 'staled']\n['retainers', 'ternaries']\n['generating', 'greatening']\n['resmelts', 'smelters', 'termless'] Hint: you might want to build a dictionary that maps from a\ncollection of letters to a list of words that can be spelled with those\nletters. The question is, how can you represent the collection of\nletters in a way that can be used as a key? Modify the previous program so that it prints the longest list\nof anagrams first, followed by the second longest, and so on. In Scrabble a \u201cbingo\u201d is when you play all seven tiles in\nyour rack, along with a letter on the board, to form an eight-letter\nword. What collection of 8 letters forms the most possible bingos? Solution: https://thinkpython.com/code/anagram_sets.py . Exercise\u00a03 Two words form a \u201cmetathesis pair\u201d if you can transform one into the\nother by swapping two letters; for example, \u201cconverse\u201d and\n\u201cconserve\u201d. Write a program that finds all of the metathesis pairs\nin the dictionary. Hint: don\u2019t test all pairs of words, and don\u2019t\ntest all possible swaps. Solution: https://thinkpython.com/code/metathesis.py . Credit: This\nexercise is inspired by an example at http://puzzlers.org . Exercise\u00a04 Here\u2019s another Car Talk Puzzler\n( http://www.cartalk.com/content/puzzlers ): What is the longest English word, that remains a valid English word,\nas you remove its letters one at a time? Now, letters can be removed from either end, or the middle, but you\ncan\u2019t rearrange any of the letters. Every time you drop a letter, you\nwind up with another English word. If you do that, you\u2019re eventually\ngoing to wind up with one letter and that too is going to be an\nEnglish word\u2014one that\u2019s found in the dictionary. I want to know\nwhat\u2019s the longest word and how many letters does it\nhave? I\u2019m going to give you a little modest example: Sprite. Ok? You start\noff with sprite, you take a letter off, one from the interior of the\nword, take the r away, and we\u2019re left with the word spite, then we\ntake the e off the end, we\u2019re left with spit, we take the s off, we\u2019re\nleft with pit, it, and I. Write a program to find all words that can be reduced in this way,\nand then find the longest one. This exercise is a little more challenging than most, so here are\nsome suggestions: You might want to write a function that takes a word and\ncomputes a list of all the words that can be formed by removing one\nletter. These are the \u201cchildren\u201d of the word. Recursively, a word is reducible if any of its children\nare reducible. As a base case, you can consider the empty\nstring reducible. The wordlist I provided, words.txt , doesn\u2019t\ncontain single letter words. So you might want to add\n\u201cI\u201d, \u201ca\u201d, and the empty string. To improve the performance of your program, you might want\nto memoize the words that are known to be reducible. Solution: https://thinkpython.com/code/reducible.py . Buy this book at Amazon.com\n\n#### Contribute\n\nIf you would like to make a contribution to support my books,\nyou can use the button below and pay with PayPal.  Thank you!\nPay what you want:\nSmall $1.00 USD\nMedium $5.00 USD\nLarge $10.00 USD\nX-Large $20.00 USD\nXX-Large $50.00 USD\nAre you using one of our books in a class? We'd like to know\nabout it.  Please consider filling out this short survey . Think DSP Think Java Think Bayes Think Python 2e Think Stats 2e Think Complexity",
      "difficulty": "intermediate",
      "doc_id": "doc-chapter-12-tuples-821d2530d4",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-NC 3.0",
        "source_file": "data/corpus_raw/thinkpython2_html_thinkpython2013_html_4bdc7a.json",
        "url": "https://greenteapress.com/thinkpython2/html/thinkpython2013.html"
      },
      "title": "Chapter\u00a012\u00a0\u00a0Tuples",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "OOP",
        "operator_overloading",
        "special_methods"
      ],
      "content": "Buy this book at Amazon.com Chapter\u00a013\u00a0\u00a0Case study: data structure selection At this point you have learned about Python\u2019s core data structures,\nand you have seen some of the algorithms that use them.\nIf you would like to know more about algorithms, this might be a good\ntime to read Chapter B .\nBut you don\u2019t have to read it before you go on; you can read\nit whenever you are interested. This chapter presents a case study with exercises that let\nyou think about choosing data structures and practice using them. 13.1\u00a0\u00a0Word frequency analysis As usual, you should at least attempt the exercises\nbefore you read my solutions. Exercise\u00a01 Write a program that reads a file, breaks each line into\nwords, strips whitespace and punctuation from the words, and\nconverts them to lowercase. Hint: The string module provides a string named whitespace ,\nwhich contains space, tab, newline, etc., and punctuation which contains the punctuation characters. Let\u2019s see\nif we can make Python swear: >>> import string\n>>> string.punctuation\n'!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~' Also, you might consider using the string methods strip , replace and translate . Exercise\u00a02 Go to Project Gutenberg ( http://gutenberg.org ) and download\nyou downloaded, skip over the header information at the beginning\nof the file, and process the rest of the words as before. Then modify the program to count the total number of words in\nthe book, and the number of times each word is used. Print the number of different words used in the book. Compare\ndifferent books by different authors, written in different eras.\nWhich author uses the most extensive vocabulary? Exercise\u00a03 Modify the program from the previous exercise to print the\n20 most frequently used words in the book. Exercise\u00a04 Modify the previous program to read a word list (see\nSection 9.1 ) and then print all the words in the book that\nare not in the word list. How many of them are typos? How many of\nthem are common words that should be in the word list, and how\nmany of them are really obscure? 13.2\u00a0\u00a0Random numbers Given the same inputs, most computer programs generate the same\noutputs every time, so they are said to be deterministic .\nDeterminism is usually a good thing, since we expect the same\ncalculation to yield the same result. For some applications, though,\nwe want the computer to be unpredictable. Games are an obvious\nexample, but there are more. Making a program truly nondeterministic turns out to be difficult,\nbut there are ways to make it at least seem nondeterministic. One of\nthem is to use algorithms that generate pseudorandom numbers.\nPseudorandom numbers are not truly random because they are generated\nby a deterministic computation, but just by looking at the numbers it\nis all but impossible to distinguish them from random. The random module provides functions that generate\npseudorandom numbers (which I will simply call \u201crandom\u201d from\nhere on). The function random returns a random float\nbetween 0.0 and 1.0 (including 0.0 but not 1.0). Each time you\ncall random , you get the next number in a long series. To see a\nsample, run this loop: import random\n\nfor i in range(10):\n    x = random.random()\n    print(x) The function randint takes parameters low and high and returns an integer between low and high (including both). >>> random.randint(5, 10)\n5\n>>> random.randint(5, 10)\n9 To choose an element from a sequence at random, you can use choice : >>> t = [1, 2, 3]\n>>> random.choice(t)\n2\n>>> random.choice(t)\n3 The random module also provides functions to generate\nrandom values from continuous distributions including\nGaussian, exponential, gamma, and a few more. Exercise\u00a05 Write a function named choose_from_hist that takes\na histogram as defined in Section 11.2 and returns a\nrandom value from the histogram, chosen with probability\nin proportion to frequency. For example, for this histogram: >>> t = ['a', 'a', 'b']\n>>> hist = histogram(t)\n>>> hist\n{'a': 2, 'b': 1} your function should return 'a' with probability 2/3 and 'b' with probability 1/3 . 13.3\u00a0\u00a0Word histogram You should attempt the previous exercises before you go on.\nYou can download my solution from https://thinkpython.com/code/analyze_book1.py . You will\nalso need https://thinkpython.com/code/emma.txt . Here is a program that reads a file and builds a histogram of the\nwords in the file: import string\n\ndef process_file(filename):\n    hist = dict()\n    fp = open(filename)\n    for line in fp:\n        process_line(line, hist)\n    return hist\n\ndef process_line(line, hist):\n    line = line.replace('-', ' ')\n\n    for word in line.split():\n        word = word.strip(string.punctuation + string.whitespace)\n        word = word.lower()\n        hist[word] = hist.get(word, 0) + 1\n\nhist = process_file('emma.txt') This program reads emma.txt , which contains the text of Emma by Jane Austen. process_file loops through the lines of the file,\npassing them one at a time to process_line . The histogram hist is being used as an accumulator. process_line uses the string method replace to replace\nhyphens with spaces before using split to break the line into a\nlist of strings. It traverses the list of words and uses strip and lower to remove punctuation and convert to lower case. (It\nis a shorthand to say that strings are \u201cconverted\u201d; remember that\nstrings are immutable, so methods like strip and lower return new strings.) Finally, process_line updates the histogram by creating a new\nitem or incrementing an existing one. To count the total number of words in the file, we can add up\nthe frequencies in the histogram: def total_words(hist):\n    return sum(hist.values()) The number of different words is just the number of items in\nthe dictionary: def different_words(hist):\n    return len(hist) Here is some code to print the results: print('Total number of words:', total_words(hist))\nprint('Number of different words:', different_words(hist)) And the results: Total number of words: 161080\nNumber of different words: 7214 13.4\u00a0\u00a0Most common words To find the most common words, we can make a list of tuples,\nwhere each tuple contains a word and its frequency,\nand sort it. The following function takes a histogram and returns a list of\nword-frequency tuples: def most_common(hist):\n    t = []\n    for key, value in hist.items():\n        t.append((value, key))\n\n    t.sort(reverse=True)\n    return t In each tuple, the frequency appears first, so the resulting list is\nsorted by frequency. Here is a loop that prints the ten most common\nwords: t = most_common(hist)\nprint('The most common words are:')\nfor freq, word in t[:10]:\n    print(word, freq, sep='\\t') I use the keyword argument sep to tell print to use a tab\ncharacter as a \u201cseparator\u201d, rather than a space, so the second\ncolumn is lined up. Here are the results from Emma : The most common words are:\nto      5242\nthe     5205\nand     4897\nof      4295\ni       3191\na       3130\nit      2529\nher     2483\nwas     2400\nshe     2364 This code can be simplified using the key parameter of\nthe sort function. If you are curious, you can read about it\nat https://wiki.python.org/moin/HowTo/Sorting . 13.5\u00a0\u00a0Optional parameters We have seen built-in functions and methods that take optional\narguments. It is possible to write programmer-defined functions\nwith optional arguments, too. For example, here is a function that\nprints the most common words in a histogram def print_most_common(hist, num=10):\n    t = most_common(hist)\n    print('The most common words are:')\n    for freq, word in t[:num]:\n        print(word, freq, sep='\\t') The first parameter is required; the second is optional.\nThe default value of num is 10. If you only provide one argument: print_most_common(hist) num gets the default value. If you provide two arguments: print_most_common(hist, 20) num gets the value of the argument instead. In other\nwords, the optional argument overrides the default value. If a function has both required and optional parameters, all\nthe required parameters have to come first, followed by the\noptional ones. 13.6\u00a0\u00a0Dictionary subtraction Finding the words from the book that are not in the word list\nfrom words.txt is a problem you might recognize as set\nsubtraction; that is, we want to find all the words from one\nset (the words in the book) that are not in the other (the\nwords in the list). subtract takes dictionaries d1 and d2 and returns a\nnew dictionary that contains all the keys from d1 that are not\nin d2 . Since we don\u2019t really care about the values, we\nset them all to None. def subtract(d1, d2):\n    res = dict()\n    for key in d1:\n        if key not in d2:\n            res[key] = None\n    return res To find the words in the book that are not in words.txt ,\nwe can use process_file to build a histogram for words.txt , and then subtract: words = process_file('words.txt')\ndiff = subtract(hist, words)\n\nprint(\"Words in the book that aren't in the word list:\")\nfor word in diff:\n    print(word, end=' ') Here are some of the results from Emma : Words in the book that aren't in the word list:\nrencontre jane's blanche woodhouses disingenuousness\nfriend's venice apartment ... Some of these words are names and possessives. Others, like\n\u201crencontre\u201d, are no longer in common use. But a few are common\nwords that should really be in the list! Exercise\u00a06 Python provides a data structure called set that provides many\ncommon set operations. You can read about them in Section 19.5 ,\nor read the documentation at http://docs.python.org/3/library/stdtypes.html#types-set . Write a program that uses set subtraction to find words in the book\nthat are not in the word list. Solution: https://thinkpython.com/code/analyze_book2.py . 13.7\u00a0\u00a0Random words To choose a random word from the histogram, the simplest algorithm\nis to build a list with multiple copies of each word, according\nto the observed frequency, and then choose from the list: def random_word(h):\n    t = []\n    for word, freq in h.items():\n        t.extend([word] * freq)\n\n    return random.choice(t) The expression [word] * freq creates a list with freq copies of the string word . The extend method is similar to append except that the argument is\na sequence. This algorithm works, but it is not very efficient; each time you\nchoose a random word, it rebuilds the list, which is as big as\nthe original book. An obvious improvement is to build the list\nonce and then make multiple selections, but the list is still big. An alternative is: Use keys to get a list of the words in the book. Build a list that contains the cumulative sum of the word\nfrequencies (see Exercise 2 ). The last item\nin this list is the total number of words in the book, n . Choose a random number from 1 to n . Use a bisection search\n(See Exercise 10 ) to find the index where the random\nnumber would be inserted in the cumulative sum. Use the index to find the corresponding word in the word list. Exercise\u00a07 Write a program that uses this algorithm to choose a random word from\nthe book. Solution: https://thinkpython.com/code/analyze_book3.py . 13.8\u00a0\u00a0Markov analysis If you choose words from the book at random, you can get a\nsense of the vocabulary, but you probably won\u2019t get a sentence: this the small regard harriet which knightley's it most things A series of random words seldom makes sense because there\nis no relationship between successive words. For example, in\na real sentence you would expect an article like \u201cthe\u201d to\nbe followed by an adjective or a noun, and probably not a verb\nor adverb. One way to measure these kinds of relationships is Markov\nanalysis, which\ncharacterizes, for a given sequence of words, the probability of the\nwords that might come next. For example, the song Eric, the Half a\nBee begins: Half a bee, philosophically, Must, ipso facto, half not be. But half the bee has got to be Vis a vis, its entity. D\u2019you see? But can a bee be said to be Or not to be an entire bee When half the bee is not a bee Due to some ancient injury? In this text,\nthe phrase \u201chalf the\u201d is always followed by the word \u201cbee\u201d,\nbut the phrase \u201cthe bee\u201d might be followed by either\n\u201chas\u201d or \u201cis\u201d. The result of Markov analysis is a mapping from each prefix\n(like \u201chalf the\u201d and \u201cthe bee\u201d) to all possible suffixes\n(like \u201chas\u201d and \u201cis\u201d). Given this mapping, you can generate a random text by\nstarting with any prefix and choosing at random from the\npossible suffixes. Next, you can combine the end of the\nprefix and the new suffix to form the next prefix, and repeat. For example, if you start with the prefix \u201cHalf a\u201d, then the\nnext word has to be \u201cbee\u201d, because the prefix only appears\nonce in the text. The next prefix is \u201ca bee\u201d, so the\nnext suffix might be \u201cphilosophically\u201d, \u201cbe\u201d or \u201cdue\u201d. In this example the length of the prefix is always two, but\nyou can do Markov analysis with any prefix length. Exercise\u00a08 Markov analysis: Write a program to read a text from a file and perform Markov\nanalysis. The result should be a dictionary that maps from\nprefixes to a collection of possible suffixes. The collection\nmight be a list, tuple, or dictionary; it is up to you to make\nan appropriate choice. You can test your program with prefix\nlength two, but you should write the program in a way that makes\nit easy to try other lengths. Add a function to the previous program to generate random text\nbased on the Markov analysis. Here is an example from Emma with prefix length 2: He was very clever, be it sweetness or be angry, ashamed or only\namused, at such a stroke. She had never thought of Hannah till you\nwere never meant for me?\" \"I cannot make speeches, Emma:\" he soon cut\nit all himself. For this example, I left the punctuation attached to the words.\nThe result is almost syntactically correct, but not quite.\nSemantically, it almost makes sense, but not quite. What happens if you increase the prefix length? Does the random\ntext make more sense? Once your program is working, you might want to try a mash-up:\nif you combine text from two or more books, the random\ntext you generate will blend the vocabulary and phrases from\nthe sources in interesting ways. Credit: This case study is based on an example from Kernighan and\nPike, The Practice of Programming , Addison-Wesley, 1999. You should attempt this exercise before you go on; then you can\ndownload my solution from https://thinkpython.com/code/markov.py .\nYou will also need https://thinkpython.com/code/emma.txt . 13.9\u00a0\u00a0Data structures Using Markov analysis to generate random text is fun, but there is\nalso a point to this exercise: data structure selection. In your\nsolution to the previous exercises, you had to choose: How to represent the prefixes. How to represent the collection of possible suffixes. How to represent the mapping from each prefix to\nthe collection of possible suffixes. The last one is easy: a dictionary is the obvious choice\nfor a mapping from keys to corresponding values. For the prefixes, the most obvious options are string,\nlist of strings, or tuple of strings. For the suffixes,\none option is a list; another is a histogram (dictionary). How should you choose? The first step is to think about\nthe operations you will need to implement for each data structure.\nFor the prefixes, we need to be able to remove words from\nthe beginning and add to the end. For example, if the current\nprefix is \u201cHalf a\u201d, and the next word is \u201cbee\u201d, you need\nto be able to form the next prefix, \u201ca bee\u201d. Your first choice might be a list, since it is easy to add\nand remove elements, but we also need to be able to use the\nprefixes as keys in a dictionary, so that rules out lists.\nWith tuples, you can\u2019t append or remove, but you can use\nthe addition operator to form a new tuple: def shift(prefix, word):\n    return prefix[1:] + (word,) shift takes a tuple of words, prefix , and a string, word , and forms a new tuple that has all the words\nin prefix except the first, and word added to\nthe end. For the collection of suffixes, the operations we need to\nperform include adding a new suffix (or increasing the frequency\nof an existing one), and choosing a random suffix. Adding a new suffix is equally easy for the list implementation\nor the histogram. Choosing a random element from a list\nis easy; choosing from a histogram is harder to do\nefficiently (see Exercise 7 ). So far we have been talking mostly about ease of implementation,\nbut there are other factors to consider in choosing data structures.\nOne is run time. Sometimes there is a theoretical reason to expect\none data structure to be faster than other; for example, I mentioned\nthat the in operator is faster for dictionaries than for lists,\nat least when the number of elements is large. But often you don\u2019t know ahead of time which implementation will\nbe faster. One option is to implement both of them and see which\nis better. This approach is called benchmarking . A practical\nalternative is to choose the data structure that is\neasiest to implement, and then see if it is fast enough for the\nintended application. If so, there is no need to go on. If not,\nthere are tools, like the profile module, that can identify\nthe places in a program that take the most time. The other factor to consider is storage space. For example, using a\nhistogram for the collection of suffixes might take less space because\nyou only have to store each word once, no matter how many times it\nappears in the text. In some cases, saving space can also make your\nprogram run faster, and in the extreme, your program might not run at\nall if you run out of memory. But for many applications, space is a\nsecondary consideration after run time. One final thought: in this discussion, I have implied that\nwe should use one data structure for both analysis and generation. But\nsince these are separate phases, it would also be possible to use one\nstructure for analysis and then convert to another structure for\ngeneration. This would be a net win if the time saved during\ngeneration exceeded the time spent in conversion. 13.10\u00a0\u00a0Debugging When you are debugging a program, and especially if you are\nworking on a hard bug, there are five things to try: Reading: Examine your code, read it back to yourself, and\ncheck that it says what you meant to say. Running: Experiment by making changes and running different\nversions. Often if you display the right thing at the right place\nin the program, the problem becomes obvious, but sometimes you have to\nbuild scaffolding. Ruminating: Take some time to think! What kind of error\nis it: syntax, runtime, or semantic? What information can you get from\nthe error messages, or from the output of the program? What kind of\nerror could cause the problem you\u2019re seeing? What did you change\nlast, before the problem appeared? Rubberducking: If you explain the problem to someone else, you\nsometimes find the answer before you finish asking the question.\nOften you don\u2019t need the other person; you could just talk to a rubber\nduck. And that\u2019s the origin of the well-known strategy called rubber duck debugging . I am not making this up; see https://en.wikipedia.org/wiki/Rubber_duck_debugging . Retreating: At some point, the best thing to do is back\noff, undoing recent changes, until you get back to a program that\nworks and that you understand. Then you can start rebuilding. Beginning programmers sometimes get stuck on one of these activities\nand forget the others. Each activity comes with its own failure\nmode. For example, reading your code might help if the problem is a\ntypographical error, but not if the problem is a conceptual\nmisunderstanding. If you don\u2019t understand what your program does, you\ncan read it 100 times and never see the error, because the error is in\nyour head. Running experiments can help, especially if you run small, simple\ntests. But if you run experiments without thinking or reading your\ncode, you might fall into a pattern I call \u201crandom walk programming\u201d,\nwhich is the process of making random changes until the program\ndoes the right thing. Needless to say, random walk programming\ncan take a long time. You have to take time to think. Debugging is like an\nexperimental science. You should have at least one hypothesis about\nwhat the problem is. If there are two or more possibilities, try to\nthink of a test that would eliminate one of them. But even the best debugging techniques will fail if there are too many\nerrors, or if the code you are trying to fix is too big and\ncomplicated. Sometimes the best option is to retreat, simplifying the\nprogram until you get to something that works and that you\nunderstand. Beginning programmers are often reluctant to retreat because\nthey can\u2019t stand to delete a line of code (even if it\u2019s wrong).\nIf it makes you feel better, copy your program into another file\nbefore you start stripping it down. Then you can copy the pieces\nback one at a time. Finding a hard bug requires reading, running, ruminating, and\nsometimes retreating. If you get stuck on one of these activities,\ntry the others. 13.11\u00a0\u00a0Glossary deterministic: Pertaining to a program that does the same\nthing each time it runs, given the same inputs. pseudorandom: Pertaining to a sequence of numbers that appears\nto be random, but is generated by a deterministic program. default value: The value given to an optional parameter if no\nargument is provided. override: To replace a default value with an argument. benchmarking: The process of choosing between data structures\nby implementing alternatives and testing them on a sample of the\npossible inputs. rubber duck debugging: Debugging by explaining your problem\nto an inanimate object such as a rubber duck. Articulating the\nproblem can help you solve it, even if the rubber duck doesn\u2019t know\nPython. 13.12\u00a0\u00a0Exercises Exercise\u00a09 The \u201crank\u201d of a word is its position in a list of words\nsorted by frequency: the most common word has rank 1, the\nsecond most common has rank 2, etc. Zipf\u2019s law describes a relationship between the ranks and frequencies\nof words in natural languages\n( http://en.wikipedia.org/wiki/Zipf's_law ). Specifically, it\npredicts that the frequency, f , of the word with rank r is: f = c r \u2212 s where s and c are parameters that depend on the language and the\ntext. If you take the logarithm of both sides of this equation, you\nget: log f =\u00a0log c \u2212 s log r So if you plot log f versus log r , you should get\na straight line with slope \u2212 s and intercept log c . Write a program that reads a text from a file, counts\nword frequencies, and prints one line\nfor each word, in descending order of frequency, with\nlog f and log r . Use the graphing program of your\nchoice to plot the results and check whether they form\na straight line. Can you estimate the value of s ? Solution: https://thinkpython.com/code/zipf.py .\nTo run my solution, you need the plotting module matplotlib .\nIf you installed Anaconda, you already have matplotlib ;\notherwise you might have to install it. Buy this book at Amazon.com\n\n#### Contribute\n\nIf you would like to make a contribution to support my books,\nyou can use the button below and pay with PayPal.  Thank you!\nPay what you want:\nSmall $1.00 USD\nMedium $5.00 USD\nLarge $10.00 USD\nX-Large $20.00 USD\nXX-Large $50.00 USD\nAre you using one of our books in a class? We'd like to know\nabout it.  Please consider filling out this short survey . Think DSP Think Java Think Bayes Think Python 2e Think Stats 2e Think Complexity",
      "difficulty": "intermediate",
      "doc_id": "doc-chapter-13-case-study-data-structure-selection-f05d897455",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-NC 3.0",
        "source_file": "data/corpus_raw/scraped/thinkpython2_html_thinkpython2014_html_8ba08b.json",
        "url": "https://greenteapress.com/thinkpython2/html/thinkpython2014.html"
      },
      "title": "Chapter\u00a013\u00a0\u00a0Case study: data structure selection",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "algorithms",
        "recursion",
        "sorting"
      ],
      "content": "Buy this book at Amazon.com Chapter\u00a014\u00a0\u00a0Files This chapter introduces the idea of \u201cpersistent\u201d programs that\nkeep data in permanent storage, and shows how to use different\nkinds of permanent storage, like files and databases. 14.1\u00a0\u00a0Persistence Most of the programs we have seen so far are transient in the\nsense that they run for a short time and produce some output,\nbut when they end, their data disappears. If you run the program\nagain, it starts with a clean slate. Other programs are persistent : they run for a long time\n(or all the time); they keep at least some of their data\nin permanent storage (a hard drive, for example); and\nif they shut down and restart, they pick up where they left off. Examples of persistent programs are operating systems, which\nrun pretty much whenever a computer is on, and web servers,\nwhich run all the time, waiting for requests to come in on\nthe network. One of the simplest ways for programs to maintain their data\nis by reading and writing text files. We have already seen\nprograms that read text files; in this chapter we will see programs\nthat write them. An alternative is to store the state of the program in a database.\nIn this chapter I will present a simple database and a module, pickle , that makes it easy to store program data. 14.2\u00a0\u00a0Reading and writing A text file is a sequence of characters stored on a permanent\nmedium like a hard drive, flash memory, or CD-ROM. We saw how\nto open and read a file in Section 9.1 . To write a file, you have to open it with mode 'w' as a second\nparameter: >>> fout = open('output.txt', 'w') If the file already exists, opening it in write mode clears out\nthe old data and starts fresh, so be careful!\nIf the file doesn\u2019t exist, a new one is created. open returns a file object that provides methods for working\nwith the file.\nThe write method puts data into the file. >>> line1 = \"This here's the wattle,\\n\"\n>>> fout.write(line1)\n24 The return value is the number of characters that were written.\nThe file object keeps track of where it is, so if\nyou call write again, it adds the new data to the end of\nthe file. >>> line2 = \"the emblem of our land.\\n\"\n>>> fout.write(line2)\n24 When you are done writing, you should close the file. >>> fout.close() If you don\u2019t close the file, it gets closed for you when the\nprogram ends. 14.3\u00a0\u00a0Format operator The argument of write has to be a string, so if we want\nto put other values in a file, we have to convert them to\nstrings. The easiest way to do that is with str : >>> x = 52\n>>> fout.write(str(x)) An alternative is to use the format operator , % . When\napplied to integers, % is the modulus operator. But\nwhen the first operand is a string, % is the format operator. The first operand is the format string , which contains\none or more format sequences , which\nspecify how\nthe second operand is formatted. The result is a string. For example, the format sequence '%d' means that\nthe second operand should be formatted as a decimal\ninteger: >>> camels = 42\n>>> '%d' % camels\n'42' The result is the string '42' , which is not to be confused\nwith the integer value 42 . A format sequence can appear anywhere in the string,\nso you can embed a value in a sentence: >>> 'I have spotted %d camels.' % camels\n'I have spotted 42 camels.' If there is more than one format sequence in the string,\nthe second argument has to be a tuple. Each format sequence is\nmatched with an element of the tuple, in order. The following example uses '%d' to format an integer, '%g' to format a floating-point number, and '%s' to format a string: >>> 'In %d years I have spotted %g %s.' % (3, 0.1, 'camels')\n'In 3 years I have spotted 0.1 camels.' The number of elements in the tuple has to match the number\nof format sequences in the string. Also, the types of the\nelements have to match the format sequences: >>> '%d %d %d' % (1, 2)\nTypeError: not enough arguments for format string\n>>> '%d' % 'dollars'\nTypeError: %d format: a number is required, not str In the first example, there aren\u2019t enough elements; in the\nsecond, the element is the wrong type. For more information on the format operator, see https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting . A more powerful alternative is the string\nformat method, which you can read about at https://docs.python.org/3/library/stdtypes.html#str.format . 14.4\u00a0\u00a0Filenames and paths Files are organized into directories (also called \u201cfolders\u201d).\nEvery running program has a \u201ccurrent directory\u201d, which is the\ndefault directory for most operations.\nFor example, when you open a file for reading, Python looks for it in the\ncurrent directory. The os module provides functions for working with files and\ndirectories (\u201cos\u201d stands for \u201coperating system\u201d). os.getcwd returns the name of the current directory: >>> import os\n>>> cwd = os.getcwd()\n>>> cwd\n'/home/dinsdale' cwd stands for \u201ccurrent working directory\u201d. The result in\nthis example is /home/dinsdale , which is the home directory of a\nuser named dinsdale . A string like '/home/dinsdale' that identifies a file or\ndirectory is called a path . A simple filename, like memo.txt is also considered a path,\nbut it is a relative path because it relates to the current\ndirectory. If the current directory is /home/dinsdale , the\nfilename memo.txt would refer to /home/dinsdale/memo.txt . A path that begins with / does not depend on the current\ndirectory; it is called an absolute path . To find the absolute\npath to a file, you can use os.path.abspath : >>> os.path.abspath('memo.txt')\n'/home/dinsdale/memo.txt' os.path provides other functions for working with filenames\nand paths. For example, os.path.exists checks\nwhether a file or directory exists: >>> os.path.exists('memo.txt')\nTrue If it exists, os.path.isdir checks whether it\u2019s a directory: >>> os.path.isdir('memo.txt')\nFalse\n>>> os.path.isdir('/home/dinsdale')\nTrue Similarly, os.path.isfile checks whether it\u2019s a file. os.listdir returns a list of the files (and other directories)\nin the given directory: >>> os.listdir(cwd)\n['music', 'photos', 'memo.txt'] To demonstrate these functions, the following example\n\u201cwalks\u201d through a directory, prints\nthe names of all the files, and calls itself recursively on\nall the directories. def walk(dirname):\n    for name in os.listdir(dirname):\n        path = os.path.join(dirname, name)\n\n        if os.path.isfile(path):\n            print(path)\n        else:\n            walk(path) os.path.join takes a directory and a file name and joins\nthem into a complete path. The os module provides a function called walk that is\nsimilar to this one but more versatile. As an exercise, read the\ndocumentation and use it to print the names of the files in a given\ndirectory and its subdirectories. You can download my solution from https://thinkpython.com/code/walk.py . 14.5\u00a0\u00a0Catching exceptions A lot of things can go wrong when you try to read and write\nfiles. If you try to open a file that doesn\u2019t exist, you get an FileNotFoundError : >>> fin = open('bad_file')\nFileNotFoundError: [Errno 2] No such file or directory: 'bad_file' If you don\u2019t have permission to access a file: >>> fout = open('/etc/passwd', 'w')\nPermissionError: [Errno 13] Permission denied: '/etc/passwd' And if you try to open a directory for reading, you get >>> fin = open('/home')\nIsADirectoryError: [Errno 21] Is a directory: '/home' To avoid these errors, you could use functions like os.path.exists and os.path.isfile , but it would take a lot of time and code\nto check all the possibilities (if \u201c Errno 21 \u201d is any\nindication, there are at least 21 things that can go wrong). It is better to go ahead and try\u2014and deal with problems if they\nhappen\u2014which is exactly what the try statement does. The\nsyntax is similar to an if...else statement: try:\n    fin = open('bad_file')\nexcept:\n    print('Something went wrong.') Python starts by executing the try clause. If all goes\nwell, it skips the except clause and proceeds. If an\nexception occurs, it jumps out of the try clause and\nruns the except clause. Handling an exception with a try statement is called catching an exception. In this example, the except clause\nprints an error message that is not very helpful. In general,\ncatching an exception gives you a chance to fix the problem, or try\nagain, or at least end the program gracefully. 14.6\u00a0\u00a0Databases A database is a file that is organized for storing data. Many\ndatabases are organized like a dictionary in the sense that they map\nfrom keys to values. The biggest difference between a database and a\ndictionary is that the database is on disk (or other permanent\nstorage), so it persists after the program ends. The module dbm provides an interface for creating\nand updating database files.\nAs an example, I\u2019ll create a database\nthat contains captions for image files. Opening a database is similar to opening other files: >>> import dbm\n>>> db = dbm.open('captions', 'c') The mode 'c' means that the database should be created if\nit doesn\u2019t already exist. The result is a database object\nthat can be used (for most operations) like a dictionary. When you create a new item, dbm updates the database file. >>> db['cleese.png'] = 'Photo of John Cleese.' When you access one of the items, dbm reads the file: >>> db['cleese.png']\nb'Photo of John Cleese.' The result is a bytes object , which is why it begins with b . A bytes object is similar to a string in many ways. When you\nget farther into Python, the difference becomes important, but for now\nwe can ignore it. If you make another assignment to an existing key, dbm replaces\nthe old value: >>> db['cleese.png'] = 'Photo of John Cleese doing a silly walk.'\n>>> db['cleese.png']\nb'Photo of John Cleese doing a silly walk.' Some dictionary methods, like keys and items , don\u2019t\nwork with database objects. But iteration with a for loop works: for key in db.keys():\n    print(key, db[key]) As with other files, you should close the database when you are\ndone: >>> db.close() 14.7\u00a0\u00a0Pickling A limitation of dbm is that the keys and values have to be\nstrings or bytes. If you try to use any other type, you get an error. The pickle module can help. It translates\nalmost any type of object into a string suitable for storage in a\ndatabase, and then translates strings back into objects. pickle.dumps takes an object as a parameter and returns\na string representation ( dumps is short for \u201cdump string\u201d): >>> import pickle\n>>> t = [1, 2, 3]\n>>> pickle.dumps(t)\nb'\\x80\\x03]q\\x00(K\\x01K\\x02K\\x03e.' The format isn\u2019t obvious to human readers; it is meant to be\neasy for pickle to interpret. pickle.loads (\u201cload string\u201d) reconstitutes the object: >>> t1 = [1, 2, 3]\n>>> s = pickle.dumps(t1)\n>>> t2 = pickle.loads(s)\n>>> t2\n[1, 2, 3] Although the new object has the same value as the old, it is\nnot (in general) the same object: >>> t1 == t2\nTrue\n>>> t1 is t2\nFalse In other words, pickling and then unpickling has the same effect\nas copying the object. You can use pickle to store non-strings in a database.\nIn fact, this combination is so common that it has been\nencapsulated in a module called shelve . 14.8\u00a0\u00a0Pipes Most operating systems provide a command-line interface,\nalso known as a shell . Shells usually provide commands\nto navigate the file system and launch applications. For\nexample, in Unix you can change directories with cd ,\ndisplay the contents of a directory with ls , and launch\na web browser by typing (for example) firefox . Any program that you can launch from the shell can also be\nlaunched from Python using a pipe object , which\nrepresents a running program. For example, the Unix command ls -l normally displays the\ncontents of the current directory in long format. You can\nlaunch ls with os.popen 1 : >>> cmd = 'ls -l'\n>>> fp = os.popen(cmd) The argument is a string that contains a shell command. The\nreturn value is an object that behaves like an open\nfile. You can read the output from the ls process one\nline at a time with readline or get the whole thing at\nonce with read : >>> res = fp.read() When you are done, you close the pipe like a file: >>> stat = fp.close()\n>>> print(stat)\nNone The return value is the final status of the ls process; None means that it ended normally (with no errors). For example, most Unix systems provide a command called md5sum that reads the contents of a file and computes a \u201cchecksum\u201d.\nYou can read about MD5 at http://en.wikipedia.org/wiki/Md5 . This\ncommand provides an efficient way to check whether two files\nhave the same contents. The probability that different contents\nyield the same checksum is very small (that is, unlikely to happen\nbefore the universe collapses). You can use a pipe to run md5sum from Python and get the result: >>> filename = 'book.tex'\n>>> cmd = 'md5sum ' + filename\n>>> fp = os.popen(cmd)\n>>> res = fp.read()\n>>> stat = fp.close()\n>>> print(res)\n1e0033f0ed0656636de0d75144ba32e0  book.tex\n>>> print(stat)\nNone 14.9\u00a0\u00a0Writing modules Any file that contains Python code can be imported as a module.\nFor example, suppose you have a file named wc.py with the following\ncode: def linecount(filename):\n    count = 0\n    for line in open(filename):\n        count += 1\n    return count\n\nprint(linecount('wc.py')) If you run this program, it reads itself and prints the number\nof lines in the file, which is 7.\nYou can also import it like this: >>> import wc\n7 Now you have a module object wc : >>> wc\n<module 'wc' from 'wc.py'> The module object provides linecount : >>> wc.linecount('wc.py')\n7 So that\u2019s how you write modules in Python. The only problem with this example is that when you import\nthe module it runs the test code at the bottom. Normally\nwhen you import a module, it defines new functions but it\ndoesn\u2019t run them. Programs that will be imported as modules often\nuse the following idiom: if __name__ == '__main__':\n    print(linecount('wc.py')) __name__ is a built-in variable that is set when the\nprogram starts. If the program is running as a script, __name__ has the value '__main__' ; in that\ncase, the test code runs. Otherwise,\nif the module is being imported, the test code is skipped. As an exercise, type this example into a file named wc.py and run\nit as a script. Then run the Python interpreter and import wc . What is the value of __name__ when the module is being imported? Warning: If you import a module that has already been imported,\nPython does nothing. It does not re-read the file, even if it has\nchanged. If you want to reload a module, you can use the built-in function reload , but it can be tricky, so the safest thing to do is\nrestart the interpreter and then import the module again. 14.10\u00a0\u00a0Debugging When you are reading and writing files, you might run into problems\nwith whitespace. These errors can be hard to debug because spaces,\ntabs and newlines are normally invisible: >>> s = '1 2\\t 3\\n 4'\n>>> print(s)\n1 2  3\n 4 The built-in function repr can help. It takes any object as an\nargument and returns a string representation of the object. For\nstrings, it represents whitespace\ncharacters with backslash sequences: >>> print(repr(s))\n'1 2\\t 3\\n 4' This can be helpful for debugging. One other problem you might run into is that different systems\nuse different characters to indicate the end of a line. Some\nsystems use a newline, represented \\n . Others use\na return character, represented \\r . Some use both.\nIf you move files between different systems, these inconsistencies\ncan cause problems. For most systems, there are applications to convert from one\nformat to another. You can find them (and read more about this\nissue) at http://en.wikipedia.org/wiki/Newline . Or, of course, you\ncould write one yourself. 14.11\u00a0\u00a0Glossary persistent: Pertaining to a program that runs indefinitely\nand keeps at least some of its data in permanent storage. format operator: An operator, % , that takes a format\nstring and a tuple and generates a string that includes\nthe elements of the tuple formatted as specified by the format string. format string: A string, used with the format operator, that\ncontains format sequences. format sequence: A sequence of characters in a format string,\nlike %d , that specifies how a value should be formatted. text file: A sequence of characters stored in permanent\nstorage like a hard drive. directory: A named collection of files, also called a folder. path: A string that identifies a file. relative path: A path that starts from the current directory. absolute path: A path that starts from the topmost directory\nin the file system. catch: To prevent an exception from terminating\na program using the try and except statements. database: A file whose contents are organized like a dictionary\nwith keys that correspond to values. bytes object: An object similar to a string. shell: A program that allows users to type commands and then\nexecutes them by starting other programs. pipe object: An object that represents a running program, allowing\na Python program to run commands and read the results. 14.12\u00a0\u00a0Exercises Exercise\u00a01 Write a function called sed that takes as arguments a pattern string,\na replacement string, and two filenames; it should read the first file\nand write the contents into the second file (creating it if\nnecessary). If the pattern string appears anywhere in the file, it\nshould be replaced with the replacement string. If an error occurs while opening, reading, writing or closing files,\nyour program should catch the exception, print an error message, and\nexit. Solution: https://thinkpython.com/code/sed.py . Exercise\u00a02 If you download my solution to Exercise 2 from https://thinkpython.com/code/anagram_sets.py , you\u2019ll see that it creates\na dictionary that maps from a sorted string of letters to the list of\nwords that can be spelled with those letters. For example, 'opst' maps to the list ['opts', 'post', 'pots', 'spot', 'stop', 'tops'] . Write a module that imports anagram_sets and provides\ntwo new functions: store_anagrams should store the\nanagram dictionary in a \u201cshelf\u201d; read_anagrams should\nlook up a word and return a list of its anagrams.\nSolution: https://thinkpython.com/code/anagram_db.py . Exercise\u00a03 In a large collection of MP3 files, there may be more than one\ncopy of the same song, stored in different directories or with\ndifferent file names. The goal of this exercise is to search for\nduplicates. Write a program that searches a directory and all of its\nsubdirectories, recursively, and returns a list of complete paths\nfor all files with a given suffix (like .mp3 ).\nHint: os.path provides several useful functions for\nmanipulating file and path names. To recognize duplicates, you can use md5sum to compute a \u201cchecksum\u201d for each files. If two files have\nthe same checksum, they probably have the same contents. To double-check, you can use the Unix command diff . Solution: https://thinkpython.com/code/find_duplicates.py . 1 popen is deprecated\nnow, which means we are supposed to stop using it and start using\nthe subprocess module. But for simple cases, I find subprocess more complicated than necessary. So I am going\nto keep using popen until they take it away. Buy this book at Amazon.com\n\n#### Contribute\n\nIf you would like to make a contribution to support my books,\nyou can use the button below and pay with PayPal.  Thank you!\nPay what you want:\nSmall $1.00 USD\nMedium $5.00 USD\nLarge $10.00 USD\nX-Large $20.00 USD\nXX-Large $50.00 USD\nAre you using one of our books in a class? We'd like to know\nabout it.  Please consider filling out this short survey . Think DSP Think Java Think Bayes Think Python 2e Think Stats 2e Think Complexity",
      "difficulty": "intermediate",
      "doc_id": "doc-chapter-14-files-4dcfd85da9",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-NC 3.0",
        "source_file": "data/corpus_raw/thinkpython2_html_thinkpython2015_html_c04cd8.json",
        "url": "https://greenteapress.com/thinkpython2/html/thinkpython2015.html"
      },
      "title": "Chapter\u00a014\u00a0\u00a0Files",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "algorithms",
        "recursion",
        "searching",
        "sorting"
      ],
      "content": "Buy this book at Amazon.com Chapter\u00a015\u00a0\u00a0Classes and objects At this point you know how to use\nfunctions to organize code and\nbuilt-in types to organize data. The next step is to learn\n\u201cobject-oriented programming\u201d, which uses programmer-defined types\nto organize both code and data. Object-oriented programming is\na big topic; it will take a few chapters to get there. Code examples from this chapter are available from https://thinkpython.com/code/Point1.py ; solutions\nto the exercises are available from https://thinkpython.com/code/Point1_soln.py . 15.1\u00a0\u00a0Programmer-defined types We have used many of Python\u2019s built-in types; now we are going\nto define a new type. As an example, we will create a type\ncalled Point that represents a point in two-dimensional\nspace. In mathematical notation, points are often written in\nparentheses with a comma separating the coordinates. For example,\n(0,0) represents the origin, and ( x , y ) represents the\npoint x units to the right and y units up from the origin. There are several ways we might represent points in Python: We could store the coordinates separately in two\nvariables, x and y . We could store the coordinates as elements in a list\nor tuple. We could create a new type to represent points as\nobjects. Creating a new type\nis more complicated than the other options, but\nit has advantages that will be apparent soon. A programmer-defined type is also called a class .\nA class definition looks like this: class Point:\n    \"\"\"Represents a point in 2-D space.\"\"\" The header indicates that the new class is called Point .\nThe body is a docstring that explains what the class is for.\nYou can define variables and methods inside a class definition,\nbut we will get back to that later. Defining a class named Point creates a class object . >>> Point\n<class '__main__.Point'> Because Point is defined at the top level, its \u201cfull\nname\u201d is __main__.Point . The class object is like a factory for creating objects. To create a\nPoint, you call Point as if it were a function. >>> blank = Point()\n>>> blank\n<__main__.Point object at 0xb7e9d3ac> The return value is a reference to a Point object, which we\nassign to blank . Creating a new object is called instantiation , and the object is an instance of\nthe class. When you print an instance, Python tells you what class it\nbelongs to and where it is stored in memory (the prefix 0x means that the following number is in hexadecimal). Every object is an instance of some class, so \u201cobject\u201d and\n\u201cinstance\u201d are interchangeable. But in this chapter I use\n\u201cinstance\u201d to indicate that I am talking about a programmer-defined\ntype. 15.2\u00a0\u00a0Attributes You can assign values to an instance using dot notation: >>> blank.x = 3.0\n>>> blank.y = 4.0 This syntax is similar to the syntax for selecting a variable from a\nmodule, such as math.pi or string.whitespace . In this case,\nthough, we are assigning values to named elements of an object.\nThese elements are called attributes . As a noun, \u201cAT-trib-ute\u201d is pronounced with emphasis on the first\nsyllable, as opposed to \u201ca-TRIB-ute\u201d, which is a verb. Figure 15.1 is a state diagram that shows the result of these assignments.\nA state diagram that shows an object and its attributes is\ncalled an object diagram . Figure 15.1: Object diagram. The variable blank refers to a Point object, which\ncontains two attributes. Each attribute refers to a\nfloating-point number. You can read the value of an attribute using the same syntax: >>> blank.y\n4.0\n>>> x = blank.x\n>>> x\n3.0 The expression blank.x means, \u201cGo to the object blank refers to and get the value of x .\u201d In the example, we assign that\nvalue to a variable named x . There is no conflict between\nthe variable x and the attribute x . You can use dot notation as part of any expression. For example: >>> '(%g, %g)' % (blank.x, blank.y)\n'(3.0, 4.0)'\n>>> distance = math.sqrt(blank.x**2 + blank.y**2)\n>>> distance\n5.0 You can pass an instance as an argument in the usual way.\nFor example: def print_point(p):\n    print('(%g, %g)' % (p.x, p.y)) print_point takes a point as an argument and displays it in\nmathematical notation. To invoke it, you can pass blank as\nan argument: >>> print_point(blank)\n(3.0, 4.0) Inside the function, p is an alias for blank , so if\nthe function modifies p , blank changes. As an exercise, write a function called distance_between_points that takes two Points as arguments and returns the distance between\nthem. 15.3\u00a0\u00a0Rectangles Sometimes it is obvious what the attributes of an object should be,\nbut other times you have to make decisions. For example, imagine you\nare designing a class to represent rectangles. What attributes would\nyou use to specify the location and size of a rectangle? You can\nignore angle; to keep things simple, assume that the rectangle is\neither vertical or horizontal. There are at least two possibilities: You could specify one corner of the rectangle\n(or the center), the width, and the height. You could specify two opposing corners. At this point it is hard to say whether either is better than\nthe other, so we\u2019ll implement the first one, just as an example. Here is the class definition: class Rectangle:\n    \"\"\"Represents a rectangle.\n\n    attributes: width, height, corner.\n    \"\"\" The docstring lists the attributes: width and height are numbers; corner is a Point object that\nspecifies the lower-left corner. To represent a rectangle, you have to instantiate a Rectangle\nobject and assign values to the attributes: box = Rectangle()\nbox.width = 100.0\nbox.height = 200.0\nbox.corner = Point()\nbox.corner.x = 0.0\nbox.corner.y = 0.0 The expression box.corner.x means,\n\u201cGo to the object box refers to and select the attribute named corner ; then go to that object and select the attribute named x .\u201d Figure 15.2: Object diagram. Figure 15.2 shows the state of this object.\nAn object that is an attribute of another object is embedded . 15.4\u00a0\u00a0Instances as return values Functions can return instances. For example, find_center takes a Rectangle as an argument and returns a Point that contains the coordinates of the center of the Rectangle : def find_center(rect):\n    p = Point()\n    p.x = rect.corner.x + rect.width/2\n    p.y = rect.corner.y + rect.height/2\n    return p Here is an example that passes box as an argument and assigns\nthe resulting Point to center : >>> center = find_center(box)\n>>> print_point(center)\n(50, 100) 15.5\u00a0\u00a0Objects are mutable You can change the state of an object by making an assignment to one of\nits attributes. For example, to change the size of a rectangle\nwithout changing its position, you can modify the values of width and height : box.width = box.width + 50\nbox.height = box.height + 100 You can also write functions that modify objects. For example, grow_rectangle takes a Rectangle object and two numbers, dwidth and dheight , and adds the numbers to the\nwidth and height of the rectangle: def grow_rectangle(rect, dwidth, dheight):\n    rect.width += dwidth\n    rect.height += dheight Here is an example that demonstrates the effect: >>> box.width, box.height\n(150.0, 300.0)\n>>> grow_rectangle(box, 50, 100)\n>>> box.width, box.height\n(200.0, 400.0) Inside the function, rect is an\nalias for box , so when the function modifies rect , box changes. As an exercise, write a function named move_rectangle that takes\na Rectangle and two numbers named dx and dy . It\nshould change the location of the rectangle by adding dx to the x coordinate of corner and adding dy to the y coordinate of corner . 15.6\u00a0\u00a0Copying Aliasing can make a program difficult to read because changes\nin one place might have unexpected effects in another place.\nIt is hard to keep track of all the variables that might refer\nto a given object. Copying an object is often an alternative to aliasing.\nThe copy module contains a function called copy that\ncan duplicate any object: >>> p1 = Point()\n>>> p1.x = 3.0\n>>> p1.y = 4.0\n\n>>> import copy\n>>> p2 = copy.copy(p1) p1 and p2 contain the same data, but they are\nnot the same Point. >>> print_point(p1)\n(3, 4)\n>>> print_point(p2)\n(3, 4)\n>>> p1 is p2\nFalse\n>>> p1 == p2\nFalse The is operator indicates that p1 and p2 are not the\nsame object, which is what we expected. But you might have expected == to yield True because these points contain the same\ndata. In that case, you will be disappointed to learn that for\ninstances, the default behavior of the == operator is the same\nas the is operator; it checks object identity, not object\nequivalence. That\u2019s because for programmer-defined types, Python doesn\u2019t\nknow what should be considered equivalent. At least, not yet. If you use copy.copy to duplicate a Rectangle, you will find\nthat it copies the Rectangle object but not the embedded Point. >>> box2 = copy.copy(box)\n>>> box2 is box\nFalse\n>>> box2.corner is box.corner\nTrue Figure 15.3: Object diagram. Figure 15.3 shows what the object diagram looks like. This operation is called a shallow copy because it copies the\nobject and any references it contains, but not the embedded objects. For most applications, this is not what you want. In this example,\ninvoking grow_rectangle on one of the Rectangles would not\naffect the other, but invoking move_rectangle on either would\naffect both! This behavior is confusing and error-prone. Fortunately, the copy module provides a method named deepcopy that copies not only the object but also\nthe objects it refers to, and the objects they refer to,\nand so on.\nYou will not be surprised to learn that this operation is\ncalled a deep copy . >>> box3 = copy.deepcopy(box)\n>>> box3 is box\nFalse\n>>> box3.corner is box.corner\nFalse box3 and box are completely separate objects. As an exercise, write a version of move_rectangle that creates and\nreturns a new Rectangle instead of modifying the old one. 15.7\u00a0\u00a0Debugging When you start working with objects, you are likely to encounter\nsome new exceptions. If you try to access an attribute\nthat doesn\u2019t exist, you get an AttributeError : >>> p = Point()\n>>> p.x = 3\n>>> p.y = 4\n>>> p.z\nAttributeError: Point instance has no attribute 'z' If you are not sure what type an object is, you can ask: >>> type(p)\n<class '__main__.Point'> You can also use isinstance to check whether an object\nis an instance of a class: >>> isinstance(p, Point)\nTrue If you are not sure whether an object has a particular attribute,\nyou can use the built-in function hasattr : >>> hasattr(p, 'x')\nTrue\n>>> hasattr(p, 'z')\nFalse The first argument can be any object; the second argument is a string that contains the name of the attribute. You can also use a try statement to see if the object has the\nattributes you need: try:\n    x = p.x\nexcept AttributeError:\n    x = 0 This approach can make it easier to write functions that work with\ndifferent types; more on that topic is\ncoming up in Section 17.9 . 15.8\u00a0\u00a0Glossary class: A programmer-defined type. A class definition creates a new\nclass object. class object: An object that contains information about a\nprogrammer-defined type. The class object can be used to create instances\nof the type. instance: An object that belongs to a class. instantiate: To create a new object. attribute: One of the named values associated with an object. embedded object: An object that is stored as an attribute\nof another object. shallow copy: To copy the contents of an object, including\nany references to embedded objects;\nimplemented by the copy function in the copy module. deep copy: To copy the contents of an object as well as any\nembedded objects, and any objects embedded in them, and so on;\nimplemented by the deepcopy function in the copy module. object diagram: A diagram that shows objects, their\nattributes, and the values of the attributes. 15.9\u00a0\u00a0Exercises Exercise\u00a01 Write a definition for a class named Circle with attributes center and radius , where center is a Point object\nand radius is a number. Instantiate a Circle object that represents a circle with its center\nat (150, 100) and radius 75. Write a function named point_in_circle that takes a Circle and\na Point and returns True if the Point lies in or on the boundary of\nthe circle. Write a function named rect_in_circle that takes a Circle and a\nRectangle and returns True if the Rectangle lies entirely in or on the boundary\nof the circle. Write a function named rect_circle_overlap that takes a Circle\nand a Rectangle and returns True if any of the corners of the Rectangle fall\ninside the Circle. Or as a more challenging version, return True if\nany part of the Rectangle falls inside the Circle. Solution: https://thinkpython.com/code/Circle.py . Exercise\u00a02 Write a function called draw_rect that takes a Turtle object\nand a Rectangle and uses the Turtle to draw the Rectangle. See\nChapter 4 for examples using Turtle objects. Write a function called draw_circle that takes a Turtle and\na Circle and draws the Circle. Solution: https://thinkpython.com/code/draw.py . Buy this book at Amazon.com\n\n#### Contribute\n\nIf you would like to make a contribution to support my books,\nyou can use the button below and pay with PayPal.  Thank you!\nPay what you want:\nSmall $1.00 USD\nMedium $5.00 USD\nLarge $10.00 USD\nX-Large $20.00 USD\nXX-Large $50.00 USD\nAre you using one of our books in a class? We'd like to know\nabout it.  Please consider filling out this short survey . Think DSP Think Java Think Bayes Think Python 2e Think Stats 2e Think Complexity",
      "difficulty": "intermediate",
      "doc_id": "doc-chapter-15-classes-and-objects-9467cf0dec",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-NC 3.0",
        "source_file": "data/corpus_raw/thinkpython2_html_thinkpython2016_html_bb1d60.json",
        "url": "https://greenteapress.com/thinkpython2/html/thinkpython2016.html"
      },
      "title": "Chapter\u00a015\u00a0\u00a0Classes and objects",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "debugging",
        "error_handling",
        "exceptions"
      ],
      "content": "Buy this book at Amazon.com Chapter\u00a016\u00a0\u00a0Classes and functions Now that we know how to create new types, the next\nstep is to write functions that take programmer-defined objects\nas parameters and return them as results. In this chapter I\nalso present \u201cfunctional programming style\u201d and two new\nprogram development plans. Code examples from this chapter are available from https://thinkpython.com/code/Time1.py .\nSolutions to the exercises are at https://thinkpython.com/code/Time1_soln.py . 16.1\u00a0\u00a0Time As another example of a programmer-defined type, we\u2019ll define a class\ncalled Time that records the time of day. The class definition\nlooks like this: class Time:\n    \"\"\"Represents the time of day.\n\n    attributes: hour, minute, second\n    \"\"\" We can create a new Time object and assign\nattributes for hours, minutes, and seconds: time = Time()\ntime.hour = 11\ntime.minute = 59\ntime.second = 30 The state diagram for the Time object looks like Figure 16.1 . As an exercise, write a function called print_time that takes a\nTime object and prints it in the form hour:minute:second .\nHint: the format sequence '%.2d' prints an integer using\nat least two digits, including a leading zero if necessary. Write a boolean function called is_after that\ntakes two Time objects, t1 and t2 , and\nreturns True if t1 follows t2 chronologically and False otherwise. Challenge: don\u2019t use an if statement. Figure 16.1: Object diagram. 16.2\u00a0\u00a0Pure functions In the next few sections, we\u2019ll write two functions that add time\nvalues. They demonstrate two kinds of functions: pure functions and\nmodifiers. They also demonstrate a development plan I\u2019ll call prototype and patch , which is a way of tackling a complex problem\nby starting with a simple prototype and incrementally dealing with the\ncomplications. Here is a simple prototype of add_time : def add_time(t1, t2):\n    sum = Time()\n    sum.hour = t1.hour + t2.hour\n    sum.minute = t1.minute + t2.minute\n    sum.second = t1.second + t2.second\n    return sum The function creates a new Time object, initializes its\nattributes, and returns a reference to the new object. This is called\na pure function because it does not modify any of the objects\npassed to it as arguments and it has no effect,\nlike displaying a value or getting user input,\nother than returning a value. To test this function, I\u2019ll create two Time objects: start contains the start time of a movie, like Monty Python and the\nHoly Grail , and duration contains the run time of the movie,\nwhich is one hour 35 minutes. add_time figures out when the movie will be done. >>> start = Time()\n>>> start.hour = 9\n>>> start.minute = 45\n>>> start.second =  0\n\n>>> duration = Time()\n>>> duration.hour = 1\n>>> duration.minute = 35\n>>> duration.second = 0\n\n>>> done = add_time(start, duration)\n>>> print_time(done)\n10:80:00 The result, 10:80:00 might not be what you were hoping\nfor. The problem is that this function does not deal with cases where the\nnumber of seconds or minutes adds up to more than sixty. When that\nhappens, we have to \u201ccarry\u201d the extra seconds into the minute column\nor the extra minutes into the hour column. Here\u2019s an improved version: def add_time(t1, t2):\n    sum = Time()\n    sum.hour = t1.hour + t2.hour\n    sum.minute = t1.minute + t2.minute\n    sum.second = t1.second + t2.second\n\n    if sum.second >= 60:\n        sum.second -= 60\n        sum.minute += 1\n\n    if sum.minute >= 60:\n        sum.minute -= 60\n        sum.hour += 1\n\n    return sum Although this function is correct, it is starting to get big.\nWe will see a shorter alternative later. 16.3\u00a0\u00a0Modifiers Sometimes it is useful for a function to modify the objects it gets as\nparameters. In that case, the changes are visible to the caller.\nFunctions that work this way are called modifiers . increment , which adds a given number of seconds to a Time object, can be written naturally as a\nmodifier. Here is a rough draft: def increment(time, seconds):\n    time.second += seconds\n\n    if time.second >= 60:\n        time.second -= 60\n        time.minute += 1\n\n    if time.minute >= 60:\n        time.minute -= 60\n        time.hour += 1 The first line performs the basic operation; the remainder deals\nwith the special cases we saw before. Is this function correct? What happens if seconds is much greater than sixty? In that case, it is not enough to carry once; we have to keep doing it\nuntil time.second is less than sixty. One solution is to\nreplace the if statements with while statements. That\nwould make the function correct, but not very efficient. As an\nexercise, write a correct version of increment that doesn\u2019t\ncontain any loops. Anything that can be done with modifiers can also be done with pure\nfunctions. In fact, some programming languages only allow pure\nfunctions. There is some evidence that programs that use pure\nfunctions are faster to develop and less error-prone than programs\nthat use modifiers. But modifiers are convenient at times,\nand functional programs tend to be less efficient. In general, I recommend that you write pure functions whenever it is\nreasonable and resort to modifiers only if there is a compelling\nadvantage. This approach might be called a functional\nprogramming style . As an exercise, write a \u201cpure\u201d version of increment that\ncreates and returns a new Time object rather than modifying the\nparameter. 16.4\u00a0\u00a0Prototyping versus planning The development plan I am demonstrating is called \u201cprototype and\npatch\u201d. For each function, I wrote a prototype that performed the\nbasic calculation and then tested it, patching errors along the\nway. This approach can be effective, especially if you don\u2019t yet have a\ndeep understanding of the problem. But incremental corrections can\ngenerate code that is unnecessarily complicated\u2014since it deals with\nmany special cases\u2014and unreliable\u2014since it is hard to know if you\nhave found all the errors. An alternative is designed development , in which high-level\ninsight into the problem can make the programming much easier. In\nthis case, the insight is that a Time object is really a three-digit\nnumber in base 60 (see http://en.wikipedia.org/wiki/Sexagesimal ). The second attribute is the \u201cones column\u201d, the minute attribute is the \u201csixties column\u201d, and the hour attribute is\nthe \u201cthirty-six hundreds column\u201d. When we wrote add_time and increment , we were effectively\ndoing addition in base 60, which is why we had to carry from one\ncolumn to the next. This observation suggests another approach to the whole problem\u2014we\ncan convert Time objects to integers and take advantage of the fact\nthat the computer knows how to do integer arithmetic. Here is a function that converts Times to integers: def time_to_int(time):\n    minutes = time.hour * 60 + time.minute\n    seconds = minutes * 60 + time.second\n    return seconds And here is a function that converts an integer to a Time\n(recall that divmod divides the first argument by the second\nand returns the quotient and remainder as a tuple). def int_to_time(seconds):\n    time = Time()\n    minutes, time.second = divmod(seconds, 60)\n    time.hour, time.minute = divmod(minutes, 60)\n    return time You might have to think a bit, and run some tests, to convince\nyourself that these functions are correct. One way to test them is to\ncheck that time_to_int(int_to_time(x)) == x for many values of x . This is an example of a consistency check. Once you are convinced they are correct, you can use them to\nrewrite add_time : def add_time(t1, t2):\n    seconds = time_to_int(t1) + time_to_int(t2)\n    return int_to_time(seconds) This version is shorter than the original, and easier to verify. As\nan exercise, rewrite increment using time_to_int and int_to_time . In some ways, converting from base 60 to base 10 and back is harder\nthan just dealing with times. Base conversion is more abstract; our\nintuition for dealing with time values is better. But if we have the insight to treat times as base 60 numbers and make\nthe investment of writing the conversion functions ( time_to_int and int_to_time ), we get a program that is shorter, easier to\nread and debug, and more reliable. It is also easier to add features later. For example, imagine\nsubtracting two Times to find the duration between them. The\nnaive approach would be to implement subtraction with borrowing.\nUsing the conversion functions would be easier and more likely to be\ncorrect. Ironically, sometimes making a problem harder (or more general) makes it\neasier (because there are fewer special cases and fewer opportunities\nfor error). 16.5\u00a0\u00a0Debugging A Time object is well-formed if the values of minute and second are between 0 and 60 (including 0 but not 60) and if hour is positive. hour and minute should be\ninteger values, but we might allow second to have a\nfraction part. Requirements like these are called invariants because\nthey should always be true. To put it a different way, if they\nare not true, something has gone wrong. Writing code to check invariants can help detect errors\nand find their causes. For example, you might have a function\nlike valid_time that takes a Time object and returns False if it violates an invariant: def valid_time(time):\n    if time.hour < 0 or time.minute < 0 or time.second < 0:\n        return False\n    if time.minute >= 60 or time.second >= 60:\n        return False\n    return True At the beginning of each function you could check the\narguments to make sure they are valid: def add_time(t1, t2):\n    if not valid_time(t1) or not valid_time(t2):\n        raise ValueError('invalid Time object in add_time')\n    seconds = time_to_int(t1) + time_to_int(t2)\n    return int_to_time(seconds) Or you could use an assert statement , which checks a given invariant\nand raises an exception if it fails: def add_time(t1, t2):\n    assert valid_time(t1) and valid_time(t2)\n    seconds = time_to_int(t1) + time_to_int(t2)\n    return int_to_time(seconds) assert statements are useful because they distinguish\ncode that deals with normal conditions from code\nthat checks for errors. 16.6\u00a0\u00a0Glossary prototype and patch: A development plan that involves\nwriting a rough draft of a program, testing, and correcting errors as\nthey are found. designed development: A development plan that involves\nhigh-level insight into the problem and more planning than incremental\ndevelopment or prototype development. pure function: A function that does not modify any of the objects it\nreceives as arguments. Most pure functions are fruitful. modifier: A function that changes one or more of the objects it\nreceives as arguments. Most modifiers are void; that is, they\nreturn None . functional programming style: A style of program design in which the\nmajority of functions are pure. invariant: A condition that should always be true during the\nexecution of a program. assert statement: A statement that checks a condition and raises\nan exception if it fails. 16.7\u00a0\u00a0Exercises Code examples from this chapter are available from https://thinkpython.com/code/Time1.py ; solutions to the\nexercises are available from https://thinkpython.com/code/Time1_soln.py . Exercise\u00a01 Write a function called mul_time that takes a Time object\nand a number and returns a new Time object that contains\nthe product of the original Time and the number. Then use mul_time to write a function that takes a Time\nobject that represents the finishing time in a race, and a number\nthat represents the distance, and returns a Time object that represents\nthe average pace (time per mile). Exercise\u00a02 The datetime module provides time objects\nthat are similar to the Time objects in this chapter, but\nthey provide a rich set of methods and operators. Read the\ndocumentation at http://docs.python.org/3/library/datetime.html . Use the datetime module to write a program that gets the\ncurrent date and prints the day of the week. Write a program that takes a birthday as input and prints the\nuser\u2019s age and the number of days, hours, minutes and seconds until\ntheir next birthday. For two people born on different days, there is a day when one\nis twice as old as the other. That\u2019s their Double Day. Write a\nprogram that takes two birth dates and computes their Double Day. For a little more challenge, write the more general version that\ncomputes the day when one person is n times older than the other. Solution: https://thinkpython.com/code/double.py Buy this book at Amazon.com\n\n#### Contribute\n\nIf you would like to make a contribution to support my books,\nyou can use the button below and pay with PayPal.  Thank you!\nPay what you want:\nSmall $1.00 USD\nMedium $5.00 USD\nLarge $10.00 USD\nX-Large $20.00 USD\nXX-Large $50.00 USD\nAre you using one of our books in a class? We'd like to know\nabout it.  Please consider filling out this short survey . Think DSP Think Java Think Bayes Think Python 2e Think Stats 2e Think Complexity",
      "difficulty": "intro",
      "doc_id": "doc-chapter-16-classes-and-functions-130c309393",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-NC 3.0",
        "source_file": "data/corpus_raw/thinkpython2_html_thinkpython2017_html_8b1699.json",
        "url": "https://greenteapress.com/thinkpython2/html/thinkpython2017.html"
      },
      "title": "Chapter\u00a016\u00a0\u00a0Classes and functions",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "common_errors",
        "debugging",
        "error_handling"
      ],
      "content": "Buy this book at Amazon.com Chapter\u00a019\u00a0\u00a0The Goodies One of my goals for this book has been to teach you as little Python\nas possible. When there were two ways to do something, I picked\none and avoided mentioning the other. Or sometimes I put the second\none into an exercise. Now I want to go back for some of the good bits that got left behind.\nPython provides a number of features that are not really necessary\u2014you\ncan write good code without them\u2014but with them you can sometimes\nwrite code that\u2019s more concise, readable or efficient, and sometimes\nall three. 19.1\u00a0\u00a0Conditional expressions We saw conditional statements in Section 5.4 .\nConditional statements are often used to choose one of two values;\nfor example: if x > 0:\n    y = math.log(x)\nelse:\n    y = float('nan') This statement checks whether x is positive. If so, it computes math.log . If not, math.log would raise a ValueError. To\navoid stopping the program, we generate a \u201cNaN\u201d, which is a special\nfloating-point value that represents \u201cNot a Number\u201d. We can write this statement more concisely using a conditional\nexpression : y = math.log(x) if x > 0 else float('nan') You can almost read this line like English: \u201c y gets log- x if x is greater than 0; otherwise it gets NaN\u201d. Recursive functions can sometimes be rewritten using conditional\nexpressions. For example, here is a recursive version of factorial : def factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1) We can rewrite it like this: def factorial(n):\n    return 1 if n == 0 else n * factorial(n-1) Another use of conditional expressions is handling optional\narguments. For example, here is the init method from GoodKangaroo (see Exercise 2 ): def __init__(self, name, contents=None):\n        self.name = name\n        if contents == None:\n            contents = []\n        self.pouch_contents = contents We can rewrite this one like this: def __init__(self, name, contents=None):\n        self.name = name\n        self.pouch_contents = [] if contents == None else contents In general, you can replace a conditional statement with a conditional\nexpression if both branches contain simple expressions that are\neither returned or assigned to the same variable. 19.2\u00a0\u00a0List comprehensions In Section 10.7 we saw the map and filter patterns. For\nexample, this function takes a list of strings, maps the string method capitalize to the elements, and returns a new list of strings: def capitalize_all(t):\n    res = []\n    for s in t:\n        res.append(s.capitalize())\n    return res We can write this more concisely using a list comprehension : def capitalize_all(t):\n    return [s.capitalize() for s in t] The bracket operators indicate that we are constructing a new\nlist. The expression inside the brackets specifies the elements\nof the list, and the for clause indicates what sequence\nwe are traversing. The syntax of a list comprehension is a little awkward because\nthe loop variable, s in this example, appears in the expression\nbefore we get to the definition. List comprehensions can also be used for filtering. For example,\nthis function selects only the elements of t that are\nupper case, and returns a new list: def only_upper(t):\n    res = []\n    for s in t:\n        if s.isupper():\n            res.append(s)\n    return res We can rewrite it using a list comprehension def only_upper(t):\n    return [s for s in t if s.isupper()] List comprehensions are concise and easy to read, at least for simple\nexpressions. And they are usually faster than the equivalent for\nloops, sometimes much faster. So if you are mad at me for not\nmentioning them earlier, I understand. But, in my defense, list comprehensions are harder to debug because\nyou can\u2019t put a print statement inside the loop. I suggest that you\nuse them only if the computation is simple enough that you are likely\nto get it right the first time. And for beginners that means never. 19.3\u00a0\u00a0Generator expressions Generator expressions are similar to list comprehensions, but\nwith parentheses instead of square brackets: >>> g = (x**2 for x in range(5))\n>>> g\n<generator object <genexpr> at 0x7f4c45a786c0> The result is a generator object that knows how to iterate through\na sequence of values. But unlike a list comprehension, it does not\ncompute the values all at once; it waits to be asked. The built-in\nfunction next gets the next value from the generator: >>> next(g)\n0\n>>> next(g)\n1 When you get to the end of the sequence, next raises a\nStopIteration exception. You can also use a for loop to iterate\nthrough the values: >>> for val in g:\n...     print(val)\n4\n9\n16 The generator object keeps track of where it is in the sequence,\nso the for loop picks up where next left off. Once the\ngenerator is exhausted, it continues to raise StopIteration : >>> next(g)\nStopIteration Generator expressions are often used with functions like sum , max , and min : >>> sum(x**2 for x in range(5))\n30 19.4 any and all Python provides a built-in function, any , that takes a sequence\nof boolean values and returns True if any of the values are True . It works on lists: >>> any([False, False, True])\nTrue But it is often used with generator expressions: >>> any(letter == 't' for letter in 'monty')\nTrue That example isn\u2019t very useful because it does the same thing\nas the in operator. But we could use any to rewrite\nsome of the search functions we wrote in Section 9.3 . For\nexample, we could write avoids like this: def avoids(word, forbidden):\n    return not any(letter in forbidden for letter in word) The function almost reads like English, \u201c word avoids forbidden if there are not any forbidden letters in word .\u201d Using any with a generator expression is efficient because\nit stops immediately if it finds a True value,\nso it doesn\u2019t have to evaluate the whole sequence. Python provides another built-in function, all , that returns True if every element of the sequence is True . As\nan exercise, use all to re-write uses_all from\nSection 9.3 . 19.5\u00a0\u00a0Sets In Section 13.6 I use dictionaries to find the words\nthat appear in a document but not in a word list. The function\nI wrote takes d1 , which contains the words from the document\nas keys, and d2 , which contains the list of words. It\nreturns a dictionary that contains the keys from d1 that\nare not in d2 . def subtract(d1, d2):\n    res = dict()\n    for key in d1:\n        if key not in d2:\n            res[key] = None\n    return res In all of these dictionaries, the values are None because\nwe never use them. As a result, we waste some storage space. Python provides another built-in type, called a set , that\nbehaves like a collection of dictionary keys with no values. Adding\nelements to a set is fast; so is checking membership. And sets\nprovide methods and operators to compute common set operations. For example, set subtraction is available as a method called difference or as an operator, - . So we can rewrite subtract like this: def subtract(d1, d2):\n    return set(d1) - set(d2) The result is a set instead of a dictionary, but for operations like\niteration, the behavior is the same. Some of the exercises in this book can be done concisely and\nefficiently with sets. For example, here is a solution to has_duplicates , from\nExercise 7 , that uses a dictionary: def has_duplicates(t):\n    d = {}\n    for x in t:\n        if x in d:\n            return True\n        d[x] = True\n    return False When an element appears for the first time, it is added to the\ndictionary. If the same element appears again, the function returns True . Using sets, we can write the same function like this: def has_duplicates(t):\n    return len(set(t)) < len(t) An element can only appear in a set once, so if an element in t appears more than once, the set will be smaller than t . If there\nare no duplicates, the set will be the same size as t . We can also use sets to do some of the exercises in\nChapter 9 . For example, here\u2019s a version of uses_only with a loop: def uses_only(word, available):\n    for letter in word:\n        if letter not in available:\n            return False\n    return True uses_only checks whether all letters in word are\nin available . We can rewrite it like this: def uses_only(word, available):\n    return set(word) <= set(available) The <= operator checks whether one set is a subset of another,\nincluding the possibility that they are equal, which is true if all\nthe letters in word appear in available . As an exercise, rewrite avoids using sets. 19.6\u00a0\u00a0Counters A Counter is like a set, except that if an element appears more\nthan once, the Counter keeps track of how many times it appears.\nIf you are familiar with the mathematical idea of a multiset ,\na Counter is a natural way to represent a multiset. Counter is defined in a standard module called collections ,\nso you have to import it. You can initialize a Counter with a string,\nlist, or anything else that supports iteration: >>> from collections import Counter\n>>> count = Counter('parrot')\n>>> count\nCounter({'r': 2, 't': 1, 'o': 1, 'p': 1, 'a': 1}) Counters behave like dictionaries in many ways; they map from each\nkey to the number of times it appears. As in dictionaries,\nthe keys have to be hashable. Unlike dictionaries, Counters don\u2019t raise an exception if you access\nan element that doesn\u2019t appear. Instead, they return 0: >>> count['d']\n0 We can use Counters to rewrite is_anagram from\nExercise 6 : def is_anagram(word1, word2):\n    return Counter(word1) == Counter(word2) If two words are anagrams, they contain the same letters with the same\ncounts, so their Counters are equivalent. Counters provide methods and operators to perform set-like operations,\nincluding addition, subtraction, union and intersection. And\nthey provide an often-useful method, most_common , which\nreturns a list of value-frequency pairs, sorted from most common to\nleast: >>> count = Counter('parrot')\n>>> for val, freq in count.most_common(3):\n...     print(val, freq)\nr 2\np 1\na 1 19.7\u00a0\u00a0defaultdict The collections module also provides defaultdict , which is\nlike a dictionary except that if you access a key that doesn\u2019t exist,\nit can generate a new value on the fly. When you create a defaultdict, you provide a function that\u2019s used to\ncreate new values. A function used to create objects is sometimes\ncalled a factory . The built-in functions that create lists, sets,\nand other types can be used as factories: >>> from collections import defaultdict\n>>> d = defaultdict(list) Notice that the argument is list , which is a class object,\nnot list() , which is a new list. The function you provide\ndoesn\u2019t get called unless you access a key that doesn\u2019t exist. >>> t = d['new key']\n>>> t\n[] The new list, which we\u2019re calling t , is also added to the\ndictionary. So if we modify t , the change appears in d : >>> t.append('new value')\n>>> d\ndefaultdict(<class 'list'>, {'new key': ['new value']}) If you are making a dictionary of lists, you can often write simpler\ncode using defaultdict . In my solution to\nExercise 2 , which you can get from https://thinkpython.com/code/anagram_sets.py , I make a\ndictionary that maps from a sorted string of letters to the list of\nwords that can be spelled with those letters. For example, \u2019opst\u2019 maps to the list [\u2019opts\u2019, \u2019post\u2019, \u2019pots\u2019, \u2019spot\u2019,\n\u2019stop\u2019, \u2019tops\u2019] . Here\u2019s the original code: def all_anagrams(filename):\n    d = {}\n    for line in open(filename):\n        word = line.strip().lower()\n        t = signature(word)\n        if t not in d:\n            d[t] = [word]\n        else:\n            d[t].append(word)\n    return d This can be simplified using setdefault , which you might\nhave used in Exercise 2 : def all_anagrams(filename):\n    d = {}\n    for line in open(filename):\n        word = line.strip().lower()\n        t = signature(word)\n        d.setdefault(t, []).append(word)\n    return d This solution has the drawback that it makes a new list\nevery time, regardless of whether it is needed. For lists,\nthat\u2019s no big deal, but if the factory\nfunction is complicated, it might be. We can avoid this problem and\nsimplify the code using a defaultdict : def all_anagrams(filename):\n    d = defaultdict(list)\n    for line in open(filename):\n        word = line.strip().lower()\n        t = signature(word)\n        d[t].append(word)\n    return d My solution to Exercise 3 , which you can download from https://thinkpython.com/code/PokerHandSoln.py ,\nuses setdefault in the function has_straightflush . This solution has the drawback\nof creating a Hand object every time through the loop, whether\nit is needed or not. As an exercise, rewrite it using\na defaultdict. 19.8\u00a0\u00a0Named tuples Many simple objects are basically collections of related values.\nFor example, the Point object defined in Chapter 15 contains\ntwo numbers, x and y . When you define a class like\nthis, you usually start with an init method and a str method: class Point:\n\n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n\n    def __str__(self):\n        return '(%g, %g)' % (self.x, self.y) This is a lot of code to convey a small amount of information.\nPython provides a more concise way to say the same thing: from collections import namedtuple\nPoint = namedtuple('Point', ['x', 'y']) The first argument is the name of the class you want to create.\nThe second is a list of the attributes Point objects should have,\nas strings. The return value from namedtuple is a class object: >>> Point\n<class '__main__.Point'> Point automatically provides methods like __init__ and __str__ so you don\u2019t have to write them. To create a Point object, you use the Point class as a function: >>> p = Point(1, 2)\n>>> p\nPoint(x=1, y=2) The init method assigns the arguments to attributes using the names\nyou provided. The str method prints a representation of the Point\nobject and its attributes. You can access the elements of the named tuple by name: >>> p.x, p.y\n(1, 2) But you can also treat a named tuple as a tuple: >>> p[0], p[1]\n(1, 2)\n\n>>> x, y = p\n>>> x, y\n(1, 2) Named tuples provide a quick way to define simple classes.\nThe drawback is that simple classes don\u2019t always stay simple.\nYou might decide later that you want to add methods to a named tuple.\nIn that case, you could define a new class that inherits from\nthe named tuple: class Pointier(Point):\n    # add more methods here Or you could switch to a conventional class definition. 19.9\u00a0\u00a0Gathering keyword args In Section 12.4 , we saw how to write a function that\ngathers its arguments into a tuple: def printall(*args):\n    print(args) You can call this function with any number of positional arguments\n(that is, arguments that don\u2019t have keywords): >>> printall(1, 2.0, '3')\n(1, 2.0, '3') But the * operator doesn\u2019t gather keyword arguments: >>> printall(1, 2.0, third='3')\nTypeError: printall() got an unexpected keyword argument 'third' To gather keyword arguments, you can use the ** operator: def printall(*args, **kwargs):\n    print(args, kwargs) You can call the keyword gathering parameter anything you want, but kwargs is a common choice. The result is a dictionary that maps\nfrom keywords to values: >>> printall(1, 2.0, third='3')\n(1, 2.0) {'third': '3'} If you have a dictionary of keywords and values, you can use the\nscatter operator, ** to call a function: >>> d = dict(x=1, y=2)\n>>> Point(**d)\nPoint(x=1, y=2) Without the scatter operator, the function would treat d as\na single positional argument, so it would assign d to x and complain because there\u2019s nothing to assign to y : >>> d = dict(x=1, y=2)\n>>> Point(d)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: __new__() missing 1 required positional argument: 'y' When you are working with functions that have a large number of\nparameters, it is often useful to create and pass around dictionaries\nthat specify frequently used options. 19.10\u00a0\u00a0Glossary conditional expression: An expression that has one of two\nvalues, depending on a condition. list comprehension: An expression with a for loop in square\nbrackets that yields a new list. generator expression: An expression with a for loop in parentheses\nthat yields a generator object. multiset: A mathematical entity that represents a mapping\nbetween the elements of a set and the number of times they appear. factory: A function, usually passed as a parameter, used to\ncreate objects. 19.11\u00a0\u00a0Exercises Exercise\u00a01 The following is a function that computes the binomial\ncoefficient recursively. def binomial_coeff(n, k):\n    \"\"\"Compute the binomial coefficient \"n choose k\".\n\n    n: number of trials\n    k: number of successes\n\n    returns: int\n    \"\"\"\n    if k == 0:\n        return 1\n    if n == 0:\n        return 0\n\n    res = binomial_coeff(n-1, k) + binomial_coeff(n-1, k-1)\n    return res Rewrite the body of the function using nested conditional\nexpressions. One note: this function is not very efficient because it ends up computing\nthe same values over and over. You could make it more efficient by\nmemoizing (see Section 11.6 ). But you will find that it\u2019s harder to\nmemoize if you write it using conditional expressions. Buy this book at Amazon.com\n\n#### Contribute\n\nIf you would like to make a contribution to support my books,\nyou can use the button below and pay with PayPal.  Thank you!\nPay what you want:\nSmall $1.00 USD\nMedium $5.00 USD\nLarge $10.00 USD\nX-Large $20.00 USD\nXX-Large $50.00 USD\nAre you using one of our books in a class? We'd like to know\nabout it.  Please consider filling out this short survey . Think DSP Think Java Think Bayes Think Python 2e Think Stats 2e Think Complexity",
      "difficulty": "intro",
      "doc_id": "doc-chapter-19-the-goodies-3a303ea7ff",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-NC 3.0",
        "source_file": "data/corpus_raw/scraped/thinkpython2_html_thinkpython2020_html_8f1a31.json",
        "url": "https://greenteapress.com/thinkpython2/html/thinkpython2020.html"
      },
      "title": "Chapter\u00a019\u00a0\u00a0The Goodies",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "arguments",
        "functions",
        "return_values"
      ],
      "content": "Buy this book at Amazon.com Chapter\u00a02\u00a0\u00a0Variables, expressions and statements One of the most powerful features of a programming language is the\nability to manipulate variables . A variable is a name that\nrefers to a value. 2.1\u00a0\u00a0Assignment statements An assignment statement creates a new variable and gives\nit a value: >>> message = 'And now for something completely different'\n>>> n = 17\n>>> pi = 3.1415926535897932 This example makes three assignments. The first assigns a string\nto a new variable named message ;\nthe second gives the integer 17 to n ; the third\nassigns the (approximate) value of \u03c0 to pi . A common way to represent variables on paper is to write the name with\nan arrow pointing to its value. This kind of figure is\ncalled a state diagram because it shows what state each of the\nvariables is in (think of it as the variable\u2019s state of mind).\nFigure 2.1 shows the result of the previous example. Figure 2.1: State diagram. 2.2\u00a0\u00a0Variable names Programmers generally choose names for their variables that\nare meaningful\u2014they document what the variable is used for. Variable names can be as long as you like. They can contain\nboth letters and numbers, but they can\u2019t begin with a number.\nIt is legal to use uppercase letters, but it is conventional\nto use only lower case for variables names. The underscore character, _ , can appear in a name.\nIt is often used in names with multiple words, such as your_name or airspeed_of_unladen_swallow . If you give a variable an illegal name, you get a syntax error: >>> 76trombones = 'big parade'\nSyntaxError: invalid syntax\n>>> more@ = 1000000\nSyntaxError: invalid syntax\n>>> class = 'Advanced Theoretical Zymurgy'\nSyntaxError: invalid syntax 76trombones is illegal because it begins with a number. more@ is illegal because it contains an illegal character, @ . But what\u2019s wrong with class ? It turns out that class is one of Python\u2019s keywords . The\ninterpreter uses keywords to recognize the structure of the program,\nand they cannot be used as variable names. Python 3 has these keywords: False      class      finally    is         return\nNone       continue   for        lambda     try\nTrue       def        from       nonlocal   while\nand        del        global     not        with\nas         elif       if         or         yield\nassert     else       import     pass\nbreak      except     in         raise You don\u2019t have to memorize this list. In most development environments,\nkeywords are displayed in a different color; if you try to use one\nas a variable name, you\u2019ll know. 2.3\u00a0\u00a0Expressions and statements An expression is a combination of values, variables, and operators.\nA value all by itself is considered an expression, and so is\na variable, so the following are all legal expressions: >>> 42\n42\n>>> n\n17\n>>> n + 25\n42 When you type an expression at the prompt, the interpreter evaluates it, which means that it finds the value of\nthe expression.\nIn this example, n has the value 17 and n + 25 has the value 42. A statement is a unit of code that has an effect, like\ncreating a variable or displaying a value. >>> n = 17\n>>> print(n) The first line is an assignment statement that gives a value to n . The second line is a print statement that displays the\nvalue of n . When you type a statement, the interpreter executes it,\nwhich means that it does whatever the statement says. In general,\nstatements don\u2019t have values. 2.4\u00a0\u00a0Script mode So far we have run Python in interactive mode , which\nmeans that you interact directly with the interpreter.\nInteractive mode is a good way to get started,\nbut if you are working with more than a few lines of code, it can be\nclumsy. The alternative is to save code in a file called a script and\nthen run the interpreter in script mode to execute the script. By\nconvention, Python scripts have names that end with .py . If you know how to create and run a script on your computer, you\nare ready to go. Otherwise I recommend using PythonAnywhere again.\nI have posted instructions for running in script mode at http://tinyurl.com/thinkpython2e . Because Python provides both modes,\nyou can test bits of code in interactive mode before you put them\nin a script. But there are differences between interactive mode\nand script mode that can be confusing. For example, if you are using Python as a calculator, you might type >>> miles = 26.2\n>>> miles * 1.61\n42.182 The first line assigns a value to miles , but it has no visible\neffect. The second line is an expression, so the\ninterpreter evaluates it and displays the result. It turns out that a\nmarathon is about 42 kilometers. But if you type the same code into a script and run it, you get no\noutput at all.\nIn script mode an expression, all by itself, has no\nvisible effect. Python evaluates the expression, but it doesn\u2019t\ndisplay the result.\nTo display the result, you need a print statement like this: miles = 26.2\nprint(miles * 1.61) This behavior can be confusing at first.\nTo check your understanding, type the following statements in the\nPython interpreter and see what they do: 5\nx = 5\nx + 1 Now put the same statements in a script and run it. What\nis the output? Modify the script by transforming each\nexpression into a print statement and then run it again. 2.5\u00a0\u00a0Order of operations When an expression contains more than one operator, the order of\nevaluation depends on the order of operations . For\nmathematical operators, Python follows mathematical convention.\nThe acronym PEMDAS is a useful way to\nremember the rules: P arentheses have the highest precedence and can be used\nto force an expression to evaluate in the order you want. Since\nexpressions in parentheses are evaluated first, 2 * (3-1) is 4,\nand (1+1)**(5-2) is 8. You can also use parentheses to make an\nexpression easier to read, as in (minute * 100) / 60 , even\nif it doesn\u2019t change the result. E xponentiation has the next highest precedence, so 1 + 2**3 is 9, not 27, and 2 * 3**2 is 18, not 36. M ultiplication and D ivision have higher precedence\nthan A ddition and S ubtraction. So 2*3-1 is 5, not\n4, and 6+4/2 is 8, not 5. Operators with the same precedence are evaluated from left to\nright (except exponentiation). So in the expression degrees /\n2 * pi , the division happens first and the result is multiplied\nby pi . To divide by 2 \u03c0, you can use parentheses or write degrees / 2 / pi . I don\u2019t work very hard to remember the precedence of\noperators. If I can\u2019t tell by looking at the expression, I use\nparentheses to make it obvious. 2.6\u00a0\u00a0String operations In general, you can\u2019t perform mathematical operations on strings, even\nif the strings look like numbers, so the following are illegal: 'chinese'-'food'    'eggs'/'easy'    'third'*'a charm' But there are two exceptions, + and * . The + operator performs string concatenation , which means\nit joins the strings by linking them end-to-end. For example: >>> first = 'throat'\n>>> second = 'warbler'\n>>> first + second\nthroatwarbler The * operator also works on strings; it performs repetition.\nFor example, 'Spam'*3 is 'SpamSpamSpam' . If one of the\nvalues is a string, the other has to be an integer. This use of + and * makes sense by\nanalogy with addition and multiplication. Just as 4*3 is\nequivalent to 4+4+4 , we expect 'Spam'*3 to be the same as 'Spam'+'Spam'+'Spam' , and it is. On the other hand, there is a\nsignificant way in which string concatenation and repetition are\ndifferent from integer addition and multiplication.\nCan you think of a property that addition has\nthat string concatenation does not? 2.7\u00a0\u00a0Comments As programs get bigger and more complicated, they get more difficult\nto read. Formal languages are dense, and it is often difficult to\nlook at a piece of code and figure out what it is doing, or why. For this reason, it is a good idea to add notes to your programs to explain\nin natural language what the program is doing. These notes are called comments , and they start with the # symbol: # compute the percentage of the hour that has elapsed\npercentage = (minute * 100) / 60 In this case, the comment appears on a line by itself. You can also put\ncomments at the end of a line: percentage = (minute * 100) / 60     # percentage of an hour Everything from the # to the end of the line is ignored\u2014it\nhas no effect on the execution of the program. Comments are most useful when they document non-obvious features of\nthe code. It is reasonable to assume that the reader can figure out what the code does; it is more useful to explain why . This comment is redundant with the code and useless: v = 5     # assign 5 to v This comment contains useful information that is not in the code: v = 5     # velocity in meters/second. Good variable names can reduce the need for comments, but\nlong names can make complex expressions hard to read, so there is\na tradeoff. 2.8\u00a0\u00a0Debugging Three kinds of errors can occur in a program: syntax errors, runtime\nerrors, and semantic errors. It is useful\nto distinguish between them in order to track them down more quickly. Syntax error: \u201cSyntax\u201d refers to the structure of a program\nand the rules about that structure. For example, parentheses have\nto come in matching pairs, so (1 + 2) is legal, but 8) is a syntax error . If there is a syntax error\nanywhere in your program, Python displays an error message and quits,\nand you will not be able to run the program. During the first few\nweeks of your programming career, you might spend a lot of\ntime tracking down syntax errors. As you gain experience, you will\nmake fewer errors and find them faster. Runtime error: The second type of error is a runtime error, so\ncalled because the error does not appear until after the program has\nstarted running. These errors are also called exceptions because they usually indicate that something exceptional (and bad)\nhas happened. Runtime errors are rare in the simple programs you will see in the\nfirst few chapters, so it might be a while before you encounter one. Semantic error: The third type of error is \u201csemantic\u201d, which\nmeans related to meaning. If there is a semantic error in your\nprogram, it will run without generating error messages, but it will\nnot do the right thing. It will do something else. Specifically,\nit will do what you told it to do. Identifying semantic errors can be tricky because it requires you to work\nbackward by looking at the output of the program and trying to figure\nout what it is doing. 2.9\u00a0\u00a0Glossary variable: A name that refers to a value. assignment: A statement that assigns a value to a variable. state diagram: A graphical representation of a set of variables and the\nvalues they refer to. keyword: A reserved word that is used to parse a\nprogram; you cannot use keywords like if , def , and while as\nvariable names. operand: One of the values on which an operator operates. expression: A combination of variables, operators, and values that\nrepresents a single result. evaluate: To simplify an expression by performing the operations\nin order to yield a single value. statement: A section of code that represents a command or action. So\nfar, the statements we have seen are assignments and print statements. execute: To run a statement and do what it says. interactive mode: A way of using the Python interpreter by\ntyping code at the prompt. script mode: A way of using the Python interpreter to read\ncode from a script and run it. script: A program stored in a file. order of operations: Rules governing the order in which\nexpressions involving multiple operators and operands are evaluated. concatenate: To join two operands end-to-end. comment: Information in a program that is meant for other\nprogrammers (or anyone reading the source code) and has no effect on the\nexecution of the program. syntax error: An error in a program that makes it impossible\nto parse (and therefore impossible to interpret). exception: An error that is detected while the program is running. semantics: The meaning of a program. semantic error: An error in a program that makes it do something\nother than what the programmer intended. 2.10\u00a0\u00a0Exercises Exercise\u00a01 Repeating my advice from the previous chapter, whenever you learn\na new feature, you should try it out in interactive mode and make\nerrors on purpose to see what goes wrong. We\u2019ve seen that n = 42 is legal. What about 42 = n ? How about x = y = 1 ? In some languages every statement ends with a semi-colon, ; .\nWhat happens if you put a semi-colon at the end of a Python statement? What if you put a period at the end of a statement? In math notation you can multiply x and y like this: x y .\nWhat happens if you try that in Python? Exercise\u00a02 Practice using the Python interpreter as a calculator: The volume of a sphere with radius r is 4/3 \u03c0 r 3 .\nWhat is the volume of a sphere with radius 5? Suppose the cover price of a book is $24.95, but bookstores get a\n40% discount. Shipping costs $3 for the first copy and 75 cents\nfor each additional copy. What is the total wholesale cost for\n60 copies? If I leave my house at 6:52 am and run 1 mile at an easy pace\n(8:15 per mile), then 3 miles at tempo (7:12 per mile) and 1 mile at\neasy pace again, what time do I get home for breakfast? Buy this book at Amazon.com\n\n#### Contribute\n\nIf you would like to make a contribution to support my books,\nyou can use the button below and pay with PayPal.  Thank you!\nPay what you want:\nSmall $1.00 USD\nMedium $5.00 USD\nLarge $10.00 USD\nX-Large $20.00 USD\nXX-Large $50.00 USD\nAre you using one of our books in a class? We'd like to know\nabout it.  Please consider filling out this short survey . Think DSP Think Java Think Bayes Think Python 2e Think Stats 2e Think Complexity",
      "difficulty": "intro",
      "doc_id": "doc-chapter-2-variables-expressions-and-statements-021d779cec",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-NC 3.0",
        "source_file": "data/corpus_raw/scraped/thinkpython2_html_thinkpython2003_html_3c07d8.json",
        "url": "https://greenteapress.com/thinkpython2/html/thinkpython2003.html"
      },
      "title": "Chapter\u00a02\u00a0\u00a0Variables, expressions and statements",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "conditionals",
        "control_flow",
        "recursion"
      ],
      "content": "Buy this book at Amazon.com Chapter\u00a03\u00a0\u00a0Functions In the context of programming, a function is a named sequence of\nstatements that performs a computation. When you define a function,\nyou specify the name and the sequence of statements. Later, you can\n\u201ccall\u201d the function by name. 3.1\u00a0\u00a0Function calls We have already seen one example of a function call : >>> type(42)\n<class 'int'> The name of the function is type . The expression in parentheses\nis called the argument of the function. The result, for this\nfunction, is the type of the argument. It is common to say that a function \u201ctakes\u201d an argument and \u201creturns\u201d\na result. The result is also called the return value . Python provides functions that convert values\nfrom one type to another. The int function takes any value and\nconverts it to an integer, if it can, or complains otherwise: >>> int('32')\n32\n>>> int('Hello')\nValueError: invalid literal for int(): Hello int can convert floating-point values to integers, but it\ndoesn\u2019t round off; it chops off the fraction part: >>> int(3.99999)\n3\n>>> int(-2.3)\n-2 float converts integers and strings to floating-point\nnumbers: >>> float(32)\n32.0\n>>> float('3.14159')\n3.14159 Finally, str converts its argument to a string: >>> str(32)\n'32'\n>>> str(3.14159)\n'3.14159' 3.2\u00a0\u00a0Math functions Python has a math module that provides most of the familiar\nmathematical functions. A module is a file that contains a\ncollection of related functions. Before we can use the functions in a module, we have to import it with\nan import statement : >>> import math This statement creates a module object named math. If\nyou display the module object, you get some information about it: >>> math\n<module 'math' (built-in)> The module object contains the functions and variables defined in the\nmodule. To access one of the functions, you have to specify the name\nof the module and the name of the function, separated by a dot (also\nknown as a period). This format is called dot notation . >>> ratio = signal_power / noise_power\n>>> decibels = 10 * math.log10(ratio)\n\n>>> radians = 0.7\n>>> height = math.sin(radians) The first example uses math.log10 to compute\na signal-to-noise ratio in decibels (assuming that signal_power and noise_power are defined). The math module also provides log ,\nwhich computes logarithms base e . The second example finds the sine of radians . The variable name radians is a hint that sin and the other trigonometric\nfunctions ( cos , tan , etc.) take arguments in radians. To\nconvert from degrees to radians, divide by 180 and multiply by\n\u03c0: >>> degrees = 45\n>>> radians = degrees / 180.0 * math.pi\n>>> math.sin(radians)\n0.707106781187 The expression math.pi gets the variable pi from the math\nmodule. Its value is a floating-point approximation\nof \u03c0, accurate to about 15 digits. If you know\ntrigonometry, you can check the previous result by comparing it to\nthe square root of two, divided by two: >>> math.sqrt(2) / 2.0\n0.707106781187 3.3\u00a0\u00a0Composition So far, we have looked at the elements of a program\u2014variables,\nexpressions, and statements\u2014in isolation, without talking about how to\ncombine them. One of the most useful features of programming languages is their\nability to take small building blocks and compose them. For\nexample, the argument of a function can be any kind of expression,\nincluding arithmetic operators: x = math.sin(degrees / 360.0 * 2 * math.pi) And even function calls: x = math.exp(math.log(x+1)) Almost anywhere you can put a value, you can put an arbitrary\nexpression, with one exception: the left side of an assignment\nstatement has to be a variable name. Any other expression on the left\nside is a syntax error (we will see exceptions to this rule\nlater). >>> minutes = hours * 60                 # right\n>>> hours * 60 = minutes                 # wrong!\nSyntaxError: can't assign to operator 3.4\u00a0\u00a0Adding new functions So far, we have only been using the functions that come with Python,\nbut it is also possible to add new functions.\nA function definition specifies the name of a new function and\nthe sequence of statements that run when the function is called. Here is an example: def print_lyrics():\n    print(\"I'm a lumberjack, and I'm okay.\")\n    print(\"I sleep all night and I work all day.\") def is a keyword that indicates that this is a function\ndefinition. The name of the function is print_lyrics . The\nrules for function names are the same as for variable names: letters,\nnumbers and underscore are legal, but the first character\ncan\u2019t be a number. You can\u2019t use a keyword as the name of a function,\nand you should avoid having a variable and a function with the same\nname. The empty parentheses after the name indicate that this function\ndoesn\u2019t take any arguments. The first line of the function definition is called the header ;\nthe rest is called the body . The header has to end with a colon\nand the body has to be indented. By convention, indentation is\nalways four spaces. The body can contain\nany number of statements. The strings in the print statements are enclosed in double\nquotes. Single quotes and double quotes do the same thing;\nmost people use single quotes except in cases like this where\na single quote (which is also an apostrophe) appears in the string. All quotation marks (single and double)\nmust be \u201cstraight quotes\u201d, usually\nlocated next to Enter on the keyboard. \u201cCurly quotes\u201d, like\nthe ones in this sentence, are not legal in Python. If you type a function definition in interactive mode, the interpreter\nprints dots ( ... ) to let you know that the definition\nisn\u2019t complete: >>> def print_lyrics():\n...     print(\"I'm a lumberjack, and I'm okay.\")\n...     print(\"I sleep all night and I work all day.\")\n... To end the function, you have to enter an empty line. Defining a function creates a function object , which\nhas type function : >>> print(print_lyrics)\n<function print_lyrics at 0xb7e99e9c>\n>>> type(print_lyrics)\n<class 'function'> The syntax for calling the new function is the same as\nfor built-in functions: >>> print_lyrics()\nI'm a lumberjack, and I'm okay.\nI sleep all night and I work all day. Once you have defined a function, you can use it inside another\nfunction. For example, to repeat the previous refrain, we could write\na function called repeat_lyrics : def repeat_lyrics():\n    print_lyrics()\n    print_lyrics() And then call repeat_lyrics : >>> repeat_lyrics()\nI'm a lumberjack, and I'm okay.\nI sleep all night and I work all day.\nI'm a lumberjack, and I'm okay.\nI sleep all night and I work all day. But that\u2019s not really how the song goes. 3.5\u00a0\u00a0Definitions and uses Pulling together the code fragments from the previous section, the\nwhole program looks like this: def print_lyrics():\n    print(\"I'm a lumberjack, and I'm okay.\")\n    print(\"I sleep all night and I work all day.\")\n\ndef repeat_lyrics():\n    print_lyrics()\n    print_lyrics()\n\nrepeat_lyrics() This program contains two function definitions: print_lyrics and repeat_lyrics . Function definitions get executed just like other\nstatements, but the effect is to create function objects. The statements\ninside the function do not run until the function is called, and\nthe function definition generates no output. As you might expect, you have to create a function before you can\nrun it. In other words, the function definition has to run\nbefore the function gets called. As an exercise, move the last line of this program\nto the top, so the function call appears before the definitions. Run\nthe program and see what error\nmessage you get. Now move the function call back to the bottom\nand move the definition of print_lyrics after the definition of repeat_lyrics . What happens when you run this program? 3.6\u00a0\u00a0Flow of execution To ensure that a function is defined before its first use,\nyou have to know the order statements run in, which is\ncalled the flow of execution . Execution always begins at the first statement of the program.\nStatements are run one at a time, in order from top to bottom. Function definitions do not alter the flow of execution of the\nprogram, but remember that statements inside the function don\u2019t\nrun until the function is called. A function call is like a detour in the flow of execution. Instead of\ngoing to the next statement, the flow jumps to the body of\nthe function, runs the statements there, and then comes back\nto pick up where it left off. That sounds simple enough, until you remember that one function can\ncall another. While in the middle of one function, the program might\nhave to run the statements in another function. Then, while\nrunning that new function, the program might have to run yet\nanother function! Fortunately, Python is good at keeping track of where it is, so each\ntime a function completes, the program picks up where it left off in\nthe function that called it. When it gets to the end of the program,\nit terminates. In summary, when you read a program, you\ndon\u2019t always want to read from top to bottom. Sometimes it makes\nmore sense if you follow the flow of execution. 3.7\u00a0\u00a0Parameters and arguments Some of the functions we have seen require arguments. For\nexample, when you call math.sin you pass a number\nas an argument. Some functions take more than one argument: math.pow takes two, the base and the exponent. Inside the function, the arguments are assigned to\nvariables called parameters . Here is a definition for\na function that takes an argument: def print_twice(bruce):\n    print(bruce)\n    print(bruce) This function assigns the argument to a parameter\nnamed bruce . When the function is called, it prints the value of\nthe parameter (whatever it is) twice. This function works with any value that can be printed. >>> print_twice('Spam')\nSpam\nSpam\n>>> print_twice(42)\n42\n42\n>>> print_twice(math.pi)\n3.14159265359\n3.14159265359 The same rules of composition that apply to built-in functions also\napply to programmer-defined functions, so we can use any kind of expression\nas an argument for print_twice : >>> print_twice('Spam '*4)\nSpam Spam Spam Spam\nSpam Spam Spam Spam\n>>> print_twice(math.cos(math.pi))\n-1.0\n-1.0 The argument is evaluated before the function is called, so\nin the examples the expressions 'Spam '*4 and math.cos(math.pi) are only evaluated once. You can also use a variable as an argument: >>> michael = 'Eric, the half a bee.'\n>>> print_twice(michael)\nEric, the half a bee.\nEric, the half a bee. The name of the variable we pass as an argument ( michael ) has\nnothing to do with the name of the parameter ( bruce ). It\ndoesn\u2019t matter what the value was called back home (in the caller);\nhere in print_twice , we call everybody bruce . 3.8\u00a0\u00a0Variables and parameters are local When you create a variable inside a function, it is local ,\nwhich means that it only\nexists inside the function. For example: def cat_twice(part1, part2):\n    cat = part1 + part2\n    print_twice(cat) This function takes two arguments, concatenates them, and prints\nthe result twice. Here is an example that uses it: >>> line1 = 'Bing tiddle '\n>>> line2 = 'tiddle bang.'\n>>> cat_twice(line1, line2)\nBing tiddle tiddle bang.\nBing tiddle tiddle bang. When cat_twice terminates, the variable cat is destroyed. If we try to print it, we get an exception: >>> print(cat)\nNameError: name 'cat' is not defined Parameters are also local.\nFor example, outside print_twice , there is no\nsuch thing as bruce . 3.9\u00a0\u00a0Stack diagrams To keep track of which variables can be used where, it is sometimes\nuseful to draw a stack diagram . Like state diagrams, stack\ndiagrams show the value of each variable, but they also show the\nfunction each variable belongs to. Each function is represented by a frame . A frame is a box with\nthe name of a function beside it and the parameters and variables of\nthe function inside it. The stack diagram for the previous example is\nshown in Figure 3.1 . Figure 3.1: Stack diagram. The frames are arranged in a stack that indicates which function\ncalled which, and so on. In this example, print_twice was called by cat_twice , and cat_twice was called by __main__ , which is a special name for the topmost frame. When\nyou create a variable outside of any function, it belongs to __main__ . Each parameter refers to the same value as its corresponding\nargument. So, part1 has the same value as line1 , part2 has the same value as line2 ,\nand bruce has the same value as cat . If an error occurs during a function call, Python prints the\nname of the function, the name of the function that called\nit, and the name of the function that called that , all the\nway back to __main__ . For example, if you try to access cat from within print_twice , you get a NameError : Traceback (innermost last):\n  File \"test.py\", line 13, in __main__\n    cat_twice(line1, line2)\n  File \"test.py\", line 5, in cat_twice\n    print_twice(cat)\n  File \"test.py\", line 9, in print_twice\n    print(cat)\nNameError: name 'cat' is not defined This list of functions is called a traceback . It tells you what\nprogram file the error occurred in, and what line, and what functions\nwere executing at the time. It also shows the line of code that\ncaused the error. The order of the functions in the traceback is the same as the\norder of the frames in the stack diagram. The function that is\ncurrently running is at the bottom. 3.10\u00a0\u00a0Fruitful functions and void functions Some of the functions we have used, such as the math functions, return\nresults; for lack of a better name, I call them fruitful\nfunctions . Other functions, like print_twice , perform an\naction but don\u2019t return a value. They are called void\nfunctions . When you call a fruitful function, you almost always\nwant to do something with the result; for example, you might\nassign it to a variable or use it as part of an expression: x = math.cos(radians)\ngolden = (math.sqrt(5) + 1) / 2 When you call a function in interactive mode, Python displays\nthe result: >>> math.sqrt(5)\n2.2360679774997898 But in a script, if you call a fruitful function all by itself,\nthe return value is lost forever! math.sqrt(5) This script computes the square root of 5, but since it doesn\u2019t store\nor display the result, it is not very useful. Void functions might display something on the screen or have some\nother effect, but they don\u2019t have a return value. If you\nassign the result to a variable, you get a special value called None . >>> result = print_twice('Bing')\nBing\nBing\n>>> print(result)\nNone The value None is not the same as the string 'None' .\nIt is a special value that has its own type: >>> type(None)\n<class 'NoneType'> The functions we have written so far are all void. We will start\nwriting fruitful functions in a few chapters. 3.11\u00a0\u00a0Why functions? It may not be clear why it is worth the trouble to divide\na program into functions. There are several reasons: Creating a new function gives you an opportunity to name a group\nof statements, which makes your program easier to read and debug. Functions can make a program smaller by eliminating repetitive\ncode. Later, if you make a change, you only have\nto make it in one place. Dividing a long program into functions allows you to debug the\nparts one at a time and then assemble them into a working whole. Well-designed functions are often useful for many programs.\nOnce you write and debug one, you can reuse it. 3.12\u00a0\u00a0Debugging One of the most important skills you will acquire is debugging.\nAlthough it can be frustrating, debugging is one of the most\nintellectually rich, challenging, and interesting parts of\nprogramming. In some ways debugging is like detective work. You are confronted\nwith clues and you have to infer the processes and events that led\nto the results you see. Debugging is also like an experimental science. Once you have an idea\nabout what is going wrong, you modify your program and try again. If\nyour hypothesis was correct, you can predict the result of the\nmodification, and you take a step closer to a working program. If\nyour hypothesis was wrong, you have to come up with a new one. As\nSherlock Holmes pointed out, \u201cWhen you have eliminated the\nimpossible, whatever remains, however improbable, must be the truth.\u201d\n(A. Conan Doyle, The Sign of Four ) For some people, programming and debugging are the same thing. That\nis, programming is the process of gradually debugging a program until\nit does what you want. The idea is that you should start with a\nworking program and make small modifications,\ndebugging them as you go. For example, Linux is an operating system that contains millions of\nlines of code, but it started out as a simple program Linus Torvalds\nused to explore the Intel 80386 chip. According to Larry Greenfield,\n\u201cOne of Linus\u2019s earlier projects was a program that would switch\nbetween printing AAAA and BBBB. This later evolved to Linux.\u201d\n( The Linux Users\u2019 Guide Beta Version 1). 3.13\u00a0\u00a0Glossary function: A named sequence of statements that performs some\nuseful operation. Functions may or may not take arguments and may or\nmay not produce a result. function definition: A statement that creates a new function,\nspecifying its name, parameters, and the statements it contains. function object: A value created by a function definition.\nThe name of the function is a variable that refers to a function\nobject. header: The first line of a function definition. body: The sequence of statements inside a function definition. parameter: A name used inside a function to refer to the value\npassed as an argument. function call: A statement that runs a function. It\nconsists of the function name followed by an argument list in\nparentheses. argument: A value provided to a function when the function is called.\nThis value is assigned to the corresponding parameter in the function. local variable: A variable defined inside a function. A local\nvariable can only be used inside its function. return value: The result of a function. If a function call\nis used as an expression, the return value is the value of\nthe expression. fruitful function: A function that returns a value. void function: A function that always returns None . None : A special value returned by void functions. module: A file that contains a\ncollection of related functions and other definitions. import statement: A statement that reads a module file and creates\na module object. module object: A value created by an import statement\nthat provides access to the values defined in a module. dot notation: The syntax for calling a function in another\nmodule by specifying the module name followed by a dot (period) and\nthe function name. composition: Using an expression as part of a larger expression,\nor a statement as part of a larger statement. flow of execution: The order statements run in. stack diagram: A graphical representation of a stack of functions,\ntheir variables, and the values they refer to. frame: A box in a stack diagram that represents a function call.\nIt contains the local variables and parameters of the function. traceback: A list of the functions that are executing,\nprinted when an exception occurs. 3.14\u00a0\u00a0Exercises Exercise\u00a01 Write a function named right_justify that takes a string\nnamed s as a parameter and prints the string with enough\nleading spaces so that the last letter of the string is in column 70\nof the display. >>> right_justify('monty')\n                                                                 monty Hint: Use string concatenation and repetition. Also,\nPython provides a built-in function called len that\nreturns the length of a string, so the value of len('monty') is 5. Exercise\u00a02 A function object is a value you can assign to a variable\nor pass as an argument. For example, do_twice is a function\nthat takes a function object as an argument and calls it twice: def do_twice(f):\n    f()\n    f() Here\u2019s an example that uses do_twice to call a function\nnamed print_spam twice. def print_spam():\n    print('spam')\n\ndo_twice(print_spam) Type this example into a script and test it. Modify do_twice so that it takes two arguments, a\nfunction object and a value, and calls the function twice,\npassing the value as an argument. Copy the definition of print_twice from earlier in this chapter to your script. Use the modified version of do_twice to call print_twice twice, passing 'spam' as an argument. Define a new function called do_four that takes a function object and a value\nand calls the function four times, passing the value\nas a parameter. There should be only\ntwo statements in the body of this function, not four. Solution: https://thinkpython.com/code/do_four.py . Exercise\u00a03 Note: This exercise should be\ndone using only the statements and other features we have learned so\nfar. Write a function that draws a grid like the following: + - - - - + - - - - +\n|         |         |\n|         |         |\n|         |         |\n|         |         |\n+ - - - - + - - - - +\n|         |         |\n|         |         |\n|         |         |\n|         |         |\n+ - - - - + - - - - + Hint: to print more than one value on a line, you can print\na comma-separated sequence of values: print('+', '-') By default, print advances to the next line, but you\ncan override that behavior and put a space at the end, like this: print('+', end=' ')\nprint('-') The output of these statements is '+ -' on the same line.\nThe output from the next print statement would begin on the next line. Write a function that draws a similar grid\nwith four rows and four columns. Solution: https://thinkpython.com/code/grid.py .\nCredit: This exercise is based on an exercise in Oualline, Practical C Programming, Third Edition , O\u2019Reilly Media, 1997. Buy this book at Amazon.com\n\n#### Contribute\n\nIf you would like to make a contribution to support my books,\nyou can use the button below and pay with PayPal.  Thank you!\nPay what you want:\nSmall $1.00 USD\nMedium $5.00 USD\nLarge $10.00 USD\nX-Large $20.00 USD\nXX-Large $50.00 USD\nAre you using one of our books in a class? We'd like to know\nabout it.  Please consider filling out this short survey . Think DSP Think Java Think Bayes Think Python 2e Think Stats 2e Think Complexity",
      "difficulty": "intro",
      "doc_id": "doc-chapter-3-functions-c49902cedc",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-NC 3.0",
        "source_file": "data/corpus_raw/scraped/thinkpython2_html_thinkpython2004_html_512493.json",
        "url": "https://greenteapress.com/thinkpython2/html/thinkpython2004.html"
      },
      "title": "Chapter\u00a03\u00a0\u00a0Functions",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "functions",
        "recursion",
        "return_values",
        "scope"
      ],
      "content": "Buy this book at Amazon.com Chapter\u00a04\u00a0\u00a0Case study: interface design This chapter presents a case study that demonstrates a process for\ndesigning functions that work together. It introduces the turtle module, which allows you to\ncreate images using turtle graphics. The turtle module is\nincluded in most Python installations, but if you are running Python\nusing PythonAnywhere, you won\u2019t be able to run the turtle examples (at\nleast you couldn\u2019t when I wrote this). If you have already installed Python on your computer, you should\nbe able to run the examples. Otherwise, now is a good time\nto install. I have posted instructions at http://tinyurl.com/thinkpython2e . Code examples from this chapter are available from https://thinkpython.com/code/polygon.py . 4.1\u00a0\u00a0The turtle module To check whether you have the turtle module, open the Python\ninterpreter and type >>> import turtle\n>>> bob = turtle.Turtle() When you run this code, it should create a new window\nwith small arrow that represents the turtle. Close the window. Create a file named mypolygon.py and type in the following\ncode: import turtle\nbob = turtle.Turtle()\nprint(bob)\nturtle.mainloop() The turtle module (with a lowercase \u2019t\u2019) provides a function\ncalled Turtle (with an uppercase \u2019T\u2019) that creates a Turtle\nobject, which we assign to a variable named bob .\nPrinting bob displays something like: <turtle.Turtle object at 0xb7bfbf4c> This means that bob refers to an object with type Turtle as defined in module turtle . mainloop tells the window to wait for the user\nto do something, although in this case there\u2019s not much for\nthe user to do except close the window. Once you create a Turtle, you can call a method to move it\naround the window. A method is similar to a function, but it\nuses slightly different syntax. For example, to move the turtle\nforward: bob.fd(100) The method, fd , is associated with the turtle\nobject we\u2019re calling bob .\nCalling a method is like making a request: you are asking bob to move forward. The argument of fd is a distance in pixels, so the actual\nsize depends on your display. Other methods you can call on a Turtle are bk to move\nbackward, lt for left turn, and rt right turn. The\nargument for lt and rt is an angle in degrees. Also, each Turtle is holding a pen, which is\neither down or up; if the pen is down, the Turtle leaves\na trail when it moves. The methods pu and pd stand for \u201cpen up\u201d and \u201cpen down\u201d. To draw a right angle, add these lines to the program\n(after creating bob and before calling mainloop ): bob.fd(100)\nbob.lt(90)\nbob.fd(100) When you run this program, you should see bob move east and then\nnorth, leaving two line segments behind. Now modify the program to draw a square. Don\u2019t go on until\nyou\u2019ve got it working! 4.2\u00a0\u00a0Simple repetition Chances are you wrote something like this: bob.fd(100)\nbob.lt(90)\n\nbob.fd(100)\nbob.lt(90)\n\nbob.fd(100)\nbob.lt(90)\n\nbob.fd(100) We can do the same thing more concisely with a for statement.\nAdd this example to mypolygon.py and run it again: for i in range(4):\n    print('Hello!') You should see something like this: Hello!\nHello!\nHello!\nHello! This is the simplest use of the for statement; we will see\nmore later. But that should be enough to let you rewrite your\nsquare-drawing program. Don\u2019t go on until you do. Here is a for statement that draws a square: for i in range(4):\n    bob.fd(100)\n    bob.lt(90) The syntax of a for statement is similar to a function\ndefinition. It has a header that ends with a colon and an indented\nbody. The body can contain any number of statements. A for statement is also called a loop because\nthe flow of execution runs through the body and then loops back\nto the top. In this case, it runs the body four times. This version is actually a little different from the previous\nsquare-drawing code because it makes another turn after\ndrawing the last side of the square. The extra turn takes\nmore time, but it simplifies the code if we do the same thing\nevery time through the loop. This version also has the effect\nof leaving the turtle back in the starting position, facing in\nthe starting direction. 4.3\u00a0\u00a0Exercises The following is a series of exercises using the turtle module. They\nare meant to be fun, but they have a point, too. While you are\nworking on them, think about what the point is. The following sections have solutions to the exercises, so\ndon\u2019t look until you have finished (or at least tried). Write a function called square that takes a parameter\nnamed t , which is a turtle. It should use the turtle to draw\na square. Write a function call that passes bob as an argument to square , and then run the program again. Add another parameter, named length , to square .\nModify the body so length of the sides is length , and then\nmodify the function call to provide a second argument. Run the\nprogram again. Test your program with a range of values for length . Make a copy of square and change the name to polygon . Add another parameter named n and modify the body\nso it draws an n-sided regular polygon. Hint: The exterior angles\nof an n-sided regular polygon are 360/ n degrees. Write a function called circle that takes a turtle, t , and radius, r , as parameters and that draws an\napproximate circle by calling polygon with an appropriate\nlength and number of sides. Test your function with a range of values\nof r . Hint: figure out the circumference of the circle and make sure that length * n = circumference . Make a more general version of circle called arc that takes an additional parameter angle , which determines\nwhat fraction of a circle to draw. angle is in units of\ndegrees, so when angle=360 , arc should draw a complete\ncircle. 4.4\u00a0\u00a0Encapsulation The first exercise asks you to put your square-drawing code\ninto a function definition and then call the function, passing\nthe turtle as a parameter. Here is a solution: def square(t):\n    for i in range(4):\n        t.fd(100)\n        t.lt(90)\n\nsquare(bob) The innermost statements, fd and lt are indented twice to\nshow that they are inside the for loop, which is inside the\nfunction definition. The next line, square(bob) , is flush with\nthe left margin, which indicates the end of both the for loop\nand the function definition. Inside the function, t refers to the same turtle bob , so t.lt(90) has the same effect as bob.lt(90) . In that\ncase, why not\ncall the parameter bob ? The idea is that t can be any\nturtle, not just bob , so you could create a second turtle and\npass it as an argument to square : alice = turtle.Turtle()\nsquare(alice) Wrapping a piece of code up in a function is called encapsulation . One of the benefits of encapsulation is that it\nattaches a name to the code, which serves as a kind of documentation.\nAnother advantage is that if you re-use the code, it is more concise\nto call a function twice than to copy and paste the body! 4.5\u00a0\u00a0Generalization The next step is to add a length parameter to square .\nHere is a solution: def square(t, length):\n    for i in range(4):\n        t.fd(length)\n        t.lt(90)\n\nsquare(bob, 100) Adding a parameter to a function is called generalization because it makes the function more general: in the previous\nversion, the square is always the same size; in this version\nit can be any size. The next step is also a generalization. Instead of drawing\nsquares, polygon draws regular polygons with any number of\nsides. Here is a solution: def polygon(t, n, length):\n    angle = 360 / n\n    for i in range(n):\n        t.fd(length)\n        t.lt(angle)\n\npolygon(bob, 7, 70) This example draws a 7-sided polygon with side length 70. If you are using Python 2, the value of angle might be off\nbecause of integer division. A simple solution is to compute angle = 360.0 / n . Because the numerator is a floating-point\nnumber, the result is floating point. When a function has more than a few numeric arguments, it is easy to\nforget what they are, or what order they should be in. In that case\nit is often a good idea to include the names of the parameters in the\nargument list: polygon(bob, n=7, length=70) These are called keyword arguments because they include\nthe parameter names as \u201ckeywords\u201d (not to be confused with\nPython keywords like while and def ). This syntax makes the program more readable. It is also a reminder\nabout how arguments and parameters work: when you call a function, the\narguments are assigned to the parameters. 4.6\u00a0\u00a0Interface design The next step is to write circle , which takes a radius, r , as a parameter. Here is a simple solution that uses polygon to draw a 50-sided polygon: import math\n\ndef circle(t, r):\n    circumference = 2 * math.pi * r\n    n = 50\n    length = circumference / n\n    polygon(t, n, length) The first line computes the circumference of a circle with radius r using the formula 2 \u03c0 r . Since we use math.pi , we\nhave to import math . By convention, import statements\nare usually at the beginning of the script. n is the number of line segments in our approximation of a circle,\nso length is the length of each segment. Thus, polygon draws a 50-sided polygon that approximates a circle with radius r . One limitation of this solution is that n is a constant, which\nmeans that for very big circles, the line segments are too long, and\nfor small circles, we waste time drawing very small segments. One\nsolution would be to generalize the function by taking n as\na parameter. This would give the user (whoever calls circle )\nmore control, but the interface would be less clean. The interface of a function is a summary of how it is used: what\nare the parameters? What does the function do? And what is the return\nvalue? An interface is \u201cclean\u201d if it allows the caller to do\nwhat they want without dealing with unnecessary details. In this example, r belongs in the interface because it\nspecifies the circle to be drawn. n is less appropriate\nbecause it pertains to the details of how the circle should\nbe rendered. Rather than clutter up the interface, it is better\nto choose an appropriate value of n depending on circumference : def circle(t, r):\n    circumference = 2 * math.pi * r\n    n = int(circumference / 3) + 3\n    length = circumference / n\n    polygon(t, n, length) Now the number of segments is an integer near circumference/3 ,\nso the length of each segment is approximately 3, which is small\nenough that the circles look good, but big enough to be efficient,\nand acceptable for any size circle. Adding 3 to n guarantees that the polygon has at least 3 sides. 4.7\u00a0\u00a0Refactoring When I wrote circle , I was able to re-use polygon because a many-sided polygon is a good approximation of a circle.\nBut arc is not as cooperative; we can\u2019t use polygon or circle to draw an arc. One alternative is to start with a copy\nof polygon and transform it into arc . The result\nmight look like this: def arc(t, r, angle):\n    arc_length = 2 * math.pi * r * angle / 360\n    n = int(arc_length / 3) + 1\n    step_length = arc_length / n\n    step_angle = angle / n\n\n    for i in range(n):\n        t.fd(step_length)\n        t.lt(step_angle) The second half of this function looks like polygon , but we\ncan\u2019t re-use polygon without changing the interface. We could\ngeneralize polygon to take an angle as a third argument,\nbut then polygon would no longer be an appropriate name!\nInstead, let\u2019s call the more general function polyline : def polyline(t, n, length, angle):\n    for i in range(n):\n        t.fd(length)\n        t.lt(angle) Now we can rewrite polygon and arc to use polyline : def polygon(t, n, length):\n    angle = 360.0 / n\n    polyline(t, n, length, angle)\n\ndef arc(t, r, angle):\n    arc_length = 2 * math.pi * r * angle / 360\n    n = int(arc_length / 3) + 1\n    step_length = arc_length / n\n    step_angle = float(angle) / n\n    polyline(t, n, step_length, step_angle) Finally, we can rewrite circle to use arc : def circle(t, r):\n    arc(t, r, 360) This process\u2014rearranging a program to improve\ninterfaces and facilitate code re-use\u2014is called refactoring .\nIn this case, we noticed that there was similar code in arc and polygon , so we \u201cfactored it out\u201d into polyline . If we had planned ahead, we might have written polyline first\nand avoided refactoring, but often you don\u2019t know enough at the\nbeginning of a project to design all the interfaces. Once you start\ncoding, you understand the problem better. Sometimes refactoring is a\nsign that you have learned something. 4.8\u00a0\u00a0A development plan A development plan is a process for writing programs. The\nprocess we used in this case study is \u201cencapsulation and\ngeneralization\u201d. The steps of this process are: Start by writing a small program with no function definitions. Once you get the program working, identify a coherent piece of\nit, encapsulate the piece in a function and give it a name. Generalize the function by adding appropriate parameters. Repeat steps 1\u20133 until you have a set of working functions.\nCopy and paste working code to avoid retyping (and re-debugging). Look for opportunities to improve the program by refactoring.\nFor example, if you have similar code in several places, consider\nfactoring it into an appropriately general function. This process has some drawbacks\u2014we will see alternatives later\u2014but\nit can be useful if you don\u2019t know ahead of time how to divide the\nprogram into functions. This approach lets you design as you go\nalong. 4.9\u00a0\u00a0docstring A docstring is a string at the beginning of a function that\nexplains the interface (\u201cdoc\u201d is short for \u201cdocumentation\u201d). Here\nis an example: def polyline(t, n, length, angle):\n    \"\"\"Draws n line segments with the given length and\n    angle (in degrees) between them.  t is a turtle.\n    \"\"\"\n    for i in range(n):\n        t.fd(length)\n        t.lt(angle) By convention, all docstrings are triple-quoted strings, also known\nas multiline strings because the triple quotes allow the string\nto span more than one line. It is terse, but it contains the essential information\nsomeone would need to use this function. It explains concisely what\nthe function does (without getting into the details of how it does\nit). It explains what effect each parameter has on the behavior of\nthe function and what type each parameter should be (if it is not\nobvious). Writing this kind of documentation is an important part of interface\ndesign. A well-designed interface should be simple to explain;\nif you have a hard time explaining one of your functions,\nmaybe the interface could be improved. 4.10\u00a0\u00a0Debugging An interface is like a contract between a function and a caller.\nThe caller agrees to provide certain parameters and the function\nagrees to do certain work. For example, polyline requires four arguments: t has to be\na Turtle; n has to be an\ninteger; length should be a positive number; and angle has to be a number, which is understood to be in degrees. These requirements are called preconditions because they\nare supposed to be true before the function starts executing.\nConversely, conditions at the end of the function are postconditions . Postconditions include the intended\neffect of the function (like drawing line segments) and any\nside effects (like moving the Turtle or making other changes). Preconditions are the responsibility of the caller. If the caller\nviolates a (properly documented!) precondition and the function\ndoesn\u2019t work correctly, the bug is in the caller, not the function. If the preconditions are satisfied and the postconditions are\nnot, the bug is in the function. If your pre- and postconditions\nare clear, they can help with debugging. 4.11\u00a0\u00a0Glossary method: A function that is associated with an object and called\nusing dot notation. loop: A part of a program that can run repeatedly. encapsulation: The process of transforming a sequence of\nstatements into a function definition. generalization: The process of replacing something\nunnecessarily specific (like a number) with something appropriately\ngeneral (like a variable or parameter). keyword argument: An argument that includes the name of\nthe parameter as a \u201ckeyword\u201d. interface: A description of how to use a function, including\nthe name and descriptions of the arguments and return value. refactoring: The process of modifying a working program to\nimprove function interfaces and other qualities of the code. development plan: A process for writing programs. docstring: A string that appears at the top of a function\ndefinition to document the function\u2019s interface. precondition: A requirement that should be satisfied by\nthe caller before a function starts. postcondition: A requirement that should be satisfied by\nthe function before it ends. 4.12\u00a0\u00a0Exercises Exercise\u00a01 Download the code in this chapter from https://thinkpython.com/code/polygon.py . Draw a stack diagram that shows the state of the program\nwhile executing circle(bob, radius) . You can do the\narithmetic by hand or add print statements to the code. The version of arc in Section 4.7 is not\nvery accurate because the linear approximation of the\ncircle is always outside the true circle. As a result,\nthe Turtle ends up a few pixels away from the correct\ndestination. My solution shows a way to reduce\nthe effect of this error. Read the code and see if it makes\nsense to you. If you draw a diagram, you might see how it works. Figure 4.1: Turtle flowers. Exercise\u00a02 Write an appropriately general set of functions that\ncan draw flowers as in Figure 4.1 . Solution: https://thinkpython.com/code/flower.py ,\nalso requires https://thinkpython.com/code/polygon.py . Figure 4.2: Turtle pies. Exercise\u00a03 Write an appropriately general set of functions that\ncan draw shapes as in Figure 4.2 . Solution: https://thinkpython.com/code/pie.py . Exercise\u00a04 The letters of the alphabet can be constructed from a moderate number\nof basic elements, like vertical and horizontal lines and a few\ncurves. Design an alphabet that can be drawn with a minimal\nnumber of basic elements and then write functions that draw the letters. You should write one function for each letter, with names draw_a , draw_b , etc., and put your functions\nin a file named letters.py . You can download a\n\u201cturtle typewriter\u201d from https://thinkpython.com/code/typewriter.py to help you test your code. You can get a solution from https://thinkpython.com/code/letters.py ;\nit also requires https://thinkpython.com/code/polygon.py . Exercise\u00a05 Read about spirals at http://en.wikipedia.org/wiki/Spiral ; then\nwrite a program that draws an Archimedian spiral (or one of the other\nkinds). Solution: https://thinkpython.com/code/spiral.py . Buy this book at Amazon.com\n\n#### Contribute\n\nIf you would like to make a contribution to support my books,\nyou can use the button below and pay with PayPal.  Thank you!\nPay what you want:\nSmall $1.00 USD\nMedium $5.00 USD\nLarge $10.00 USD\nX-Large $20.00 USD\nXX-Large $50.00 USD\nAre you using one of our books in a class? We'd like to know\nabout it.  Please consider filling out this short survey . Think DSP Think Java Think Bayes Think Python 2e Think Stats 2e Think Complexity",
      "difficulty": "intro",
      "doc_id": "doc-chapter-4-case-study-interface-design-3b8d3e6d00",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-NC 3.0",
        "source_file": "data/corpus_raw/thinkpython2_html_thinkpython2005_html_82fc01.json",
        "url": "https://greenteapress.com/thinkpython2/html/thinkpython2005.html"
      },
      "title": "Chapter\u00a04\u00a0\u00a0Case study: interface design",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "iteration",
        "loops",
        "strings"
      ],
      "content": "Buy this book at Amazon.com Chapter\u00a05\u00a0\u00a0Conditionals and recursion The main topic of this chapter is the if statement, which\nexecutes different code depending on the state of the program.\nBut first I want to introduce two new operators: floor division\nand modulus. 5.1\u00a0\u00a0Floor division and modulus The floor division operator, // , divides\ntwo numbers and rounds down to an integer. For example, suppose the\nrun time of a movie is 105 minutes. You might want to know how\nlong that is in hours. Conventional division\nreturns a floating-point number: >>> minutes = 105\n>>> minutes / 60\n1.75 But we don\u2019t normally write hours with decimal points. Floor\ndivision returns the integer number of hours, rounding down: >>> minutes = 105\n>>> hours = minutes // 60\n>>> hours\n1 To get the remainder, you could subtract off one hour in minutes: >>> remainder = minutes - hours * 60\n>>> remainder\n45 An alternative is to use the modulus operator , % , which\ndivides two numbers and returns the remainder. >>> remainder = minutes % 60\n>>> remainder\n45 The modulus operator is more useful than it seems. For\nexample, you can check whether one number is divisible by another\u2014if x % y is zero, then x is divisible by y . Also, you can extract the right-most digit\nor digits from a number. For example, x % 10 yields the\nright-most digit of x (in base 10). Similarly x % 100 yields the last two digits. If you are using Python 2, division works differently. The\ndivision operator, / , performs floor division if both\noperands are integers, and floating-point division if either\noperand is a float . 5.2\u00a0\u00a0Boolean expressions A boolean expression is an expression that is either true\nor false. The following examples use the\noperator == , which compares two operands and produces True if they are equal and False otherwise: >>> 5 == 5\nTrue\n>>> 5 == 6\nFalse True and False are special\nvalues that belong to the type bool ; they are not strings: >>> type(True)\n<class 'bool'>\n>>> type(False)\n<class 'bool'> The == operator is one of the relational operators ; the\nothers are: x != y               # x is not equal to y\n      x > y                # x is greater than y\n      x < y                # x is less than y\n      x >= y               # x is greater than or equal to y\n      x <= y               # x is less than or equal to y Although these operations are probably familiar to you, the Python\nsymbols are different from the mathematical symbols. A common error\nis to use a single equal sign ( = ) instead of a double equal sign\n( == ). Remember that = is an assignment operator and == is a relational operator. There is no such thing as =< or => . 5.3\u00a0\u00a0Logical operators There are three logical operators : and , or , and not . The semantics (meaning) of these operators is\nsimilar to their meaning in English. For example, x > 0 and x < 10 is true only if x is greater than 0 and less than 10. n%2 == 0 or n%3 == 0 is true if either or both of the\nconditions is true, that is, if the number is divisible by 2 or 3. Finally, the not operator negates a boolean\nexpression, so not (x > y) is true if x > y is false,\nthat is, if x is less than or equal to y . Strictly speaking, the operands of the logical operators should be\nboolean expressions, but Python is not very strict.\nAny nonzero number is interpreted as True : >>> 42 and True\nTrue This flexibility can be useful, but there are some subtleties to\nit that might be confusing. You might want to avoid it (unless\nyou know what you are doing). 5.4\u00a0\u00a0Conditional execution In order to write useful programs, we almost always need the ability\nto check conditions and change the behavior of the program\naccordingly. Conditional statements give us this ability. The\nsimplest form is the if statement: if x > 0:\n    print('x is positive') The boolean expression after if is\ncalled the condition . If it is true, the indented\nstatement runs. If not, nothing happens. if statements have the same structure as function definitions:\na header followed by an indented body. Statements like this are\ncalled compound statements . There is no limit on the number of statements that can appear in\nthe body, but there has to be at least one.\nOccasionally, it is useful to have a body with no statements (usually\nas a place keeper for code you haven\u2019t written yet). In that\ncase, you can use the pass statement, which does nothing. if x < 0:\n    pass          # TODO: need to handle negative values! 5.5\u00a0\u00a0Alternative execution A second form of the if statement is \u201calternative execution\u201d,\nin which there are two possibilities and the condition determines\nwhich one runs. The syntax looks like this: if x % 2 == 0:\n    print('x is even')\nelse:\n    print('x is odd') If the remainder when x is divided by 2 is 0, then we know that x is even, and the program displays an appropriate message. If\nthe condition is false, the second set of statements runs.\nSince the condition must be true or false, exactly one of the\nalternatives will run. The alternatives are called branches , because they are branches in the flow of execution. 5.6\u00a0\u00a0Chained conditionals Sometimes there are more than two possibilities and we need more than\ntwo branches. One way to express a computation like that is a chained conditional : if x < y:\n    print('x is less than y')\nelif x > y:\n    print('x is greater than y')\nelse:\n    print('x and y are equal') elif is an abbreviation of \u201celse if\u201d. Again, exactly one\nbranch will run. There is no limit on the number of elif statements. If there is an else clause, it has to be\nat the end, but there doesn\u2019t have to be one. if choice == 'a':\n    draw_a()\nelif choice == 'b':\n    draw_b()\nelif choice == 'c':\n    draw_c() Each condition is checked in order. If the first is false,\nthe next is checked, and so on. If one of them is\ntrue, the corresponding branch runs and the statement\nends. Even if more than one condition is true, only the\nfirst true branch runs. 5.7\u00a0\u00a0Nested conditionals One conditional can also be nested within another. We could have\nwritten the example in the previous section like this: if x == y:\n    print('x and y are equal')\nelse:\n    if x < y:\n        print('x is less than y')\n    else:\n        print('x is greater than y') The outer conditional contains two branches. The\nfirst branch contains a simple statement. The second branch\ncontains another if statement, which has two branches of its\nown. Those two branches are both simple statements,\nalthough they could have been conditional statements as well. Although the indentation of the statements makes the structure\napparent, nested conditionals become difficult to read very\nquickly. It is a good idea to avoid them when you can. Logical operators often provide a way to simplify nested conditional\nstatements. For example, we can rewrite the following code using a\nsingle conditional: if 0 < x:\n    if x < 10:\n        print('x is a positive single-digit number.') The print statement runs only if we make it past both\nconditionals, so we can get the same effect with the and operator: if 0 < x and x < 10:\n    print('x is a positive single-digit number.') For this kind of condition, Python provides a more concise option: if 0 < x < 10:\n    print('x is a positive single-digit number.') 5.8\u00a0\u00a0Recursion It is legal for one function to call another;\nit is also legal for a function to call itself. It may not be obvious\nwhy that is a good thing, but it turns out to be one of the most\nmagical things a program can do.\nFor example, look at the following function: def countdown(n):\n    if n <= 0:\n        print('Blastoff!')\n    else:\n        print(n)\n        countdown(n-1) If n is 0 or negative, it outputs the word, \u201cBlastoff!\u201d\nOtherwise, it outputs n and then calls a function named countdown \u2014itself\u2014passing n-1 as an argument. What happens if we call this function like this? >>> countdown(3) The execution of countdown begins with n=3 , and since n is greater than 0, it outputs the value 3, and then calls itself... The execution of countdown begins with n=2 , and since n is greater than 0, it outputs the value 2, and then calls itself... The execution of countdown begins with n=1 , and since n is greater than 0, it outputs the value 1, and then calls itself... The execution of countdown begins with n=0 , and since n is not greater than 0, it outputs the word, \u201cBlastoff!\u201d and then\nreturns. The countdown that got n=1 returns. The countdown that got n=2 returns. The countdown that got n=3 returns. And then you\u2019re back in __main__ . So, the\ntotal output looks like this: 3\n2\n1\nBlastoff! A function that calls itself is recursive ; the process of\nexecuting it is called recursion . As another example, we can write a function that prints a\nstring n times. def print_n(s, n):\n    if n <= 0:\n        return\n    print(s)\n    print_n(s, n-1) If n <= 0 the return statement exits the function. The\nflow of execution immediately returns to the caller, and the remaining\nlines of the function don\u2019t run. The rest of the function is similar to countdown : it displays s and then calls itself to display s n \u22121 additional\ntimes. So the number of lines of output is 1 + (n - 1) , which\nadds up to n . For simple examples like this, it is probably easier to use a for loop. But we will see examples later that are hard to write\nwith a for loop and easy to write with recursion, so it is\ngood to start early. 5.9\u00a0\u00a0Stack diagrams for recursive functions In Section 3.9 , we used a stack diagram to represent\nthe state of a program during a function call. The same kind of\ndiagram can help interpret a recursive function. Every time a function gets called, Python creates a\nframe to contain the function\u2019s local variables and parameters.\nFor a recursive function, there might be more than one frame on the\nstack at the same time. Figure 5.1 shows a stack diagram for countdown called with n = 3 . Figure 5.1: Stack diagram. As usual, the top of the stack is the frame for __main__ .\nIt is empty because we did not create any variables in __main__ or pass any arguments to it. The four countdown frames have different values for the\nparameter n . The bottom of the stack, where n=0 , is\ncalled the base case . It does not make a recursive call, so\nthere are no more frames. As an exercise, draw a stack diagram for print_n called with s = 'Hello' and n=2 .\nThen write a function called do_n that takes a function\nobject and a number, n , as arguments, and that calls\nthe given function n times. 5.10\u00a0\u00a0Infinite recursion If a recursion never reaches a base case, it goes on making\nrecursive calls forever, and the program never terminates. This is\nknown as infinite recursion , and it is generally not\na good idea. Here is a minimal program with an infinite recursion: def recurse():\n    recurse() In most programming environments, a program with infinite recursion\ndoes not really run forever. Python reports an error\nmessage when the maximum recursion depth is reached: File \"<stdin>\", line 2, in recurse\n  File \"<stdin>\", line 2, in recurse\n  File \"<stdin>\", line 2, in recurse\n                  .\n                  .\n                  .\n  File \"<stdin>\", line 2, in recurse\nRuntimeError: Maximum recursion depth exceeded This traceback is a little bigger than the one we saw in the\nprevious chapter. When the error occurs, there are 1000 recurse frames on the stack! If you encounter an infinite recursion by accident, review\nyour function to confirm that there is a base case that does not\nmake a recursive call. And if there is a base case, check whether\nyou are guaranteed to reach it. 5.11\u00a0\u00a0Keyboard input The programs we have written so far accept no input from the user.\nThey just do the same thing every time. Python provides a built-in function called input that\nstops the program and\nwaits for the user to type something. When the user presses Return or Enter , the program resumes and input returns what the user typed as a string. In Python 2, the same\nfunction is called raw_input . >>> text = input()\nWhat are you waiting for?\n>>> text\n'What are you waiting for?' Before getting input from the user, it is a good idea to print a\nprompt telling the user what to type. input can take a\nprompt as an argument: >>> name = input('What...is your name?\\n')\nWhat...is your name?\nArthur, King of the Britons!\n>>> name\n'Arthur, King of the Britons!' The sequence \\n at the end of the prompt represents a newline , which is a special character that causes a line break.\nThat\u2019s why the user\u2019s input appears below the prompt. If you expect the user to type an integer, you can try to convert\nthe return value to int : >>> prompt = 'What...is the airspeed velocity of an unladen swallow?\\n'\n>>> speed = input(prompt)\nWhat...is the airspeed velocity of an unladen swallow?\n42\n>>> int(speed)\n42 But if the user types something other than a string of digits,\nyou get an error: >>> speed = input(prompt)\nWhat...is the airspeed velocity of an unladen swallow?\nWhat do you mean, an African or a European swallow?\n>>> int(speed)\nValueError: invalid literal for int() with base 10 We will see how to handle this kind of error later. 5.12\u00a0\u00a0Debugging When a syntax or runtime error occurs, the error message contains\na lot of information, but it can be overwhelming. The most\nuseful parts are usually: What kind of error it was, and Where it occurred. Syntax errors are usually easy to find, but there are a few\ngotchas. Whitespace errors can be tricky because spaces and\ntabs are invisible and we are used to ignoring them. >>> x = 5\n>>>  y = 6\n  File \"<stdin>\", line 1\n    y = 6\n    ^\nIndentationError: unexpected indent In this example, the problem is that the second line is indented by\none space. But the error message points to y , which is\nmisleading. In general, error messages indicate where the problem was\ndiscovered, but the actual error might be earlier in the code,\nsometimes on a previous line. The same is true of runtime errors. Suppose you are trying\nto compute a signal-to-noise ratio in decibels. The formula\nis SNR db = 10 log 10 ( P signal / P noise ). In Python,\nyou might write something like this: import math\nsignal_power = 9\nnoise_power = 10\nratio = signal_power // noise_power\ndecibels = 10 * math.log10(ratio)\nprint(decibels) When you run this program, you get an exception: Traceback (most recent call last):\n  File \"snr.py\", line 5, in ?\n    decibels = 10 * math.log10(ratio)\nValueError: math domain error The error message indicates line 5, but there is nothing\nwrong with that line. To find the real error, it might be\nuseful to print the value of ratio , which turns out to\nbe 0. The problem is in line 4, which uses floor division\ninstead of floating-point division. You should take the time to read error messages carefully, but don\u2019t\nassume that everything they say is correct. 5.13\u00a0\u00a0Glossary floor division: An operator, denoted // , that divides two\nnumbers and rounds down (toward negative infinity) to an integer. modulus operator: An operator, denoted with a percent sign\n( % ), that works on integers and returns the remainder when one\nnumber is divided by another. boolean expression: An expression whose value is either True or False . relational operator: One of the operators that compares\nits operands: == , != , > , < , >= , and <= . logical operator: One of the operators that combines boolean\nexpressions: and , or , and not . conditional statement: A statement that controls the flow of\nexecution depending on some condition. condition: The boolean expression in a conditional statement\nthat determines which branch runs. compound statement: A statement that consists of a header\nand a body. The header ends with a colon (:). The body is indented\nrelative to the header. branch: One of the alternative sequences of statements in\na conditional statement. chained conditional: A conditional statement with a series\nof alternative branches. nested conditional: A conditional statement that appears\nin one of the branches of another conditional statement. return statement: A statement that causes a function to\nend immediately and return to the caller. recursion: The process of calling the function that is\ncurrently executing. base case: A conditional branch in a\nrecursive function that does not make a recursive call. infinite recursion: A recursion that doesn\u2019t have a\nbase case, or never reaches it. Eventually, an infinite recursion\ncauses a runtime error. 5.14\u00a0\u00a0Exercises Exercise\u00a01 The time module provides a function, also named time , that\nreturns the current Greenwich Mean Time in \u201cthe epoch\u201d, which is\nan arbitrary time used as a reference point. On UNIX systems, the\nepoch is 1 January 1970. >>> import time\n>>> time.time()\n1437746094.5735958 Write a script that reads the current time and converts it to\na time of day in hours, minutes, and seconds, plus the number of\ndays since the epoch. Exercise\u00a02 Fermat\u2019s Last Theorem says that there are no positive integers a , b , and c such that a n + b n = c n for any values of n greater than 2. Write a function named check_fermat that takes four\nparameters\u2014 a , b , c and n \u2014and\nchecks to see if Fermat\u2019s theorem holds. If n is greater than 2 and a n + b n = c n the program should print, \u201cHoly smokes, Fermat was wrong!\u201d\nOtherwise the program should print, \u201cNo, that doesn\u2019t work.\u201d Write a function that prompts the user to input values\nfor a , b , c and n , converts them to\nintegers, and uses check_fermat to check whether they\nviolate Fermat\u2019s theorem. Exercise\u00a03 If you are given three sticks, you may or may not be able to arrange\nthem in a triangle. For example, if one of the sticks is 12 inches\nlong and the other two are one inch long, you will\nnot be able to get the short sticks to meet in the middle. For any\nthree lengths, there is a simple test to see if it is possible to form\na triangle: If any of the three lengths is greater than the sum of the other\ntwo, then you cannot form a triangle. Otherwise, you\ncan. (If the sum of two lengths equals the third, they form\nwhat is called a \u201cdegenerate\u201d triangle.) Write a function named is_triangle that takes three\nintegers as arguments, and that prints either \u201cYes\u201d or \u201cNo\u201d, depending\non whether you can or cannot form a triangle from sticks with the\ngiven lengths. Write a function that prompts the user to input three stick\nlengths, converts them to integers, and uses is_triangle to\ncheck whether sticks with the given lengths can form a triangle. Exercise\u00a04 What is the output of the following program?\nDraw a stack diagram that shows the state of the program\nwhen it prints the result. def recurse(n, s):\n    if n == 0:\n        print(s)\n    else:\n        recurse(n-1, n+s)\n\nrecurse(3, 0) What would happen if you called this function like this: recurse(-1, 0) ? Write a docstring that explains everything someone would need to\nknow in order to use this function (and nothing else). The following exercises use the turtle module, described in\nChapter 4 : Exercise\u00a05 Read the following function and see if you can figure out\nwhat it does (see the examples in Chapter 4 ). Then run it\nand see if you got it right. def draw(t, length, n):\n    if n == 0:\n        return\n    angle = 50\n    t.fd(length*n)\n    t.lt(angle)\n    draw(t, length, n-1)\n    t.rt(2*angle)\n    draw(t, length, n-1)\n    t.lt(angle)\n    t.bk(length*n) Figure 5.2: A Koch curve. Exercise\u00a06 The Koch curve is a fractal that looks something like\nFigure 5.2 . To draw a Koch curve with length x , all you\nhave to do is Draw a Koch curve with length x /3 . Turn left 60 degrees. Draw a Koch curve with length x /3 . Turn right 120 degrees. Draw a Koch curve with length x /3 . Turn left 60 degrees. Draw a Koch curve with length x /3 . The exception is if x is less than 3: in that case,\nyou can just draw a straight line with length x . Write a function called koch that takes a turtle and\na length as parameters, and that uses the turtle to draw a Koch\ncurve with the given length. Write a function called snowflake that draws three\nKoch curves to make the outline of a snowflake. Solution: https://thinkpython.com/code/koch.py . The Koch curve can be generalized in several ways. See http://en.wikipedia.org/wiki/Koch_snowflake for examples and\nimplement your favorite. Buy this book at Amazon.com\n\n#### Contribute\n\nIf you would like to make a contribution to support my books,\nyou can use the button below and pay with PayPal.  Thank you!\nPay what you want:\nSmall $1.00 USD\nMedium $5.00 USD\nLarge $10.00 USD\nX-Large $20.00 USD\nXX-Large $50.00 USD\nAre you using one of our books in a class? We'd like to know\nabout it.  Please consider filling out this short survey . Think DSP Think Java Think Bayes Think Python 2e Think Stats 2e Think Complexity",
      "difficulty": "intro",
      "doc_id": "doc-chapter-5-conditionals-and-recursion-0e72a852c9",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-NC 3.0",
        "source_file": "data/corpus_raw/thinkpython2_html_thinkpython2006_html_58db3a.json",
        "url": "https://greenteapress.com/thinkpython2/html/thinkpython2006.html"
      },
      "title": "Chapter\u00a05\u00a0\u00a0Conditionals and recursion",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "indexing",
        "slicing",
        "string_methods",
        "strings"
      ],
      "content": "Buy this book at Amazon.com Chapter\u00a06\u00a0\u00a0Fruitful functions Many of the Python functions we have used, such as the math\nfunctions, produce return values. But the functions we\u2019ve written\nare all void: they have an effect, like printing a value\nor moving a turtle, but they don\u2019t have a return value. In\nthis chapter you will learn to write fruitful functions. 6.1\u00a0\u00a0Return values Calling the function generates a return\nvalue, which we usually assign to a variable or use as part of an\nexpression. e = math.exp(1.0)\nheight = radius * math.sin(radians) The functions we have written so far are void. Speaking casually,\nthey have no return value; more precisely,\ntheir return value is None . In this chapter, we are (finally) going to write fruitful functions.\nThe first example is area , which returns the area of a circle\nwith the given radius: def area(radius):\n    a = math.pi * radius**2\n    return a We have seen the return statement before, but in a fruitful\nfunction the return statement includes\nan expression. This statement means: \u201cReturn immediately from\nthis function and use the following expression as a return value.\u201d\nThe expression can be arbitrarily complicated, so we could\nhave written this function more concisely: def area(radius):\n    return math.pi * radius**2 On the other hand, temporary variables like a can make\ndebugging easier. Sometimes it is useful to have multiple return statements, one in each\nbranch of a conditional: def absolute_value(x):\n    if x < 0:\n        return -x\n    else:\n        return x Since these return statements are in an alternative conditional,\nonly one runs. As soon as a return statement runs, the function\nterminates without executing any subsequent statements.\nCode that appears after a return statement, or any other place\nthe flow of execution can never reach, is called dead code . In a fruitful function, it is a good idea to ensure\nthat every possible path through the program hits a return statement. For example: def absolute_value(x):\n    if x < 0:\n        return -x\n    if x > 0:\n        return x This function is incorrect because if x happens to be 0,\nneither condition is true, and the function ends without hitting a return statement. If the flow of execution gets to the end\nof a function, the return value is None , which is not\nthe absolute value of 0. >>> print(absolute_value(0))\nNone By the way, Python provides a built-in function called abs that computes absolute values. As an exercise, write a compare function that\ntakes two values, x and y , and returns 1 if x > y , 0 if x == y , and -1 if x < y . 6.2\u00a0\u00a0Incremental development As you write larger functions, you might find yourself\nspending more time debugging. To deal with increasingly complex programs,\nyou might want to try a process called incremental development . The goal of incremental development\nis to avoid long debugging sessions by adding and testing only\na small amount of code at a time. As an example, suppose you want to find the distance between two\npoints, given by the coordinates ( x 1 , y 1 ) and ( x 2 , y 2 ).\nBy the Pythagorean theorem, the distance is: distance = \u221a ( x 2 \u2212 x 1 ) 2 +\u00a0( y 2 \u2212 y 1 ) 2 The first step is to consider what a distance function should\nlook like in Python. In other words, what are the inputs (parameters)\nand what is the output (return value)? In this case, the inputs are two points, which you can represent\nusing four numbers. The return value is the distance represented by\na floating-point value. Immediately you can write an outline of the function: def distance(x1, y1, x2, y2):\n    return 0.0 Obviously, this version doesn\u2019t compute distances; it always returns\nzero. But it is syntactically correct, and it runs, which means that\nyou can test it before you make it more complicated. To test the new function, call it with sample arguments: >>> distance(1, 2, 4, 6)\n0.0 I chose these values so that the horizontal distance is 3 and the\nvertical distance is 4; that way, the result is 5, the hypotenuse\nof a 3-4-5 right triangle. When testing a function, it is\nuseful to know the right answer. At this point we have confirmed that the function is syntactically\ncorrect, and we can start adding code to the body.\nA reasonable next step is to find the differences x 2 \u2212 x 1 and y 2 \u2212 y 1 . The next version stores those values in\ntemporary variables and prints them. def distance(x1, y1, x2, y2):\n    dx = x2 - x1\n    dy = y2 - y1\n    print('dx is', dx)\n    print('dy is', dy)\n    return 0.0 If the function is working, it should display dx is 3 and dy is 4 . If so, we know that the function is getting the right\narguments and performing the first computation correctly. If not,\nthere are only a few lines to check. Next we compute the sum of squares of dx and dy : def distance(x1, y1, x2, y2):\n    dx = x2 - x1\n    dy = y2 - y1\n    dsquared = dx**2 + dy**2\n    print('dsquared is: ', dsquared)\n    return 0.0 Again, you would run the program at this stage and check the output\n(which should be 25).\nFinally, you can use math.sqrt to compute and return the result: def distance(x1, y1, x2, y2):\n    dx = x2 - x1\n    dy = y2 - y1\n    dsquared = dx**2 + dy**2\n    result = math.sqrt(dsquared)\n    return result If that works correctly, you are done. Otherwise, you might\nwant to print the value of result before the return\nstatement. The final version of the function doesn\u2019t display anything when it\nruns; it only returns a value. The print statements we wrote\nare useful for debugging, but once you get the function working, you\nshould remove them. Code like that is called scaffolding because it is helpful for building the program but is not part of the\nfinal product. When you start out, you should add only a line or two of code at a\ntime. As you gain more experience, you might find yourself writing\nand debugging bigger chunks. Either way, incremental development\ncan save you a lot of debugging time. The key aspects of the process are: Start with a working program and make small incremental changes.\nAt any point, if there is an error, you should have a good idea\nwhere it is. Use variables to hold intermediate values so you can\ndisplay and check them. Once the program is working, you might want to remove some of\nthe scaffolding or consolidate multiple statements into compound\nexpressions, but only if it does not make the program difficult to\nread. As an exercise, use incremental development to write a function\ncalled hypotenuse that returns the length of the hypotenuse of a\nright triangle given the lengths of the other two legs as arguments.\nRecord each stage of the development process as you go. 6.3\u00a0\u00a0Composition As you should expect by now, you can call one function from within\nanother. As an example, we\u2019ll write a function that takes two points,\nthe center of the circle and a point on the perimeter, and computes\nthe area of the circle. Assume that the center point is stored in the variables xc and yc , and the perimeter point is in xp and yp . The\nfirst step is to find the radius of the circle, which is the distance\nbetween the two points. We just wrote a function, distance , that does that: radius = distance(xc, yc, xp, yp) The next step is to find the area of a circle with that radius;\nwe just wrote that, too: result = area(radius) Encapsulating these steps in a function, we get: def circle_area(xc, yc, xp, yp):\n    radius = distance(xc, yc, xp, yp)\n    result = area(radius)\n    return result The temporary variables radius and result are useful for\ndevelopment and debugging, but once the program is working, we can\nmake it more concise by composing the function calls: def circle_area(xc, yc, xp, yp):\n    return area(distance(xc, yc, xp, yp)) 6.4\u00a0\u00a0Boolean functions Functions can return booleans, which is often convenient for hiding\ncomplicated tests inside functions. For example: def is_divisible(x, y):\n    if x % y == 0:\n        return True\n    else:\n        return False It is common to give boolean functions names that sound like yes/no\nquestions; is_divisible returns either True or False to indicate whether x is divisible by y . Here is an example: >>> is_divisible(6, 4)\nFalse\n>>> is_divisible(6, 3)\nTrue The result of the == operator is a boolean, so we can write the\nfunction more concisely by returning it directly: def is_divisible(x, y):\n    return x % y == 0 Boolean functions are often used in conditional statements: if is_divisible(x, y):\n    print('x is divisible by y') It might be tempting to write something like: if is_divisible(x, y) == True:\n    print('x is divisible by y') But the extra comparison is unnecessary. As an exercise, write a function is_between(x, y, z) that\nreturns True if x \u2264 y \u2264 z or False otherwise. 6.5\u00a0\u00a0More recursion We have only covered a small subset of Python, but you might\nbe interested to know that this subset is a complete programming language, which means that anything that can be\ncomputed can be expressed in this language. Any program ever written\ncould be rewritten using only the language features you have learned\nso far (actually, you would need a few commands to control devices\nlike the mouse, disks, etc., but that\u2019s all). Proving that claim is a nontrivial exercise first accomplished by Alan\nTuring, one of the first computer scientists (some would argue that he\nwas a mathematician, but a lot of early computer scientists started as\nmathematicians). Accordingly, it is known as the Turing Thesis.\nFor a more complete (and accurate) discussion of the Turing Thesis,\nI recommend Michael Sipser\u2019s book Introduction to the\nTheory of Computation . To give you an idea of what you can do with the tools you have learned\nso far, we\u2019ll evaluate a few recursively defined mathematical\nfunctions. A recursive definition is similar to a circular\ndefinition, in the sense that the definition contains a reference to\nthe thing being defined. A truly circular definition is not very\nuseful: vorpal: An adjective used to describe something that is vorpal. If you saw that definition in the dictionary, you might be annoyed. On\nthe other hand, if you looked up the definition of the factorial\nfunction, denoted with the symbol !, you might get something like\nthis: 0!\u00a0=\u00a01 n !\u00a0= n ( n \u22121)! This definition says that the factorial of 0 is 1, and the factorial\nof any other value, n , is n multiplied by the factorial of n \u22121. So 3! is 3 times 2!, which is 2 times 1!, which is 1 times\n0!. Putting it all together, 3! equals 3 times 2 times 1 times 1,\nwhich is 6. If you can write a recursive definition of something, you can\nwrite a Python program to evaluate it. The first step is to decide\nwhat the parameters should be. In this case it should be clear\nthat factorial takes an integer: def factorial(n): If the argument happens to be 0, all we have to do is return 1: def factorial(n):\n    if n == 0:\n        return 1 Otherwise, and this is the interesting part, we have to make a\nrecursive call to find the factorial of n \u22121 and then multiply it by n : def factorial(n):\n    if n == 0:\n        return 1\n    else:\n        recurse = factorial(n-1)\n        result = n * recurse\n        return result The flow of execution for this program is similar to the flow of countdown in Section 5.8 . If we call factorial with the value 3: Since 3 is not 0, we take the second branch and calculate the factorial\nof n-1 ... Since 2 is not 0, we take the second branch and calculate the factorial of n-1 ... Since 1 is not 0, we take the second branch and calculate the factorial\nof n-1 ... Since 0 equals 0, we take the first branch and return 1\nwithout making any more recursive calls. The return value, 1, is multiplied by n , which is 1, and the\nresult is returned. The return value, 1, is multiplied by n , which is 2, and the\nresult is returned. The return value (2) is multiplied by n , which is 3, and the result, 6,\nbecomes the return value of the function call that started the whole\nprocess. Figure 6.1 shows what the stack diagram looks like for\nthis sequence of function calls. Figure 6.1: Stack diagram. The return values are shown being passed back up the stack. In each\nframe, the return value is the value of result , which is the\nproduct of n and recurse . In the last frame, the local\nvariables recurse and result do not exist, because\nthe branch that creates them does not run. 6.6\u00a0\u00a0Leap of faith Following the flow of execution is one way to read programs, but\nit can quickly become overwhelming. An\nalternative is what I call the \u201cleap of faith\u201d. When you come to a\nfunction call, instead of following the flow of execution, you assume that the function works correctly and returns the right\nresult. In fact, you are already practicing this leap of faith when you use\nbuilt-in functions. When you call math.cos or math.exp ,\nyou don\u2019t examine the bodies of those functions. You just\nassume that they work because the people who wrote the built-in\nfunctions were good programmers. The same is true when you call one of your own functions. For\nexample, in Section 6.4 , we wrote a function called is_divisible that determines whether one number is divisible by\nanother. Once we have convinced ourselves that this function is\ncorrect\u2014by examining the code and testing\u2014we can use the function\nwithout looking at the body again. The same is true of recursive programs. When you get to the recursive\ncall, instead of following the flow of execution, you should assume\nthat the recursive call works (returns the correct result) and then ask\nyourself, \u201cAssuming that I can find the factorial of n \u22121, can I\ncompute the factorial of n ?\u201d It is clear that you\ncan, by multiplying by n . Of course, it\u2019s a bit strange to assume that the function works\ncorrectly when you haven\u2019t finished writing it, but that\u2019s why\nit\u2019s called a leap of faith! 6.7\u00a0\u00a0One more example After factorial , the most common example of a recursively\ndefined mathematical function is fibonacci , which has the\nfollowing definition (see http://en.wikipedia.org/wiki/Fibonacci_number ): fibonacci (0)\u00a0=\u00a00 fibonacci (1)\u00a0=\u00a01 fibonacci ( n )\u00a0= fibonacci ( n \u22121)\u00a0+ fibonacci ( n \u22122) Translated into Python, it looks like this: def fibonacci(n):\n    if n == 0:\n        return 0\n    elif  n == 1:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2) If you try to follow the flow of execution here, even for fairly\nsmall values of n , your head explodes. But according to the\nleap of faith, if you assume that the two recursive calls\nwork correctly, then it is clear that you get\nthe right result by adding them together. 6.8\u00a0\u00a0Checking types What happens if we call factorial and give it 1.5 as an argument? >>> factorial(1.5)\nRuntimeError: Maximum recursion depth exceeded It looks like an infinite recursion. How can that be? The function\nhas a base case\u2014when n == 0 . But if n is not an integer,\nwe can miss the base case and recurse forever. In the first recursive call, the value of n is 0.5.\nIn the next, it is -0.5. From there, it gets smaller\n(more negative), but it will never be 0. We have two choices. We can try to generalize the factorial function to work with floating-point numbers, or we can make factorial check the type of its argument. The first option is\ncalled the gamma function and it\u2019s a\nlittle beyond the scope of this book. So we\u2019ll go for the second. We can use the built-in function isinstance to verify the type\nof the argument. While we\u2019re at it, we can also make sure the\nargument is positive: def factorial(n):\n    if not isinstance(n, int):\n        print('Factorial is only defined for integers.')\n        return None\n    elif n < 0:\n        print('Factorial is not defined for negative integers.')\n        return None\n    elif n == 0:\n        return 1\n    else:\n        return n * factorial(n-1) The first base case handles nonintegers; the\nsecond handles negative integers. In both cases, the program prints\nan error message and returns None to indicate that something\nwent wrong: >>> print(factorial('fred'))\nFactorial is only defined for integers.\nNone\n>>> print(factorial(-2))\nFactorial is not defined for negative integers.\nNone If we get past both checks, we know that n is a non-negative integer, so we can prove that the recursion terminates. This program demonstrates a pattern sometimes called a guardian .\nThe first two conditionals act as guardians, protecting the code that\nfollows from values that might cause an error. The guardians make it\npossible to prove the correctness of the code. In Section 11.4 we will see a more flexible alternative to printing\nan error message: raising an exception. 6.9\u00a0\u00a0Debugging Breaking a large program into smaller functions creates natural\ncheckpoints for debugging. If a function is not\nworking, there are three possibilities to consider: There is something wrong with the arguments the function\nis getting; a precondition is violated. There is something wrong with the function; a postcondition\nis violated. There is something wrong with the return value or the\nway it is being used. To rule out the first possibility, you can add a print statement\nat the beginning of the function and display the values of the\nparameters (and maybe their types). Or you can write code\nthat checks the preconditions explicitly. If the parameters look good, add a print statement before each return statement and display the return value. If\npossible, check the result by hand. Consider calling the\nfunction with values that make it easy to check the result\n(as in Section 6.2 ). If the function seems to be working, look at the function call\nto make sure the return value is being used correctly (or used\nat all!). Adding print statements at the beginning and end of a function\ncan help make the flow of execution more visible.\nFor example, here is a version of factorial with\nprint statements: def factorial(n):\n    space = ' ' * (4 * n)\n    print(space, 'factorial', n)\n    if n == 0:\n        print(space, 'returning 1')\n        return 1\n    else:\n        recurse = factorial(n-1)\n        result = n * recurse\n        print(space, 'returning', result)\n        return result space is a string of space characters that controls the\nindentation of the output. Here is the result of factorial(4) : factorial 4\n             factorial 3\n         factorial 2\n     factorial 1\n factorial 0\n returning 1\n     returning 1\n         returning 2\n             returning 6\n                 returning 24 If you are confused about the flow of execution, this kind of\noutput can be helpful. It takes some time to develop effective\nscaffolding, but a little bit of scaffolding can save a lot of debugging. 6.10\u00a0\u00a0Glossary temporary variable: A variable used to store an intermediate value in\na complex calculation. dead code: Part of a program that can never run, often because\nit appears after a return statement. incremental development: A program development plan intended to\navoid debugging by adding and testing only\na small amount of code at a time. scaffolding: Code that is used during program development but is\nnot part of the final version. guardian: A programming pattern that uses a conditional\nstatement to check for and handle circumstances that\nmight cause an error. 6.11\u00a0\u00a0Exercises Exercise\u00a01 Draw a stack diagram for the following program. What does the program print? def b(z):\n    prod = a(z, z)\n    print(z, prod)\n    return prod\n\ndef a(x, y):\n    x = x + 1\n    return x * y\n\ndef c(x, y, z):\n    total = x + y + z\n    square = b(total)**2\n    return square\n\nx = 1\ny = x + 1\nprint(c(x, y+3, x+y)) Exercise\u00a02 The Ackermann function, A ( m , n ) , is defined: A ( m , n )\u00a0= \u23a7 \u23aa \u23a8 \u23aa \u23a9 n +1 if m =\u00a00 A ( m \u22121,\u00a01) if m >\u00a00\u00a0 and n =\u00a00 A ( m \u22121, A ( m , n \u22121)) if m >\u00a00\u00a0 and n >\u00a00. See http://en.wikipedia.org/wiki/Ackermann_function .\nWrite a function named ack that evaluates the Ackermann function.\nUse your function to evaluate ack(3, 4) , which should be 125.\nWhat happens for larger values of m and n ?\nSolution: https://thinkpython.com/code/ackermann.py . Exercise\u00a03 A palindrome is a word that is spelled the same backward and\nforward, like \u201cnoon\u201d and \u201credivider\u201d. Recursively, a word\nis a palindrome if the first and last letters are the same\nand the middle is a palindrome. The following are functions that take a string argument and\nreturn the first, last, and middle letters: def first(word):\n    return word[0]\n\ndef last(word):\n    return word[-1]\n\ndef middle(word):\n    return word[1:-1] We\u2019ll see how they work in Chapter 8 . Type these functions into a file named palindrome.py and test them out. What happens if you call middle with\na string with two letters? One letter? What about the empty\nstring, which is written '' and contains no letters? Write a function called is_palindrome that takes\na string argument and returns True if it is a palindrome\nand False otherwise. Remember that you can use the\nbuilt-in function len to check the length of a string. Solution: https://thinkpython.com/code/palindrome_soln.py . Exercise\u00a04 A number, a , is a power of b if it is divisible by b and a / b is a power of b . Write a function called is_power that takes parameters a and b and returns True if a is a power of b .\nNote: you will have to think about the base case. Exercise\u00a05 The greatest common divisor (GCD) of a and b is the largest number\nthat divides both of them with no remainder. One way to find the GCD of two numbers is based on the observation\nthat if r is the remainder when a is divided by b , then gcd ( a , b ) = gcd ( b , r ) . As a base case, we can use gcd ( a , 0) = a . Write a function called gcd that takes parameters a and b and returns their greatest common divisor. Credit: This exercise is based on an example from Abelson and\nSussman\u2019s Structure and Interpretation of Computer Programs . Buy this book at Amazon.com\n\n#### Contribute\n\nIf you would like to make a contribution to support my books,\nyou can use the button below and pay with PayPal.  Thank you!\nPay what you want:\nSmall $1.00 USD\nMedium $5.00 USD\nLarge $10.00 USD\nX-Large $20.00 USD\nXX-Large $50.00 USD\nAre you using one of our books in a class? We'd like to know\nabout it.  Please consider filling out this short survey . Think DSP Think Java Think Bayes Think Python 2e Think Stats 2e Think Complexity",
      "difficulty": "intro",
      "doc_id": "doc-chapter-6-fruitful-functions-19f263827a",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-NC 3.0",
        "source_file": "data/corpus_raw/thinkpython2_html_thinkpython2007_html_92a5e1.json",
        "url": "https://greenteapress.com/thinkpython2/html/thinkpython2007.html"
      },
      "title": "Chapter\u00a06\u00a0\u00a0Fruitful functions",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "indexing",
        "lists",
        "mutability",
        "slicing"
      ],
      "content": "Buy this book at Amazon.com Chapter\u00a07\u00a0\u00a0Iteration This chapter is about iteration, which is the ability to run\na block of statements repeatedly. We saw a kind of iteration,\nusing recursion, in Section 5.8 .\nWe saw another kind, using a for loop,\nin Section 4.2 . In this chapter we\u2019ll see yet another\nkind, using a while statement.\nBut first I want to say a little more about variable assignment. 7.1\u00a0\u00a0Reassignment As you may have discovered, it is legal to make more than one\nassignment to the same variable. A new assignment makes an existing\nvariable refer to a new value (and stop referring to the old value). >>> x = 5\n>>> x\n5\n>>> x = 7\n>>> x\n7 The first time we display x , its value is 5; the second time, its\nvalue is 7. Figure 7.1 shows what reassignment looks\nlike in a state diagram. At this point I want to address a common source of\nconfusion.\nBecause Python uses the equal sign ( = ) for assignment, it is\ntempting to interpret a statement like a = b as a\nmathematical\nproposition of equality; that is, the claim that a and b are equal. But this interpretation is wrong. First, equality is a symmetric relationship and assignment is not. For\nexample, in mathematics, if a =7 then 7= a . But in Python, the\nstatement a = 7 is legal and 7 = a is not. Also, in mathematics, a proposition of equality is either true or\nfalse for all time. If a = b now, then a will always equal b .\nIn Python, an assignment statement can make two variables equal, but\nthey don\u2019t have to stay that way: >>> a = 5\n>>> b = a    # a and b are now equal\n>>> a = 3    # a and b are no longer equal\n>>> b\n5 The third line changes the value of a but does not change the\nvalue of b , so they are no longer equal. Reassigning variables is often useful, but you should use it\nwith caution. If the values of variables change frequently, it can\nmake the code difficult to read and debug. Figure 7.1: State diagram. 7.2\u00a0\u00a0Updating variables A common kind of reassignment is an update ,\nwhere the new value of the variable depends on the old. >>> x = x + 1 This means \u201cget the current value of x , add one, and then\nupdate x with the new value.\u201d If you try to update a variable that doesn\u2019t exist, you get an\nerror, because Python evaluates the right side before it assigns\na value to x : >>> x = x + 1\nNameError: name 'x' is not defined Before you can update a variable, you have to initialize it, usually with a simple assignment: >>> x = 0\n>>> x = x + 1 Updating a variable by adding 1 is called an increment ;\nsubtracting 1 is called a decrement . 7.3\u00a0\u00a0The while statement Computers are often used to automate repetitive tasks. Repeating\nidentical or similar tasks without making errors is something that\ncomputers do well and people do poorly. In a computer program,\nrepetition is also called iteration . We have already seen two functions, countdown and print_n , that iterate using recursion. Because iteration is so\ncommon, Python provides language features to make it easier.\nOne is the for statement we saw in Section 4.2 .\nWe\u2019ll get back to that later. Another is the while statement. Here is a version of countdown that uses a while statement: def countdown(n):\n    while n > 0:\n        print(n)\n        n = n - 1\n    print('Blastoff!') You can almost read the while statement as if it were English.\nIt means, \u201cWhile n is greater than 0,\ndisplay the value of n and then decrement n . When you get to 0, display the word Blastoff! \u201d More formally, here is the flow of execution for a while statement: Determine whether the condition is true or false. If false, exit the while statement\nand continue execution at the next statement. If the condition is true, run the\nbody and then go back to step 1. This type of flow is called a loop because the third step\nloops back around to the top. The body of the loop should change the value of one or more variables\nso that the condition becomes false eventually and the loop\nterminates. Otherwise the loop will repeat forever, which is called\nan infinite loop . An endless source of amusement for computer\nscientists is the observation that the directions on shampoo,\n\u201cLather, rinse, repeat\u201d, are an infinite loop. In the case of countdown , we can prove that the loop\nterminates: if n is zero or negative, the loop never runs.\nOtherwise, n gets smaller each time through the\nloop, so eventually we have to get to 0. For some other loops, it is not so easy to tell. For example: def sequence(n):\n    while n != 1:\n        print(n)\n        if n % 2 == 0:        # n is even\n            n = n / 2\n        else:                 # n is odd\n            n = n*3 + 1 The condition for this loop is n != 1 , so the loop will continue\nuntil n is 1 , which makes the condition false. Each time through the loop, the program outputs the value of n and then checks whether it is even or odd. If it is even, n is\ndivided by 2. If it is odd, the value of n is replaced with n*3 + 1 . For example, if the argument passed to sequence is 3, the resulting values of n are 3, 10, 5, 16, 8, 4, 2, 1. Since n sometimes increases and sometimes decreases, there is no\nobvious proof that n will ever reach 1, or that the program\nterminates. For some particular values of n , we can prove\ntermination. For example, if the starting value is a power of two, n will be even every time through the loop\nuntil it reaches 1. The previous example ends with such a sequence,\nstarting with 16. The hard question is whether we can prove that this program terminates\nfor all positive values of n . So far, no one has\nbeen able to prove it or disprove it! (See http://en.wikipedia.org/wiki/Collatz_conjecture .) As an exercise, rewrite the function print_n from\nSection 5.8 using iteration instead of recursion. 7.4 break Sometimes you don\u2019t know it\u2019s time to end a loop until you get half\nway through the body. In that case you can use the break statement to jump out of the loop. For example, suppose you want to take input from the user until they\ntype done . You could write: while True:\n    line = input('> ')\n    if line == 'done':\n        break\n    print(line)\n\nprint('Done!') The loop condition is True , which is always true, so the\nloop runs until it hits the break statement. Each time through, it prompts the user with an angle bracket.\nIf the user types done , the break statement exits\nthe loop. Otherwise the program echoes whatever the user types\nand goes back to the top of the loop. Here\u2019s a sample run: > not done\nnot done\n> done\nDone! This way of writing while loops is common because you\ncan check the condition anywhere in the loop (not just at the\ntop) and you can express the stop condition affirmatively\n(\u201cstop when this happens\u201d) rather than negatively (\u201ckeep going\nuntil that happens\u201d). 7.5\u00a0\u00a0Square roots Loops are often used in programs that compute\nnumerical results by starting with an approximate answer and\niteratively improving it. For example, one way of computing square roots is Newton\u2019s method.\nSuppose that you want to know the square root of a . If you start\nwith almost any estimate, x , you can compute a better\nestimate with the following formula: y = x + a / x 2 For example, if a is 4 and x is 3: >>> a = 4\n>>> x = 3\n>>> y = (x + a/x) / 2\n>>> y\n2.16666666667 The result is closer to the correct answer (\u221a 4 = 2). If we\nrepeat the process with the new estimate, it gets even closer: >>> x = y\n>>> y = (x + a/x) / 2\n>>> y\n2.00641025641 After a few more updates, the estimate is almost exact: >>> x = y\n>>> y = (x + a/x) / 2\n>>> y\n2.00001024003\n>>> x = y\n>>> y = (x + a/x) / 2\n>>> y\n2.00000000003 In general we don\u2019t know ahead of time how many steps it takes\nto get to the right answer, but we know when we get there\nbecause the estimate\nstops changing: >>> x = y\n>>> y = (x + a/x) / 2\n>>> y\n2.0\n>>> x = y\n>>> y = (x + a/x) / 2\n>>> y\n2.0 When y == x , we can stop. Here is a loop that starts\nwith an initial estimate, x , and improves it until it\nstops changing: while True:\n    print(x)\n    y = (x + a/x) / 2\n    if y == x:\n        break\n    x = y For most values of a this works fine, but in general it is\ndangerous to test float equality.\nFloating-point values are only approximately right:\nmost rational numbers, like 1/3, and irrational numbers, like\n\u221a 2 , can\u2019t be represented exactly with a float . Rather than checking whether x and y are exactly equal, it\nis safer to use the built-in function abs to compute the\nabsolute value, or magnitude, of the difference between them: if abs(y-x) < epsilon:\n        break Where epsilon has a value like 0.0000001 that\ndetermines how close is close enough. 7.6\u00a0\u00a0Algorithms Newton\u2019s method is an example of an algorithm : it is a\nmechanical process for solving a category of problems (in this\ncase, computing square roots). To understand what an algorithm is, it might help to start with\nsomething that is not an algorithm. When you learned to multiply\nsingle-digit numbers, you probably memorized the multiplication table.\nIn effect, you memorized 100 specific solutions. That kind of\nknowledge is not algorithmic. But if you were \u201clazy\u201d, you might have learned a few\ntricks. For example, to find the product of n and 9, you can\nwrite n \u22121 as the first digit and 10\u2212 n as the second\ndigit. This trick is a general solution for multiplying any\nsingle-digit number by 9. That\u2019s an algorithm! Similarly, the techniques you learned for addition with carrying,\nsubtraction with borrowing, and long division are all algorithms. One\nof the characteristics of algorithms is that they do not require any\nintelligence to carry out. They are mechanical processes where\neach step follows from the last according to a simple set of rules. Executing algorithms is boring, but designing them is interesting,\nintellectually challenging, and a central part of computer science. Some of the things that people do naturally, without difficulty or\nconscious thought, are the hardest to express algorithmically.\nUnderstanding natural language is a good example. We all do it, but\nso far no one has been able to explain how we do it, at least\nnot in the form of an algorithm. 7.7\u00a0\u00a0Debugging As you start writing bigger programs, you might find yourself\nspending more time debugging. More code means more chances to\nmake an error and more places for bugs to hide. One way to cut your debugging time is \u201cdebugging by bisection\u201d.\nFor example, if there are 100 lines in your program and you\ncheck them one at a time, it would take 100 steps. Instead, try to break the problem in half. Look at the middle\nof the program, or near it, for an intermediate value you\ncan check. Add a print statement (or something else\nthat has a verifiable effect) and run the program. If the mid-point check is incorrect, there must be a problem in the\nfirst half of the program. If it is correct, the problem is\nin the second half. Every time you perform a check like this, you halve the number of\nlines you have to search. After six steps (which is fewer than 100),\nyou would be down to one or two lines of code, at least in theory. In practice it is not always clear what\nthe \u201cmiddle of the program\u201d is and not always possible to\ncheck it. It doesn\u2019t make sense to count lines and find the\nexact midpoint. Instead, think about places\nin the program where there might be errors and places where it\nis easy to put a check. Then choose a spot where you\nthink the chances are about the same that the bug is before\nor after the check. 7.8\u00a0\u00a0Glossary reassignment: Assigning a new value to a variable that\nalready exists. update: An assignment where the new value of the variable\ndepends on the old. initialization: An assignment that gives an initial value to\na variable that will be updated. increment: An update that increases the value of a variable\n(often by one). decrement: An update that decreases the value of a variable. iteration: Repeated execution of a set of statements using\neither a recursive function call or a loop. infinite loop: A loop in which the terminating condition is\nnever satisfied. algorithm: A general process for solving a category of\nproblems. 7.9\u00a0\u00a0Exercises Exercise\u00a01 Copy the loop from Section 7.5 and encapsulate it in a function called mysqrt that takes a as a parameter, chooses a\nreasonable value of x , and returns an estimate of the square\nroot of a . To test it, write a function named test_square_root that prints a table like this: a   mysqrt(a)     math.sqrt(a)  diff\n-   ---------     ------------  ----\n1.0 1.0           1.0           0.0\n2.0 1.41421356237 1.41421356237 2.22044604925e-16\n3.0 1.73205080757 1.73205080757 0.0\n4.0 2.0           2.0           0.0\n5.0 2.2360679775  2.2360679775  0.0\n6.0 2.44948974278 2.44948974278 0.0\n7.0 2.64575131106 2.64575131106 0.0\n8.0 2.82842712475 2.82842712475 4.4408920985e-16\n9.0 3.0           3.0           0.0 The first column is a number, a ; the second column is the square\nroot of a computed with mysqrt ; the third column is the\nsquare root computed by math.sqrt ; the fourth column is the\nabsolute value of the difference between the two estimates. Exercise\u00a02 The built-in function eval takes a string and evaluates\nit using the Python interpreter. For example: >>> eval('1 + 2 * 3')\n7\n>>> import math\n>>> eval('math.sqrt(5)')\n2.2360679774997898\n>>> eval('type(math.pi)')\n<class 'float'> Write a function called eval_loop that iteratively\nprompts the user, takes the resulting input and evaluates\nit using eval , and prints the result. It should continue until the user enters 'done' , and then\nreturn the value of the last expression it evaluated. Exercise\u00a03 The mathematician Srinivasa Ramanujan found an\ninfinite series\nthat can be used to generate a numerical\napproximation of 1 / \u03c0 : 1 \u03c0 = 2 \u221a 2 9801 \u221e \u2211 k =0 (4 k )!(1103+26390 k ) ( k !) 4 396 4 k Write a function called estimate_pi that uses this formula\nto compute and return an estimate of \u03c0 . It should use a while loop to compute terms of the summation until the last term is\nsmaller than 1e-15 (which is Python notation for 10 \u221215 ).\nYou can check the result by comparing it to math.pi . Solution: https://thinkpython.com/code/pi.py . Buy this book at Amazon.com\n\n#### Contribute\n\nIf you would like to make a contribution to support my books,\nyou can use the button below and pay with PayPal.  Thank you!\nPay what you want:\nSmall $1.00 USD\nMedium $5.00 USD\nLarge $10.00 USD\nX-Large $20.00 USD\nXX-Large $50.00 USD\nAre you using one of our books in a class? We'd like to know\nabout it.  Please consider filling out this short survey . Think DSP Think Java Think Bayes Think Python 2e Think Stats 2e Think Complexity",
      "difficulty": "intro",
      "doc_id": "doc-chapter-7-iteration-4fefdcb3c2",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-NC 3.0",
        "source_file": "data/corpus_raw/scraped/thinkpython2_html_thinkpython2008_html_e12c4d.json",
        "url": "https://greenteapress.com/thinkpython2/html/thinkpython2008.html"
      },
      "title": "Chapter\u00a07\u00a0\u00a0Iteration",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "assignment",
        "data_structures",
        "tuples"
      ],
      "content": "Buy this book at Amazon.com Chapter\u00a08\u00a0\u00a0Strings Strings are not like integers, floats, and booleans. A string\nis a sequence , which means it is\nan ordered collection of other values. In this chapter you\u2019ll see\nhow to access the characters that make up a string, and you\u2019ll\nlearn about some of the methods strings provide. 8.1\u00a0\u00a0A string is a sequence A string is a sequence of characters.\nYou can access the characters one at a time with the\nbracket operator: >>> fruit = 'banana'\n>>> letter = fruit[1] The second statement selects character number 1 from fruit and assigns it to letter . The expression in brackets is called an index .\nThe index indicates which character in the sequence you\nwant (hence the name). But you might not get what you expect: >>> letter\n'a' For most people, the first letter of 'banana' is b , not a . But for computer scientists, the index is an offset from the\nbeginning of the string, and the offset of the first letter is zero. >>> letter = fruit[0]\n>>> letter\n'b' So b is the 0th letter (\u201czero-eth\u201d) of 'banana' , a is the 1th letter (\u201cone-eth\u201d), and n is the 2th letter\n(\u201ctwo-eth\u201d). As an index you can use an expression that contains variables and\noperators: >>> i = 1\n>>> fruit[i]\n'a'\n>>> fruit[i+1]\n'n' But the value of the index has to be an integer. Otherwise you\nget: >>> letter = fruit[1.5]\nTypeError: string indices must be integers 8.2 len len is a built-in function that returns the number of characters\nin a string: >>> fruit = 'banana'\n>>> len(fruit)\n6 To get the last letter of a string, you might be tempted to try something\nlike this: >>> length = len(fruit)\n>>> last = fruit[length]\nIndexError: string index out of range The reason for the IndexError is that there is no letter in \u2019banana\u2019 with the index 6. Since we started counting at zero, the\nsix letters are numbered 0 to 5. To get the last character, you have\nto subtract 1 from length : >>> last = fruit[length-1]\n>>> last\n'a' Or you can use negative indices, which count backward from\nthe end of the string. The expression fruit[-1] yields the last\nletter, fruit[-2] yields the second to last, and so on. 8.3\u00a0\u00a0Traversal with a for loop A lot of computations involve processing a string one character at a\ntime. Often they start at the beginning, select each character in\nturn, do something to it, and continue until the end. This pattern of\nprocessing is called a traversal . One way to write a traversal\nis with a while loop: index = 0\nwhile index < len(fruit):\n    letter = fruit[index]\n    print(letter)\n    index = index + 1 This loop traverses the string and displays each letter on a line by\nitself. The loop condition is index < len(fruit) , so\nwhen index is equal to the length of the string, the\ncondition is false, and the body of the loop doesn\u2019t run. The\nlast character accessed is the one with the index len(fruit)-1 ,\nwhich is the last character in the string. As an exercise, write a function that takes a string as an argument\nand displays the letters backward, one per line. Another way to write a traversal is with a for loop: for letter in fruit:\n    print(letter) Each time through the loop, the next character in the string is assigned\nto the variable letter . The loop continues until no characters are\nleft. The following example shows how to use concatenation (string addition)\nand a for loop to generate an abecedarian series (that is, in\nalphabetical order). In Robert McCloskey\u2019s book Make\nWay for Ducklings , the names of the ducklings are Jack, Kack, Lack,\nMack, Nack, Ouack, Pack, and Quack. This loop outputs these names in\norder: prefixes = 'JKLMNOPQ'\nsuffix = 'ack'\n\nfor letter in prefixes:\n    print(letter + suffix) The output is: Jack\nKack\nLack\nMack\nNack\nOack\nPack\nQack Of course, that\u2019s not quite right because \u201cOuack\u201d and \u201cQuack\u201d are\nmisspelled. As an exercise, modify the program to fix this error. 8.4\u00a0\u00a0String slices A segment of a string is called a slice . Selecting a slice is\nsimilar to selecting a character: >>> s = 'Monty Python'\n>>> s[0:5]\n'Monty'\n>>> s[6:12]\n'Python' The operator [n:m] returns the part of the string from the\n\u201cn-eth\u201d character to the \u201cm-eth\u201d character, including the first but\nexcluding the last. This behavior is counterintuitive, but it might\nhelp to imagine the indices pointing between the\ncharacters, as in Figure 8.1 . Figure 8.1: Slice indices. If you omit the first index (before the colon), the slice starts at\nthe beginning of the string. If you omit the second index, the slice\ngoes to the end of the string: >>> fruit = 'banana'\n>>> fruit[:3]\n'ban'\n>>> fruit[3:]\n'ana' If the first index is greater than or equal to the second the result\nis an empty string , represented by two quotation marks: >>> fruit = 'banana'\n>>> fruit[3:3]\n'' An empty string contains no characters and has length 0, but other\nthan that, it is the same as any other string. Continuing this example, what do you think fruit[:] means? Try it and see. 8.5\u00a0\u00a0Strings are immutable It is tempting to use the [] operator on the left side of an\nassignment, with the intention of changing a character in a string.\nFor example: >>> greeting = 'Hello, world!'\n>>> greeting[0] = 'J'\nTypeError: 'str' object does not support item assignment The \u201cobject\u201d in this case is the string and the \u201citem\u201d is\nthe character you tried to assign. For now, an object is\nthe same thing as a value, but we will refine that definition\nlater (Section 10.10 ). The reason for the error is that\nstrings are immutable , which means you can\u2019t change an\nexisting string. The best you can do is create a new string\nthat is a variation on the original: >>> greeting = 'Hello, world!'\n>>> new_greeting = 'J' + greeting[1:]\n>>> new_greeting\n'Jello, world!' This example concatenates a new first letter onto\na slice of greeting . It has no effect on\nthe original string. 8.6\u00a0\u00a0Searching What does the following function do? def find(word, letter):\n    index = 0\n    while index < len(word):\n        if word[index] == letter:\n            return index\n        index = index + 1\n    return -1 In a sense, find is the inverse of the [] operator.\nInstead of taking an index and extracting the corresponding character,\nit takes a character and finds the index where that character\nappears. If the character is not found, the function returns -1 . This is the first example we have seen of a return statement\ninside a loop. If word[index] == letter , the function breaks\nout of the loop and returns immediately. If the character doesn\u2019t appear in the string, the program\nexits the loop normally and returns -1 . This pattern of computation\u2014traversing a sequence and returning\nwhen we find what we are looking for\u2014is called a search . As an exercise, modify find so that it has a\nthird parameter, the index in word where it should start\nlooking. 8.7\u00a0\u00a0Looping and counting The following program counts the number of times the letter a appears in a string: word = 'banana'\ncount = 0\nfor letter in word:\n    if letter == 'a':\n        count = count + 1\nprint(count) This program demonstrates another pattern of computation called a counter . The variable count is initialized to 0 and then\nincremented each time an a is found.\nWhen the loop exits, count contains the result\u2014the total number of a \u2019s. As an exercise, encapsulate this code in a function named count , and generalize it so that it accepts the string and the\nletter as arguments. Then rewrite the function so that instead of\ntraversing the string, it uses the three-parameter version of find from the previous section. 8.8\u00a0\u00a0String methods Strings provide methods that perform a variety of useful operations.\nA method is similar to a function\u2014it takes arguments and\nreturns a value\u2014but the syntax is different. For example, the\nmethod upper takes a string and returns a new string with\nall uppercase letters. Instead of the function syntax upper(word) , it uses\nthe method syntax word.upper() . >>> word = 'banana'\n>>> new_word = word.upper()\n>>> new_word\n'BANANA' This form of dot notation specifies the name of the method, upper , and the name of the string to apply the method to, word . The empty parentheses indicate that this method takes no\narguments. A method call is called an invocation ; in this case, we would\nsay that we are invoking upper on word . As it turns out, there is a string method named find that\nis remarkably similar to the function we wrote: >>> word = 'banana'\n>>> index = word.find('a')\n>>> index\n1 In this example, we invoke find on word and pass\nthe letter we are looking for as a parameter. Actually, the find method is more general than our function;\nit can find substrings, not just characters: >>> word.find('na')\n2 By default, find starts at the beginning of the string, but\nit can take a second argument, the index where it should start: >>> word.find('na', 3)\n4 This is an example of an optional argument ; find can\nalso take a third argument, the index where it should stop: >>> name = 'bob'\n>>> name.find('b', 1, 2)\n-1 This search fails because b does not\nappear in the index range from 1 to 2 , not including 2 . Searching up to, but not including, the second index makes find consistent with the slice operator. 8.9\u00a0\u00a0The in operator The word in is a boolean operator that takes two strings and\nreturns True if the first appears as a substring in the second: >>> 'a' in 'banana'\nTrue\n>>> 'seed' in 'banana'\nFalse For example, the following function prints all the\nletters from word1 that also appear in word2 : def in_both(word1, word2):\n    for letter in word1:\n        if letter in word2:\n            print(letter) With well-chosen variable names,\nPython sometimes reads like English. You could read\nthis loop, \u201cfor (each) letter in (the first) word, if (the) letter\n(appears) in (the second) word, print (the) letter.\u201d Here\u2019s what you get if you compare apples and oranges: >>> in_both('apples', 'oranges')\na\ne\ns 8.10\u00a0\u00a0String comparison The relational operators work on strings. To see if two strings are equal: if word == 'banana':\n    print('All right, bananas.') Other relational operations are useful for putting words in alphabetical\norder: if word < 'banana':\n    print('Your word, ' + word + ', comes before banana.')\nelif word > 'banana':\n    print('Your word, ' + word + ', comes after banana.')\nelse:\n    print('All right, bananas.') Python does not handle uppercase and lowercase letters the same way\npeople do. All the uppercase letters come before all the\nlowercase letters, so: Your word, Pineapple, comes before banana. A common way to address this problem is to convert strings to a\nstandard format, such as all lowercase, before performing the\ncomparison. Keep that in mind in case you have to defend yourself\nagainst a man armed with a Pineapple. 8.11\u00a0\u00a0Debugging When you use indices to traverse the values in a sequence,\nit is tricky to get the beginning and end of the traversal\nright. Here is a function that is supposed to compare two\nwords and return True if one of the words is the reverse\nof the other, but it contains two errors: def is_reverse(word1, word2):\n    if len(word1) != len(word2):\n        return False\n\n    i = 0\n    j = len(word2)\n\n    while j > 0:\n        if word1[i] != word2[j]:\n            return False\n        i = i+1\n        j = j-1\n\n    return True The first if statement checks whether the words are the\nsame length. If not, we can return False immediately.\nOtherwise, for the rest of the function, we can assume that the words\nare the same length. This is an example of the guardian pattern\nin Section 6.8 . i and j are indices: i traverses word1 forward while j traverses word2 backward. If we find\ntwo letters that don\u2019t match, we can return False immediately.\nIf we get through the whole loop and all the letters match, we\nreturn True . If we test this function with the words \u201cpots\u201d and \u201cstop\u201d, we\nexpect the return value True , but we get an IndexError: >>> is_reverse('pots', 'stop')\n...\n  File \"reverse.py\", line 15, in is_reverse\n    if word1[i] != word2[j]:\nIndexError: string index out of range For debugging this kind of error, my first move is to\nprint the values of the indices immediately before the line\nwhere the error appears. while j > 0:\n        print(i, j)        # print here\n\n        if word1[i] != word2[j]:\n            return False\n        i = i+1\n        j = j-1 Now when I run the program again, I get more information: >>> is_reverse('pots', 'stop')\n0 4\n...\nIndexError: string index out of range The first time through the loop, the value of j is 4,\nwhich is out of range for the string 'pots' .\nThe index of the last character is 3, so the\ninitial value for j should be len(word2)-1 . If I fix that error and run the program again, I get: >>> is_reverse('pots', 'stop')\n0 3\n1 2\n2 1\nTrue This time we get the right answer, but it looks like the loop only ran\nthree times, which is suspicious. To get a better idea of what is\nhappening, it is useful to draw a state diagram. During the first\niteration, the frame for is_reverse is shown in\nFigure 8.2 . Figure 8.2: State diagram. I took some license by arranging the variables in the frame\nand adding dotted lines to show that the values of i and j indicate characters in word1 and word2 . Starting with this diagram, run the program on paper, changing the\nvalues of i and j during each iteration. Find and fix the\nsecond error in this function. 8.12\u00a0\u00a0Glossary object: Something a variable can refer to. For now,\nyou can use \u201cobject\u201d and \u201cvalue\u201d interchangeably. sequence: An ordered collection of\nvalues where each value is identified by an integer index. item: One of the values in a sequence. index: An integer value used to select an item in\na sequence, such as a character in a string. In Python\nindices start from 0. slice: A part of a string specified by a range of indices. empty string: A string with no characters and length 0, represented\nby two quotation marks. immutable: The property of a sequence whose items cannot\nbe changed. traverse: To iterate through the items in a sequence,\nperforming a similar operation on each. search: A pattern of traversal that stops\nwhen it finds what it is looking for. counter: A variable used to count something, usually initialized\nto zero and then incremented. invocation: A statement that calls a method. optional argument: A function or method argument that is not\nrequired. 8.13\u00a0\u00a0Exercises Exercise\u00a01 Read the documentation of the string methods at http://docs.python.org/3/library/stdtypes.html#string-methods .\nYou might want to experiment with some of them to make sure you\nunderstand how they work. strip and replace are\nparticularly useful. The documentation uses a syntax that might be confusing.\nFor example, in find(sub[, start[, end]]) , the brackets\nindicate optional arguments. So sub is required, but start is optional, and if you include start ,\nthen end is optional. Exercise\u00a02 There is a string method called count that is similar\nto the function in Section 8.7 . Read the documentation\nof this method\nand write an invocation that counts the number of a \u2019s\nin 'banana' . Exercise\u00a03 A string slice can take a third index that specifies the \u201cstep\nsize\u201d; that is, the number of spaces between successive characters.\nA step size of 2 means every other character; 3 means every third,\netc. >>> fruit = 'banana'\n>>> fruit[0:5:2]\n'bnn' A step size of -1 goes through the word backwards, so\nthe slice [::-1] generates a reversed string. Use this idiom to write a one-line version of is_palindrome from Exercise 3 . Exercise\u00a04 The following functions are all intended to check whether a\nstring contains any lowercase letters, but at least some of them are\nwrong. For each function, describe what the function actually does\n(assuming that the parameter is a string). def any_lowercase1(s):\n    for c in s:\n        if c.islower():\n            return True\n        else:\n            return False\n\ndef any_lowercase2(s):\n    for c in s:\n        if 'c'.islower():\n            return 'True'\n        else:\n            return 'False'\n\ndef any_lowercase3(s):\n    for c in s:\n        flag = c.islower()\n    return flag\n\ndef any_lowercase4(s):\n    flag = False\n    for c in s:\n        flag = flag or c.islower()\n    return flag\n\ndef any_lowercase5(s):\n    for c in s:\n        if not c.islower():\n            return False\n    return True Exercise\u00a05 A Caesar cypher is a weak form of encryption that involves \u201crotating\u201d each\nletter by a fixed number of places. To rotate a letter means\nto shift it through the alphabet, wrapping around to the beginning if\nnecessary, so \u2019A\u2019 rotated by 3 is \u2019D\u2019 and \u2019Z\u2019 rotated by 1 is \u2019A\u2019. To rotate a word, rotate each letter by the same amount.\nFor example, \u201ccheer\u201d rotated by 7 is \u201cjolly\u201d and \u201cmelon\u201d rotated\nby -10 is \u201ccubed\u201d. In the movie 2001: A Space Odyssey , the\nship computer is called HAL, which is IBM rotated by -1. Write a function called rotate_word that takes a string and an integer as parameters, and returns\na new string that contains the letters from the original string\nrotated by the given amount. You might want to use the built-in function ord , which converts\na character to a numeric code, and chr , which converts numeric\ncodes to characters. Letters of the alphabet are encoded in alphabetical\norder, so for example: >>> ord('c') - ord('a')\n2 Because 'c' is the two-eth letter of the alphabet. But\nbeware: the numeric codes for upper case letters are different. Potentially offensive jokes on the Internet are sometimes encoded in\nROT13, which is a Caesar cypher with rotation 13. If you are not\neasily offended, find and decode some of them. Solution: https://thinkpython.com/code/rotate.py . Buy this book at Amazon.com\n\n#### Contribute\n\nIf you would like to make a contribution to support my books,\nyou can use the button below and pay with PayPal.  Thank you!\nPay what you want:\nSmall $1.00 USD\nMedium $5.00 USD\nLarge $10.00 USD\nX-Large $20.00 USD\nXX-Large $50.00 USD\nAre you using one of our books in a class? We'd like to know\nabout it.  Please consider filling out this short survey . Think DSP Think Java Think Bayes Think Python 2e Think Stats 2e Think Complexity",
      "difficulty": "intro",
      "doc_id": "doc-chapter-8-strings-689ec2f30c",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-NC 3.0",
        "source_file": "data/corpus_raw/thinkpython2_html_thinkpython2009_html_f2f5e0.json",
        "url": "https://greenteapress.com/thinkpython2/html/thinkpython2009.html"
      },
      "title": "Chapter\u00a08\u00a0\u00a0Strings",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "data_structures",
        "dictionaries",
        "key_value"
      ],
      "content": "Buy this book at Amazon.com Chapter\u00a09\u00a0\u00a0Case study: word play This chapter presents the second case study, which involves\nsolving word puzzles by searching for words that have certain\nproperties. For example, we\u2019ll find the longest palindromes\nin English and search for words whose letters appear in\nalphabetical order. And I will present another program development\nplan: reduction to a previously solved problem. 9.1\u00a0\u00a0Reading word lists For the exercises in this chapter we need a list of English words.\nThere are lots of word lists available on the Web, but the one most\nsuitable for our purpose is one of the word lists collected and\ncontributed to the public domain by Grady Ward as part of the Moby\nlexicon project (see http://wikipedia.org/wiki/Moby_Project ). It\nis a list of 113,809 official crosswords; that is, words that are\nconsidered valid in crossword puzzles and other word games. In the\nMoby collection, the filename is 113809of.fic ; you can download\na copy, with the simpler name words.txt , from https://thinkpython.com/code/words.txt . This file is in plain text, so you can open it with a text\neditor, but you can also read it from Python. The built-in\nfunction open takes the name of the file as a parameter\nand returns a file object you can use to read the file. >>> fin = open('words.txt') fin is a common name for a file object used for input. The file\nobject provides several methods for reading, including readline ,\nwhich reads characters from the file until it gets to a newline and\nreturns the result as a string: >>> fin.readline()\n'aa\\n' The first word in this particular list is \u201caa\u201d, which is a kind of\nlava. The sequence \\n represents the newline character that\nseparates this word from the next. The file object keeps track of where it is in the file, so\nif you call readline again, you get the next word: >>> fin.readline()\n'aah\\n' The next word is \u201caah\u201d, which is a perfectly legitimate\nword, so stop looking at me like that.\nOr, if it\u2019s the newline character that\u2019s bothering you,\nwe can get rid of it with the string method strip : >>> line = fin.readline()\n>>> word = line.strip()\n>>> word\n'aahed' You can also use a file object as part of a for loop.\nThis program reads words.txt and prints each word, one\nper line: fin = open('words.txt')\nfor line in fin:\n    word = line.strip()\n    print(word) 9.2\u00a0\u00a0Exercises There are solutions to these exercises in the next section.\nYou should at least attempt each one before you read the solutions. Exercise\u00a01 Write a program that reads words.txt and prints only the\nwords with more than 20 characters (not counting whitespace). Exercise\u00a02 In 1939 Ernest Vincent Wright published a 50,000 word novel called Gadsby that does not contain the letter \u201ce\u201d. Since \u201ce\u201d is\nthe most common letter in English, that\u2019s not easy to do. In fact, it is difficult to construct a solitary thought without using\nthat most common symbol. It is slow going at first, but with caution\nand hours of training you can gradually gain facility. All right, I\u2019ll stop now. Write a function called has_no_e that returns True if\nthe given word doesn\u2019t have the letter \u201ce\u201d in it. Write a program that reads words.txt and prints only the words\nthat have no \u201ce\u201d. Compute the percentage of words in the list\nthat have no \u201ce\u201d. Exercise\u00a03 Write a function named avoids that takes a word and a string of forbidden letters, and\nthat returns True if the word doesn\u2019t use any of the forbidden\nletters. Write a program that prompts the user to enter a string\nof forbidden letters and then prints the number of words that\ndon\u2019t contain any of them.\nCan you find a combination of 5 forbidden letters that\nexcludes the smallest number of words? Exercise\u00a04 Write a function named uses_only that takes a word and a\nstring of letters, and that returns True if the word contains\nonly letters in the list. Can you make a sentence using only the\nletters acefhlo ? Other than \u201cHoe alfalfa\u201d? Exercise\u00a05 Write a function named uses_all that takes a word and a\nstring of required letters, and that returns True if the word\nuses all the required letters at least once. How many words are there\nthat use all the vowels aeiou ? How about aeiouy ? Exercise\u00a06 Write a function called is_abecedarian that returns True if the letters in a word appear in alphabetical order\n(double letters are ok).\nHow many abecedarian words are there? 9.3\u00a0\u00a0Search All of the exercises in the previous section have something\nin common; they can be solved with the search pattern we saw\nin Section 8.6 . The simplest example is: def has_no_e(word):\n    for letter in word:\n        if letter == 'e':\n            return False\n    return True The for loop traverses the characters in word . If we find\nthe letter \u201ce\u201d, we can immediately return False ; otherwise we\nhave to go to the next letter. If we exit the loop normally, that\nmeans we didn\u2019t find an \u201ce\u201d, so we return True . You could write this function more concisely using the in operator, but I started with this version because it\ndemonstrates the logic of the search pattern. avoids is a more general version of has_no_e but it\nhas the same structure: def avoids(word, forbidden):\n    for letter in word:\n        if letter in forbidden:\n            return False\n    return True We can return False as soon as we find a forbidden letter;\nif we get to the end of the loop, we return True . uses_only is similar except that the sense of the condition\nis reversed: def uses_only(word, available):\n    for letter in word:\n        if letter not in available:\n            return False\n    return True Instead of a list of forbidden letters, we have a list of available\nletters. If we find a letter in word that is not in available , we can return False . uses_all is similar except that we reverse the role\nof the word and the string of letters: def uses_all(word, required):\n    for letter in required:\n        if letter not in word:\n            return False\n    return True Instead of traversing the letters in word , the loop\ntraverses the required letters. If any of the required letters\ndo not appear in the word, we can return False . If you were really thinking like a computer scientist, you would\nhave recognized that uses_all was an instance of a\npreviously solved problem, and you would have written: def uses_all(word, required):\n    return uses_only(required, word) This is an example of a program development plan called reduction to a previously solved problem , which means that you\nrecognize the problem you are working on as an instance of a solved\nproblem and apply an existing solution. 9.4\u00a0\u00a0Looping with indices I wrote the functions in the previous section with for loops because I only needed the characters in the strings; I didn\u2019t\nhave to do anything with the indices. For is_abecedarian we have to compare adjacent letters,\nwhich is a little tricky with a for loop: def is_abecedarian(word):\n    previous = word[0]\n    for c in word:\n        if c < previous:\n            return False\n        previous = c\n    return True An alternative is to use recursion: def is_abecedarian(word):\n    if len(word) <= 1:\n        return True\n    if word[0] > word[1]:\n        return False\n    return is_abecedarian(word[1:]) Another option is to use a while loop: def is_abecedarian(word):\n    i = 0\n    while i < len(word)-1:\n        if word[i+1] < word[i]:\n            return False\n        i = i+1\n    return True The loop starts at i=0 and ends when i=len(word)-1 . Each\ntime through the loop, it compares the i th character (which you can\nthink of as the current character) to the i +1th character (which you\ncan think of as the next). If the next character is less than (alphabetically before) the current\none, then we have discovered a break in the abecedarian trend, and\nwe return False . If we get to the end of the loop without finding a fault, then the\nword passes the test. To convince yourself that the loop ends\ncorrectly, consider an example like 'flossy' . The\nlength of the word is 6, so\nthe last time the loop runs is when i is 4, which is the\nindex of the second-to-last character. On the last iteration,\nit compares the second-to-last character to the last, which is\nwhat we want. Here is a version of is_palindrome (see\nExercise 3 ) that uses two indices; one starts at the\nbeginning and goes up; the other starts at the end and goes down. def is_palindrome(word):\n    i = 0\n    j = len(word)-1\n\n    while i<j:\n        if word[i] != word[j]:\n            return False\n        i = i+1\n        j = j-1\n\n    return True Or we could reduce to a previously solved\nproblem and write: def is_palindrome(word):\n    return is_reverse(word, word) Using is_reverse from Section 8.11 . 9.5\u00a0\u00a0Debugging Testing programs is hard. The functions in this chapter are\nrelatively easy to test because you can check the results by hand.\nEven so, it is somewhere between difficult and impossible to choose a\nset of words that test for all possible errors. Taking has_no_e as an example, there are two obvious\ncases to check: words that have an \u2018e\u2019 should return False , and\nwords that don\u2019t should return True . You should have no\ntrouble coming up with one of each. Within each case, there are some less obvious subcases. Among the\nwords that have an \u201ce\u201d, you should test words with an \u201ce\u201d at the\nbeginning, the end, and somewhere in the middle. You should test long\nwords, short words, and very short words, like the empty string. The\nempty string is an example of a special case , which is one of\nthe non-obvious cases where errors often lurk. In addition to the test cases you generate, you can also test\nyour program with a word list like words.txt . By scanning\nthe output, you might be able to catch errors, but be careful:\nyou might catch one kind of error (words that should not be\nincluded, but are) and not another (words that should be included,\nbut aren\u2019t). In general, testing can help you find bugs, but it is not easy to\ngenerate a good set of test cases, and even if you do, you can\u2019t\nbe sure your program is correct.\nAccording to a legendary computer scientist: Program testing can be used to show the presence of bugs, but never to\nshow their absence! \u2014 Edsger W. Dijkstra 9.6\u00a0\u00a0Glossary file object: A value that represents an open file. reduction to a previously solved problem: A way of solving a\nproblem by expressing it as an instance of a previously solved\nproblem. special case: A test case that is atypical or non-obvious\n(and less likely to be handled correctly). 9.7\u00a0\u00a0Exercises Exercise\u00a07 This question is based on a Puzzler that was broadcast on the radio\nprogram Car Talk ( http://www.cartalk.com/content/puzzlers ): Give me a word with three consecutive double letters. I\u2019ll give you a\ncouple of words that almost qualify, but don\u2019t. For example, the word\ncommittee, c-o-m-m-i-t-t-e-e. It would be great except for the \u2018i\u2019 that\nsneaks in there. Or Mississippi: M-i-s-s-i-s-s-i-p-p-i. If you could\ntake out those i\u2019s it would work. But there is a word that has three\nconsecutive pairs of letters and to the best of my knowledge this may\nbe the only word. Of course there are probably 500 more but I can only\nthink of one. What is the word? Write a program to find it.\nSolution: https://thinkpython.com/code/cartalk1.py . Exercise\u00a08 Here\u2019s another Car Talk Puzzler ( http://www.cartalk.com/content/puzzlers ): \u201cI was driving on the highway the other day and I happened to\nnotice my odometer. Like most odometers, it shows six digits,\nin whole miles only. So, if my car had 300,000\nmiles, for example, I\u2019d see 3-0-0-0-0-0. \u201cNow, what I saw that day was very interesting. I noticed that the\nlast 4 digits were palindromic; that is, they read the same forward as\nbackward. For example, 5-4-4-5 is a palindrome, so my odometer\ncould have read 3-1-5-4-4-5. \u201cOne mile later, the last 5 numbers were palindromic. For example, it\ncould have read 3-6-5-4-5-6. One mile after that, the middle 4 out of\n6 numbers were palindromic. And you ready for this? One mile later,\nall 6 were palindromic! \u201cThe question is, what was on the odometer when I first looked?\u201d Write a Python program that tests all the six-digit numbers and prints\nany numbers that satisfy these requirements.\nSolution: https://thinkpython.com/code/cartalk2.py . Exercise\u00a09 Here\u2019s another Car Talk Puzzler you can solve with a\nsearch ( http://www.cartalk.com/content/puzzlers ): \u201cRecently I had a visit with my mom and we realized that\nthe two digits that make up my age when reversed resulted in her\nage. For example, if she\u2019s 73, I\u2019m 37. We wondered how often this has\nhappened over the years but we got sidetracked with other topics and\nwe never came up with an answer. \u201cWhen I got home I figured out that the digits of our ages have been\nreversible six times so far. I also figured out that if we\u2019re lucky it\nwould happen again in a few years, and if we\u2019re really lucky it would\nhappen one more time after that. In other words, it would have\nhappened 8 times over all. So the question is, how old am I now?\u201d Write a Python program that searches for solutions to this Puzzler.\nHint: you might find the string method zfill useful. Solution: https://thinkpython.com/code/cartalk3.py . Buy this book at Amazon.com\n\n#### Contribute\n\nIf you would like to make a contribution to support my books,\nyou can use the button below and pay with PayPal.  Thank you!\nPay what you want:\nSmall $1.00 USD\nMedium $5.00 USD\nLarge $10.00 USD\nX-Large $20.00 USD\nXX-Large $50.00 USD\nAre you using one of our books in a class? We'd like to know\nabout it.  Please consider filling out this short survey . Think DSP Think Java Think Bayes Think Python 2e Think Stats 2e Think Complexity",
      "difficulty": "intro",
      "doc_id": "doc-chapter-9-case-study-word-play-5f128ed3ca",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-NC 3.0",
        "source_file": "data/corpus_raw/thinkpython2_html_thinkpython2010_html_ba8145.json",
        "url": "https://greenteapress.com/thinkpython2/html/thinkpython2010.html"
      },
      "title": "Chapter\u00a09\u00a0\u00a0Case study: word play",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "closures",
        "lambdas",
        "late-binding",
        "loops",
        "scope",
        "variables"
      ],
      "content": "Python uses lexical scoping: inner functions can reference names from enclosing scopes. However, closure variables are often **late-bound**, meaning the name is looked up when the inner function runs, not when it is created.\n\n---\n## 1) The classic pitfall: closures created in a loop\n\n```python\nfuncs = []\nfor i in range(5):\n    funcs.append(lambda: i)\n\nprint([f() for f in funcs])  # often [4, 4, 4, 4, 4]\n```python\n\nAll lambdas refer to the same name `i`, which ends at 4 after the loop.\n\n---\n## 2) Fix pattern A: default argument capture (simple and popular)\nDefault arguments are evaluated when the function is defined.\n\n```python\nfuncs = []\nfor i in range(5):\n    funcs.append(lambda i=i: i)\n\nprint([f() for f in funcs])  # [0, 1, 2, 3, 4]\n```python\n\n---\n## 3) Fix pattern B: helper factory function\n\n```python\ndef make_func(i):\n    def f():\n        return i\n    return f\n\nfuncs = [make_func(i) for i in range(5)]\nprint([f() for f in funcs])  # [0, 1, 2, 3, 4]\n```python\n\n---\n## 4) Fix pattern C: functools.partial\n\n```python\nfrom functools import partial\n\ndef identity(x):\n    return x\n\nfuncs = [partial(identity, i) for i in range(5)]\nprint([f() for f in funcs])  # [0, 1, 2, 3, 4]\n```python\n\n---\n## 5) A chunking-friendly \u201creal use\u201d example\nMake a set of functions that add different offsets.\n\n```python\nadders = []\nfor offset in (0, 10, 100):\n    adders.append(lambda x, offset=offset: x + offset)\n\nprint([f(5) for f in adders])  # [5, 15, 105]\n```python\n\n---\n## 6) Extra: closures with multiple captured names\n\n```python\ndef factory(mult):\n    funcs = []\n    for i in range(3):\n        funcs.append(lambda x, i=i, mult=mult: (x + i) * mult)\n    return funcs\n\nfs = factory(10)\nprint([f(1) for f in fs])  # [10, 20, 30]\n```python\n\n---\n## 7) Practical takeaways\n- If you build lambdas in loops, **assume late binding** unless you capture values explicitly.\n- Default arguments are the shortest \u201cfreeze this value now\u201d technique.",
      "difficulty": "hard",
      "doc_id": "doc-closures-and-late-binding-loop-variable-capture-and-dependable-ways-to-freeze-values-562b6f6f3d",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-SA (Stack Overflow; version depends on post date)",
        "source_file": "data/corpus_raw/variables_hard_3.json",
        "url": "https://stackoverflow.com/questions/2295290/what-do-lambda-function-closures-capture"
      },
      "title": "Closures and late binding: loop variable capture and dependable ways to freeze values",
      "type": "tutorial"
    },
    {
      "ai_generated": true,
      "concept_tags": [
        "caching",
        "closures",
        "function-factory",
        "functions",
        "nested-functions",
        "nonlocal"
      ],
      "content": "Functions can be nested in Python. When an inner function uses variables from the outer scope, it forms a **closure**.\n\n---\n## 1) Nested functions\n\n```python\ndef outer():\n    msg = \"hello\"\n\n    def inner():\n        return msg\n\n    return inner\n\nf = outer()\nprint(f())\n```python\n\n`inner()` still remembers `msg` even after `outer()` has finished.\n\n---\n## 2) Function factory: build functions that customize behavior\n\n```python\ndef make_multiplier(factor):\n    def mul(x):\n        return x * factor\n    return mul\n\nby2 = make_multiplier(2)\nby10 = make_multiplier(10)\n\nprint(by2(7))\nprint(by10(7))\n```python\n\n---\n## 3) Capturing changing state with nonlocal\nIf you want to *modify* a captured variable, use `nonlocal`.\n\n```python\ndef make_counter():\n    count = 0\n\n    def inc():\n        nonlocal count\n        count += 1\n        return count\n\n    return inc\n\nc = make_counter()\nprint(c())\nprint(c())\nprint(c())\n```python\n\n---\n## 4) A realistic closure: configurable validator\n\n```python\ndef make_range_checker(lo, hi):\n    def check(n):\n        return lo <= n <= hi\n    return check\n\nis_age = make_range_checker(0, 120)\nprint(is_age(20))\nprint(is_age(999))\n```python\n\n---\n## 5) Practice block: build a tiny \"memoize\" wrapper (simple caching)\nThis is a gentle intro to decorators without introducing decorator syntax yet.\n\n```python\ndef memoize_1arg(func):\n    cache = {}\n\n    def wrapped(x):\n        if x in cache:\n            return cache[x]\n        cache[x] = func(x)\n        return cache[x]\n\n    return wrapped\n\ndef slow_square(n):\n    # imagine expensive work here\n    return n * n\n\nfast_square = memoize_1arg(slow_square)\nprint(fast_square(10))\nprint(fast_square(10))  # cached\n```",
      "difficulty": "moderate",
      "doc_id": "doc-closures-moderate-inner-functions-nonlocal-state-and-function-factories-ce0632487d",
      "provenance": {
        "author": "",
        "date": "",
        "license": "",
        "source_file": "data/corpus_raw/functions_moderate_5.json",
        "url": ""
      },
      "title": "Closures (moderate): inner functions, nonlocal state, and function factories",
      "type": "tutorial"
    },
    {
      "ai_generated": true,
      "concept_tags": [
        "and",
        "conditionals",
        "guards",
        "not",
        "or",
        "parentheses",
        "readability"
      ],
      "content": "As programs grow, you often combine several checks in one decision. The goal is to keep conditions readable.\n\n---\n## 1) Basic and/or/not\n\n```python\nlogged_in = True\nis_admin = False\n\nif logged_in and is_admin:\n    print(\"admin panel\")\nelse:\n    print(\"regular view\")\n```python\n\n```python\nrole = \"editor\"\n\nif role == \"admin\" or role == \"editor\":\n    print(\"can edit\")\nelse:\n    print(\"read only\")\n```python\n\n```python\nname = \"\"\nif not name:\n    print(\"name required\")\n```python\n\n---\n## 2) Parentheses for clarity\n\n```python\nage = 19\nhas_ticket = True\nvip = False\n\nif (age >= 18 and has_ticket) or vip:\n    print(\"enter\")\nelse:\n    print(\"no entry\")\n```python\n\n---\n## 3) A slightly larger example: validate a password\n\n```python\npwd = \"Abc123\"\n\nhas_len = len(pwd) >= 6\nhas_digit = any(ch.isdigit() for ch in pwd)\nhas_upper = any(ch.isupper() for ch in pwd)\n\nif has_len and has_digit and has_upper:\n    print(\"strong enough\")\nelse:\n    print(\"try again\")\n```",
      "difficulty": "intro",
      "doc_id": "doc-combining-conditions-and-or-not-parentheses-and-readable-checks-271c64265a",
      "provenance": {
        "author": "",
        "date": "",
        "license": "",
        "source_file": "data/corpus_raw/conditionals_easy_5.json",
        "url": ""
      },
      "title": "Combining conditions: and/or/not, parentheses, and readable checks",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "comparisons",
        "conditionals",
        "else",
        "guard-clauses",
        "if",
        "membership",
        "ternary"
      ],
      "content": "Beyond basic if/else, Python has small patterns that make code shorter while staying readable.\n\n---\n## 1) The if-expression (ternary)\nPython supports a compact expression form:\n\n```python\nresult = \"yay\" if 1 < 2 else \"nay\"\nprint(result)\n```python\n\nThis is best used for simple decisions.\n\n---\n## 2) Membership tests with in\n\n```python\nallowed = {\"start\", \"stop\", \"status\"}\ncmd = \"status\"\n\nif cmd in allowed:\n    print(\"ok\")\nelse:\n    print(\"unknown\")\n```python\n\n---\n## 3) Guard clauses (simple early returns)\nIn functions, a clear style is to return early for invalid input.\n\n```python\ndef parse_age(text):\n    text = text.strip()\n    if not text.isdigit():\n        return None\n    return int(text)\n\nprint(parse_age(\" 21 \"))\nprint(parse_age(\"x\"))\n```python\n\n---\n## 4) Comparing multiple conditions cleanly\n\n```python\nx = 10\nif 0 <= x <= 100:\n    print(\"in range\")\n```python\n\n---\n## 5) A slightly larger example: categorize a value\n\n```python\ndef categorize(n):\n    if n < 0:\n        return \"negative\"\n    elif n == 0:\n        return \"zero\"\n    else:\n        return \"positive\"\n\nfor v in [-2, 0, 5]:\n    print(v, categorize(v))\n```",
      "difficulty": "intro",
      "doc_id": "doc-common-conditional-patterns-ternary-if-expression-membership-tests-and-clean-checks-4c1c191966",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-SA 3.0 (Learn X in Y Minutes)",
        "source_file": "data/corpus_raw/conditionals_easy_3.json",
        "url": "https://learnxinyminutes.com/python/"
      },
      "title": "Common conditional patterns: ternary if-expression, membership tests, and clean checks",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "conditional-expression",
        "conditionals",
        "formatting",
        "readability",
        "ternary"
      ],
      "content": "Python supports a compact conditional expression:\n\n`value_if_true if condition else value_if_false`\n\nThis is often called a \u201cternary expression.\u201d It can make code shorter, but it should still remain readable.\n\n---\n## 1) Basic usage\n\n```python\nx = 7\nlabel = \"even\" if x % 2 == 0 else \"odd\"\nprint(label)\n```python\n\n---\n## 2) Prefer it for simple expressions\nA short conditional expression is great for small decisions.\n\n```python\nname = \"\"\ndisplay = name if name else \"(anonymous)\"\nprint(display)\n```python\n\nFor more complex logic, a standard if/elif/else block is easier to maintain.\n\n---\n## 3) Using conditional expressions inside formatting\n\n```python\nscore = 82\nstatus = \"pass\" if score >= 75 else \"fail\"\nprint(f\"score={score} status={status}\")\n```python\n\n---\n## 4) A compact mapping pattern\nSometimes you can replace a short if/else with a mapping, but the conditional expression is still helpful for quick cases.\n\n```python\nn = -3\nsign = \"pos\" if n > 0 else (\"zero\" if n == 0 else \"neg\")\nprint(sign)\n```python\n\n---\n## 5) Practice block: sanitize a value\n\n```python\nraw = \"  42 \"\nclean = raw.strip()\nvalue = int(clean) if clean.isdigit() else None\nprint(value)\n```",
      "difficulty": "moderate",
      "doc_id": "doc-conditional-expressions-using-a-if-cond-else-b-responsibly-37656294f5",
      "provenance": {
        "author": "",
        "date": "",
        "license": "Public domain (PEP text)",
        "source_file": "data/corpus_raw/conditionals_moderate_3.json",
        "url": "https://peps.python.org/pep-0308/"
      },
      "title": "Conditional expressions: using 'a if cond else b' responsibly",
      "type": "reference"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "and-or",
        "comparisons",
        "conditionals",
        "elif",
        "else",
        "if",
        "input-validation",
        "practice"
      ],
      "content": "Conditionals are used to run code only when certain conditions are true. Most beginner programs use conditionals for validation (checking input) and for choosing behavior.\n\n---\n## 1) Basic comparisons\n\n```python\nx = 3\nif x < 5:\n    print(\"small\")\n```python\n\n```python\nname = \"Ana\"\nif name == \"Ana\":\n    print(\"hello\")\nelse:\n    print(\"hi\")\n```python\n\n---\n## 2) Using elif to avoid nesting\n\n```python\ntemp = 22\nif temp < 0:\n    print(\"freezing\")\nelif temp < 15:\n    print(\"cold\")\nelif temp < 25:\n    print(\"warm\")\nelse:\n    print(\"hot\")\n```python\n\n---\n## 3) Combining conditions with and/or\n\n```python\nage = 20\nmember = True\n\nif age >= 18 and member:\n    print(\"allowed\")\nelse:\n    print(\"not allowed\")\n```python\n\n---\n## 4) A password attempt example (typical beginner pattern)\n\n```python\npassword = \"unicorn\"\ntries = 0\n\nwhile True:\n    guess = input(\"Password: \")\n    if guess == password:\n        print(\"success\")\n        break\n\n    tries += 1\n    if tries >= 3:\n        print(\"denied\")\n        break\n```python\n\n---\n## 5) Practice: compare sums\n\n```python\na = 40\nb = 70\n\nif a + b > 100:\n    print(\"big number\")\nelse:\n    print(\"not big\")\n```",
      "difficulty": "intro",
      "doc_id": "doc-conditional-statements-comparisons-elif-chains-and-simple-input-based-decisions-6e8ed35909",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-SA 4.0 (Wikibooks) / also dual-licensed with GFDL per Wikibooks policy",
        "source_file": "data/corpus_raw/conditionals_easy_2.json",
        "url": "https://en.wikibooks.org/wiki/Python_Programming/Conditional_Statements"
      },
      "title": "Conditional statements: comparisons, elif chains, and simple input-based decisions",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "blocks",
        "comparisons",
        "conditionals",
        "elif",
        "else",
        "if",
        "indentation",
        "truthiness"
      ],
      "content": "Conditionals let your program choose different actions based on data. In Python, the basic tools are `if`, `elif`, and `else`.\n\n---\n## 1) The simplest if-statement\n\n```python\nx = 10\nif x > 5:\n    print(\"x is bigger than 5\")\n```python\n\nPython uses **indentation** to define the block (the code controlled by the `if`).\n\n---\n## 2) if/else: choose between two paths\n\n```python\nage = 17\nif age >= 18:\n    print(\"adult\")\nelse:\n    print(\"minor\")\n```python\n\n---\n## 3) elif: multiple choices\nUse `elif` to avoid deeply nested `if` statements.\n\n```python\nscore = 82\nif score >= 90:\n    grade = \"A\"\nelif score >= 80:\n    grade = \"B\"\nelif score >= 70:\n    grade = \"C\"\nelse:\n    grade = \"D\"\n\nprint(\"grade\", grade)\n```python\n\n---\n## 4) Comparing the same value to several constants\n\n```python\ncmd = \"start\"\n\nif cmd == \"start\":\n    print(\"starting\")\nelif cmd == \"stop\":\n    print(\"stopping\")\nelif cmd == \"status\":\n    print(\"show status\")\nelse:\n    print(\"unknown command\")\n```python\n\n---\n## 5) Truthiness: if checks a truth value\nMany expressions can be used directly in `if`.\n\n```python\nitems = []\nif items:\n    print(\"has items\")\nelse:\n    print(\"empty\")\n\nname = \"\"\nif not name:\n    print(\"missing name\")\n```python\n\n---\n## 6) A small practice script: validate and respond\n\n```python\ntext = \"42\"\n\nif text.isdigit():\n    n = int(text)\n    if n % 2 == 0:\n        print(\"even\")\n    else:\n        print(\"odd\")\nelse:\n    print(\"not a number\")\n```",
      "difficulty": "intro",
      "doc_id": "doc-conditionals-in-python-if-elif-else-blocks-and-readable-decision-logic-a5516b23d9",
      "provenance": {
        "author": "",
        "date": "",
        "license": "PSF Documentation License; code examples are dual-licensed (PSF-2.0 and BSD-0 starting Python 3.8.6+)",
        "source_file": "data/corpus_raw/conditionals_easy_1.json",
        "url": "https://docs.python.org/3/tutorial/controlflow.html"
      },
      "title": "Conditionals in Python: if/elif/else, blocks, and readable decision logic",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "assert",
        "debugging",
        "defaults",
        "functions",
        "parameters",
        "return",
        "testing"
      ],
      "content": "A practical way to learn functions is to write small, single-purpose helpers and then test them quickly.\n\n---\n## 1) Start simple: a function that transforms data\n\n```python\ndef normalize_name(name):\n    return name.strip().title()\n\nprint(normalize_name(\"  aNa  \"))\n```python\n\n---\n## 2) Add parameters to generalize behavior\n\n```python\ndef repeat(text, times):\n    return text * times\n\nprint(repeat(\"ha\", 3))\n```python\n\n---\n## 3) Return values instead of printing\nReturning makes functions easier to reuse.\n\n```python\ndef perimeter_rectangle(w, h):\n    return 2 * (w + h)\n\np = perimeter_rectangle(3, 4)\nprint(p)\n```python\n\n---\n## 4) Default parameter values\nDefaults reduce clutter in calls.\n\n```python\ndef greet(name, punctuation=\"!\"):\n    return \"Hello \" + name + punctuation\n\nprint(greet(\"Ana\"))\nprint(greet(\"Ana\", \"...\"))\n```python\n\n---\n## 5) Quick tests (lightweight)\nA simple \u201cassert\u201d can confirm a function behaves as expected.\n\n```python\ndef add_tax(price, rate=0.12):\n    return price * (1 + rate)\n\nassert add_tax(100) == 112\nassert add_tax(100, 0.10) == 110\nprint(\"tests passed\")\n```python\n\n---\n## 6) A bigger example: build a small pipeline\n\n```python\ndef parse_ints(tokens):\n    out = []\n    for t in tokens:\n        s = str(t).strip()\n        if s.isdigit():\n            out.append(int(s))\n    return out\n\ndef mean(nums):\n    if not nums:\n        return None\n    return sum(nums) / len(nums)\n\nraw = [\"10\", \"x\", \" 5 \", \"-\", 7]\nnums = parse_ints(raw)\nprint(\"nums\", nums)\nprint(\"mean\", mean(nums))\n```",
      "difficulty": "intro",
      "doc_id": "doc-creating-functions-easy-small-reusable-pieces-defaults-and-quick-tests-1a947f02ed",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY 4.0 (The Carpentries lesson material)",
        "source_file": "data/corpus_raw/functions_easy_3.json",
        "url": "https://carpentries-incubator.github.io/python-novice-programming-gapminder/08-func/index.html"
      },
      "title": "Creating functions (easy): small reusable pieces, defaults, and quick tests",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "assignment",
        "input",
        "nameerror",
        "naming",
        "snake_case",
        "type-conversion",
        "unpacking",
        "variables"
      ],
      "content": "Python does not require variable declarations. A variable is created when you assign to it.\n\n---\n## 1) Variables are created by assignment\n\n```python\nsome_var = 5\nprint(some_var)      # 5\n\nsome_var = some_var + 10\nprint(some_var)      # 15\n```python\n\n---\n## 2) Naming: use snake_case\nReadable names reduce mistakes and make code easier to scan.\n\n```python\nuser_age = 20\nmax_retries = 3\npi_estimate = 3.14\n\nprint(user_age, max_retries, pi_estimate)\n```python\n\n---\n## 3) Accessing an unassigned name raises NameError\n\n```python\nvalue = 10\nprint(value)\n\n# print(vaule)  # NameError (typo)\n```python\n\n---\n## 4) Input returns a string (convert when needed)\n\n```python\nraw = input(\"Enter a number: \")\nprint(type(raw))   # <class 'str'>\n\nn = int(raw)\nprint(n + 1)\n```python\n\nIf conversion fails, you\u2019ll get a ValueError. A safe beginner-friendly pattern:\n\n```python\nraw = input(\"Enter an integer: \")\nif raw.isdigit():\n    n = int(raw)\n    print(\"OK:\", n)\nelse:\n    print(\"Not an integer:\", raw)\n```python\n\n---\n## 5) Quick patterns that feel like \u201cvariable tools\u201d\n### Swap two variables\n\n```python\na = \"left\"\nb = \"right\"\na, b = b, a\nprint(a, b)  # right left\n```python\n\n### Multiple assignment (unpacking)\n\n```python\nx, y, z = 1, 2, 3\nprint(x, y, z)\n```python\n\n---\n## 6) Mini practice: predict the output\n\n```python\nx = 1\nx = x + 2\n\ny = x\nx = 50\n\nprint(\"x\", x)\nprint(\"y\", y)\n\nx, y = y, x\nprint(\"swap\", x, y)\n```",
      "difficulty": "intro",
      "doc_id": "doc-creating-variables-by-assignment-naming-input-and-common-errors-af2dd8ed46",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-SA 3.0 (Learn X in Y Minutes docs)",
        "source_file": "data/corpus_raw/variables_easy_2.json",
        "url": "https://learnxinyminutes.com/python/"
      },
      "title": "Creating variables by assignment: naming, input, and common errors",
      "type": "tutorial"
    },
    {
      "ai_generated": true,
      "concept_tags": [
        "decorator-factory",
        "decorators",
        "functions",
        "retry",
        "validation",
        "wraps"
      ],
      "content": "A decorator that accepts arguments is typically a **decorator factory**: a function that returns a decorator.\n\n---\n## 1) Goal: @repeat(n=3)\nWe want this style:\n\n```python\n@repeat(n=3)\ndef shout(text):\n    return text.upper()\n```python\n\n---\n## 2) Implementation using a factory + wraps\n\n```python\nimport functools\n\ndef repeat(*, n=2):\n    if n < 1:\n        raise ValueError(\"n must be >= 1\")\n\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            last = None\n            for _ in range(n):\n                last = func(*args, **kwargs)\n            return last\n        return wrapper\n\n    return decorator\n\n@repeat(n=3)\ndef shout(text):\n    return text.upper()\n\nprint(shout(\"hi\"))\n```python\n\n---\n## 3) A more practical example: retry on exceptions\n\n```python\nimport functools\n\ndef retry(*, tries=3, exceptions=(Exception,)):\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            last_err = None\n            for _ in range(tries):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_err = e\n            raise last_err\n        return wrapper\n    return decorator\n\ncounter = {\"n\": 0}\n\n@retry(tries=3, exceptions=(ValueError,))\ndef flaky():\n    counter[\"n\"] += 1\n    if counter[\"n\"] < 3:\n        raise ValueError(\"not yet\")\n    return \"ok\"\n\nprint(flaky())\n```",
      "difficulty": "hard",
      "doc_id": "doc-decorator-factories-hard-writing-decorators-that-accept-arguments-safely-4ccdf84500",
      "provenance": {
        "author": "",
        "date": "",
        "license": "",
        "source_file": "data/corpus_raw/functions_hard_4.json",
        "url": ""
      },
      "title": "Decorator factories (hard): writing decorators that accept arguments safely",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "classmethod",
        "decorators",
        "functions",
        "methods",
        "pep-318",
        "stacking",
        "staticmethod",
        "wrapping"
      ],
      "content": "Decorators are a way to transform a function (or method) at definition time. The `@decorator` syntax makes transformations explicit and keeps them close to the function they affect.\n\n---\n## 1) Mental model: @decorator rewrites the function binding\nConceptually, this:\n\n```python\n@decorator\ndef f(x):\n    return x + 1\n```python\n\nis like:\n\n```python\ndef f(x):\n    return x + 1\n\nf = decorator(f)\n```python\n\nThis \u201crebinding\u201d happens when the function definition is executed.\n\n---\n## 2) A simple decorator: log calls\n\n```python\ndef log_calls(func):\n    def wrapper(*args, **kwargs):\n        print(\"calling\", func.__name__, args, kwargs)\n        result = func(*args, **kwargs)\n        print(\"returned\", result)\n        return result\n    return wrapper\n\n@log_calls\ndef add(a, b):\n    return a + b\n\nprint(add(2, 3))\n```python\n\n---\n## 3) Stacking decorators (order matters)\n\n```python\ndef d1(func):\n    def w(*a, **k):\n        print(\"d1 before\")\n        r = func(*a, **k)\n        print(\"d1 after\")\n        return r\n    return w\n\ndef d2(func):\n    def w(*a, **k):\n        print(\"d2 before\")\n        r = func(*a, **k)\n        print(\"d2 after\")\n        return r\n    return w\n\n@d1\n@d2\ndef work():\n    print(\"work\")\n\nwork()\n```python\n\nThink of it as:\n\n```python\n# roughly\nwork = d1(d2(work))\n```python\n\n---\n## 4) Decorators are common for method transformations\nA classic motivation is avoiding \u201cwrap then assign\u201d patterns for things like `staticmethod` / `classmethod`.\n\n```python\nclass C:\n    @staticmethod\n    def f(x):\n        return x * 2\n\nprint(C.f(10))\n```python\n\n---\n## 5) A bigger example: permission check decorator\n\n```python\ndef require_admin(func):\n    def wrapper(user, *args, **kwargs):\n        if user.get(\"role\") != \"admin\":\n            raise PermissionError(\"admin only\")\n        return func(user, *args, **kwargs)\n    return wrapper\n\n@require_admin\ndef delete_post(user, post_id):\n    return f\"deleted {post_id}\"\n\nadmin = {\"role\": \"admin\"}\nguest = {\"role\": \"guest\"}\n\nprint(delete_post(admin, 123))\n# delete_post(guest, 123) would raise PermissionError\n```",
      "difficulty": "hard",
      "doc_id": "doc-decorators-hard-what-decorator-means-stacking-decorators-and-readable-function-transformations-7abd2d614e",
      "provenance": {
        "author": "",
        "date": "",
        "license": "Public domain (PEP text)",
        "source_file": "data/corpus_raw/functions_hard_1.json",
        "url": "https://peps.python.org/pep-0318/"
      },
      "title": "Decorators (hard): what @decorator means, stacking decorators, and readable function transformations",
      "type": "reference"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "break",
        "continue",
        "dicts",
        "enumerate",
        "for",
        "items",
        "loops",
        "parsing"
      ],
      "content": "Loops are most useful when they help you *process collections* (lists, strings, dictionaries) and build outputs.\n\n---\n## 1) Loop over a string\n\n```python\nfor ch in \"hello\":\n    print(ch)\n```python\n\n---\n## 2) Loop over a list and build a new list\n\n```python\nnums = [1, 2, 3, 4]\nsquares = []\n\nfor n in nums:\n    squares.append(n * n)\n\nprint(squares)  # [1, 4, 9, 16]\n```python\n\n---\n## 3) enumerate(): loop with index and value\n\n```python\nitems = [\"a\", \"b\", \"c\"]\nfor i, v in enumerate(items):\n    print(i, v)\n```python\n\nYou can start indices at 1:\n\n```python\nfor i, v in enumerate(items, start=1):\n    print(i, v)\n```python\n\n---\n## 4) Loop over dictionaries\nLoop over keys:\n\n```python\nm = {\"a\": 1, \"b\": 2}\nfor k in m:\n    print(k, m[k])\n```python\n\nLoop over key/value pairs:\n\n```python\nfor k, v in m.items():\n    print(k, v)\n```python\n\n---\n## 5) break and continue in a simple filter\n\n```python\nnums = [2, 4, 0, 6, 8]\n\nfor n in nums:\n    if n == 0:\n        print(\"stop at zero\")\n        break\n    if n % 4 != 0:\n        continue\n    print(\"multiple of 4:\", n)\n```python\n\n---\n## 6) A small practice script: sum only valid integers\n\n```python\ndata = [\"10\", \"x\", \"3\", \"-\", \"7\"]\n\ns = 0\nfor token in data:\n    if token.isdigit():\n        s += int(token)\n\nprint(\"sum\", s)  # 20\n```",
      "difficulty": "intro",
      "doc_id": "doc-everyday-loop-patterns-iterating-lists-dicts-enumerate-and-building-results-ec0531db99",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-SA 3.0 (Learn X in Y Minutes)",
        "source_file": "data/corpus_raw/loops_easy_3.json",
        "url": "https://learnxinyminutes.com/python/"
      },
      "title": "Everyday loop patterns: iterating lists, dicts, enumerate, and building results",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "assignment",
        "errors",
        "extended-unpacking",
        "parsing",
        "unpacking",
        "variables"
      ],
      "content": "Extended iterable unpacking lets you capture \u201cthe remaining items\u201d in a sequence using a starred target. This is extremely useful when parsing structured data like lines, tokens, or tuples.\n\n---\n## 1) First/rest pattern\n\n```python\nfirst, *rest = [10, 20, 30, 40]\nprint(first)  # 10\nprint(rest)   # [20, 30, 40]\n```python\n\n---\n## 2) Head/middle/tail pattern\n\n```python\nhead, *middle, tail = (1, 2, 3, 4, 5)\nprint(head)    # 1\nprint(middle)  # [2, 3, 4]\nprint(tail)    # 5\n```python\n\n---\n## 3) Practical parsing example (tokenizing)\n\n```python\ncmd = \"git commit -m 'hello'\".split()\nprogram, subcmd, *args = cmd\n\nprint(program)  # git\nprint(subcmd)   # commit\nprint(args)     # ['-m', \"'hello'\"]\n```python\n\n---\n## 4) Nested unpacking (moderate complexity)\n\n```python\nrecord = (\"user1\", (10, 20), [\"admin\", \"active\"])\nname, (x, y), flags = record\nprint(name, x, y, flags)\n```python\n\n---\n## 5) Common errors to recognize\n### Too many values to unpack\n\n```python\n# a, b = (1, 2, 3)  # ValueError: too many values to unpack\n```python\n\n### Not enough values to unpack\n\n```python\n# a, b, c = (1, 2)  # ValueError: not enough values to unpack\n```python\n\n### Only one starred target is allowed\n\n```python\n# a, *b, *c = range(5)  # invalid\n```python\n\n---\n## 6) A chunk-friendly \u201cmany shapes\u201d practice section\n\n```python\nvalues = [1, 2, 3, 4]\na, *b, c = values\nprint(a, b, c)  # 1 [2, 3] 4\n```python\n\n```python\npair = (\"x\", 1)\nkey, val = pair\nprint(key, val)\n```python\n\n```python\nletters = \"ABCDE\"\n*prefix, last = letters\nprint(prefix, last)  # ['A','B','C','D'] E\n```",
      "difficulty": "moderate",
      "doc_id": "doc-extended-unpacking-rest-splitting-sequences-safe-patterns-and-common-errors-595c1e439b",
      "provenance": {
        "author": "",
        "date": "",
        "license": "Public domain (PEP text)",
        "source_file": "data/corpus_raw/variables_moderate_3.json",
        "url": "https://peps.python.org/pep-3132/"
      },
      "title": "Extended unpacking (*rest): splitting sequences, safe patterns, and common errors",
      "type": "reference"
    },
    {
      "ai_generated": true,
      "concept_tags": [
        "args",
        "defaults",
        "functions",
        "keyword-only",
        "kwargs"
      ],
      "content": "Sometimes you want a function that can accept a variable number of inputs. Python supports this with `*args` and `**kwargs`.\n\n---\n## 1) *args collects extra positional arguments into a tuple\n\n```python\ndef add_many(*args):\n    total = 0\n    for n in args:\n        total += n\n    return total\n\nprint(add_many(1, 2, 3))\nprint(add_many(10))\nprint(add_many())\n```python\n\n---\n## 2) **kwargs collects extra keyword arguments into a dict\n\n```python\ndef show_fields(**kwargs):\n    for k, v in kwargs.items():\n        print(k, \"=\", v)\n\nshow_fields(name=\"Ana\", age=20)\n```python\n\n---\n## 3) Mix normal params + *args + **kwargs\n\n```python\ndef user_info(name, age=18, *skills, **extra):\n    return {\n        \"name\": name,\n        \"age\": age,\n        \"skills\": list(skills),\n        \"extra\": dict(extra),\n    }\n\nprint(user_info(\"Ben\", 20, \"Python\", \"Django\", city=\"Manila\"))\n```python\n\n---\n## 4) Keyword-only parameters (easy intro)\nA `*` in the signature can force parameters to be passed by name.\n\n```python\ndef greet(*, name):\n    return \"Hello \" + name\n\nprint(greet(name=\"Ana\"))\n# greet(\"Ana\") would be an error because name is keyword-only\n```",
      "difficulty": "intro",
      "doc_id": "doc-flexible-function-inputs-easy-args-kwargs-and-keyword-only-parameters-b887e583fa",
      "provenance": {
        "author": "",
        "date": "",
        "license": "",
        "source_file": "data/corpus_raw/functions_easy_4.json",
        "url": ""
      },
      "title": "Flexible function inputs (easy): *args, **kwargs, and keyword-only parameters",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "args",
        "defaults",
        "functions",
        "keyword-arguments",
        "keyword-only",
        "kwargs",
        "mutable-defaults",
        "parameters",
        "positional-only"
      ],
      "content": "At moderate difficulty, functions become more about designing clean APIs: deciding which arguments are required, which are optional, and how callers are allowed to pass them.\n\n---\n## 1) Default argument values\nDefaults make an argument optional.\n\n```python\ndef power(base, exp=2):\n    return base ** exp\n\nprint(power(3))     # 9\nprint(power(3, 3))  # 27\n```python\n\n---\n## 2) Keyword arguments\nCalling with keywords improves readability and allows flexible ordering.\n\n```python\ndef format_user(name, age, city):\n    return f\"{name} ({age}) from {city}\"\n\nprint(format_user(age=20, city=\"Manila\", name=\"Ana\"))\n```python\n\n---\n## 3) Mixing positional and keyword arguments (common pattern)\nPositional first, then keyword.\n\n```python\ndef banner(text, width=10, fill=\"-\"):\n    if len(text) >= width:\n        return text\n    pad = width - len(text)\n    left = pad // 2\n    right = pad - left\n    return fill * left + text + fill * right\n\nprint(banner(\"hi\"))\nprint(banner(\"hi\", width=12, fill=\"*\"))\n```python\n\n---\n## 4) *args and **kwargs\n`*args` collects extra positional arguments; `**kwargs` collects extra keyword arguments.\n\n```python\ndef add_many(*args):\n    total = 0\n    for n in args:\n        total += n\n    return total\n\nprint(add_many(1, 2, 3))\n```python\n\n```python\ndef show_fields(**kwargs):\n    for k, v in kwargs.items():\n        print(k, \"=\", v)\n\nshow_fields(name=\"Ana\", age=20)\n```python\n\n---\n## 5) Special parameters: positional-only (/) and keyword-only (*)\nPython supports marking parameters as:\n- **positional-only**: must be passed by position (left of `/`)\n- **keyword-only**: must be passed by keyword (right of `*`)\n\n```python\n# a and b are positional-only\n# c and d are positional-or-keyword\n# e and f are keyword-only\n\ndef f(a, b, /, c, d, *, e, f):\n    return a, b, c, d, e, f\n\nprint(f(1, 2, 3, d=4, e=5, f=6))\n# f(a=1, b=2, ...) would fail because a and b are positional-only\n```python\n\nKeyword-only example:\n\n```python\ndef greet(name, *, punctuation=\"!\"):\n    return \"Hello \" + name + punctuation\n\nprint(greet(\"Ana\", punctuation=\"...\"))\n# greet(\"Ana\", \"...\") would fail because punctuation is keyword-only\n```python\n\n---\n## 6) Default value gotcha (preview): defaults are evaluated once\nThis matters when the default is mutable.\n\n```python\ndef append_item(x, items=[]):\n    items.append(x)\n    return items\n\nprint(append_item(1))\nprint(append_item(2))  # keeps growing across calls\n```python\n\nA common safe pattern is using None:\n\n```python\ndef append_item(x, items=None):\n    if items is None:\n        items = []\n    items.append(x)\n    return items\n\nprint(append_item(1))\nprint(append_item(2))\n```",
      "difficulty": "moderate",
      "doc_id": "doc-function-parameters-moderate-defaults-keyword-args-args-kwargs-and-special-parameters-930de72751",
      "provenance": {
        "author": "",
        "date": "",
        "license": "PSF Documentation License; code examples in docs are dual-licensed (PSF-2.0 and BSD-0 starting Python 3.8.6+)",
        "source_file": "data/corpus_raw/functions_moderate_1.json",
        "url": "https://docs.python.org/3/tutorial/controlflow.html"
      },
      "title": "Function parameters (moderate): defaults, keyword args, *args/**kwargs, and / + * special parameters",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "arguments",
        "callables",
        "functions",
        "locals",
        "parameters",
        "pure-functions",
        "scope"
      ],
      "content": "A function is a callable piece of code that can accept arguments and optionally return a value.\n\n---\n## 1) A function as a reusable \u201crecipe\u201d\n\n```python\ndef headline(text):\n    return text.strip().title()\n\nprint(headline(\"  hello world  \"))\nprint(headline(\"python functions\"))\n```python\n\n---\n## 2) Parameters vs arguments\n- **Parameters**: names in the function definition\n- **Arguments**: actual values passed in calls\n\n```python\ndef multiply(a, b):\n    return a * b\n\nprint(multiply(6, 7))\n```python\n\n---\n## 3) Local variables live inside the function\nVariables created inside a function normally exist only within that function.\n\n```python\nx = \"global\"\n\ndef demo():\n    x = \"local\"\n    return x\n\nprint(demo())\nprint(x)\n```python\n\n---\n## 4) Pure functions (easy-to-test)\nA pure-style function depends only on inputs and returns outputs (no hidden state).\n\n```python\ndef clamp(n, lo, hi):\n    if n < lo:\n        return lo\n    if n > hi:\n        return hi\n    return n\n\nprint(clamp(5, 0, 10))\nprint(clamp(-2, 0, 10))\nprint(clamp(99, 0, 10))\n```python\n\n---\n## 5) A slightly larger example: compute basic stats\n\n```python\ndef stats(nums):\n    if not nums:\n        return None\n    return {\n        \"count\": len(nums),\n        \"min\": min(nums),\n        \"max\": max(nums),\n        \"sum\": sum(nums),\n        \"avg\": sum(nums) / len(nums),\n    }\n\nprint(stats([10, 20, 30]))\nprint(stats([]))\n```",
      "difficulty": "intro",
      "doc_id": "doc-functions-as-callables-easy-inputs-outputs-and-simple-scoping-intuition-204adfda5a",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-SA 4.0 (Wikibooks) / also dual-licensed with GFDL per Wikibooks policy",
        "source_file": "data/corpus_raw/functions_easy_2.json",
        "url": "https://en.wikibooks.org/wiki/Python_Programming/Functions"
      },
      "title": "Functions as callables (easy): inputs, outputs, and simple scoping intuition",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "generator-expressions",
        "generators",
        "lazy-evaluation",
        "loops",
        "memory-efficiency",
        "pipelines"
      ],
      "content": "Generator expressions are a compact way to build a lazy iterator. They often replace loops that \u201cbuild a list just to consume it once.\u201d\n\n---\n## 1) Generator expression vs list comprehension\nList comprehensions build the whole list immediately:\n\n```python\nsquares_list = [x * x for x in range(10)]\nprint(squares_list)\n```python\n\nGenerator expressions are lazy (produce items on demand):\n\n```python\nsquares_gen = (x * x for x in range(10))\nprint(squares_gen)          # generator object\nprint(next(squares_gen))    # 0\nprint(next(squares_gen))    # 1\n```python\n\n---\n## 2) Common \u201creduce\u201d patterns: sum/min/max\nA classic use is feeding a generator directly into a reducer.\n\n```python\nlines = [\"a\", \"abcd\", \"xy\", \"\"]\n\nlongest = max((len(line) for line in lines if line))\nprint(longest)  # 4\n```python\n\n```python\nnums = [1, 2, 3, 4]\nprint(sum(n * n for n in nums))  # 30\n```python\n\n---\n## 3) One-pass behavior (easy to forget)\nOnce you consume a generator, it\u2019s exhausted.\n\n```python\ng = (x for x in range(3))\nprint(list(g))  # [0, 1, 2]\nprint(list(g))  # []\n```python\n\nIf you need two passes, recreate it:\n\n```python\nprint(list(x for x in range(3)))\nprint(list(x for x in range(3)))\n```python\n\n---\n## 4) Nested generator expressions (powerful but can get dense)\n\n```python\npairs = ((a, b) for a in range(3) for b in range(3) if a != b)\nprint(list(pairs))\n```python\n\n---\n## 5) A readable pipeline-style example\n\n```python\ntext = [\"10\", \"x\", \"5\", \"-\", \"7\"]\n\nnums = (int(t) for t in text if t.isdigit())\nprint(sum(nums))\n```python\n\n---\n## 6) Practical takeaways\n- Generator expressions are great for large inputs.\n- They are lazy and single-pass.\n- Keep them readable; if it becomes too dense, expand into a generator function or a loop.",
      "difficulty": "hard",
      "doc_id": "doc-generator-expressions-lazy-looping-one-pass-behavior-and-common-patterns-2bd4b01471",
      "provenance": {
        "author": "",
        "date": "",
        "license": "Public domain (PEP text)",
        "source_file": "data/corpus_raw/loops_hard_3.json",
        "url": "https://peps.python.org/pep-0289/"
      },
      "title": "Generator expressions: lazy looping, one-pass behavior, and common patterns",
      "type": "reference"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "OOP",
        "data_types",
        "functions",
        "scope",
        "variables"
      ],
      "content": "# Glossary\u00c2\u00b6\n\n`>>>`\n\u00c2\u00b6\nThe default Python prompt of the interactive shell.  Often\nseen for code examples which can be executed interactively in the\ninterpreter.\n\n`...`\n\u00c2\u00b6\nCan refer to:\n\n- The default Python prompt of the interactive shell when entering the\ncode for an indented code block, when within a pair of matching left and\nright delimiters (parentheses, square brackets, curly braces or triple\nquotes), or after specifying a decorator.\n\n- The three dots form of the Ellipsis object.\n\nabstract base class\n\u00c2\u00b6\nAbstract base classes complement duck-typing by\nproviding a way to define interfaces when other techniques like hasattr() would be clumsy or subtly wrong (for example with magic methods ).  ABCs introduce virtual\nsubclasses, which are classes that don\u00e2\u0080\u0099t inherit from a class but are\nstill recognized by isinstance() and issubclass() ; see the abc module documentation.  Python comes with many built-in ABCs for\ndata structures (in the collections.abc module), numbers (in the numbers module), streams (in the io module), import finders\nand loaders (in the importlib.abc module).  You can create your own\nABCs with the abc module.\n\nannotate function\n\u00c2\u00b6\nA function that can be called to retrieve the annotations of an object. This function is accessible as the __annotate__ attribute of functions, classes, and modules. Annotate functions are a\nsubset of evaluate functions .\n\nannotation\n\u00c2\u00b6\nA label associated with a variable, a class\nattribute or a function parameter or return value,\nused by convention as a type hint .\n\nAnnotations of local variables cannot be accessed at runtime, but\nannotations of global variables, class attributes, and functions\ncan be retrieved by calling annotationlib.get_annotations() on modules, classes, and functions, respectively.\n\nSee variable annotation , function annotation , PEP 484 , PEP 526 , and PEP 649 , which describe this functionality.\nAlso see Annotations Best Practices for best practices on working with annotations.\n\nargument\n\u00c2\u00b6\nA value passed to a function (or method ) when calling the\nfunction.  There are two kinds of argument:\n\n- keyword argument : an argument preceded by an identifier (e.g. name= ) in a function call or passed as a value in a dictionary\npreceded by ** .  For example, 3 and 5 are both keyword\narguments in the following calls to complex() : complex ( real = 3 , imag = 5 ) complex ( ** { 'real' : 3 , 'imag' : 5 })\n- positional argument : an argument that is not a keyword argument.\nPositional arguments can appear at the beginning of an argument list\nand/or be passed as elements of an iterable preceded by * .\nFor example, 3 and 5 are both positional arguments in the\nfollowing calls: complex ( 3 , 5 ) complex ( * ( 3 , 5 ))\n\nArguments are assigned to the named local variables in a function body.\nSee the Calls section for the rules governing this assignment.\nSyntactically, any expression can be used to represent an argument; the\nevaluated value is assigned to the local variable.\n\nSee also the parameter glossary entry, the FAQ question on the difference between arguments and parameters , and PEP 362 .\n\nasynchronous context manager\n\u00c2\u00b6\nAn object which controls the environment seen in an async with statement by defining __aenter__() and __aexit__() methods.  Introduced by PEP 492 .\n\nasynchronous generator\n\u00c2\u00b6\nA function which returns an asynchronous generator iterator .  It\nlooks like a coroutine function defined with async def except\nthat it contains yield expressions for producing a series of\nvalues usable in an async for loop.\n\nUsually refers to an asynchronous generator function, but may refer to an asynchronous generator iterator in some contexts.  In cases where the\nintended meaning isn\u00e2\u0080\u0099t clear, using the full terms avoids ambiguity.\n\nAn asynchronous generator function may contain await expressions as well as async for , and async with statements.\n\nasynchronous generator iterator\n\u00c2\u00b6\nAn object created by an asynchronous generator function.\n\nThis is an asynchronous iterator which when called using the __anext__() method returns an awaitable object which will execute\nthe body of the asynchronous generator function until the next yield expression.\n\nEach yield temporarily suspends processing, remembering the\nexecution state (including local variables and pending\ntry-statements).  When the asynchronous generator iterator effectively\nresumes with another awaitable returned by __anext__() , it\npicks up where it left off.  See PEP 492 and PEP 525 .\n\nasynchronous iterable\n\u00c2\u00b6\nAn object, that can be used in an async for statement.\nMust return an asynchronous iterator from its __aiter__() method.  Introduced by PEP 492 .\n\nasynchronous iterator\n\u00c2\u00b6\nAn object that implements the __aiter__() and __anext__() methods. __anext__() must return an awaitable object. async for resolves the awaitables returned by an asynchronous\niterator\u00e2\u0080\u0099s __anext__() method until it raises a StopAsyncIteration exception.  Introduced by PEP 492 .\n\natomic operation\n\u00c2\u00b6\nAn operation that appears to execute as a single, indivisible step: no\nother thread can observe it half-done, and its effects become visible all\nat once.  Python does not guarantee that high-level statements are atomic\n(for example, x += 1 performs multiple bytecode operations and is not\natomic).  Atomicity is only guaranteed where explicitly documented.  See\nalso race condition and data race .\n\nattached thread state\n\u00c2\u00b6\nA thread state that is active for the current OS thread.\n\nWhen a thread state is attached, the OS thread has\naccess to the full Python C API and can safely invoke the\nbytecode interpreter.\n\nUnless a function explicitly notes otherwise, attempting to call\nthe C API without an attached thread state will result in a fatal\nerror or undefined behavior.  A thread state can be attached and detached\nexplicitly by the user through the C API, or implicitly by the runtime,\nincluding during blocking C calls and by the bytecode interpreter in between\ncalls.\n\nOn most builds of Python, having an attached thread state implies that the\ncaller holds the GIL for the current interpreter, so only\none OS thread can have an attached thread state at a given moment. In free-threaded builds of Python, threads can\nconcurrently hold an attached thread state, allowing for true parallelism of\nthe bytecode interpreter.\n\nattribute\n\u00c2\u00b6\nA value associated with an object which is usually referenced by name\nusing dotted expressions.\nFor example, if an object o has an attribute a it would be referenced as o.a .\n\nIt is possible to give an object an attribute whose name is not an\nidentifier as defined by Names (identifiers and keywords) , for example using setattr() , if the object allows it.\nSuch an attribute will not be accessible using a dotted expression,\nand would instead need to be retrieved with getattr() .\n\nawaitable\n\u00c2\u00b6\nAn object that can be used in an await expression.  Can be\na coroutine or an object with an __await__() method.\nSee also PEP 492 .\n\nBDFL\n\u00c2\u00b6\nBenevolent Dictator For Life, a.k.a. Guido van Rossum , Python\u00e2\u0080\u0099s creator.\n\nbinary file\n\u00c2\u00b6\nA file object able to read and write bytes-like objects .\nExamples of binary files are files opened in binary mode ( 'rb' , 'wb' or 'rb+' ), sys.stdin.buffer , sys.stdout.buffer , and instances of io.BytesIO and gzip.GzipFile .\n\nSee also text file for a file object able to read and write str objects.\n\nborrowed reference\n\u00c2\u00b6\nIn Python\u00e2\u0080\u0099s C API, a borrowed reference is a reference to an object,\nwhere the code using the object does not own the reference.\nIt becomes a dangling\npointer if the object is destroyed. For example, a garbage collection can\nremove the last strong reference to the object and so destroy it.\n\nCalling Py_INCREF() on the borrowed reference is\nrecommended to convert it to a strong reference in-place, except\nwhen the object cannot be destroyed before the last usage of the borrowed\nreference. The Py_NewRef() function can be used to create a new strong reference .\n\nbytes-like object\n\u00c2\u00b6\nAn object that supports the Buffer Protocol and can\nexport a C- contiguous buffer. This includes all bytes , bytearray , and array.array objects, as well as many\ncommon memoryview objects.  Bytes-like objects can\nbe used for various operations that work with binary data; these include\ncompression, saving to a binary file, and sending over a socket.\n\nSome operations need the binary data to be mutable.  The documentation\noften refers to these as \u00e2\u0080\u009cread-write bytes-like objects\u00e2\u0080\u009d.  Example\nmutable buffer objects include bytearray and a memoryview of a bytearray .\nOther operations require the binary data to be stored in\nimmutable objects (\u00e2\u0080\u009cread-only bytes-like objects\u00e2\u0080\u009d); examples\nof these include bytes and a memoryview of a bytes object.\n\nbytecode\n\u00c2\u00b6\nPython source code is compiled into bytecode, the internal representation\nof a Python program in the CPython interpreter.  The bytecode is also\ncached in .pyc files so that executing the same file is\nfaster the second time (recompilation from source to bytecode can be\navoided).  This \u00e2\u0080\u009cintermediate language\u00e2\u0080\u009d is said to run on a virtual machine that executes the machine code corresponding to\neach bytecode. Do note that bytecodes are not expected to work between\ndifferent Python virtual machines, nor to be stable between Python\nreleases.\n\nA list of bytecode instructions can be found in the documentation for the dis module .\n\ncallable\n\u00c2\u00b6\nA callable is an object that can be called, possibly with a set\nof arguments (see argument ), with the following syntax:\n\n```python\ncallable(argument1, argument2, argumentN)\n```python\n\nA function , and by extension a method , is a callable.\nAn instance of a class that implements the __call__() method is also a callable.\n\ncallback\n\u00c2\u00b6\nA subroutine function which is passed as an argument to be executed at\nsome point in the future.\n\nclass\n\u00c2\u00b6\nA template for creating user-defined objects. Class definitions\nnormally contain method definitions which operate on instances of the\nclass.\n\nclass variable\n\u00c2\u00b6\nA variable defined in a class and intended to be modified only at\nclass level (i.e., not in an instance of the class).\n\nclosure variable\n\u00c2\u00b6\nA free variable referenced from a nested scope that is defined in an outer\nscope rather than being resolved at runtime from the globals or builtin namespaces.\nMay be explicitly defined with the nonlocal keyword to allow write access,\nor implicitly defined if the variable is only being read.\n\nFor example, in the inner function in the following code, both x and print are free variables , but only x is a closure variable :\n\n```python\ndef outer():\n    x = 0\n    def inner():\n        nonlocal x\n        x += 1\n        print(x)\n    return inner\n```python\n\nDue to the codeobject.co_freevars attribute (which, despite its name, only\nincludes the names of closure variables rather than listing all referenced free\nvariables), the more general free variable term is sometimes used even\nwhen the intended meaning is to refer specifically to closure variables.\n\ncomplex number\n\u00c2\u00b6\nAn extension of the familiar real number system in which all numbers are\nexpressed as a sum of a real part and an imaginary part.  Imaginary\nnumbers are real multiples of the imaginary unit (the square root of -1 ), often written i in mathematics or j in\nengineering.  Python has built-in support for complex numbers, which are\nwritten with this latter notation; the imaginary part is written with a j suffix, e.g., 3+1j .  To get access to complex equivalents of the math module, use cmath .  Use of complex numbers is a fairly\nadvanced mathematical feature.  If you\u00e2\u0080\u0099re not aware of a need for them,\nit\u00e2\u0080\u0099s almost certain you can safely ignore them.\n\nconcurrency\n\u00c2\u00b6\nThe ability of a computer program to perform multiple tasks at the same\ntime.  Python provides libraries for writing programs that make use of\ndifferent forms of concurrency. asyncio is a library for dealing\nwith asynchronous tasks and coroutines. threading provides\naccess to operating system threads and multiprocessing to\noperating system processes. Multi-core processors can execute threads and\nprocesses on different CPU cores at the same time (see parallelism ).\n\nconcurrent modification\n\u00c2\u00b6\nWhen multiple threads modify shared data at the same time.  Concurrent\nmodification without proper synchronization can cause race conditions , and might also trigger a data race , data corruption, or both.\n\ncontext\n\u00c2\u00b6\nThis term has different meanings depending on where and how it is used.\nSome common meanings:\n\n- The temporary state or environment established by a context\nmanager via a with statement.\n- The collection of key\u00c2\u00advalue bindings associated with a particular contextvars.Context object and accessed via ContextVar objects.  Also see context\nvariable .\n- A contextvars.Context object.  Also see current\ncontext .\n\ncontext management protocol\n\u00c2\u00b6\nThe __enter__() and __exit__() methods called\nby the with statement.  See PEP 343 .\n\ncontext manager\n\u00c2\u00b6\nAn object which implements the context management protocol and\ncontrols the environment seen in a with statement.  See PEP 343 .\n\ncontext variable\n\u00c2\u00b6\nA variable whose value depends on which context is the current\ncontext .  Values are accessed via contextvars.ContextVar objects.  Context variables are primarily used to isolate state between\nconcurrent asynchronous tasks.\n\ncontiguous\n\u00c2\u00b6\nA buffer is considered contiguous exactly if it is either C-contiguous or Fortran contiguous .  Zero-dimensional buffers are\nC and Fortran contiguous.  In one-dimensional arrays, the items\nmust be laid out in memory next to each other, in order of\nincreasing indexes starting from zero.  In multidimensional\nC-contiguous arrays, the last index varies the fastest when\nvisiting items in order of memory address.  However, in\nFortran contiguous arrays, the first index varies the fastest.\n\ncoroutine\n\u00c2\u00b6\nCoroutines are a more generalized form of subroutines. Subroutines are\nentered at one point and exited at another point.  Coroutines can be\nentered, exited, and resumed at many different points.  They can be\nimplemented with the async def statement.  See also PEP 492 .\n\ncoroutine function\n\u00c2\u00b6\nA function which returns a coroutine object.  A coroutine\nfunction may be defined with the async def statement,\nand may contain await , async for , and async with keywords.  These were introduced\nby PEP 492 .\n\nCPython\n\u00c2\u00b6\nThe canonical implementation of the Python programming language, as\ndistributed on python.org .  The term \u00e2\u0080\u009cCPython\u00e2\u0080\u009d\nis used when necessary to distinguish this implementation from others\nsuch as Jython or IronPython.\n\ncurrent context\n\u00c2\u00b6\nThe context ( contextvars.Context object) that is\ncurrently used by ContextVar objects to access (get\nor set) the values of context variables .  Each\nthread has its own current context.  Frameworks for executing asynchronous\ntasks (see asyncio ) associate each task with a context which\nbecomes the current context whenever the task starts or resumes execution.\n\ncyclic isolate\n\u00c2\u00b6\nA subgroup of one or more objects that reference each other in a reference\ncycle, but are not referenced by objects outside the group.  The goal of\nthe cyclic garbage collector is to identify these groups and break the reference\ncycles so that the memory can be reclaimed.\n\ndata race\n\u00c2\u00b6\nA situation where multiple threads access the same memory location\nconcurrently, at least one of the accesses is a write, and the threads\ndo not use any synchronization to control their access.  Data races\nlead to non-deterministic behavior and can cause data corruption.\nProper use of locks and other synchronization primitives prevents data races.  Note that data races\ncan only happen in native code, but that native code might be\nexposed in a Python API.  See also race condition and thread-safe .\n\ndeadlock\n\u00c2\u00b6\nA situation in which two or more tasks (threads, processes, or coroutines)\nwait indefinitely for each other to release resources or complete actions,\npreventing any from making progress.  For example, if thread A holds lock\n1 and waits for lock 2, while thread B holds lock 2 and waits for lock 1,\nboth threads will wait indefinitely.  In Python this often arises from\nacquiring multiple locks in conflicting orders or from circular\njoin/await dependencies.  Deadlocks can be avoided by always acquiring\nmultiple locks in a consistent order.  See also lock and reentrant .\n\ndecorator\n\u00c2\u00b6\nA function returning another function, usually applied as a function\ntransformation using the @wrapper syntax.  Common examples for\ndecorators are classmethod() and staticmethod() .\n\nThe decorator syntax is merely syntactic sugar, the following two\nfunction definitions are semantically equivalent:\n\n```python\ndef f(arg):\n    ...\nf = staticmethod(f)\n\n@staticmethod\ndef f(arg):\n    ...\n```python\n\nThe same concept exists for classes, but is less commonly used there.  See\nthe documentation for function definitions and class definitions for more about decorators.\n\ndescriptor\n\u00c2\u00b6\nAny object which defines the methods __get__() , __set__() , or __delete__() .\nWhen a class attribute is a descriptor, its special\nbinding behavior is triggered upon attribute lookup.  Normally, using a.b to get, set or delete an attribute looks up the object named b in\nthe class dictionary for a , but if b is a descriptor, the respective\ndescriptor method gets called.  Understanding descriptors is a key to a\ndeep understanding of Python because they are the basis for many features\nincluding functions, methods, properties, class methods, static methods,\nand reference to super classes.\n\nFor more information about descriptors\u00e2\u0080\u0099 methods, see Implementing Descriptors or the Descriptor How To Guide .\n\ndictionary\n\u00c2\u00b6\nAn associative array, where arbitrary keys are mapped to values.  The\nkeys can be any object with __hash__() and __eq__() methods.\nCalled a hash in Perl.\n\ndictionary comprehension\n\u00c2\u00b6\nA compact way to process all or part of the elements in an iterable and\nreturn a dictionary with the results. results = {n: n ** 2 for n in range(10)} generates a dictionary containing key n mapped to\nvalue n ** 2 . See Displays for lists, sets and dictionaries .\n\ndictionary view\n\u00c2\u00b6\nThe objects returned from dict.keys() , dict.values() , and dict.items() are called dictionary views. They provide a dynamic\nview on the dictionary\u00e2\u0080\u0099s entries, which means that when the dictionary\nchanges, the view reflects these changes. To force the\ndictionary view to become a full list use list(dictview) .  See Dictionary view objects .\n\ndocstring\n\u00c2\u00b6\nA string literal which appears as the first expression in a class,\nfunction or module.  While ignored when the suite is executed, it is\nrecognized by the compiler and put into the __doc__ attribute\nof the enclosing class, function or module.  Since it is available via\nintrospection, it is the canonical place for documentation of the\nobject.\n\nduck-typing\n\u00c2\u00b6\nA programming style which does not look at an object\u00e2\u0080\u0099s type to determine\nif it has the right interface; instead, the method or attribute is simply\ncalled or used (\u00e2\u0080\u009cIf it looks like a duck and quacks like a duck, it\nmust be a duck.\u00e2\u0080\u009d)  By emphasizing interfaces rather than specific types,\nwell-designed code improves its flexibility by allowing polymorphic\nsubstitution.  Duck-typing avoids tests using type() or isinstance() .  (Note, however, that duck-typing can be complemented\nwith abstract base classes .)  Instead, it\ntypically employs hasattr() tests or EAFP programming.\n\ndunder\n\u00c2\u00b6\nAn informal short-hand for \u00e2\u0080\u009cdouble underscore\u00e2\u0080\u009d, used when talking about a special method . For example, __init__ is often pronounced\n\u00e2\u0080\u009cdunder init\u00e2\u0080\u009d.\n\nEAFP\n\u00c2\u00b6\nEasier to ask for forgiveness than permission.  This common Python coding\nstyle assumes the existence of valid keys or attributes and catches\nexceptions if the assumption proves false.  This clean and fast style is\ncharacterized by the presence of many try and except statements.  The technique contrasts with the LBYL style\ncommon to many other languages such as C.\n\nevaluate function\n\u00c2\u00b6\nA function that can be called to evaluate a lazily evaluated attribute\nof an object, such as the value of type aliases created with the type statement.\n\nexpression\n\u00c2\u00b6\nA piece of syntax which can be evaluated to some value.  In other words,\nan expression is an accumulation of expression elements like literals,\nnames, attribute access, operators or function calls which all return a\nvalue.  In contrast to many other languages, not all language constructs\nare expressions.  There are also statement s which cannot be used\nas expressions, such as while .  Assignments are also statements,\nnot expressions.\n\nextension module\n\u00c2\u00b6\nA module written in C or C++, using Python\u00e2\u0080\u0099s C API to interact with the\ncore and with user code.\n\nf-string\n\u00c2\u00b6\nf-strings\n\u00c2\u00b6\nString literals prefixed with f or F are commonly called\n\u00e2\u0080\u009cf-strings\u00e2\u0080\u009d which is short for formatted string literals .  See also PEP 498 .\n\nfile object\n\u00c2\u00b6\nAn object exposing a file-oriented API (with methods such as read() or write() ) to an underlying resource.  Depending\non the way it was created, a file object can mediate access to a real\non-disk file or to another type of storage or communication device\n(for example standard input/output, in-memory buffers, sockets, pipes,\netc.).  File objects are also called file-like objects or streams .\n\nThere are actually three categories of file objects: raw binary files , buffered binary files and text files .\nTheir interfaces are defined in the io module.  The canonical\nway to create a file object is by using the open() function.\n\nfile-like object\n\u00c2\u00b6\nA synonym for file object .\n\nfilesystem encoding and error handler\n\u00c2\u00b6\nEncoding and error handler used by Python to decode bytes from the\noperating system and encode Unicode to the operating system.\n\nThe filesystem encoding must guarantee to successfully decode all bytes\nbelow 128. If the file system encoding fails to provide this guarantee,\nAPI functions can raise UnicodeError .\n\nThe sys.getfilesystemencoding() and sys.getfilesystemencodeerrors() functions can be used to get the\nfilesystem encoding and error handler.\n\nThe filesystem encoding and error handler are configured at\nPython startup by the PyConfig_Read() function: see filesystem_encoding and filesystem_errors members of PyConfig .\n\nSee also the locale encoding .\n\nfinder\n\u00c2\u00b6\nAn object that tries to find the loader for a module that is\nbeing imported.\n\nThere are two types of finder: meta path finders for use with sys.meta_path , and path\nentry finders for use with sys.path_hooks .\n\nSee Finders and loaders and importlib for much more detail.\n\nfloor division\n\u00c2\u00b6\nMathematical division that rounds down to nearest integer.  The floor\ndivision operator is // .  For example, the expression 11 // 4 evaluates to 2 in contrast to the 2.75 returned by float true\ndivision.  Note that (-11) // 4 is -3 because that is -2.75 rounded downward . See PEP 238 .\n\nfree threading\n\u00c2\u00b6\nA threading model where multiple threads can run Python bytecode\nsimultaneously within the same interpreter.  This is in contrast to\nthe global interpreter lock which allows only one thread to\nexecute Python bytecode at a time.  See PEP 703 .\n\nfree-threaded build\n\u00c2\u00b6\nA build of CPython that supports free threading ,\nconfigured using the --disable-gil option before compilation.\n\nSee Python support for free threading .\n\nfree variable\n\u00c2\u00b6\nFormally, as defined in the language execution model , a free\nvariable is any variable used in a namespace which is not a local variable in that\nnamespace. See closure variable for an example.\nPragmatically, due to the name of the codeobject.co_freevars attribute,\nthe term is also sometimes used as a synonym for closure variable .\n\nfunction\n\u00c2\u00b6\nA series of statements which returns some value to a caller. It can also\nbe passed zero or more arguments which may be used in\nthe execution of the body. See also parameter , method ,\nand the Function definitions section.\n\nfunction annotation\n\u00c2\u00b6\nAn annotation of a function parameter or return value.\n\nFunction annotations are usually used for type hints : for example, this function is expected to take two int arguments and is also expected to have an int return value:\n\n```python\ndef sum_two_numbers(a: int, b: int) -> int:\n   return a + b\n```python\n\nFunction annotation syntax is explained in section Function definitions .\n\nSee variable annotation and PEP 484 ,\nwhich describe this functionality.\nAlso see Annotations Best Practices for best practices on working with annotations.\n\n__future__\n\u00c2\u00b6\nA future statement , from __future__ import <feature> ,\ndirects the compiler to compile the current module using syntax or\nsemantics that will become standard in a future release of Python.\nThe __future__ module documents the possible values of feature .  By importing this module and evaluating its variables,\nyou can see when a new feature was first added to the language and\nwhen it will (or did) become the default:\n\n```python\n>>> import __future__\n>>> __future__.division\n_Feature((2, 2, 0, 'alpha', 2), (3, 0, 0, 'alpha', 0), 8192)\n```python\n\ngarbage collection\n\u00c2\u00b6\nThe process of freeing memory when it is not used anymore.  Python\nperforms garbage collection via reference counting and a cyclic garbage\ncollector that is able to detect and break reference cycles.  The\ngarbage collector can be controlled using the gc module.\n\ngenerator\n\u00c2\u00b6\nA function which returns a generator iterator .  It looks like a\nnormal function except that it contains yield expressions\nfor producing a series of values usable in a for-loop or that can be\nretrieved one at a time with the next() function.\n\nUsually refers to a generator function, but may refer to a generator iterator in some contexts.  In cases where the intended\nmeaning isn\u00e2\u0080\u0099t clear, using the full terms avoids ambiguity.\n\ngenerator iterator\n\u00c2\u00b6\nAn object created by a generator function.\n\nEach yield temporarily suspends processing, remembering the\nexecution state (including local variables and pending\ntry-statements).  When the generator iterator resumes, it picks up where\nit left off (in contrast to functions which start fresh on every\ninvocation).\n\ngenerator expression\n\u00c2\u00b6\nAn expression that returns an iterator .  It looks like a normal expression\nfollowed by a for clause defining a loop variable, range,\nand an optional if clause.  The combined expression\ngenerates values for an enclosing function:\n\n```python\n>>> sum(i*i for i in range(10))         # sum of squares 0, 1, 4, ... 81\n285\n```python\n\ngeneric function\n\u00c2\u00b6\nA function composed of multiple functions implementing the same operation\nfor different types. Which implementation should be used during a call is\ndetermined by the dispatch algorithm.\n\nSee also the single dispatch glossary entry, the functools.singledispatch() decorator, and PEP 443 .\n\ngeneric type\n\u00c2\u00b6\nA type that can be parameterized; typically a container class such as list or dict . Used for type hints and annotations .\n\nFor more details, see generic alias types , PEP 483 , PEP 484 , PEP 585 , and the typing module.\n\nGIL\n\u00c2\u00b6\nSee global interpreter lock .\n\nglobal interpreter lock\n\u00c2\u00b6\nThe mechanism used by the CPython interpreter to assure that\nonly one thread executes Python bytecode at a time.\nThis simplifies the CPython implementation by making the object model\n(including critical built-in types such as dict ) implicitly\nsafe against concurrent access.  Locking the entire interpreter\nmakes it easier for the interpreter to be multi-threaded, at the\nexpense of much of the parallelism afforded by multi-processor\nmachines.\n\nHowever, some extension modules, either standard or third-party,\nare designed so as to release the GIL when doing computationally intensive\ntasks such as compression or hashing.  Also, the GIL is always released\nwhen doing I/O.\n\nAs of Python 3.13, the GIL can be disabled using the --disable-gil build configuration. After building Python with this option, code must be\nrun with -X gil=0 or after setting the PYTHON_GIL=0 environment variable. This feature enables improved performance for\nmulti-threaded applications and makes it easier to use multi-core CPUs\nefficiently. For more details, see PEP 703 .\n\nIn prior versions of Python\u00e2\u0080\u0099s C API, a function might declare that it\nrequires the GIL to be held in order to use it. This refers to having an attached thread state .\n\nglobal state\n\u00c2\u00b6\nData that is accessible throughout a program, such as module-level\nvariables, class variables, or C static variables in extension modules .  In multi-threaded programs, global state shared\nbetween threads typically requires synchronization to avoid race conditions and data races .\n\nhash-based pyc\n\u00c2\u00b6\nA bytecode cache file that uses the hash rather than the last-modified\ntime of the corresponding source file to determine its validity. See Cached bytecode invalidation .\n\nhashable\n\u00c2\u00b6\nAn object is hashable if it has a hash value which never changes during\nits lifetime (it needs a __hash__() method), and can be\ncompared to other objects (it needs an __eq__() method).\nHashable objects which\ncompare equal must have the same hash value.\n\nHashability makes an object usable as a dictionary key and a set member,\nbecause these data structures use the hash value internally.\n\nMost of Python\u00e2\u0080\u0099s immutable built-in objects are hashable; mutable\ncontainers (such as lists or dictionaries) are not; immutable\ncontainers (such as tuples and frozensets) are only hashable if\ntheir elements are hashable.  Objects which are\ninstances of user-defined classes are hashable by default.  They all\ncompare unequal (except with themselves), and their hash value is derived\nfrom their id() .\n\nIDLE\n\u00c2\u00b6\nAn Integrated Development and Learning Environment for Python. IDLE \u00e2\u0080\u0094 Python editor and shell is a basic editor and interpreter environment\nwhich ships with the standard distribution of Python.\n\nimmortal\n\u00c2\u00b6\nImmortal objects are a CPython implementation detail introduced\nin PEP 683 .\n\nIf an object is immortal, its reference count is never modified,\nand therefore it is never deallocated while the interpreter is running.\nFor example, True and None are immortal in CPython.\n\nImmortal objects can be identified via sys._is_immortal() , or\nvia PyUnstable_IsImmortal() in the C API.\n\nimmutable\n\u00c2\u00b6\nAn object with a fixed value.  Immutable objects include numbers, strings and\ntuples.  Such an object cannot be altered.  A new object has to\nbe created if a different value has to be stored.  They play an important\nrole in places where a constant hash value is needed, for example as a key\nin a dictionary.  Immutable objects are inherently thread-safe because their state cannot be modified after creation, eliminating concerns\nabout improperly synchronized concurrent modification .\n\nimport path\n\u00c2\u00b6\nA list of locations (or path entries ) that are\nsearched by the path based finder for modules to import. During\nimport, this list of locations usually comes from sys.path , but\nfor subpackages it may also come from the parent package\u00e2\u0080\u0099s __path__ attribute.\n\nimporting\n\u00c2\u00b6\nThe process by which Python code in one module is made available to\nPython code in another module.\n\nimporter\n\u00c2\u00b6\nAn object that both finds and loads a module; both a finder and loader object.\n\nindex\n\u00c2\u00b6\nA numeric value that represents the position of an element in\na sequence .\n\nIn Python, indexing starts at zero.\nFor example, things[0] names the first element of things ; things[1] names the second one.\n\nIn some contexts, Python allows negative indexes for counting from the\nend of a sequence, and indexing using slices .\n\nSee also subscript .\n\ninteractive\n\u00c2\u00b6\nPython has an interactive interpreter which means you can enter\nstatements and expressions at the interpreter prompt, immediately\nexecute them and see their results.  Just launch python with no\narguments (possibly by selecting it from your computer\u00e2\u0080\u0099s main\nmenu). It is a very powerful way to test out new ideas or inspect\nmodules and packages (remember help(x) ). For more on interactive\nmode, see Interactive Mode .\n\ninterpreted\n\u00c2\u00b6\nPython is an interpreted language, as opposed to a compiled one,\nthough the distinction can be blurry because of the presence of the\nbytecode compiler.  This means that source files can be run directly\nwithout explicitly creating an executable which is then run.\nInterpreted languages typically have a shorter development/debug cycle\nthan compiled ones, though their programs generally also run more\nslowly.  See also interactive .\n\ninterpreter shutdown\n\u00c2\u00b6\nWhen asked to shut down, the Python interpreter enters a special phase\nwhere it gradually releases all allocated resources, such as modules\nand various critical internal structures.  It also makes several calls\nto the garbage collector . This can trigger\nthe execution of code in user-defined destructors or weakref callbacks.\nCode executed during the shutdown phase can encounter various\nexceptions as the resources it relies on may not function anymore\n(common examples are library modules or the warnings machinery).\n\nThe main reason for interpreter shutdown is that the __main__ module\nor the script being run has finished executing.\n\niterable\n\u00c2\u00b6\nAn object capable of returning its members one at a time. Examples of\niterables include all sequence types (such as list , str ,\nand tuple ) and some non-sequence types like dict , file objects , and objects of any classes you define\nwith an __iter__() method or with a __getitem__() method\nthat implements sequence semantics.\n\nIterables can be\nused in a for loop and in many other places where a sequence is\nneeded ( zip() , map() , \u00e2\u0080\u00a6).  When an iterable object is passed\nas an argument to the built-in function iter() , it returns an\niterator for the object.  This iterator is good for one pass over the set\nof values.  When using iterables, it is usually not necessary to call iter() or deal with iterator objects yourself.  The for statement does that automatically for you, creating a temporary unnamed\nvariable to hold the iterator for the duration of the loop.  See also iterator , sequence , and generator .\n\niterator\n\u00c2\u00b6\nAn object representing a stream of data.  Repeated calls to the iterator\u00e2\u0080\u0099s __next__() method (or passing it to the built-in function next() ) return successive items in the stream.  When no more data\nare available a StopIteration exception is raised instead.  At this\npoint, the iterator object is exhausted and any further calls to its __next__() method just raise StopIteration again.  Iterators\nare required to have an __iter__() method that returns the iterator\nobject itself so every iterator is also iterable and may be used in most\nplaces where other iterables are accepted.  One notable exception is code\nwhich attempts multiple iteration passes.  A container object (such as a list ) produces a fresh new iterator each time you pass it to the iter() function or use it in a for loop.  Attempting this\nwith an iterator will just return the same exhausted iterator object used\nin the previous iteration pass, making it appear like an empty container.\n\nMore information can be found in Iterator Types .\n\nCPython implementation detail: CPython does not consistently apply the requirement that an iterator\ndefine __iter__() .\nAnd also please note that free-threaded CPython does not guarantee thread-safe behavior of iterator\noperations.\n\nkey\n\u00c2\u00b6\nA value that identifies an entry in a mapping .\nSee also subscript .\n\nkey function\n\u00c2\u00b6\nA key function or collation function is a callable that returns a value\nused for sorting or ordering.  For example, locale.strxfrm() is\nused to produce a sort key that is aware of locale specific sort\nconventions.\n\nA number of tools in Python accept key functions to control how elements\nare ordered or grouped.  They include min() , max() , sorted() , list.sort() , heapq.merge() , heapq.nsmallest() , heapq.nlargest() , and itertools.groupby() .\n\nThere are several ways to create a key function.  For example. the str.casefold() method can serve as a key function for case insensitive\nsorts.  Alternatively, a key function can be built from a lambda expression such as lambda r: (r[0], r[2]) .  Also, operator.attrgetter() , operator.itemgetter() , and operator.methodcaller() are three key function constructors.  See the Sorting HOW TO for examples of how to create and use key functions.\n\nkeyword argument\n\u00c2\u00b6\nSee argument .\n\nlambda\n\u00c2\u00b6\nAn anonymous inline function consisting of a single expression which is evaluated when the function is called.  The syntax to create\na lambda function is lambda [parameters]: expression\n\nLBYL\n\u00c2\u00b6\nLook before you leap.  This coding style explicitly tests for\npre-conditions before making calls or lookups.  This style contrasts with\nthe EAFP approach and is characterized by the presence of many if statements.\n\nIn a multi-threaded environment, the LBYL approach can risk introducing a race condition between \u00e2\u0080\u009cthe looking\u00e2\u0080\u009d and \u00e2\u0080\u009cthe leaping\u00e2\u0080\u009d.  For example,\nthe code, if key in mapping: return mapping[key] can fail if another\nthread removes key from mapping after the test, but before the lookup.\nThis issue can be solved with locks or by using the EAFP approach.  See also thread-safe .\n\nlexical analyzer\n\u00c2\u00b6\nFormal name for the tokenizer ; see token .\n\nlist\n\u00c2\u00b6\nA built-in Python sequence .  Despite its name it is more akin\nto an array in other languages than to a linked list since access to\nelements is O (1).\n\nlist comprehension\n\u00c2\u00b6\nA compact way to process all or part of the elements in a sequence and\nreturn a list with the results. result = ['{:#04x}'.format(x) for x in range(256) if x % 2 == 0] generates a list of strings containing\neven hex numbers (0x..) in the range from 0 to 255. The if clause is optional.  If omitted, all elements in range(256) are\nprocessed.\n\nlock\n\u00c2\u00b6\nA synchronization primitive that allows only one thread at a\ntime to access a shared resource.  A thread must acquire a lock before\naccessing the protected resource and release it afterward.  If a thread\nattempts to acquire a lock that is already held by another thread, it\nwill block until the lock becomes available.  Python\u00e2\u0080\u0099s threading module provides Lock (a basic lock) and RLock (a reentrant lock).  Locks are used\nto prevent race conditions and ensure thread-safe access to shared data.  Alternative design patterns\nto locks exist such as queues, producer/consumer patterns, and\nthread-local state. See also deadlock , and reentrant .\n\nlock-free\n\u00c2\u00b6\nAn operation that does not acquire any lock and uses atomic CPU\ninstructions to ensure correctness. Lock-free operations can execute\nconcurrently without blocking each other and cannot be blocked by\noperations that hold locks. In free-threaded Python, built-in types like dict and list provide\nlock-free read operations, which means other threads may observe\nintermediate states during multi-step modifications even when those\nmodifications hold the per-object lock .\n\nloader\n\u00c2\u00b6\nAn object that loads a module.\nIt must define the exec_module() and create_module() methods\nto implement the Loader interface.\nA loader is typically returned by a finder .\nSee also:\n\n- Finders and loaders\n- importlib.abc.Loader\n- PEP 302\n\nlocale encoding\n\u00c2\u00b6\nOn Unix, it is the encoding of the LC_CTYPE locale. It can be set with locale.setlocale(locale.LC_CTYPE, new_locale) .\n\nOn Windows, it is the ANSI code page (ex: \"cp1252\" ).\n\nOn Android and VxWorks, Python uses \"utf-8\" as the locale encoding.\n\nlocale.getencoding() can be used to get the locale encoding.\n\nSee also the filesystem encoding and error handler .\n\nmagic method\n\u00c2\u00b6\nAn informal synonym for special method .\n\nmapping\n\u00c2\u00b6\nA container object that supports arbitrary key lookups and implements the\nmethods specified in the collections.abc.Mapping or collections.abc.MutableMapping abstract base classes .  Examples\ninclude dict , collections.defaultdict , collections.OrderedDict and collections.Counter .\n\nmeta path finder\n\u00c2\u00b6\nA finder returned by a search of sys.meta_path .  Meta path\nfinders are related to, but different from path entry finders .\n\nSee importlib.abc.MetaPathFinder for the methods that meta path\nfinders implement.\n\nmetaclass\n\u00c2\u00b6\nThe class of a class.  Class definitions create a class name, a class\ndictionary, and a list of base classes.  The metaclass is responsible for\ntaking those three arguments and creating the class.  Most object oriented\nprogramming languages provide a default implementation.  What makes Python\nspecial is that it is possible to create custom metaclasses.  Most users\nnever need this tool, but when the need arises, metaclasses can provide\npowerful, elegant solutions.  They have been used for logging attribute\naccess, adding thread-safety, tracking object creation, implementing\nsingletons, and many other tasks.\n\nMore information can be found in Metaclasses .\n\nmethod\n\u00c2\u00b6\nA function which is defined inside a class body.  If called as an attribute\nof an instance of that class, the method will get the instance object as\nits first argument (which is usually called self ).\nSee function and nested scope .\n\nmethod resolution order\n\u00c2\u00b6\nMethod Resolution Order is the order in which base classes are searched\nfor a member during lookup. See The Python 2.3 Method Resolution Order for details of the\nalgorithm used by the Python interpreter since the 2.3 release.\n\nmodule\n\u00c2\u00b6\nAn object that serves as an organizational unit of Python code.  Modules\nhave a namespace containing arbitrary Python objects.  Modules are loaded\ninto Python by the process of importing .\n\nSee also package .\n\nmodule spec\n\u00c2\u00b6\nA namespace containing the import-related information used to load a\nmodule. An instance of importlib.machinery.ModuleSpec .\n\nSee also Module specs .\n\nMRO\n\u00c2\u00b6\nSee method resolution order .\n\nmutable\n\u00c2\u00b6\nAn object with state that is allowed to change during the course\nof the program.  In multi-threaded programs, mutable objects that are\nshared between threads require careful synchronization to avoid race conditions .  See also immutable , thread-safe , and concurrent modification .\n\nnamed tuple\n\u00c2\u00b6\nThe term \u00e2\u0080\u009cnamed tuple\u00e2\u0080\u009d applies to any type or class that inherits from\ntuple and whose indexable elements are also accessible using named\nattributes.  The type or class may have other features as well.\n\nSeveral built-in types are named tuples, including the values returned\nby time.localtime() and os.stat() .  Another example is sys.float_info :\n\n```python\n>>> sys.float_info[1]                   # indexed access\n1024\n>>> sys.float_info.max_exp              # named field access\n1024\n>>> isinstance(sys.float_info, tuple)   # kind of tuple\nTrue\n```python\n\nSome named tuples are built-in types (such as the above examples).\nAlternatively, a named tuple can be created from a regular class\ndefinition that inherits from tuple and that defines named\nfields.  Such a class can be written by hand, or it can be created by\ninheriting typing.NamedTuple , or with the factory function collections.namedtuple() .  The latter techniques also add some\nextra methods that may not be found in hand-written or built-in named\ntuples.\n\nnamespace\n\u00c2\u00b6\nThe place where a variable is stored.  Namespaces are implemented as\ndictionaries.  There are the local, global and built-in namespaces as well\nas nested namespaces in objects (in methods).  Namespaces support\nmodularity by preventing naming conflicts.  For instance, the functions builtins.open and os.open() are distinguished by\ntheir namespaces.  Namespaces also aid readability and maintainability by\nmaking it clear which module implements a function.  For instance, writing random.seed() or itertools.islice() makes it clear that those\nfunctions are implemented by the random and itertools modules, respectively.\n\nnamespace package\n\u00c2\u00b6\nA package which serves only as a container for subpackages.\nNamespace packages may have no physical representation,\nand specifically are not like a regular package because they\nhave no __init__.py file.\n\nNamespace packages allow several individually installable packages to have a common parent package.\nOtherwise, it is recommended to use a regular package .\n\nFor more information, see PEP 420 and Namespace packages .\n\nSee also module .\n\nnative code\n\u00c2\u00b6\nCode that is compiled to machine instructions and runs directly on the\nprocessor, as opposed to code that is interpreted or runs in a virtual\nmachine.  In the context of Python, native code typically refers to\nC, C++, Rust or Fortran code in extension modules that can be called from Python.  See also extension module .\n\nnested scope\n\u00c2\u00b6\nThe ability to refer to a variable in an enclosing definition.  For\ninstance, a function defined inside another function can refer to\nvariables in the outer function.  Note that nested scopes by default work\nonly for reference and not for assignment.  Local variables both read and\nwrite in the innermost scope.  Likewise, global variables read and write\nto the global namespace.  The nonlocal allows writing to outer\nscopes.\n\nnew-style class\n\u00c2\u00b6\nOld name for the flavor of classes now used for all class objects.  In\nearlier Python versions, only new-style classes could use Python\u00e2\u0080\u0099s newer,\nversatile features like __slots__ , descriptors,\nproperties, __getattribute__() , class methods, and static\nmethods.\n\nnon-deterministic\n\u00c2\u00b6\nBehavior where the outcome of a program can vary between executions with\nthe same inputs.  In multi-threaded programs, non-deterministic behavior\noften results from race conditions where the\nrelative timing or interleaving of threads affects the result.\nProper synchronization using locks and other synchronization primitives helps\nensure deterministic behavior.\n\nobject\n\u00c2\u00b6\nAny data with state (attributes or value) and defined behavior\n(methods).  Also the ultimate base class of any new-style\nclass .\n\noptimized scope\n\u00c2\u00b6\nA scope where target local variable names are reliably known to the\ncompiler when the code is compiled, allowing optimization of read and\nwrite access to these names. The local namespaces for functions,\ngenerators, coroutines, comprehensions, and generator expressions are\noptimized in this fashion. Note: most interpreter optimizations are\napplied to all scopes, only those relying on a known set of local\nand nonlocal variable names are restricted to optimized scopes.\n\noptional module\n\u00c2\u00b6\nAn extension module that is part of the standard library ,\nbut may be absent in some builds of CPython ,\nusually due to missing third-party libraries or because the module\nis not available for a given platform.\n\nSee Requirements for optional modules for a list of optional modules\nthat require third-party libraries.\n\npackage\n\u00c2\u00b6\nA Python module which can contain submodules or recursively,\nsubpackages.  Technically, a package is a Python module with a __path__ attribute.\n\nSee also regular package and namespace package .\n\nparallelism\n\u00c2\u00b6\nExecuting multiple operations at the same time (e.g. on multiple CPU\ncores).  In Python builds with the global interpreter lock (GIL) , only one\nthread runs Python bytecode at a time, so taking advantage of multiple\nCPU cores typically involves multiple processes\n(e.g. multiprocessing ) or native extensions that release the GIL.\nIn free-threaded Python, multiple Python threads\ncan run Python code simultaneously on different cores.\n\nparameter\n\u00c2\u00b6\nA named entity in a function (or method) definition that\nspecifies an argument (or in some cases, arguments) that the\nfunction can accept.  There are five kinds of parameter:\n\n- positional-or-keyword : specifies an argument that can be passed\neither positionally or as a keyword argument .  This is the default kind of parameter, for example foo and bar in the following: def func ( foo , bar = None ): ...\n\n- positional-only : specifies an argument that can be supplied only\nby position. Positional-only parameters can be defined by including a / character in the parameter list of the function definition after\nthem, for example posonly1 and posonly2 in the following: def func ( posonly1 , posonly2 , / , positional_or_keyword ): ...\n\n- keyword-only : specifies an argument that can be supplied only\nby keyword.  Keyword-only parameters can be defined by including a\nsingle var-positional parameter or bare * in the parameter list\nof the function definition before them, for example kw_only1 and kw_only2 in the following: def func ( arg , * , kw_only1 , kw_only2 ): ...\n- var-positional : specifies that an arbitrary sequence of\npositional arguments can be provided (in addition to any positional\narguments already accepted by other parameters).  Such a parameter can\nbe defined by prepending the parameter name with * , for example args in the following: def func ( * args , ** kwargs ): ...\n- var-keyword : specifies that arbitrarily many keyword arguments\ncan be provided (in addition to any keyword arguments already accepted\nby other parameters).  Such a parameter can be defined by prepending\nthe parameter name with ** , for example kwargs in the example\nabove.\n\nParameters can specify both optional and required arguments, as well as\ndefault values for some optional arguments.\n\nSee also the argument glossary entry, the FAQ question on the difference between arguments and parameters , the inspect.Parameter class, the Function definitions section, and PEP 362 .\n\nper-object lock\n\u00c2\u00b6\nA lock associated with an individual object instance rather than\na global lock shared across all objects. In free-threaded Python, built-in types like dict and list use per-object locks to allow concurrent operations on\ndifferent objects while serializing operations on the same object.\nOperations that hold the per-object lock prevent other locking operations\non the same object from proceeding, but do not block lock-free operations.\n\npath entry\n\u00c2\u00b6\nA single location on the import path which the path\nbased finder consults to find modules for importing.\n\npath entry finder\n\u00c2\u00b6\nA finder returned by a callable on sys.path_hooks (i.e. a path entry hook ) which knows how to locate modules given\na path entry .\n\nSee importlib.abc.PathEntryFinder for the methods that path entry\nfinders implement.\n\npath entry hook\n\u00c2\u00b6\nA callable on the sys.path_hooks list which returns a path\nentry finder if it knows how to find modules on a specific path\nentry .\n\npath based finder\n\u00c2\u00b6\nOne of the default meta path finders which\nsearches an import path for modules.\n\npath-like object\n\u00c2\u00b6\nAn object representing a file system path. A path-like object is either\na str or bytes object representing a path, or an object\nimplementing the os.PathLike protocol. An object that supports\nthe os.PathLike protocol can be converted to a str or bytes file system path by calling the os.fspath() function; os.fsdecode() and os.fsencode() can be used to guarantee a str or bytes result instead, respectively. Introduced\nby PEP 519 .\n\nPEP\n\u00c2\u00b6\nPython Enhancement Proposal. A PEP is a design document\nproviding information to the Python community, or describing a new\nfeature for Python or its processes or environment. PEPs should\nprovide a concise technical specification and a rationale for proposed\nfeatures.\n\nPEPs are intended to be the primary mechanisms for proposing major new\nfeatures, for collecting community input on an issue, and for documenting\nthe design decisions that have gone into Python. The PEP author is\nresponsible for building consensus within the community and documenting\ndissenting opinions.\n\nSee PEP 1 .\n\nportion\n\u00c2\u00b6\nA set of files in a single directory (possibly stored in a zip file)\nthat contribute to a namespace package, as defined in PEP 420 .\n\npositional argument\n\u00c2\u00b6\nSee argument .\n\nprovisional API\n\u00c2\u00b6\nA provisional API is one which has been deliberately excluded from\nthe standard library\u00e2\u0080\u0099s backwards compatibility guarantees.  While major\nchanges to such interfaces are not expected, as long as they are marked\nprovisional, backwards incompatible changes (up to and including removal\nof the interface) may occur if deemed necessary by core developers.  Such\nchanges will not be made gratuitously \u00e2\u0080\u0093 they will occur only if serious\nfundamental flaws are uncovered that were missed prior to the inclusion\nof the API.\n\nEven for provisional APIs, backwards incompatible changes are seen as\na \u00e2\u0080\u009csolution of last resort\u00e2\u0080\u009d - every attempt will still be made to find\na backwards compatible resolution to any identified problems.\n\nThis process allows the standard library to continue to evolve over\ntime, without locking in problematic design errors for extended periods\nof time.  See PEP 411 for more details.\n\nprovisional package\n\u00c2\u00b6\nSee provisional API .\n\nPython 3000\n\u00c2\u00b6\nNickname for the Python 3.x release line (coined long ago when the\nrelease of version 3 was something in the distant future.)  This is also\nabbreviated \u00e2\u0080\u009cPy3k\u00e2\u0080\u009d.\n\nPythonic\n\u00c2\u00b6\nAn idea or piece of code which closely follows the most common idioms\nof the Python language, rather than implementing code using concepts\ncommon to other languages.  For example, a common idiom in Python is\nto loop over all elements of an iterable using a for statement.  Many other languages don\u00e2\u0080\u0099t have this type of construct, so\npeople unfamiliar with Python sometimes use a numerical counter instead:\n\n```python\nfor i in range(len(food)):\n    print(food[i])\n```python\n\nAs opposed to the cleaner, Pythonic method:\n\n```python\nfor piece in food:\n    print(piece)\n```python\n\nqualified name\n\u00c2\u00b6\nA dotted name showing the \u00e2\u0080\u009cpath\u00e2\u0080\u009d from a module\u00e2\u0080\u0099s global scope to a\nclass, function or method defined in that module, as defined in PEP 3155 .  For top-level functions and classes, the qualified name\nis the same as the object\u00e2\u0080\u0099s name:\n\n```python\n>>> class C:\n...     class D:\n...         def meth(self):\n...             pass\n...\n>>> C.__qualname__\n'C'\n>>> C.D.__qualname__\n'C.D'\n>>> C.D.meth.__qualname__\n'C.D.meth'\n```python\n\nWhen used to refer to modules, the fully qualified name means the\nentire dotted path to the module, including any parent packages,\ne.g. email.mime.text :\n\n```python\n>>> import email.mime.text\n>>> email.mime.text.__name__\n'email.mime.text'\n```python\n\nrace condition\n\u00c2\u00b6\nA condition of a program where the behavior\ndepends on the relative timing or ordering of events, particularly in\nmulti-threaded programs.  Race conditions can lead to non-deterministic behavior and bugs that are difficult to\nreproduce.  A data race is a specific type of race condition\ninvolving unsynchronized access to shared memory.  The LBYL coding style is particularly susceptible to race conditions in\nmulti-threaded code.  Using locks and other synchronization primitives helps prevent race conditions.\n\nreference count\n\u00c2\u00b6\nThe number of references to an object.  When the reference count of an\nobject drops to zero, it is deallocated.  Some objects are immortal and have reference counts that are never modified, and\ntherefore the objects are never deallocated.  Reference counting is\ngenerally not visible to Python code, but it is a key element of the CPython implementation.  Programmers can call the sys.getrefcount() function to return the\nreference count for a particular object.\n\nIn CPython , reference counts are not considered to be stable\nor well-defined values; the number of references to an object, and how\nthat number is affected by Python code, may be different between\nversions.\n\nregular package\n\u00c2\u00b6\nA traditional package , such as a directory containing an __init__.py file.\n\nSee also namespace package .\n\nreentrant\n\u00c2\u00b6\nA property of a function or lock that allows it to be called or\nacquired multiple times by the same thread without causing errors or a deadlock .\n\nFor functions, reentrancy means the function can be safely called again\nbefore a previous invocation has completed, which is important when\nfunctions may be called recursively or from signal handlers. Thread-unsafe\nfunctions may be non-deterministic if they\u00e2\u0080\u0099re called reentrantly in a\nmultithreaded program.\n\nFor locks, Python\u00e2\u0080\u0099s threading.RLock (reentrant lock) is\nreentrant, meaning a thread that already holds the lock can acquire it\nagain without blocking.  In contrast, threading.Lock is not\nreentrant - attempting to acquire it twice from the same thread will cause\na deadlock.\n\nSee also lock and deadlock .\n\nREPL\n\u00c2\u00b6\nAn acronym for the \u00e2\u0080\u009cread\u00e2\u0080\u0093eval\u00e2\u0080\u0093print loop\u00e2\u0080\u009d, another name for the interactive interpreter shell.\n\n__slots__\n\u00c2\u00b6\nA declaration inside a class that saves memory by pre-declaring space for\ninstance attributes and eliminating instance dictionaries.  Though\npopular, the technique is somewhat tricky to get right and is best\nreserved for rare cases where there are large numbers of instances in a\nmemory-critical application.\n\nsequence\n\u00c2\u00b6\nAn iterable which supports efficient element access using integer\nindices via the __getitem__() special method and defines a __len__() method that returns the length of the sequence.\nSome built-in sequence types are list , str , tuple , and bytes . Note that dict also\nsupports __getitem__() and __len__() , but is considered a\nmapping rather than a sequence because the lookups use arbitrary hashable keys rather than integers.\n\nThe collections.abc.Sequence abstract base class\ndefines a much richer interface that goes beyond just __getitem__() and __len__() , adding count() , index() , __contains__() , and __reversed__() .\nTypes that implement this expanded\ninterface can be registered explicitly using register() . For more documentation on sequence\nmethods generally, see Common Sequence Operations .\n\nset comprehension\n\u00c2\u00b6\nA compact way to process all or part of the elements in an iterable and\nreturn a set with the results. results = {c for c in 'abracadabra' if c not in 'abc'} generates the set of strings {'r', 'd'} .  See Displays for lists, sets and dictionaries .\n\nsingle dispatch\n\u00c2\u00b6\nA form of generic function dispatch where the implementation is\nchosen based on the type of a single argument.\n\nslice\n\u00c2\u00b6\nAn object of type slice , used to describe a portion of\na sequence .\nA slice object is created when using the slicing form\nof subscript notation , with colons inside square\nbrackets, such as in variable_name[1:3:5] .\n\nsoft deprecated\n\u00c2\u00b6\nA soft deprecated API should not be used in new code,\nbut it is safe for already existing code to use it.\nThe API remains documented and tested, but will not be enhanced further.\n\nSoft deprecation, unlike normal deprecation, does not plan on removing the API\nand will not emit warnings.\n\nSee PEP 387: Soft Deprecation .\n\nspecial method\n\u00c2\u00b6\nA method that is called implicitly by Python to execute a certain\noperation on a type, such as addition.  Such methods have names starting\nand ending with double underscores.  Special methods are documented in Special method names .\n\nstandard library\n\u00c2\u00b6\nThe collection of packages , modules and extension modules distributed as a part\nof the official Python interpreter package.  The exact membership of the\ncollection may vary based on platform, available system libraries, or\nother criteria.  Documentation can be found at The Python Standard Library .\n\nSee also sys.stdlib_module_names for a list of all possible\nstandard library module names.\n\nstatement\n\u00c2\u00b6\nA statement is part of a suite (a \u00e2\u0080\u009cblock\u00e2\u0080\u009d of code).  A statement is either\nan expression or one of several constructs with a keyword, such\nas if , while or for .\n\nstatic type checker\n\u00c2\u00b6\nAn external tool that reads Python code and analyzes it, looking for\nissues such as incorrect types. See also type hints and the typing module.\n\nstdlib\n\u00c2\u00b6\nAn abbreviation of standard library .\n\nstrong reference\n\u00c2\u00b6\nIn Python\u00e2\u0080\u0099s C API, a strong reference is a reference to an object\nwhich is owned by the code holding the reference.  The strong\nreference is taken by calling Py_INCREF() when the\nreference is created and released with Py_DECREF() when the reference is deleted.\n\nThe Py_NewRef() function can be used to create a strong reference\nto an object. Usually, the Py_DECREF() function must be called on\nthe strong reference before exiting the scope of the strong reference, to\navoid leaking one reference.\n\nSee also borrowed reference .\n\nsubscript\n\u00c2\u00b6\nThe expression in square brackets of a subscription expression , for example,\nthe 3 in items[3] .\nUsually used to select an element of a container.\nAlso called a key when subscripting a mapping ,\nor an index when subscripting a sequence .\n\nsynchronization primitive\n\u00c2\u00b6\nA basic building block for coordinating (synchronizing) the execution of\nmultiple threads to ensure thread-safe access to shared resources.\nPython\u00e2\u0080\u0099s threading module provides several synchronization primitives\nincluding Lock , RLock , Semaphore , Condition , Event , and Barrier .  Additionally,\nthe queue module provides multi-producer, multi-consumer queues\nthat are especially useful in multithreaded programs. These\nprimitives help prevent race conditions and\ncoordinate thread execution.  See also lock .\n\nt-string\n\u00c2\u00b6\nt-strings\n\u00c2\u00b6\nString literals prefixed with t or T are commonly called\n\u00e2\u0080\u009ct-strings\u00e2\u0080\u009d which is short for template string literals .\n\ntext encoding\n\u00c2\u00b6\nA string in Python is a sequence of Unicode code points (in range U+0000 \u00e2\u0080\u0093 U+10FFFF ). To store or transfer a string, it needs to be\nserialized as a sequence of bytes.\n\nSerializing a string into a sequence of bytes is known as \u00e2\u0080\u009cencoding\u00e2\u0080\u009d, and\nrecreating the string from the sequence of bytes is known as \u00e2\u0080\u009cdecoding\u00e2\u0080\u009d.\n\nThere are a variety of different text serialization codecs , which are collectively referred to as\n\u00e2\u0080\u009ctext encodings\u00e2\u0080\u009d.\n\ntext file\n\u00c2\u00b6\nA file object able to read and write str objects.\nOften, a text file actually accesses a byte-oriented datastream\nand handles the text encoding automatically.\nExamples of text files are files opened in text mode ( 'r' or 'w' ), sys.stdin , sys.stdout , and instances of io.StringIO .\n\nSee also binary file for a file object able to read and write bytes-like objects .\n\nthread state\n\u00c2\u00b6\nThe information used by the CPython runtime to run in an OS thread.\nFor example, this includes the current exception, if any, and the\nstate of the bytecode interpreter.\n\nEach thread state is bound to a single OS thread, but threads may have\nmany thread states available.  At most, one of them may be attached at once.\n\nAn attached thread state is required to call most\nof Python\u00e2\u0080\u0099s C API, unless a function explicitly documents otherwise.\nThe bytecode interpreter only runs under an attached thread state.\n\nEach thread state belongs to a single interpreter, but each interpreter\nmay have many thread states, including multiple for the same OS thread.\nThread states from multiple interpreters may be bound to the same\nthread, but only one can be attached in\nthat thread at any given moment.\n\nSee Thread State and the Global Interpreter Lock for more\ninformation.\n\nthread-safe\n\u00c2\u00b6\nA module, function, or class that behaves correctly when used by multiple\nthreads concurrently.  Thread-safe code uses appropriate synchronization primitives like locks to protect shared mutable state, or is designed\nto avoid shared mutable state entirely.  In the free-threaded build, built-in types like dict , list , and set use internal locking\nto make many operations thread-safe, although thread safety is not\nnecessarily guaranteed.  Code that is not thread-safe may experience race conditions and data races when used in multi-threaded programs.\n\ntoken\n\u00c2\u00b6\nA small unit of source code, generated by the lexical analyzer (also called the tokenizer ).\nNames, numbers, strings, operators,\nnewlines and similar are represented by tokens.\n\nThe tokenize module exposes Python\u00e2\u0080\u0099s lexical analyzer.\nThe token module contains information on the various types\nof tokens.\n\ntriple-quoted string\n\u00c2\u00b6\nA string which is bound by three instances of either a quotation mark\n(\u00e2\u0080\u009d) or an apostrophe (\u00e2\u0080\u0098).  While they don\u00e2\u0080\u0099t provide any functionality\nnot available with single-quoted strings, they are useful for a number\nof reasons.  They allow you to include unescaped single and double\nquotes within a string and they can span multiple lines without the\nuse of the continuation character, making them especially useful when\nwriting docstrings.\n\ntype\n\u00c2\u00b6\nThe type of a Python object determines what kind of object it is; every\nobject has a type.  An object\u00e2\u0080\u0099s type is accessible as its __class__ attribute or can be retrieved with type(obj) .\n\ntype alias\n\u00c2\u00b6\nA synonym for a type, created by assigning the type to an identifier.\n\nType aliases are useful for simplifying type hints .\nFor example:\n\n```python\ndef remove_gray_shades(\n        colors: list[tuple[int, int, int]]) -> list[tuple[int, int, int]]:\n    pass\n```python\n\ncould be made more readable like this:\n\n```python\nColor = tuple[int, int, int]\n\ndef remove_gray_shades(colors: list[Color]) -> list[Color]:\n    pass\n```python\n\nSee typing and PEP 484 , which describe this functionality.\n\ntype hint\n\u00c2\u00b6\nAn annotation that specifies the expected type for a variable, a class\nattribute, or a function parameter or return value.\n\nType hints are optional and are not enforced by Python but\nthey are useful to static type checkers .\nThey can also aid IDEs with code completion and refactoring.\n\nType hints of global variables, class attributes, and functions,\nbut not local variables, can be accessed using typing.get_type_hints() .\n\nSee typing and PEP 484 , which describe this functionality.\n\nuniversal newlines\n\u00c2\u00b6\nA manner of interpreting text streams in which all of the following are\nrecognized as ending a line: the Unix end-of-line convention '\\n' ,\nthe Windows convention '\\r\\n' , and the old Macintosh convention '\\r' .  See PEP 278 and PEP 3116 , as well as bytes.splitlines() for an additional use.\n\nvariable annotation\n\u00c2\u00b6\nAn annotation of a variable or a class attribute.\n\nWhen annotating a variable or a class attribute, assignment is optional:\n\n```python\nclass C:\n    field: 'annotation'\n```python\n\nVariable annotations are usually used for type hints : for example this variable is expected to take int values:\n\n```python\ncount: int = 0\n```python\n\nVariable annotation syntax is explained in section Annotated assignment statements .\n\nSee function annotation , PEP 484 and PEP 526 , which describe this functionality.\nAlso see Annotations Best Practices for best practices on working with annotations.\n\nvirtual environment\n\u00c2\u00b6\nA cooperatively isolated runtime environment that allows Python users\nand applications to install and upgrade Python distribution packages\nwithout interfering with the behaviour of other Python applications\nrunning on the same system.\n\nSee also venv .\n\nvirtual machine\n\u00c2\u00b6\nA computer defined entirely in software.  Python\u00e2\u0080\u0099s virtual machine\nexecutes the bytecode emitted by the bytecode compiler.\n\nwalrus operator\n\u00c2\u00b6\nA light-hearted way to refer to the assignment expression operator := because it looks a bit like a\nwalrus if you turn your head.\n\nZen of Python\n\u00c2\u00b6\nListing of Python design principles and philosophies that are helpful in\nunderstanding and using the language.  The listing can be found by typing\n\u00e2\u0080\u009c import this \u00e2\u0080\u009d at the interactive prompt.",
      "difficulty": "intro",
      "doc_id": "doc-glossary-4e4a714c7f",
      "provenance": {
        "author": "",
        "date": "",
        "license": "PSF Documentation License",
        "source_file": "data/corpus_raw/scraped/3_glossary_html_d0d1f2.json",
        "url": "https://docs.python.org/3/glossary.html"
      },
      "title": "Glossary\u00c2\u00b6",
      "type": "tutorial"
    },
    {
      "ai_generated": true,
      "concept_tags": [
        "conditionals",
        "guard-clauses",
        "normalization",
        "readability",
        "validation"
      ],
      "content": "Hard conditional logic is often about keeping code readable when there are many requirements. A common strategy is **guard clauses**: return early when something is invalid, so the \u201chappy path\u201d stays uncluttered.\n\n---\n## 1) Baseline: nested ifs get deep\n\n```python\ndef process(user):\n    if user is not None:\n        if \"name\" in user:\n            if user[\"name\"]:\n                return \"ok\"\n    return \"bad\"\n```python\n\n---\n## 2) Refactor with guard clauses\n\n```python\ndef process(user):\n    if user is None:\n        return \"missing user\"\n    if \"name\" not in user:\n        return \"missing name\"\n    if user[\"name\"] == \"\":\n        return \"empty name\"\n    return \"ok\"\n\nprint(process({\"name\": \"ana\"}))\nprint(process({\"name\": \"\"}))\nprint(process({}))\nprint(process(None))\n```python\n\n---\n## 3) A larger example: validate and normalize a record\n\n```python\ndef normalize_record(rec):\n    # rec should be a dict with keys: name(str), age(int-like), tags(list)\n    if rec is None or not isinstance(rec, dict):\n        return None\n\n    name = rec.get(\"name\")\n    if name is None:\n        return None\n    name = str(name).strip()\n    if name == \"\":\n        return None\n\n    age_raw = rec.get(\"age\")\n    if age_raw is None:\n        return None\n\n    # accept int or digit-string\n    if isinstance(age_raw, int):\n        age = age_raw\n    else:\n        s = str(age_raw).strip()\n        if not s.isdigit():\n            return None\n        age = int(s)\n\n    if not (0 <= age <= 120):\n        return None\n\n    tags = rec.get(\"tags\")\n    if tags is None:\n        tags = []\n    if not isinstance(tags, list):\n        return None\n\n    # normalize tags\n    clean_tags = []\n    for t in tags:\n        t = str(t).strip()\n        if t:\n            clean_tags.append(t)\n\n    return {\"name\": name, \"age\": age, \"tags\": clean_tags}\n\nprint(normalize_record({\"name\": \" Ana \", \"age\": \"20\", \"tags\": [\"x\", \" \", \"y\"]}))\nprint(normalize_record({\"name\": \"\", \"age\": \"20\"}))\n```python\n\n---\n## 4) Takeaway\nGuard clauses reduce indentation and make it easier to see why a record fails validation.",
      "difficulty": "hard",
      "doc_id": "doc-guard-clauses-for-complex-conditionals-early-returns-readable-validation-and-safer-flows-6bf0f16cf5",
      "provenance": {
        "author": "",
        "date": "",
        "license": "",
        "source_file": "data/corpus_raw/conditionals_hard_4.json",
        "url": ""
      },
      "title": "Guard clauses for complex conditionals: early returns, readable validation, and safer flows",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "cache",
        "decorators",
        "functions",
        "functools",
        "lru_cache",
        "memoization",
        "partial",
        "wraps"
      ],
      "content": "Hard-level function work often means building function wrappers (decorators), caching results, or creating specialized callables. The `functools` module supports these patterns.\n\n---\n## 1) functools.wraps: preserve metadata when wrapping\nWithout care, wrappers hide the original function\u2019s name/docstring.\n\n```python\ndef deco(func):\n    def wrapper(*args, **kwargs):\n        return func(*args, **kwargs)\n    return wrapper\n\n@deco\ndef f():\n    \"\"\"example doc\"\"\"\n    return 1\n\nprint(f.__name__)  # wrapper\nprint(f.__doc__)   # None\n```python\n\nUsing `functools.wraps` fixes that:\n\n```python\nimport functools\n\ndef deco(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        return func(*args, **kwargs)\n    return wrapper\n\n@deco\ndef f():\n    \"\"\"example doc\"\"\"\n    return 1\n\nprint(f.__name__)  # f\nprint(f.__doc__)   # example doc\n```python\n\n---\n## 2) lru_cache/cache: memoize function results\nCaching is useful when the function is pure-ish and called repeatedly with the same inputs.\n\n```python\nimport functools\n\n@functools.lru_cache(maxsize=128)\ndef fib(n):\n    if n < 2:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\nprint(fib(30))\nprint(fib.cache_info())\n```python\n\nUnbounded caching is available via `cache` (or `lru_cache(maxsize=None)`):\n\n```python\nimport functools\n\n@functools.cache\ndef f(n):\n    return n * n\n\nprint(f(10))\n```python\n\n---\n## 3) partial: create specialized callables\n`partial` pre-fills arguments.\n\n```python\nimport functools\n\ndef power(base, exp):\n    return base ** exp\n\nsquare = functools.partial(power, exp=2)\ncube = functools.partial(power, exp=3)\n\nprint(square(10))\nprint(cube(10))\n```python\n\n---\n## 4) A larger example: decorator + wraps + caching together\n\n```python\nimport functools\n\ndef log_calls(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        print(\"call\", func.__name__, args, kwargs)\n        return func(*args, **kwargs)\n    return wrapper\n\n@log_calls\n@functools.lru_cache(maxsize=64)\ndef compute(x, y):\n    return (x * x) + (y * y)\n\nprint(compute(3, 4))\nprint(compute(3, 4))  # cached\n```",
      "difficulty": "hard",
      "doc_id": "doc-higher-order-function-tools-hard-functools-wraps-lru-cache-cache-and-partial-7b6a338369",
      "provenance": {
        "author": "",
        "date": "",
        "license": "PSF Documentation License (Python docs)",
        "source_file": "data/corpus_raw/functions_hard_2.json",
        "url": "https://docs.python.org/3/library/functools.html"
      },
      "title": "Higher-order function tools (hard): functools.wraps, lru_cache/cache, and partial",
      "type": "reference"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "for",
        "generator",
        "iterables",
        "iterators",
        "loops",
        "next",
        "stopiteration"
      ],
      "content": "Hard-level loop knowledge starts with understanding what a `for` loop is *actually doing*.\n\nIn Python, `for x in iterable:` is driven by the **iterator protocol**:\n- An **iterable** can produce an **iterator**.\n- An **iterator** produces values one-at-a-time via `__next__()`.\n- When exhausted, `__next__()` raises `StopIteration`.\n\n---\n## 1) Iterables vs iterators (mental model)\n- **Iterable**: something you can loop over (it can produce an iterator)\n- **Iterator**: something you can call `next()` on until it\u2019s exhausted\n\n```python\nnums = [10, 20, 30]\n\nit = iter(nums)          # iterator\nprint(next(it))          # 10\nprint(next(it))          # 20\nprint(next(it))          # 30\n# next(it) would raise StopIteration\n```python\n\nA key detail: once an iterator is exhausted, it stays exhausted.\n\n```python\nit = iter([1, 2])\nprint(list(it))  # [1, 2]\nprint(list(it))  # []  (already consumed)\n```python\n\n---\n## 2) What the for-loop roughly does\nA simplified view:\n\n```python\n# conceptual, not exact interpreter code\nit = iter(iterable)\nwhile True:\n    try:\n        x = next(it)\n    except StopIteration:\n        break\n    # loop body runs here\n```python\n\nThis is why iterators are perfect for streaming data: they don\u2019t require loading everything into memory first.\n\n---\n## 3) Custom iterator class (stateful iteration)\nWhen implementing your own iterator, you typically provide:\n- `__iter__()` returning the iterator object\n- `__next__()` returning the next item or raising `StopIteration`\n\n```python\nclass CountUpTo:\n    def __init__(self, n):\n        self.n = n\n        self.i = 0\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.i >= self.n:\n            raise StopIteration\n        self.i += 1\n        return self.i\n\nfor x in CountUpTo(5):\n    print(x)\n```python\n\n---\n## 4) Generator functions are iterators too\nA generator function automatically creates an iterator.\n\n```python\ndef count_up_to(n):\n    i = 0\n    while i < n:\n        i += 1\n        yield i\n\nfor x in count_up_to(5):\n    print(x)\n```python\n\n---\n## 5) Practical consequence: one-pass iterators\nSome objects (like file handles, generator objects, many iterator tools) are **consumed** as you loop.\nIf you need to loop twice, you usually must recreate the iterator.\n\n```python\ndef make_iter():\n    for i in range(3):\n        yield i\n\nit = make_iter()\nprint(list(it))  # [0, 1, 2]\nprint(list(it))  # []\n\nit2 = make_iter()\nprint(list(it2)) # [0, 1, 2]\n```python\n\n---\n## 6) A dense practice block (consumption + next + for)\n\n```python\ndata = [\"a\", \"b\", \"c\"]\nit = iter(data)\n\nprint(next(it))\n\nfor x in it:\n    print(\"loop:\", x)\n\nprint(list(it))  # empty, already exhausted\n```",
      "difficulty": "hard",
      "doc_id": "doc-how-for-loops-really-work-iterables-iterators-next-and-stopiteration-fe19a3476f",
      "provenance": {
        "author": "",
        "date": "",
        "license": "PSF Documentation License (Python docs)",
        "source_file": "data/corpus_raw/loops_hard_1.json",
        "url": "https://docs.python.org/3/library/stdtypes.html"
      },
      "title": "How for-loops really work: iterables, iterators, next(), and StopIteration",
      "type": "reference"
    },
    {
      "ai_generated": true,
      "concept_tags": [
        "aliasing",
        "equality",
        "identity",
        "mutability",
        "none",
        "variables"
      ],
      "content": "A moderate step up from basic variables is understanding that variables refer to **objects**, and there are two different questions you might ask:\n\n- **Do these two values look the same?** \u2192 `==`\n- **Are these two names pointing to the same object?** \u2192 `is`\n\n---\n## 1) Equality compares values\n\n```python\nprint([1, 2, 3] == [1, 2, 3])  # True\nprint({\"a\": 1} == {\"a\": 1})  # True\n```python\n\n---\n## 2) Identity compares object sameness\n\n```python\na = [1, 2, 3]\nb = [1, 2, 3]\n\nprint(a is b)        # False (different list objects)\nprint(a == b)        # True  (same contents)\n```python\n\nYou can inspect identity with `id()`:\n\n```python\na = [1, 2]\nb = a\nc = a.copy()\n\nprint(id(a), id(b), id(c))\nprint(a is b)  # True\nprint(a is c)  # False\n```python\n\n---\n## 3) When should you use `is`?\nUse `is` when checking for singletons like `None`.\n\n```python\nvalue = None\nif value is None:\n    print(\"missing\")\n```python\n\nAvoid using `is` for string/number comparisons.\n\n```python\nx = 1000\ny = 1000\nprint(x == y)  # True\n# print(x is y)  # don't rely on this for correctness\n```python\n\n---\n## 4) A realistic example mixing identity, aliasing, and mutation\n\n```python\nitems = [\"a\", \"b\"]\nalias = items\ncopy1 = items.copy()\n\nalias.append(\"c\")\ncopy1.append(\"X\")\n\nprint(items)   # alias changed the original\nprint(alias)\nprint(copy1)   # separate\n\nprint(items is alias)   # True\nprint(items is copy1)   # False\n```python\n\n---\n## 5) Short practice block\nTry predicting which lines print True.\n\n```python\nx = [1]\ny = x\nz = [1]\n\nprint(x is y)\nprint(x == y)\nprint(x is z)\nprint(x == z)\n```",
      "difficulty": "moderate",
      "doc_id": "doc-identity-vs-equality-is-vs-id-and-how-variables-relate-to-objects-eff3606ea8",
      "provenance": {
        "author": "",
        "date": "",
        "license": "",
        "source_file": "data/corpus_raw/variables_moderate_4.json",
        "url": ""
      },
      "title": "Identity vs equality: is vs ==, id(), and how variables relate to objects",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "annotations",
        "functions",
        "inspect",
        "introspection",
        "signature",
        "tooling",
        "wrappers"
      ],
      "content": "If you\u2019re building tooling around code (parsers, generators, analyzers), function introspection becomes important. The `inspect` module provides a stable way to examine call signatures.\n\n---\n## 1) Read a function signature\n\n```python\nimport inspect\n\ndef f(a, b=10, *, c: int = 1, **kw) -> str:\n    return \"ok\"\n\nsig = inspect.signature(f)\nprint(sig)\n\nfor name, p in sig.parameters.items():\n    print(name, p.kind, p.default, p.annotation)\n\nprint(\"return\", sig.return_annotation)\n```python\n\n---\n## 2) Why wrappers can break introspection\nA decorator wrapper often looks like `(*args, **kwargs)` which hides real parameters.\n\n```python\ndef deco(func):\n    def wrapper(*args, **kwargs):\n        return func(*args, **kwargs)\n    return wrapper\n\n@deco\ndef add(a, b):\n    return a + b\n\nimport inspect\nprint(inspect.signature(add))  # shows (*args, **kwargs) not (a, b)\n```python\n\n---\n## 3) How wraps helps tools\n`functools.wraps` sets metadata (and commonly improves introspection behavior in practice).\n\n```python\nimport functools, inspect\n\ndef deco(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        return func(*args, **kwargs)\n    return wrapper\n\n@deco\ndef add(a, b):\n    return a + b\n\nprint(add.__name__)\nprint(inspect.signature(add))\n```python\n\n---\n## 4) Practical pattern: inspect + validation\n\n```python\nimport inspect\n\ndef accepts_two_args(fn):\n    sig = inspect.signature(fn)\n    params = [p for p in sig.parameters.values()\n              if p.kind in (p.POSITIONAL_ONLY, p.POSITIONAL_OR_KEYWORD)]\n    return len(params) == 2\n\nprint(accepts_two_args(lambda a, b: a + b))\nprint(accepts_two_args(lambda a, *, b: a + b))\n```python\n\n---\n## 5) A larger example: build a tiny call planner\nThis shows how tooling might build a call using defaults.\n\n```python\nimport inspect\n\ndef plan_call(fn):\n    sig = inspect.signature(fn)\n    kwargs = {}\n    for name, p in sig.parameters.items():\n        if p.default is not inspect.Parameter.empty:\n            kwargs[name] = p.default\n    return kwargs\n\ndef connect(host, port=443, *, timeout=5, secure=True):\n    return host, port, timeout, secure\n\nprint(plan_call(connect))\n```",
      "difficulty": "hard",
      "doc_id": "doc-introspecting-functions-hard-inspect-signature-parameters-annotations-and-wrapper-effects-7c83e939f7",
      "provenance": {
        "author": "",
        "date": "",
        "license": "PSF Documentation License (Python docs)",
        "source_file": "data/corpus_raw/functions_hard_3.json",
        "url": "https://docs.python.org/3/library/inspect.html"
      },
      "title": "Introspecting functions (hard): inspect.signature, parameters, annotations, and wrapper effects",
      "type": "reference"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "accumulation",
        "filtering",
        "for",
        "iterables",
        "len",
        "loops",
        "range"
      ],
      "content": "A moderate step in loops is shifting your mindset from \u201ccounting with indices\u201d to \u201citerating over **iterables**.\u201d Python\u2019s `for` loop is designed to work with any iterable: lists, sets, strings, ranges, and many custom objects.\n\n---\n## 1) for-loops iterate over items (not just numbers)\n\n```python\nfor ch in \"spam\":\n    print(ch)\n```python\n\n```python\nfor item in {\"a\", \"b\", \"c\"}:\n    print(item)\n```python\n\n---\n## 2) range(start, stop) is an iterable of numbers\n`range` produces numbers on demand (it does not build a giant list automatically).\n\n```python\nonetoten = range(1, 11)\nfor count in onetoten:\n    print(count)\n```python\n\n---\n## 3) Processing a list: accumulate a result\nModerate loop work often means building a computed output.\n\n```python\nnums = [2, 4, 6, 8]\n\ntotal = 0\nfor n in nums:\n    total += n\nprint(\"total\", total)\n```python\n\n---\n## 4) Counting + values (two common approaches)\n### Approach A: iterate values directly (preferred when possible)\n\n```python\nnums = [10, 20, 30]\nfor n in nums:\n    print(n)\n```python\n\n### Approach B: iterate indices only when needed\n\n```python\nnums = [10, 20, 30]\nfor i in range(len(nums)):\n    print(i, nums[i])\n```python\n\n---\n## 5) A slightly larger example: compute min/max and ignore bad items\n\n```python\ndata = [\"10\", \"x\", \"5\", \"-\", \"7\", \"3\"]\nvalues = []\n\nfor token in data:\n    if token.isdigit():\n        values.append(int(token))\n\nif values:\n    print(\"min\", min(values))\n    print(\"max\", max(values))\n    print(\"sum\", sum(values))\nelse:\n    print(\"no valid numbers\")\n```python\n\n---\n## 6) Practice: loop with a running average\n\n```python\nnums = [10, 20, 30, 40]\ncount = 0\ns = 0\n\nfor n in nums:\n    count += 1\n    s += n\n    print(\"after\", count, \"items avg=\", s / count)\n```",
      "difficulty": "moderate",
      "doc_id": "doc-iterating-the-python-way-iterables-range-and-processing-sequences-with-for-loops-1f45214370",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-SA 4.0 (Wikibooks) / also dual-licensed with GFDL per Wikibooks policy",
        "source_file": "data/corpus_raw/loops_moderate_2.json",
        "url": "https://en.wikibooks.org/wiki/Python_Programming/Loops"
      },
      "title": "Iterating the Python way: iterables, range(), and processing sequences with for-loops",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "chain",
        "cycle",
        "groupby",
        "islice",
        "iterators",
        "itertools",
        "loops",
        "pipelines",
        "product"
      ],
      "content": "Hard loop problems often become easier when you can **compose iterators** instead of writing nested loops manually. The `itertools` module provides fast, memory-efficient building blocks.\n\n---\n## 1) chain(): loop over multiple iterables as one\n\n```python\nimport itertools\n\nfor x in itertools.chain([1, 2], [\"a\", \"b\"], [True, False]):\n    print(x)\n```python\n\n---\n## 2) islice(): take a slice of an iterator (without converting to a list)\nUseful when you want \u201cfirst N items\u201d from a stream.\n\n```python\nimport itertools\n\nit = (i * i for i in range(100))\nfirst_five = itertools.islice(it, 5)\nprint(list(first_five))  # [0, 1, 4, 9, 16]\n```python\n\n---\n## 3) product(): nested loops without writing nested loops\n`product(A, B)` is like:\n\n```python\n# conceptual\n# for a in A:\n#   for b in B:\n#     yield (a, b)\n```python\n\nExample:\n\n```python\nimport itertools\n\ncolors = [\"red\", \"blue\"]\nsizes = [\"S\", \"M\", \"L\"]\n\nfor c, s in itertools.product(colors, sizes):\n    print(c, s)\n```python\n\n---\n## 4) cycle(): repeat values forever (be careful)\n\n```python\nimport itertools\n\nspinner = itertools.cycle([\"-\", \"\\\\\", \"|\", \"/\"])\nfor i in range(8):\n    print(next(spinner))\n```python\n\n---\n## 5) groupby(): group consecutive items\n`groupby` groups **adjacent** items with the same key (so it is usually used after sorting).\n\n```python\nimport itertools\n\ndata = [\"aa\", \"ab\", \"ac\", \"ba\", \"bb\", \"bc\"]\n\nfor key, group in itertools.groupby(data, key=lambda s: s[0]):\n    print(key, list(group))\n```python\n\nSorted grouping example:\n\n```python\nimport itertools\n\nwords = [\"dog\", \"cat\", \"apple\", \"cow\", \"banana\"]\nwords.sort(key=lambda w: w[0])\n\nfor k, g in itertools.groupby(words, key=lambda w: w[0]):\n    print(k, list(g))\n```python\n\n---\n## 6) A pipeline-style example (chain + filter + map + sum)\n\n```python\nimport itertools\n\nsources = itertools.chain([\"10\", \"x\"], [\"7\"], [\"3\", \"-\"])\n\nnums = (int(s) for s in sources if s.isdigit())\nprint(sum(nums))  # 20\n```python\n\n---\n## 7) Practical takeaways\n- Prefer iterator pipelines when data is large or streaming.\n- `itertools` tools avoid building intermediate lists.\n- Be careful with infinite iterators like `cycle()`.",
      "difficulty": "hard",
      "doc_id": "doc-iterator-algebra-with-itertools-chain-islice-product-cycle-and-groupby-373112e9f2",
      "provenance": {
        "author": "",
        "date": "",
        "license": "PSF Documentation License (Python docs)",
        "source_file": "data/corpus_raw/loops_hard_2.json",
        "url": "https://docs.python.org/3/library/itertools.html"
      },
      "title": "Iterator algebra with itertools: chain, islice, product, cycle, and groupby",
      "type": "reference"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "api-design",
        "functions",
        "keyword-only",
        "pep-3102",
        "readability",
        "special-parameters"
      ],
      "content": "Keyword-only arguments are parameters that **must** be supplied by name. They help avoid ambiguous calls and make code self-documenting.\n\nIn a function definition, putting a bare `*` means: \u201ceverything after this is keyword-only.\u201d\n\n---\n## 1) Basic keyword-only example\n\n```python\ndef connect(host, port, *, timeout=5):\n    return f\"connect {host}:{port} timeout={timeout}\"\n\nprint(connect(\"example.com\", 443, timeout=10))\n# connect(\"example.com\", 443, 10) fails because timeout is keyword-only\n```python\n\n---\n## 2) Why keyword-only is useful\nConsider a function with many optional settings. Keyword-only prevents calls like:\n\n```python\n# confusing\n# connect(\"example.com\", 443, 10)\n\n# clearer\nconnect(\"example.com\", 443, timeout=10)\n```python\n\n---\n## 3) Combining normal args + keyword-only args\n\n```python\ndef draw(text, width=10, *, fill=\"-\", align=\"center\"):\n    if len(text) >= width:\n        return text\n\n    pad = width - len(text)\n    if align == \"left\":\n        return text + fill * pad\n    if align == \"right\":\n        return fill * pad + text\n\n    left = pad // 2\n    right = pad - left\n    return fill * left + text + fill * right\n\nprint(draw(\"hi\", 12, fill=\"*\", align=\"left\"))\nprint(draw(\"hi\", 12, fill=\"*\", align=\"right\"))\nprint(draw(\"hi\", 12, fill=\"*\"))\n```python\n\n---\n## 4) Practice: make a function safer by forcing named options\n\n```python\ndef parse_int(text, *, base=10):\n    text = text.strip()\n    try:\n        return int(text, base)\n    except ValueError:\n        return None\n\nprint(parse_int(\"FF\", base=16))\nprint(parse_int(\" 42 \"))\n```",
      "difficulty": "moderate",
      "doc_id": "doc-keyword-only-arguments-pep-3102-making-calls-clearer-with-b252f08a30",
      "provenance": {
        "author": "",
        "date": "",
        "license": "Public domain (PEP text)",
        "source_file": "data/corpus_raw/functions_moderate_3.json",
        "url": "https://peps.python.org/pep-3102/"
      },
      "title": "Keyword-only arguments (PEP 3102): making calls clearer with '*'",
      "type": "reference"
    },
    {
      "ai_generated": true,
      "concept_tags": [
        "break",
        "continue",
        "counting",
        "for",
        "loop-else",
        "loops",
        "parsing",
        "unpacking"
      ],
      "content": "Looping over lines is a common real-world use of `for`. This example stays moderate: it mixes parsing, counters, and early exit, but remains readable.\n\n---\n## 1) Basic line iteration (list of lines)\n\n```python\nlines = [\n    \"INFO start\\n\",\n    \"WARN low disk\\n\",\n    \"INFO running\\n\",\n    \"ERROR crashed\\n\",\n]\n\nfor line in lines:\n    print(line.strip())\n```python\n\n---\n## 2) Counting types of lines\n\n```python\ncounts = {\"INFO\": 0, \"WARN\": 0, \"ERROR\": 0}\n\nfor line in lines:\n    text = line.strip()\n    level, *rest = text.split(\" \")\n    if level in counts:\n        counts[level] += 1\n\nprint(counts)\n```python\n\n---\n## 3) Stop when a condition is met (early exit)\n\n```python\nfor line in lines:\n    if line.startswith(\"ERROR\"):\n        print(\"first error:\", line.strip())\n        break\nelse:\n    print(\"no errors\")\n```python\n\n---\n## 4) Practice-style block: extract messages after WARN\n\n```python\nwarn_msgs = []\nfor line in lines:\n    if not line.startswith(\"WARN\"):\n        continue\n    warn_msgs.append(line.strip())\n\nprint(warn_msgs)\n```",
      "difficulty": "moderate",
      "doc_id": "doc-looping-over-text-lines-clean-parsing-counters-and-early-exit-patterns-ce462c5d5f",
      "provenance": {
        "author": "",
        "date": "",
        "license": "",
        "source_file": "data/corpus_raw/loops_moderate_4.json",
        "url": ""
      },
      "title": "Looping over text lines: clean parsing, counters, and early-exit patterns",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "counting",
        "for",
        "infinite-loop",
        "loops",
        "range",
        "sentinel",
        "while"
      ],
      "content": "Loops let you repeat a block of code. In Python, the two everyday loops are:\n\n- `for`: repeat once for each item in a sequence/iterable\n- `while`: repeat while a condition stays true\n\n---\n## 1) A simple `for` loop over a list\n\n```python\nnames = [\"Ana\", \"Ben\", \"Kai\"]\nfor name in names:\n    print(\"Hello\", name)\n```python\n\nThis reads naturally: \u201cfor each name in names, run the indented block.\u201d\n\n---\n## 2) Counting with `range()`\nUse `range(n)` to produce `0..n-1`.\n\n```python\nfor i in range(5):\n    print(i)\n# 0 1 2 3 4\n```python\n\nCounting from 1 to 5:\n\n```python\nfor i in range(1, 6):\n    print(i)\n# 1 2 3 4 5\n```python\n\nUsing a step:\n\n```python\nfor i in range(0, 10, 2):\n    print(i)\n# 0 2 4 6 8\n```python\n\n---\n## 3) A `while` loop for repeated actions\nA `while` loop checks its condition before each iteration.\n\n```python\ncount = 1\nwhile count <= 5:\n    print(\"count =\", count)\n    count += 1\n```python\n\n---\n## 4) Sentinel input loop (repeat until a target value)\nA common pattern is \u201ckeep asking until the user enters a special value.\u201d\n\n```python\npassword = \"unicorn\"\nentered = \"\"\n\nwhile entered != password:\n    entered = input(\"Password: \")\n\nprint(\"Welcome in\")\n```python\n\nThis loop stops when `entered` matches the sentinel value.\n\n---\n## 5) Avoiding infinite loops\nIf the condition never becomes false, the loop runs forever.\n\n```python\n# WARNING: infinite loop example\n# x = 1\n# while x > 0:\n#     print(x)\n#     x += 1\n```python\n\nA safe habit is to ensure your loop updates the variable that controls the condition.\n\n---\n## 6) A small practice script (for + while)\n\n```python\n# for loop: sum numbers 1..5\ns = 0\nfor i in range(1, 6):\n    s += i\nprint(\"sum\", s)\n\n# while loop: countdown\nn = 3\nwhile n > 0:\n    print(\"T-\", n)\n    n -= 1\nprint(\"Lift off\")\n```",
      "difficulty": "intro",
      "doc_id": "doc-loops-in-python-for-vs-while-counting-and-sentinel-driven-repetition-5bd4c915d6",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-SA 4.0 (Wikibooks) / also dual-licensed with GFDL per Wikibooks policy",
        "source_file": "data/corpus_raw/loops_easy_1.json",
        "url": "https://en.wikibooks.org/wiki/Python_Programming/Loops"
      },
      "title": "Loops in Python: for vs while, counting, and sentinel-driven repetition",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "chained-comparisons",
        "comparisons",
        "conditionals",
        "identity",
        "membership",
        "precedence"
      ],
      "content": "Moderate conditionals often involve writing **clear comparisons** and avoiding subtle bugs.\n\n---\n## 1) Chained comparisons\nPython allows chained comparisons like `0 < x < 10`. This is usually clearer than writing two comparisons with `and`.\n\n```python\nx = 7\nif 0 < x < 10:\n    print(\"single digit positive\")\n```python\n\nA more realistic example:\n\n```python\ntemp = 22\nif 18 <= temp <= 27:\n    print(\"comfortable\")\nelse:\n    print(\"adjust\")\n```python\n\n---\n## 2) Membership tests: in / not in\nMembership checks are often clearer than multiple equality checks.\n\n```python\ncmd = \"status\"\nif cmd in {\"start\", \"stop\", \"status\"}:\n    print(\"known command\")\nelse:\n    print(\"unknown\")\n```python\n\n---\n## 3) Identity vs equality: is vs ==\nUse `is` for singletons like `None`. Use `==` for value comparisons.\n\n```python\nvalue = None\nif value is None:\n    print(\"missing\")\n\nx = [1, 2]\ny = [1, 2]\nprint(x == y)  # True\nprint(x is y)  # False\n```python\n\n---\n## 4) Common readability tip: avoid overly clever precedence\nParentheses can make intent obvious.\n\n```python\nage = 19\nhas_ticket = True\nvip = False\n\nif (age >= 18 and has_ticket) or vip:\n    print(\"enter\")\nelse:\n    print(\"no\")\n```python\n\n---\n## 5) Practice block: classify a score with clear comparisons\n\n```python\ndef grade(score):\n    if score < 0 or score > 100:\n        return \"invalid\"\n    if score >= 90:\n        return \"A\"\n    if score >= 80:\n        return \"B\"\n    if score >= 70:\n        return \"C\"\n    return \"D\"\n\nfor s in [105, 95, 81, 70, 69]:\n    print(s, grade(s))\n```",
      "difficulty": "moderate",
      "doc_id": "doc-moderate-comparisons-chaining-membership-checks-identity-and-readable-conditions-2351734f71",
      "provenance": {
        "author": "",
        "date": "",
        "license": "PSF Documentation License (Python docs)",
        "source_file": "data/corpus_raw/conditionals_moderate_2.json",
        "url": "https://docs.python.org/3/reference/expressions.html"
      },
      "title": "Moderate comparisons: chaining, membership checks, identity, and readable conditions",
      "type": "reference"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "break",
        "continue",
        "for",
        "loop-else",
        "loops",
        "nested-loops",
        "range",
        "search-patterns"
      ],
      "content": "Once you\u2019re comfortable with basic `for` and `while` loops, the next step is learning **loop control patterns**: exiting early, skipping work, and using `else` with loops to express \u201cnot found.\u201d\n\n---\n## 1) break: exit early when the goal is reached\nA very common pattern is to stop looping as soon as you find what you need.\n\n```python\nvalues = [3, 7, 9, 12]\ntarget = 9\n\nfor v in values:\n    if v == target:\n        print(\"found\", v)\n        break\nprint(\"done\")\n```python\n\n---\n## 2) continue: skip the current iteration\nUse `continue` when you want to ignore certain items and move on.\n\n```python\nnums = [1, 2, 3, 4, 5, 6]\nfor n in nums:\n    if n % 2 == 0:\n        continue\n    print(\"odd:\", n)\n```python\n\n---\n## 3) loop-else: express \u201cno break happened\u201d\nA loop can have an `else` clause. The `else` block runs only if the loop finishes normally (not via `break`).\n\n```python\nvalues = [3, 7, 9, 12]\ntarget = 100\n\nfor v in values:\n    if v == target:\n        print(\"found\", v)\n        break\nelse:\n    print(\"not found\")\n```python\n\nThis avoids extra flags like `found = False` in many cases.\n\n---\n## 4) Nested loops + break: \u201cprime search\u201d style\nThe tutorial\u2019s classic example shows nested loops with `break` and a loop `else`.\n\n```python\nfor n in range(2, 10):\n    for x in range(2, n):\n        if n % x == 0:\n            print(n, \"equals\", x, \"*\", n // x)\n            break\n    else:\n        # ran without finding a factor\n        print(n, \"is prime\")\n```python\n\n---\n## 5) A readable \u201csearch\u201d function with loop-else\n\n```python\ndef find_first_even(values):\n    for v in values:\n        if v % 2 == 0:\n            return v\n    return None\n\nprint(find_first_even([1, 3, 5, 8, 9]))\nprint(find_first_even([1, 3, 5]))\n```python\n\nAlternative using loop-else:\n\n```python\ndef find_first_even(values):\n    for v in values:\n        if v % 2 == 0:\n            return v\n    else:\n        return None\n```python\n\n---\n## 6) Practice block: filter + early exit\n\n```python\n# Print numbers from 1..20, skipping multiples of 3.\n# Stop entirely if you hit a multiple of 11.\nfor n in range(1, 21):\n    if n % 11 == 0:\n        print(\"stop at\", n)\n        break\n    if n % 3 == 0:\n        continue\n    print(n)\n```",
      "difficulty": "moderate",
      "doc_id": "doc-moderate-loop-control-break-continue-loop-else-and-search-patterns-1fcdf722b4",
      "provenance": {
        "author": "",
        "date": "",
        "license": "PSF Documentation License; code examples are dual-licensed (PSF-2.0 and BSD-0 starting Python 3.8.6+)",
        "source_file": "data/corpus_raw/loops_moderate_1.json",
        "url": "https://docs.python.org/3/tutorial/controlflow.html"
      },
      "title": "Moderate loop control: break/continue, loop-else, and search patterns",
      "type": "tutorial"
    },
    {
      "ai_generated": true,
      "concept_tags": [
        "caching",
        "defaults",
        "dicts",
        "functions",
        "lists",
        "mutable-defaults",
        "testing"
      ],
      "content": "One of the most important moderate-level function details is that **default parameter values are evaluated once**, when the function is defined. If the default is mutable (like a list or dict), it can keep state between calls.\n\n---\n## 1) The surprising behavior\n\n```python\ndef add_tag(tag, tags=[]):\n    tags.append(tag)\n    return tags\n\nprint(add_tag(\"a\"))\nprint(add_tag(\"b\"))\nprint(add_tag(\"c\"))\n```python\n\nThis keeps growing because `tags` is the same list object each time.\n\n---\n## 2) The common safe pattern: default to None\n\n```python\ndef add_tag(tag, tags=None):\n    if tags is None:\n        tags = []\n    tags.append(tag)\n    return tags\n\nprint(add_tag(\"a\"))\nprint(add_tag(\"b\"))\n```python\n\n---\n## 3) Same pitfall with dict defaults\n\n```python\ndef count_word(word, counts={}):\n    counts[word] = counts.get(word, 0) + 1\n    return counts\n\nprint(count_word(\"hi\"))\nprint(count_word(\"hi\"))\n```python\n\nSafe version:\n\n```python\ndef count_word(word, counts=None):\n    if counts is None:\n        counts = {}\n    counts[word] = counts.get(word, 0) + 1\n    return counts\n\nprint(count_word(\"hi\"))\nprint(count_word(\"hi\"))\n```python\n\n---\n## 4) When a mutable default is actually OK\nSometimes you *want* caching. In that case, document it clearly.\n\n```python\ndef fib(n, _cache={0: 0, 1: 1}):\n    if n in _cache:\n        return _cache[n]\n    _cache[n] = fib(n - 1) + fib(n - 2)\n    return _cache[n]\n\nprint(fib(10))\nprint(fib(12))\n```python\n\n---\n## 5) Lightweight tests to catch regressions\n\n```python\ndef add_tag_safe(tag, tags=None):\n    if tags is None:\n        tags = []\n    tags.append(tag)\n    return tags\n\nassert add_tag_safe(\"x\") == [\"x\"]\nassert add_tag_safe(\"y\") == [\"y\"]\nprint(\"tests passed\")\n```",
      "difficulty": "moderate",
      "doc_id": "doc-mutable-default-arguments-moderate-why-it-happens-and-safe-design-patterns-77be358d12",
      "provenance": {
        "author": "",
        "date": "",
        "license": "",
        "source_file": "data/corpus_raw/functions_moderate_4.json",
        "url": ""
      },
      "title": "Mutable default arguments (moderate): why it happens and safe design patterns",
      "type": "tutorial"
    },
    {
      "ai_generated": true,
      "concept_tags": [
        "break",
        "enumerate",
        "functions",
        "grids",
        "loops",
        "nested-loops",
        "search"
      ],
      "content": "Nested loops show up naturally when working with 2D data (grids, tables, boards). This example is moderate because it introduces coordinate tracking and multiple exit strategies.\n\n---\n## 1) Scan a grid and print coordinates\n\n```python\ngrid = [\n    [\".\", \".\", \".\"],\n    [\".\", \"X\", \".\"],\n    [\".\", \".\", \".\"],\n]\n\nfor r in range(len(grid)):\n    for c in range(len(grid[r])):\n        print(\"cell\", r, c, grid[r][c])\n```python\n\n---\n## 2) Find the first 'X' using break + flag\n\n```python\nfound = False\npos = None\n\nfor r in range(len(grid)):\n    for c in range(len(grid[r])):\n        if grid[r][c] == \"X\":\n            found = True\n            pos = (r, c)\n            break\n    if found:\n        break\n\nprint(\"found\", found, \"pos\", pos)\n```python\n\n---\n## 3) Alternative: wrap search in a function and return early\nReturning early is often the cleanest way to exit multiple loop layers.\n\n```python\ndef find_x(grid):\n    for r, row in enumerate(grid):\n        for c, value in enumerate(row):\n            if value == \"X\":\n                return (r, c)\n    return None\n\nprint(find_x(grid))\n```python\n\n---\n## 4) Practice block: count neighbors around a coordinate\n\n```python\ndef neighbors(r, c):\n    return [\n        (r-1, c), (r+1, c),\n        (r, c-1), (r, c+1)\n    ]\n\nr0, c0 = 1, 1\ncount_dots = 0\n\nfor r, c in neighbors(r0, c0):\n    if 0 <= r < len(grid) and 0 <= c < len(grid[r]):\n        if grid[r][c] == \".\":\n            count_dots += 1\n\nprint(\"dots around X:\", count_dots)\n```",
      "difficulty": "moderate",
      "doc_id": "doc-nested-loop-search-scanning-a-grid-tracking-coordinates-and-clean-exit-strategies-cc184d15e4",
      "provenance": {
        "author": "",
        "date": "",
        "license": "",
        "source_file": "data/corpus_raw/loops_moderate_5.json",
        "url": ""
      },
      "title": "Nested loop search: scanning a grid, tracking coordinates, and clean exit strategies",
      "type": "tutorial"
    },
    {
      "ai_generated": true,
      "concept_tags": [
        "break",
        "grids",
        "loops",
        "nested-loops",
        "range",
        "tables"
      ],
      "content": "Nested loops are loops inside loops. They\u2019re useful for working with grid-like data, building tables, or processing pairs of items.\n\n---\n## 1) Print a small multiplication table\n\n```python\nfor row in range(1, 4):\n    for col in range(1, 4):\n        print(row * col, end=\" \")\n    print()  # new line after each row\n```python\n\n---\n## 2) Loop through a \u201cgrid\u201d (list of lists)\n\n```python\ngrid = [\n    [1, 2, 3],\n    [4, 5, 6],\n]\n\nfor r in grid:\n    for value in r:\n        print(value)\n```python\n\n---\n## 3) Build a flattened list (turn 2D into 1D)\n\n```python\ngrid = [\n    [1, 2, 3],\n    [4, 5, 6],\n]\n\nflat = []\nfor r in grid:\n    for value in r:\n        flat.append(value)\n\nprint(flat)  # [1, 2, 3, 4, 5, 6]\n```python\n\n---\n## 4) Pairs: all combinations of two lists\n\n```python\ncolors = [\"red\", \"blue\"]\nsizes = [\"S\", \"M\", \"L\"]\n\nfor c in colors:\n    for s in sizes:\n        print(c, s)\n```python\n\n---\n## 5) Early exit from nested loops (simple technique)\nIf you want to stop both loops when you find something, one easy approach is a flag.\n\n```python\nfound = False\nfor r in range(3):\n    for c in range(3):\n        if r == 1 and c == 2:\n            found = True\n            break\n    if found:\n        break\n\nprint(\"found?\", found)\n```",
      "difficulty": "intro",
      "doc_id": "doc-nested-loops-easy-grids-simple-tables-and-readable-structure-a0cec1dadc",
      "provenance": {
        "author": "",
        "date": "",
        "license": "",
        "source_file": "data/corpus_raw/loops_easy_4.json",
        "url": ""
      },
      "title": "Nested loops (easy): grids, simple tables, and readable structure",
      "type": "tutorial"
    },
    {
      "ai_generated": true,
      "concept_tags": [
        "debugging",
        "exhaustion",
        "generators",
        "iterators",
        "loops",
        "pipelines"
      ],
      "content": "Hard loop bugs often happen when code accidentally assumes an iterator can be reused like a list. Many iteration tools are **one-pass**.\n\n---\n## 1) The bug: consuming an iterator early\n\n```python\ndef data_stream():\n    for i in range(3):\n        yield i\n\nit = data_stream()\nprint(\"preview\", list(it))\n\n# later...\nfor x in it:\n    print(\"loop\", x)\n# nothing prints (iterator already consumed)\n```python\n\n---\n## 2) Fix A: recreate the iterator when needed\n\n```python\ndef data_stream():\n    for i in range(3):\n        yield i\n\nit1 = data_stream()\nprint(\"preview\", list(it1))\n\nit2 = data_stream()\nfor x in it2:\n    print(\"loop\", x)\n```python\n\n---\n## 3) Fix B: snapshot to a list (when data size is manageable)\n\n```python\nit = (i for i in range(5))\nitems = list(it)\n\nprint(\"preview\", items)\nfor x in items:\n    print(\"loop\", x)\n```python\n\n---\n## 4) Fix C: split iteration carefully\nIf you must use the same underlying stream twice, you may need different strategies.\nA straightforward approach is to compute what you need in a single pass.\n\n```python\nnums = (i for i in range(10))\n\ncount = 0\ns = 0\nfor n in nums:\n    count += 1\n    s += n\n\nprint(\"count\", count)\nprint(\"sum\", s)\n```python\n\n---\n## 5) A pipeline example where single-pass is a feature\n\n```python\nlines = [\"10\\n\", \"x\\n\", \"5\\n\", \"7\\n\"]\nnums = (int(line) for line in lines if line.strip().isdigit())\n\nprint(sum(nums))\n```python\n\n---\n## 6) Practical takeaway\n- If you need multiple passes, prefer **recreating the iterator**.\n- If data is small enough, snapshot with `list()`.\n- If the dataset is large, restructure to compute results in one pass.",
      "difficulty": "hard",
      "doc_id": "doc-one-pass-iterators-in-real-code-exhaustion-pitfalls-and-safe-handling-patterns-43f2cbd84c",
      "provenance": {
        "author": "",
        "date": "",
        "license": "",
        "source_file": "data/corpus_raw/loops_hard_4.json",
        "url": ""
      },
      "title": "One-pass iterators in real code: exhaustion pitfalls and safe handling patterns",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "aggregation",
        "enumerate",
        "for",
        "indexing",
        "loops",
        "parallel-iteration",
        "zip"
      ],
      "content": "After you know basic loops, a very useful moderate technique is **parallel iteration**: walking through two or more sequences at the same time. The built-ins `zip()` and `enumerate()` are common tools for this.\n\n---\n## 1) zip(): pair items by position\n\n```python\nnames = [\"Ana\", \"Ben\", \"Kai\"]\nscores = [10, 25, 18]\n\nfor name, score in zip(names, scores):\n    print(name, \"scored\", score)\n```python\n\nIf the lists have different lengths, `zip` stops at the shortest.\n\n```python\nnames = [\"Ana\", \"Ben\", \"Kai\"]\nscores = [10, 25]\n\nfor name, score in zip(names, scores):\n    print(name, score)\n# prints only Ana/Ben\n```python\n\n---\n## 2) enumerate(): add an index\n\n```python\nitems = [\"a\", \"b\", \"c\"]\nfor i, v in enumerate(items):\n    print(i, v)\n```python\n\nStart indexing from 1:\n\n```python\nfor i, v in enumerate(items, start=1):\n    print(i, v)\n```python\n\n---\n## 3) Combine enumerate + zip: index + paired values\n\n```python\nnames = [\"Ana\", \"Ben\", \"Kai\"]\nscores = [10, 25, 18]\n\nfor i, (name, score) in enumerate(zip(names, scores), start=1):\n    print(i, name, score)\n```python\n\n---\n## 4) A more realistic example: align columns and compute totals\n\n```python\nproducts = [\"pen\", \"notebook\", \"tape\"]\nprices = [1.50, 3.00, 2.25]\nqty = [2, 1, 3]\n\ngrand = 0.0\nfor i, (p, price, q) in enumerate(zip(products, prices, qty), start=1):\n    line = price * q\n    grand += line\n    print(i, p, \"line=\", line)\n\nprint(\"grand=\", grand)\n```python\n\n---\n## 5) Practice: detect mismatched lists early (simple check)\nSometimes you *want* to ensure lengths match.\n\n```python\nif len(products) != len(prices) or len(prices) != len(qty):\n    print(\"length mismatch\")\nelse:\n    for p, price, q in zip(products, prices, qty):\n        print(p, price, q)\n```",
      "difficulty": "moderate",
      "doc_id": "doc-parallel-iteration-with-zip-and-enumerate-iterate-multiple-sequences-with-an-index-deed0d77ae",
      "provenance": {
        "author": "",
        "date": "",
        "license": "Copyright (site content); verify reuse permissions before redistribution",
        "source_file": "data/corpus_raw/loops_moderate_3.json",
        "url": "https://note.nkmk.me/en/python-for-enumerate-zip/"
      },
      "title": "Parallel iteration with zip() and enumerate(): iterate multiple sequences with an index",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "api-design",
        "functions",
        "pep-570",
        "positional-only",
        "signatures",
        "special-parameters"
      ],
      "content": "Positional-only parameters let you define function arguments that **cannot** be passed by keyword. This is useful when you want to:\n- prevent callers from depending on parameter names\n- keep flexibility to rename parameters later\n- match conventions of built-in functions\n\nSyntax: parameters **before** `/` are positional-only.\n\n---\n## 1) Basic example\n\n```python\ndef divide(a, b, /):\n    return a / b\n\nprint(divide(10, 2))\n# divide(a=10, b=2) would raise TypeError\n```python\n\n---\n## 2) Mixing positional-only with other kinds\n\n```python\n# a, b: positional-only\n# c: positional-or-keyword\n# d: keyword-only\n\ndef demo(a, b, /, c, *, d):\n    return a, b, c, d\n\nprint(demo(1, 2, 3, d=4))\n# demo(a=1, b=2, c=3, d=4) fails because a and b are positional-only\n```python\n\n---\n## 3) Why it\u2019s useful (practical API perspective)\nIf you expose a function with keywords, callers may write:\n\n```python\n# caller code\nresult = demo(a=1, b=2, c=3, d=4)\n```python\n\nIf you later rename `a` to `x`, the call breaks. Positional-only reduces this risk.\n\n---\n## 4) Signature clarity vs *args tricks\nBefore `/`, libraries sometimes used `*args` to force positional usage, but that hides the signature.\nWith `/`, you can keep a clean signature while enforcing positional-only behavior.\n\n---\n## 5) Practice: design a stable numeric API\n\n```python\ndef clamp(n, /, lo=0, hi=100):\n    if n < lo:\n        return lo\n    if n > hi:\n        return hi\n    return n\n\nprint(clamp(5))\nprint(clamp(5, lo=3))\nprint(clamp(5, hi=4))\n# clamp(n=5) would fail because n is positional-only\n```",
      "difficulty": "moderate",
      "doc_id": "doc-positional-only-parameters-pep-570-using-to-control-function-call-semantics-a5d400b365",
      "provenance": {
        "author": "",
        "date": "",
        "license": "Public domain (PEP text)",
        "source_file": "data/corpus_raw/functions_moderate_2.json",
        "url": "https://peps.python.org/pep-0570/"
      },
      "title": "Positional-only parameters (PEP 570): using '/' to control function call semantics",
      "type": "reference"
    },
    {
      "ai_generated": true,
      "concept_tags": [
        "augmented-assignment",
        "copy",
        "deepcopy",
        "dicts",
        "lists",
        "parsing",
        "unpacking",
        "variables"
      ],
      "content": "This walkthrough uses moderate variable techniques in a practical mini task: parse records, update counters, and avoid accidental aliasing.\n\n---\n## 1) The input data\nEach record looks like: `(user, score, tags...)`.\n\n```python\nrecords = [\n    (\"ana\", 10, \"new\", \"mobile\"),\n    (\"ben\", 25, \"returning\"),\n    (\"ana\", 5, \"web\"),\n]\n```python\n\n---\n## 2) Use unpacking to separate fixed fields and the rest\n\n```python\ntotals = {}\ntag_index = {}\n\nfor rec in records:\n    user, score, *tags = rec\n\n    totals[user] = totals.get(user, 0) + score\n\n    for t in tags:\n        tag_index.setdefault(t, []).append(user)\n\nprint(totals)\nprint(tag_index)\n```python\n\n---\n## 3) Why aliasing matters when indexing\nIf you reuse the same list object in multiple places, one append can affect multiple keys.\nA safe habit is to create a new list per key.\n\n```python\n# Safe pattern: setdefault creates/stores a list per key\nidx = {}\nidx.setdefault(\"a\", []).append(1)\nidx.setdefault(\"a\", []).append(2)\nprint(idx)  # {'a': [1, 2]}\n```python\n\n---\n## 4) Snapshotting data: shallow copy vs deep copy\nIf your structure is nested, consider what you need.\n\n```python\nimport copy\n\nstate = {\"totals\": totals, \"tag_index\": tag_index}\nshallow = state.copy()              # outer copy only\nsafe = copy.deepcopy(state)         # nested copy\n\n# mutate nested\nstate[\"tag_index\"].setdefault(\"new\", []).append(\"SYSTEM\")\n\nprint(shallow[\"tag_index\"][\"new\"])  # likely changed (shared)\nprint(safe[\"tag_index\"].get(\"new\")) # independent snapshot\n```python\n\n---\n## 5) A compact summary script (single block)\n\n```python\nimport copy\n\nrecords = [\n    (\"ana\", 10, \"new\", \"mobile\"),\n    (\"ben\", 25, \"returning\"),\n    (\"ana\", 5, \"web\"),\n]\n\ntotals = {}\ntag_index = {}\n\nfor user, score, *tags in records:\n    totals[user] = totals.get(user, 0) + score\n    for t in tags:\n        tag_index.setdefault(t, []).append(user)\n\nsnapshot = copy.deepcopy({\"totals\": totals, \"tag_index\": tag_index})\n\nprint(\"totals\", totals)\nprint(\"tags\", tag_index)\nprint(\"snapshot\", snapshot)\n```",
      "difficulty": "moderate",
      "doc_id": "doc-putting-it-together-parsing-records-with-unpacking-updating-counters-and-copying-safely-5b6baf6607",
      "provenance": {
        "author": "",
        "date": "",
        "license": "",
        "source_file": "data/corpus_raw/variables_moderate_5.json",
        "url": ""
      },
      "title": "Putting it together: parsing records with unpacking, updating counters, and copying safely",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "def",
        "defaults",
        "docstrings",
        "functions",
        "keyword-arguments",
        "parameters",
        "return"
      ],
      "content": "Functions help you reuse logic, reduce repetition, and make code easier to read.\n\n---\n## 1) Defining and calling a function\nA function is defined with `def` and called by writing its name with parentheses.\n\n```python\ndef greet(name):\n    print(\"Hello\", name)\n\ngreet(\"Ana\")\ngreet(\"Ben\")\n```python\n\n---\n## 2) Returning values\nUse `return` to send a value back to the caller.\n\n```python\ndef add(a, b):\n    return a + b\n\nresult = add(2, 3)\nprint(result)\n```python\n\nIf a function returns nothing explicitly, it returns `None`.\n\n```python\ndef show(x):\n    print(\"x=\", x)\n\nprint(show(123))  # prints x=123 then prints None\n```python\n\n---\n## 3) Multiple return values (as a tuple)\nPython can return multiple values by returning a tuple.\n\n```python\ndef min_max(values):\n    return min(values), max(values)\n\nlo, hi = min_max([3, 9, 1, 5])\nprint(lo, hi)\n```python\n\n---\n## 4) Docstrings (notes inside the function)\nA docstring is the first string inside a function body. Tools can read it.\n\n```python\ndef area_rectangle(w, h):\n    \"\"\"Return the area of a rectangle with width w and height h.\"\"\"\n    return w * h\n\nprint(area_rectangle.__doc__)\nprint(area_rectangle(3, 4))\n```python\n\n---\n## 5) Default parameter values\nDefaults make arguments optional.\n\n```python\ndef power(base, exp=2):\n    return base ** exp\n\nprint(power(3))     # 9\nprint(power(3, 3))  # 27\n```python\n\n---\n## 6) Keyword arguments (call by name)\nKeyword arguments improve readability and allow flexible ordering.\n\n```python\ndef format_user(name, age, city):\n    return f\"{name} ({age}) from {city}\"\n\nprint(format_user(age=20, name=\"Ana\", city=\"Manila\"))\n```python\n\n---\n## 7) A small practice script: parse and compute\n\n```python\ndef parse_int(text):\n    text = text.strip()\n    if not text.isdigit():\n        return None\n    return int(text)\n\nvalues = [\"10\", \"x\", \" 7 \", \"-\", \"3\"]\nnums = []\n\nfor t in values:\n    n = parse_int(t)\n    if n is not None:\n        nums.append(n)\n\nprint(\"nums\", nums)\nprint(\"sum\", sum(nums))\n```",
      "difficulty": "intro",
      "doc_id": "doc-python-functions-easy-def-parameters-return-values-and-docstrings-124102fc40",
      "provenance": {
        "author": "",
        "date": "",
        "license": "PSF Documentation License; code examples in docs are dual-licensed (PSF-2.0 and BSD-0 starting Python 3.8.6+)",
        "source_file": "data/corpus_raw/functions_easy_1.json",
        "url": "https://docs.python.org/3/tutorial/controlflow.html"
      },
      "title": "Python functions (easy): def, parameters, return values, and docstrings",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "break",
        "continue",
        "for",
        "iteration",
        "loop-else",
        "loops",
        "range"
      ],
      "content": "Python\u2019s tutorial introduces `for` loops (iteration over items), `range()` for counting, and common loop controls like `break` and `continue`.\n\n---\n## 1) Iterating directly over items\nInstead of indexing, Python commonly loops over values directly.\n\n```python\nwords = [\"cat\", \"window\", \"defenestrate\"]\nfor w in words:\n    print(w, len(w))\n```python\n\n---\n## 2) Counting with range()\n\n```python\nfor i in range(5):\n    print(i)\n```python\n\nA frequent beginner task: iterate by index when you truly need positions.\n\n```python\nitems = [\"a\", \"b\", \"c\"]\nfor i in range(len(items)):\n    print(i, items[i])\n```python\n\n---\n## 3) break: exit a loop early\n\n```python\nfor n in range(2, 10):\n    if n == 5:\n        break\n    print(n)\nprint(\"done\")\n```python\n\n---\n## 4) continue: skip to the next iteration\n\n```python\nfor n in range(1, 8):\n    if n % 2 == 0:\n        continue\n    print(\"odd:\", n)\n```python\n\n---\n## 5) else on loops\nA loop can have an `else` clause that runs only if the loop finishes normally (not via `break`).\n\n```python\nfor n in range(2, 6):\n    if n == 4:\n        break\nelse:\n    print(\"loop ended without break\")\n\nprint(\"after loop\")\n```python\n\nTry removing the `break` line and see the `else` behavior.\n\n---\n## 6) A friendly example: find the first match\n\n```python\nvalues = [3, 7, 9, 12]\ntarget = 9\n\nfor v in values:\n    if v == target:\n        print(\"found\", v)\n        break\nelse:\n    print(\"not found\")\n```python\n\n---\n## 7) Mini practice block\n\n```python\n# Print numbers 1..10, but skip multiples of 3\nfor n in range(1, 11):\n    if n % 3 == 0:\n        continue\n    print(n)\n```",
      "difficulty": "intro",
      "doc_id": "doc-python-loop-control-for-range-break-continue-and-else-on-loops-9e511c3e9e",
      "provenance": {
        "author": "",
        "date": "",
        "license": "PSF Documentation License; code examples in docs are dual-licensed (PSF-2.0 and BSD-0 starting Python 3.8.6+)",
        "source_file": "data/corpus_raw/loops_easy_2.json",
        "url": "https://docs.python.org/3/tutorial/controlflow.html"
      },
      "title": "Python loop control: for + range, break/continue, and else on loops",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "binding",
        "blocks",
        "closures",
        "free-variables",
        "global",
        "nonlocal",
        "scope",
        "variables"
      ],
      "content": "This section builds a solid mental model for *where variable names live* and *how Python decides what a name refers to*. This is one of the most important \u201chard\u201d topics because the rules are determined by the **structure of the code block**, not by types or declarations.\n\n---\n## 1) Names, objects, and binding\nA **name** (variable) refers to an **object**. A **binding operation** creates or updates that relationship.\n\nTypical binding operations include:\n- assignment (`x = ...`)\n- function definitions (`def f(...): ...` binds `f`)\n- imports (`import math` binds `math`)\n- loop targets (`for i in ...` binds `i`)\n- exception targets (`except Exception as e` binds `e`)\n\n```python\nx = 10\n\ndef demo_bindings():\n    y = 1\n    for i in range(3):\n        pass\n    try:\n        1 / 0\n    except Exception as e:\n        pass\n    import math\n    return y, i, e, math\n\nprint(x)\nprint(demo_bindings())\n```python\n\n---\n## 2) Blocks and scope boundaries\nA **block** is code executed as a unit. The most common blocks are:\n- a module (top-level of a file)\n- a function body\n- a class body\n\nEach block has rules about where bindings go.\n\n### Module (global) scope\nNames assigned at top-level become module globals.\n\n```python\n# module scope\nA = 1\nB = 2\nprint(A + B)\n```python\n\n### Function (local) scope\nNames bound inside a function are local to that function (unless declared otherwise).\n\n```python\nX = \"global\"\n\ndef f():\n    X_local = \"local\"\n    return X, X_local\n\nprint(f())\n```python\n\n---\n## 3) Free variables and closures\nNested functions can *read* names from enclosing scopes. When an inner function uses a name that is not local to it, that name is a **free variable**.\n\n```python\ndef make_adder(n):\n    # n is in the enclosing scope of add()\n    def add(x):\n        return x + n\n    return add\n\nadd5 = make_adder(5)\nprint(add5(10))  # 15\n```python\n\n---\n## 4) Rebinding outer names: global vs nonlocal\nReading an outer variable is typically fine. **Rebinding** (assigning) is where you need explicit declarations.\n\n### 4a) global: rebind a module-level name\n\n```python\ncounter = 0\n\ndef bump():\n    global counter\n    counter += 1\n\nbump(); bump(); bump()\nprint(counter)  # 3\n```python\n\n### 4b) nonlocal: rebind an enclosing function\u2019s name\n\n```python\ndef make_counter():\n    count = 0\n\n    def inc():\n        nonlocal count\n        count += 1\n        return count\n\n    return inc\n\nc = make_counter()\nprint(c(), c(), c())  # 1 2 3\n```python\n\n---\n## 5) A dense example: multiple scopes interacting\nThis example mixes global reads, enclosing reads, and nonlocal rebinding.\n\n```python\nGLOBAL = 100\n\ndef factory(scale):\n    base = 10\n\n    def compute(x):\n        # GLOBAL is read from module scope\n        # base is read from enclosing scope\n        return (GLOBAL + base + x) * scale\n\n    def tweak(delta):\n        nonlocal base\n        base += delta\n        return base\n\n    return compute, tweak\n\ncompute, tweak = factory(2)\nprint(compute(1))  # (100+10+1)*2 = 222\nprint(tweak(5))    # base becomes 15\nprint(compute(1))  # (100+15+1)*2 = 232\n```python\n\n---\n## 6) Practical tips\n- Prefer **return values** over globals for most application code.\n- Use `nonlocal` sparingly (it\u2019s powerful, but can make flows harder to follow).\n- When debugging scope issues, try printing values from each scope or refactor into smaller pure functions.",
      "difficulty": "hard",
      "doc_id": "doc-python-variable-binding-and-scope-blocks-locals-free-variables-globals-and-nonlocal-51310631d8",
      "provenance": {
        "author": "",
        "date": "",
        "license": "PSF Documentation License (Python docs)",
        "source_file": "data/corpus_raw/variables_hard_1.json",
        "url": "https://docs.python.org/3/reference/executionmodel.html"
      },
      "title": "Python variable binding and scope: blocks, locals, free variables, globals, and nonlocal",
      "type": "reference"
    },
    {
      "ai_generated": true,
      "concept_tags": [
        "composition",
        "docstrings",
        "functions",
        "return-types",
        "type-hints"
      ],
      "content": "Even simple functions become easier to understand when they include a short docstring and (optionally) type hints.\n\n---\n## 1) A typed function with a docstring\n\n```python\nfrom typing import Optional\n\ndef parse_age(text: str) -> Optional[int]:\n    \"\"\"Convert a string to an integer age, or return None if invalid.\"\"\"\n    t = text.strip()\n    if not t.isdigit():\n        return None\n    age = int(t)\n    if not (0 <= age <= 120):\n        return None\n    return age\n\nprint(parse_age(\" 20 \"))\nprint(parse_age(\"x\"))\nprint(parse_age(\"999\"))\n```python\n\n---\n## 2) A function that returns a structured result\n\n```python\nfrom typing import Dict, List\n\ndef summarize(nums: List[int]) -> Dict[str, float]:\n    \"\"\"Return basic statistics for a list of integers.\"\"\"\n    if not nums:\n        return {\"count\": 0, \"sum\": 0, \"avg\": 0}\n\n    total = sum(nums)\n    return {\n        \"count\": len(nums),\n        \"sum\": total,\n        \"avg\": total / len(nums),\n    }\n\nprint(summarize([10, 20, 30]))\nprint(summarize([]))\n```python\n\n---\n## 3) Small composition example\n\n```python\ndef only_ints(tokens):\n    out = []\n    for t in tokens:\n        s = str(t).strip()\n        if s.isdigit():\n            out.append(int(s))\n    return out\n\nraw = [\"10\", \"x\", \" 5 \", \"-\", 7]\nnums = only_ints(raw)\nprint(nums)\nprint(summarize(nums))\n```",
      "difficulty": "intro",
      "doc_id": "doc-readable-functions-easy-type-hints-docstrings-and-example-driven-design-91bbc2f25b",
      "provenance": {
        "author": "",
        "date": "",
        "license": "",
        "source_file": "data/corpus_raw/functions_easy_5.json",
        "url": ""
      },
      "title": "Readable functions (easy): type hints, docstrings, and example-driven design",
      "type": "tutorial"
    },
    {
      "ai_generated": true,
      "concept_tags": [
        "conditionals",
        "dict",
        "dispatch-table",
        "get",
        "readability",
        "refactoring"
      ],
      "content": "As programs grow, long if/elif chains can become repetitive. A moderate technique is using a **dispatch table** (a dictionary mapping) when the logic is \u201cchoose behavior based on a key.\u201d\n\n---\n## 1) The baseline: if/elif chain\n\n```python\ncmd = \"status\"\n\nif cmd == \"start\":\n    msg = \"starting\"\nelif cmd == \"stop\":\n    msg = \"stopping\"\nelif cmd == \"status\":\n    msg = \"showing status\"\nelse:\n    msg = \"unknown\"\n\nprint(msg)\n```python\n\n---\n## 2) Dispatch table: cleaner for simple key-to-value choices\n\n```python\ncmd = \"status\"\n\nmessages = {\n    \"start\": \"starting\",\n    \"stop\": \"stopping\",\n    \"status\": \"showing status\",\n}\n\nmsg = messages.get(cmd, \"unknown\")\nprint(msg)\n```python\n\n---\n## 3) Dispatch table with functions (choose actions)\n\n```python\ndef start():\n    return \"started\"\n\ndef stop():\n    return \"stopped\"\n\ndef status():\n    return \"ok\"\n\nactions = {\n    \"start\": start,\n    \"stop\": stop,\n    \"status\": status,\n}\n\ncmd = \"start\"\nresult = actions.get(cmd, lambda: \"unknown\")()\nprint(result)\n```python\n\n---\n## 4) Guard conditions still matter\nSometimes you need both: a dispatch plus a conditional check.\n\n```python\ncmd = \"start\"\nuser_role = \"guest\"\n\nif cmd == \"start\" and user_role != \"admin\":\n    print(\"permission denied\")\nelse:\n    print(\"ok to proceed\")\n```python\n\n---\n## 5) Practice block: categorize with a mapping\n\n```python\ncode = \"PH\"\ncountry = {\n    \"PH\": \"Philippines\",\n    \"JP\": \"Japan\",\n    \"US\": \"United States\",\n}.get(code, \"Unknown\")\n\nprint(country)\n```",
      "difficulty": "moderate",
      "doc_id": "doc-refactoring-if-elif-chains-dispatch-tables-for-commands-and-categories-dacef1c4a7",
      "provenance": {
        "author": "",
        "date": "",
        "license": "",
        "source_file": "data/corpus_raw/conditionals_moderate_4.json",
        "url": ""
      },
      "title": "Refactoring if/elif chains: dispatch tables for commands and categories",
      "type": "tutorial"
    },
    {
      "ai_generated": true,
      "concept_tags": [
        "classes",
        "closures",
        "comprehensions",
        "generators",
        "late-binding",
        "scope",
        "variables"
      ],
      "content": "Some variable behaviors feel surprising because class bodies and comprehensions introduce rules that differ from plain function blocks.\n\n---\n## 1) Class bodies execute top-to-bottom\nA class body is executed when the class is created. Names are bound in the class namespace as the body runs.\n\n```python\nclass C:\n    a = 10\n    b = a + 5\n\nprint(C.a, C.b)  # 10 15\n```python\n\nOrder matters:\n\n```python\nclass D:\n    x = 1\n    y = x + 1\n\nprint(D.y)  # 2\n```python\n\n---\n## 2) List comprehensions vs generator expressions\nA list comprehension builds a list eagerly; a generator expression is lazy.\n\n```python\n# list comprehension\nnums = [i for i in range(3)]\nprint(nums)\n```python\n\n```python\n# generator expression\nit = (i for i in range(3))\nprint(list(it))\n```python\n\n---\n## 3) Generator of lambdas: late binding appears again\n\n```python\nfuncs = (lambda: i for i in range(3))\nprint([f() for f in funcs])  # typically [2, 2, 2]\n```python\n\nFix by capturing immediately:\n\n```python\nfuncs = (lambda i=i: i for i in range(3))\nprint([f() for f in funcs])  # [0, 1, 2]\n```python\n\n---\n## 4) A combined example: class builds functions safely\n\n```python\nclass Tools:\n    adders = []\n    for offset in (0, 10, 100):\n        adders.append(lambda x, offset=offset: x + offset)\n\nprint([f(5) for f in Tools.adders])  # [5, 15, 105]\n```python\n\n---\n## 5) Takeaways\n- If code is created in a loop, assume you must **capture loop variables explicitly**.\n- If you define lots of behavior in a class body, remember it executes immediately at import time.",
      "difficulty": "hard",
      "doc_id": "doc-scope-surprises-class-bodies-comprehensions-and-generator-lambda-capture-c1ad7f3f8f",
      "provenance": {
        "author": "",
        "date": "",
        "license": "",
        "source_file": "data/corpus_raw/variables_hard_5.json",
        "url": ""
      },
      "title": "Scope surprises: class bodies, comprehensions, and generator/lambda capture",
      "type": "tutorial"
    },
    {
      "ai_generated": true,
      "concept_tags": [
        "all",
        "any",
        "conditionals",
        "guards",
        "short-circuit",
        "truthiness",
        "validation"
      ],
      "content": "Short-circuit logic is not only about concision\u2014it\u2019s a practical tool to avoid errors and avoid unnecessary work.\n\n---\n## 1) Guarding attribute access\n\n```python\nuser = None\n\nif user is not None and user.get(\"active\"):\n    print(\"active user\")\nelse:\n    print(\"no active user\")\n```python\n\n---\n## 2) Avoid expensive work unless needed\n\n```python\nimport time\n\ndef expensive():\n    time.sleep(0.1)\n    return True\n\nflag = False\n\nif flag and expensive():\n    print(\"ran\")\nelse:\n    print(\"skipped\")\n```python\n\nBecause `flag` is False, `expensive()` is never called.\n\n---\n## 3) Defaulting with or (with a caution)\n\n```python\nname = \"\"\ndisplay = name or \"(anonymous)\"\nprint(display)\n```python\n\nThis works well when empty values should fall back to a default. If empty is meaningful, be explicit:\n\n```python\nname = \"\"\nif name == \"\":\n    display = \"(empty string)\"\nelse:\n    display = name\nprint(display)\n```python\n\n---\n## 4) any/all with generator expressions\n\n```python\npassword = \"Abc123\"\n\nhas_digit = any(ch.isdigit() for ch in password)\nhas_upper = any(ch.isupper() for ch in password)\nlong_enough = len(password) >= 6\n\nif has_digit and has_upper and long_enough:\n    print(\"ok\")\nelse:\n    print(\"try again\")\n```python\n\n---\n## 5) Practice block: validate a record safely\n\n```python\nrecord = {\"name\": \"ana\", \"age\": \"20\"}\n\nname_ok = bool(record.get(\"name\"))\nage_text = record.get(\"age\")\nage_ok = age_text is not None and age_text.isdigit() and 0 <= int(age_text) <= 120\n\nif name_ok and age_ok:\n    print(\"valid\")\nelse:\n    print(\"invalid\")\n```",
      "difficulty": "moderate",
      "doc_id": "doc-short-circuit-conditionals-in-practice-safe-guards-and-optional-values-b39eec0789",
      "provenance": {
        "author": "",
        "date": "",
        "license": "",
        "source_file": "data/corpus_raw/conditionals_moderate_5.json",
        "url": ""
      },
      "title": "Short-circuit conditionals in practice: safe guards and optional values",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "branching",
        "conditionals",
        "data-shapes",
        "guards",
        "match",
        "pattern-matching"
      ],
      "content": "Hard conditional logic often shows up when branching depends on the **shape** of data (tuples, dicts, nested structures). Python\u2019s `match` statement supports *structural pattern matching*, which can replace long `if/elif` chains.\n\n---\n## 1) A basic match example\n\n```python\ndef http_status(code):\n    match code:\n        case 200:\n            return \"OK\"\n        case 404:\n            return \"Not Found\"\n        case 500:\n            return \"Server Error\"\n        case _:\n            return \"Unknown\"\n\nprint(http_status(200))\nprint(http_status(123))\n```python\n\n`case _:` is a wildcard \u201cdefault.\u201d\n\n---\n## 2) Matching sequences (tuples/lists)\n\n```python\ndef describe_point(p):\n    match p:\n        case (0, 0):\n            return \"origin\"\n        case (0, y):\n            return f\"on y-axis at {y}\"\n        case (x, 0):\n            return f\"on x-axis at {x}\"\n        case (x, y):\n            return f\"point {x},{y}\"\n        case _:\n            return \"not a point\"\n\nprint(describe_point((0, 5)))\nprint(describe_point((3, 0)))\nprint(describe_point((2, 9)))\n```python\n\n---\n## 3) Matching with guards (extra conditions)\nGuards let you add an `if` to a `case`.\n\n```python\ndef classify(n):\n    match n:\n        case x if x < 0:\n            return \"negative\"\n        case 0:\n            return \"zero\"\n        case x if x % 2 == 0:\n            return \"positive even\"\n        case _:\n            return \"positive odd\"\n\nfor v in [-3, 0, 2, 5]:\n    print(v, classify(v))\n```python\n\n---\n## 4) Matching dictionaries (structured input)\n\n```python\ndef handle_event(evt):\n    match evt:\n        case {\"type\": \"login\", \"user\": user}:\n            return f\"login {user}\"\n        case {\"type\": \"score\", \"user\": user, \"value\": v} if isinstance(v, int):\n            return f\"score {user}={v}\"\n        case {\"type\": t}:\n            return f\"unknown event type {t}\"\n        case _:\n            return \"invalid\"\n\nprint(handle_event({\"type\": \"login\", \"user\": \"ana\"}))\nprint(handle_event({\"type\": \"score\", \"user\": \"ana\", \"value\": 10}))\nprint(handle_event({\"type\": \"score\", \"user\": \"ana\", \"value\": \"x\"}))\n```python\n\n---\n## 5) When match helps\n- When data has multiple possible shapes.\n- When nested if/elif becomes hard to read.\n- When you want to capture parts of the data as variables.",
      "difficulty": "hard",
      "doc_id": "doc-structural-pattern-matching-match-case-for-complex-branching-and-data-shaped-conditions-8b7b091601",
      "provenance": {
        "author": "",
        "date": "",
        "license": "Public domain (PEP text)",
        "source_file": "data/corpus_raw/conditionals_hard_2.json",
        "url": "https://peps.python.org/pep-0634/"
      },
      "title": "Structural pattern matching: match/case for complex branching and data-shaped conditions",
      "type": "reference"
    },
    {
      "ai_generated": true,
      "concept_tags": [
        "boolean-logic",
        "conditionals",
        "readability",
        "refactoring",
        "testing",
        "truthiness"
      ],
      "content": "Hard conditionals often fail not because they\u2019re wrong, but because they\u2019re hard to read and easy to modify incorrectly. A practical approach is to name sub-conditions and avoid relying on truthiness when empty values are meaningful.\n\n---\n## 1) A too-dense condition\n\n```python\nuser = {\"name\": \"\", \"age\": \"20\", \"role\": \"editor\", \"active\": True}\n\nif user and user.get(\"active\") and user.get(\"role\") in {\"admin\", \"editor\"} and user.get(\"age\") and str(user.get(\"age\")).isdigit():\n    print(\"allowed\")\nelse:\n    print(\"denied\")\n```python\n\nThis works, but it\u2019s difficult to review.\n\n---\n## 2) Refactor into named checks\n\n```python\nuser = {\"name\": \"\", \"age\": \"20\", \"role\": \"editor\", \"active\": True}\n\nis_present = user is not None\nis_active = is_present and user.get(\"active\") is True\nrole = user.get(\"role\") if is_present else None\nhas_role = role in {\"admin\", \"editor\"}\n\nage_raw = user.get(\"age\") if is_present else None\nage_text = None if age_raw is None else str(age_raw).strip()\nage_is_number = age_text is not None and age_text.isdigit()\n\nallowed = is_active and has_role and age_is_number\n\nprint(\"allowed\" if allowed else \"denied\")\n```python\n\n---\n## 3) Truthiness traps: empty string vs missing\nIf empty string is different from missing, do not use `or` defaulting blindly.\n\n```python\nname = \"\"          # intentionally empty\nfallback = \"(anon)\"\nprint(name or fallback)  # prints fallback, maybe not desired\n\n# explicit handling\nif name is None:\n    display = fallback\nelse:\n    display = name\nprint(display)\n```python\n\n---\n## 4) Test-friendly function design\n\n```python\ndef can_edit(user):\n    if user is None:\n        return False\n    if user.get(\"active\") is not True:\n        return False\n    if user.get(\"role\") not in {\"admin\", \"editor\"}:\n        return False\n\n    age = user.get(\"age\")\n    if age is None:\n        return False\n\n    s = str(age).strip()\n    if not s.isdigit():\n        return False\n\n    return True\n\ncases = [\n    {\"active\": True, \"role\": \"editor\", \"age\": \"20\"},\n    {\"active\": True, \"role\": \"viewer\", \"age\": \"20\"},\n    {\"active\": False, \"role\": \"editor\", \"age\": \"20\"},\n    None,\n]\n\nfor c in cases:\n    print(c, can_edit(c))\n```python\n\n---\n## 5) Takeaway\n- When a condition is long, name sub-conditions.\n- Be explicit when `0` and `\"\"` are valid values.\n- Write a function and test it with several cases.",
      "difficulty": "hard",
      "doc_id": "doc-taming-complex-conditions-name-sub-checks-avoid-truthiness-traps-and-make-behavior-testable-6abc768071",
      "provenance": {
        "author": "",
        "date": "",
        "license": "",
        "source_file": "data/corpus_raw/conditionals_hard_5.json",
        "url": ""
      },
      "title": "Taming complex conditions: name sub-checks, avoid truthiness traps, and make behavior testable",
      "type": "tutorial"
    },
    {
      "ai_generated": true,
      "concept_tags": [
        "__wrapped__",
        "decorators",
        "functions",
        "inspect",
        "lru_cache",
        "wrappers",
        "wraps"
      ],
      "content": "When you wrap functions, you can accidentally break tools that rely on signatures and metadata. A strong baseline is using `functools.wraps`, which also sets `__wrapped__`.\n\n---\n## 1) Wrapper that preserves doc/name\n\n```python\nimport functools\n\ndef timed(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        # placeholder timing logic\n        return func(*args, **kwargs)\n    return wrapper\n\n@timed\ndef add(a: int, b: int) -> int:\n    \"\"\"Add two integers.\"\"\"\n    return a + b\n\nprint(add.__name__)\nprint(add.__doc__)\n```python\n\n---\n## 2) Using inspect.signature on wrapped functions\n\n```python\nimport inspect\nprint(inspect.signature(add))\n```python\n\n---\n## 3) A \u201cprecheck\u201d decorator that keeps behavior readable\n\n```python\nimport functools\n\ndef require_ints(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        for x in args:\n            if not isinstance(x, int):\n                raise TypeError(\"positional args must be int\")\n        for k, v in kwargs.items():\n            if not isinstance(v, int):\n                raise TypeError(f\"{k} must be int\")\n        return func(*args, **kwargs)\n    return wrapper\n\n@require_ints\ndef mul(a: int, b: int) -> int:\n    return a * b\n\nprint(mul(2, 3))\n# mul(2, \"x\") would raise TypeError\n```python\n\n---\n## 4) Practice block: wrapper + caching in a tooling-friendly way\n\n```python\nimport functools\n\n@functools.lru_cache(maxsize=128)\ndef slow_square(n: int) -> int:\n    return n * n\n\nprint(slow_square(10))\nprint(slow_square.cache_info())\n```",
      "difficulty": "hard",
      "doc_id": "doc-tool-friendly-wrappers-hard-preserving-metadata-wrapped-and-inspection-aware-patterns-ff9835dd75",
      "provenance": {
        "author": "",
        "date": "",
        "license": "",
        "source_file": "data/corpus_raw/functions_hard_5.json",
        "url": ""
      },
      "title": "Tool-friendly wrappers (hard): preserving metadata, __wrapped__, and inspection-aware patterns",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "all",
        "and",
        "any",
        "boolean-ops",
        "conditionals",
        "not",
        "or",
        "short-circuit",
        "truthiness"
      ],
      "content": "Moderate conditional logic is less about syntax and more about understanding how expressions are evaluated.\n\nTwo key ideas:\n1) **Truth value testing** (\u201ctruthiness\u201d): many objects count as True or False in `if`.\n2) **Short-circuit evaluation**: `and` / `or` may stop early and return one of the operands.\n\n---\n## 1) Truthiness: what counts as False?\nIn `if x:`, Python evaluates `x` in a boolean context. Common falsy values include:\n- `False`\n- `None`\n- `0`, `0.0`\n- empty sequences/collections: `\"\"`, `[]`, `{}`, `set()`, `()`\n\n```python\nvalues = [0, 1, \"\", \"hi\", [], [1], None, False, True]\nfor v in values:\n    if v:\n        print(\"truthy:\", repr(v))\n    else:\n        print(\"falsy:\", repr(v))\n```python\n\nA practical pattern is checking emptiness directly:\n\n```python\nitems = []\nif not items:\n    print(\"no items\")\n```python\n\n---\n## 2) Short-circuit: and/or stop early\n### and\n`A and B` evaluates `A` first. If `A` is falsy, Python returns `A` immediately.\n\n```python\nprint(0 and 99)     # 0\nprint(5 and 99)     # 99\n```python\n\n### or\n`A or B` evaluates `A` first. If `A` is truthy, Python returns `A` immediately.\n\n```python\nprint(\"hi\" or \"bye\")  # hi\nprint(\"\" or \"bye\")    # bye\n```python\n\nThis makes \u201cdefaulting\u201d common:\n\n```python\nname = \"\"\ndisplay = name or \"(anonymous)\"\nprint(display)\n```python\n\n---\n## 3) Short-circuit is about evaluation, not just results\nBecause it stops early, it can prevent errors:\n\n```python\nobj = None\n\n# Safe: second part only runs if obj is not None\nif obj is not None and obj.get(\"k\") == 1:\n    print(\"match\")\nelse:\n    print(\"no\")\n```python\n\nIf you reversed it, you might call `.get()` on None.\n\n---\n## 4) any() and all(): readable conditionals over collections\nThese are often cleaner than manual loops.\n\n```python\nwords = [\"cat\", \"\", \"dog\"]\nprint(any(words))  # True (at least one truthy element)\nprint(all(words))  # False (not all are truthy)\n\nnums = [2, 4, 6]\nprint(all(n % 2 == 0 for n in nums))  # True\n```python\n\n---\n## 5) Practice block: validate inputs with short-circuit logic\n\n```python\ndef is_valid_username(s):\n    return s is not None and s.strip() and len(s.strip()) >= 3\n\nprint(is_valid_username(\" ana \"))\nprint(is_valid_username(\"  \"))\nprint(is_valid_username(None))\n```",
      "difficulty": "moderate",
      "doc_id": "doc-truthiness-and-short-circuit-logic-how-python-decides-true-false-and-why-it-matters-abbe1e506b",
      "provenance": {
        "author": "",
        "date": "",
        "license": "PSF Documentation License (Python docs)",
        "source_file": "data/corpus_raw/conditionals_moderate_1.json",
        "url": "https://docs.python.org/3/library/stdtypes.html"
      },
      "title": "Truthiness and short-circuit logic: how Python decides True/False and why it matters",
      "type": "reference"
    },
    {
      "ai_generated": true,
      "concept_tags": [
        "closures",
        "debugging",
        "mutability",
        "nonlocal",
        "scope",
        "variables"
      ],
      "content": "When you need state that survives across function calls, you often reach for closures. There are two common patterns:\n\n1) Use `nonlocal` to rebind an outer variable.\n2) Store state in a mutable container and mutate it.\n\nBoth work; the trade-off is readability and clarity.\n\n---\n## 1) Pattern A: nonlocal counter\n\n```python\ndef make_counter():\n    count = 0\n\n    def inc():\n        nonlocal count\n        count += 1\n        return count\n\n    return inc\n\nc = make_counter()\nprint(c(), c(), c())\n```python\n\nThis is compact, but `nonlocal` is easy to miss when scanning a large function.\n\n---\n## 2) Pattern B: mutate a container (no nonlocal)\n\n```python\ndef make_counter_box():\n    box = {\"count\": 0}\n\n    def inc():\n        box[\"count\"] += 1\n        return box[\"count\"]\n\n    return inc\n\nc2 = make_counter_box()\nprint(c2(), c2(), c2())\n```python\n\nThis avoids `nonlocal` but introduces a container.\n\n---\n## 3) Debug-friendly: expose state safely\n\n```python\ndef make_counter_with_state():\n    box = {\"count\": 0}\n\n    def inc():\n        box[\"count\"] += 1\n        return box[\"count\"]\n\n    def state():\n        # return a snapshot so callers can\u2019t mutate internal state accidentally\n        return {\"count\": box[\"count\"]}\n\n    return inc, state\n\ninc, state = make_counter_with_state()\ninc(); inc()\nprint(state())\n```python\n\n---\n## 4) A denser example mixing multiple bindings\n\n```python\ndef make_tracker(prefix):\n    events = []\n\n    def log(msg):\n        events.append(f\"{prefix}:{msg}\")\n        return len(events)\n\n    def last(n=1):\n        return events[-n:]\n\n    return log, last\n\nlog, last = make_tracker(\"SYS\")\nlog(\"start\")\nlog(\"ready\")\nprint(last())\nprint(last(2))\n```python\n\n---\n## 5) Practical rule of thumb\n- Use `nonlocal` when the meaning is clear and the closure is small.\n- Use a container when you want to attach multiple pieces of state or expose snapshots.",
      "difficulty": "hard",
      "doc_id": "doc-updating-outer-scope-state-nonlocal-vs-container-mutation-and-how-to-keep-it-readable-78109640c9",
      "provenance": {
        "author": "",
        "date": "",
        "license": "",
        "source_file": "data/corpus_raw/variables_hard_4.json",
        "url": ""
      },
      "title": "Updating outer-scope state: nonlocal vs container mutation (and how to keep it readable)",
      "type": "tutorial"
    },
    {
      "ai_generated": true,
      "concept_tags": [
        "f-strings",
        "join",
        "print",
        "strings",
        "type-conversion",
        "variables"
      ],
      "content": "Variables often hold **pieces of text** that you combine into messages. Here are common beginner-friendly patterns.\n\n---\n## 1) Concatenation with +\n\n```python\nfirst = \"Good\"\nsecond = \"morning\"\nmsg = first + \" \" + second + \"!\"\nprint(msg)  # Good morning!\n```python\n\nConcatenation requires both sides to be strings:\n\n```python\nscore = 42\n# print(\"Score: \" + score)  # TypeError\nprint(\"Score: \" + str(score))\n```python\n\n---\n## 2) f-strings (usually easiest to read)\n\n```python\nname = \"Mika\"\nscore = 42\nprint(f\"{name} scored {score} points\")\n```python\n\nYou can format numbers too:\n\n```python\npi = 3.1415926\nprint(f\"pi\u2248{pi:.2f}\")\n```python\n\n---\n## 3) str.format()\n\n```python\nname = \"Mika\"\nscore = 42\nprint(\"{} scored {} points\".format(name, score))\n```python\n\n---\n## 4) join() for many strings\nWhen joining many parts, build a list and join.\n\n```python\nparts = [\"A\", \"B\", \"C\"]\nprint(\"-\".join(parts))  # A-B-C\n```python\n\n---\n## 5) A small, realistic example\n\n```python\nuser = \"ana\"\nitems = [\"apple\", \"banana\", \"cherry\"]\ncount = len(items)\n\nline1 = f\"User: {user}\"\nline2 = \"Items: \" + \", \".join(items)\nline3 = f\"Count: {count}\"\n\nprint(line1)\nprint(line2)\nprint(line3)\n```",
      "difficulty": "intro",
      "doc_id": "doc-using-variables-to-build-text-output-concatenation-f-strings-and-join-c4e429d9a9",
      "provenance": {
        "author": "",
        "date": "",
        "license": "",
        "source_file": "data/corpus_raw/variables_easy_4.json",
        "url": ""
      },
      "title": "Using variables to build text output: concatenation, f-strings, and join()",
      "type": "tutorial"
    },
    {
      "ai_generated": true,
      "concept_tags": [
        "conditionals",
        "input-validation",
        "nested-if",
        "none-check",
        "ranges"
      ],
      "content": "Conditionals are often used to keep programs safe and predictable by validating input before using it.\n\n---\n## 1) Check if a string looks like a whole number\n\n```python\nraw = \"42\"\n\nif raw.isdigit():\n    n = int(raw)\n    print(\"number\", n)\nelse:\n    print(\"not a whole number\")\n```python\n\n---\n## 2) Range checking\n\n```python\nage = 20\n\nif age < 0:\n    print(\"invalid\")\nelif age < 13:\n    print(\"child\")\nelif age < 20:\n    print(\"teen\")\nelse:\n    print(\"adult\")\n```python\n\n---\n## 3) Handling optional values (None checks)\n\n```python\nvalue = None\n\nif value is None:\n    print(\"missing\")\nelse:\n    print(\"got\", value)\n```python\n\n---\n## 4) A balanced mini script: parse and respond\n\n```python\ntext = \" 7 \"\ntext = text.strip()\n\nif not text.isdigit():\n    print(\"please enter digits\")\nelse:\n    n = int(text)\n    if n % 2 == 0:\n        print(\"even\")\n    else:\n        print(\"odd\")\n\n    if n >= 10:\n        print(\"two digits or more\")\n    else:\n        print(\"single digit\")\n```",
      "difficulty": "intro",
      "doc_id": "doc-validating-user-input-with-conditionals-digits-ranges-and-safe-defaults-e44427239d",
      "provenance": {
        "author": "",
        "date": "",
        "license": "",
        "source_file": "data/corpus_raw/conditionals_easy_4.json",
        "url": ""
      },
      "title": "Validating user input with conditionals: digits, ranges, and safe defaults",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "assignment",
        "expressions",
        "nameerror",
        "print",
        "reassignment",
        "type-conversion",
        "variables"
      ],
      "content": "A **variable** is a *name* that refers to a value. In Python, you create (bind) a variable by using **assignment** with `=`.\n\n---\n## 1) Basic assignment and reading values\n\n```python\nlucky = 7\nprint(lucky)        # 7\nprint(lucky + 1)    # 8\n```python\n\nYou can use variables inside expressions, and Python will substitute their current values.\n\n---\n## 2) Reassignment (the name can be rebound)\nThe same variable name can be assigned a new value later.\n\n```python\nchanging = 3\nprint(changing)     # 3\n\nchanging = 9\nprint(changing)     # 9\n\nchanging = changing + 6\nprint(changing)     # 15\n```python\n\nA helpful way to read `x = x + 1` is: \u201ccompute `x + 1` using the old value, then store it back into `x`.\u201d\n\n---\n## 3) Right-hand side is evaluated first\nPython evaluates the right-hand side expression, then binds the left-hand name.\n\n```python\nx = 10\nx = x * 2 + 5\nprint(x)            # 25\n```python\n\n---\n## 4) Assigning one variable from another\nWhen you do `yellow = red`, the name `yellow` is set to the current value of `red`.\n\n```python\nred = 5\nblue = 10\n\nyellow = red\nprint(yellow, red, blue)  # 5 5 10\n\nred = blue\nprint(yellow, red, blue)  # 5 10 10\n```python\n\nNotice that `yellow` stays `5` after `red` changes.\n\n---\n## 5) Printing multiple values (useful for quick checks)\n\n```python\na = 1\nb = 2\nc = 3\nprint(a, b, c)      # 1 2 3\n```python\n\n---\n## 6) Common beginner pitfalls (with examples)\n### Using a name before assignment (NameError)\n\n```python\n# print(missing)     # NameError\nmissing = 123\nprint(missing)\n```python\n\n### Mixing types accidentally\n\n```python\nscore = 10\nlabel = \"Score: \"\n# print(label + score)    # TypeError\nprint(label + str(score))\n```python\n\n---\n## 7) A small, readable practice script\nThis combines assignment, reassignment, and printing.\n\n```python\nx = 2\nprint(\"start\", x)\n\nx = x + 3\nprint(\"after +3\", x)\n\ny = x\nx = 100\nprint(\"x\", x, \"y\", y)\n\nz = y * 10\nprint(\"z\", z)\n```",
      "difficulty": "intro",
      "doc_id": "doc-variables-in-python-names-assignment-reassignment-and-reading-values-a86c7f1c23",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-SA (Wikibooks)",
        "source_file": "data/corpus_raw/variables_easy_1.json",
        "url": "https://en.wikibooks.org/wiki/Python_Programming/Variables_and_Strings"
      },
      "title": "Variables in Python: names, assignment, reassignment, and reading values",
      "type": "tutorial"
    },
    {
      "ai_generated": true,
      "concept_tags": [
        "break",
        "continue",
        "loop-else",
        "loops",
        "menus",
        "validation",
        "while"
      ],
      "content": "While loops are great when you don\u2019t know in advance how many times you need to repeat something. Many beginner-friendly programs use them for menus, retries, or input validation.\n\n---\n## 1) A basic menu loop\n\n```python\nchoice = \"\"\nwhile choice != \"q\":\n    print(\"(a)dd  (l)ist  (q)uit\")\n    choice = input(\"Choice: \").strip().lower()\n\n    if choice == \"a\":\n        print(\"adding...\")\n    elif choice == \"l\":\n        print(\"listing...\")\n    elif choice == \"q\":\n        print(\"bye\")\n    else:\n        print(\"unknown choice\")\n```python\n\n---\n## 2) Retry pattern with a maximum attempt counter\n\n```python\nmax_tries = 3\ntries = 0\n\nwhile tries < max_tries:\n    pwd = input(\"Password: \")\n    if pwd == \"unicorn\":\n        print(\"ok\")\n        break\n    tries += 1\nelse:\n    print(\"too many tries\")\n```python\n\nNotice the `else`: it runs only if the loop finishes without `break`.\n\n---\n## 3) Input validation pattern\n\n```python\nraw = input(\"Enter a whole number: \").strip()\nwhile not raw.isdigit():\n    print(\"Please enter digits only\")\n    raw = input(\"Enter a whole number: \").strip()\n\nn = int(raw)\nprint(\"n =\", n)\n```python\n\n---\n## 4) A small practice script (mixed techniques)\n\n```python\nitems = []\n\nwhile True:\n    text = input(\"Add item (or 'done'): \").strip()\n    if text == \"done\":\n        break\n    if not text:\n        continue\n    items.append(text)\n\nprint(\"items:\", items)\n```",
      "difficulty": "intro",
      "doc_id": "doc-while-loop-patterns-easy-menus-retries-and-simple-validation-6c1217a4e0",
      "provenance": {
        "author": "",
        "date": "",
        "license": "",
        "source_file": "data/corpus_raw/loops_easy_5.json",
        "url": ""
      },
      "title": "While loop patterns (easy): menus, retries, and simple validation",
      "type": "tutorial"
    },
    {
      "ai_generated": false,
      "concept_tags": [
        "binding",
        "debugging",
        "global",
        "scope",
        "unboundlocalerror",
        "variables"
      ],
      "content": "A frequent hard-level error is:\n\n> `UnboundLocalError: local variable 'x' referenced before assignment`\n\nThis happens because Python decides whether a name is **local** by scanning the function body for **any binding** to that name. If the name is assigned anywhere in the function, it is treated as local throughout that function (unless declared `global` or `nonlocal`).\n\n---\n## 1) Minimal example\n\n```python\nx = 10\n\ndef f():\n    print(x)  # Python thinks x is local here\n    x = 3     # because of this assignment\n\n# f() would raise UnboundLocalError\n```python\n\nWhy? Because `x = 3` makes `x` local to `f()`, so `print(x)` tries to read the local `x` before it has a value.\n\n---\n## 2) Fix pattern A: rename the local variable (best default)\nIf you didn\u2019t intend to modify the global `x`, use a different name.\n\n```python\nx = 10\n\ndef f():\n    print(x)      # reads global x\n    x_local = 3\n    return x_local\n\nprint(f())\nprint(x)          # still 10\n```python\n\n---\n## 3) Fix pattern B: pass input as arguments and return results (pure function style)\n\n```python\ndef f(x):\n    print(x)\n    x = 3\n    return x\n\nprint(f(10))\n```python\n\n---\n## 4) Fix pattern C: global (only if you truly mean shared module state)\n\n```python\nx = 10\n\ndef f():\n    global x\n    print(x)\n    x = 3\n\nf()\nprint(x)  # 3\n```python\n\n---\n## 5) A more realistic \u201cbranch\u201d example\nEven if the assignment happens only in one branch, it still makes the name local for the whole function.\n\n```python\nflag = False\nx = 100\n\ndef g():\n    if flag:\n        x = 5   # assignment exists \u2192 x is local in g\n    return x\n\n# g() would error if flag is False (it tries to return local x before assignment)\n```python\n\nA safe refactor is to always assign before use:\n\n```python\nflag = False\nx = 100\n\ndef g():\n    local_x = x\n    if flag:\n        local_x = 5\n    return local_x\n\nprint(g())\n```python\n\n---\n## 6) Related: comprehension variables can also create bindings\nSome confusing cases happen when a name becomes local because of a binding inside an expression (e.g., comprehensions).\n\n```python\ndef h():\n    # If you bind a name inside the function body, it can change locality expectations.\n    data = [1, 2, 3]\n    out = [v for v in data]\n    return out\n\nprint(h())\n```",
      "difficulty": "hard",
      "doc_id": "doc-why-unboundlocalerror-happens-assignment-makes-a-name-local-and-how-to-fix-it-safely-07825eb2a0",
      "provenance": {
        "author": "",
        "date": "",
        "license": "CC BY-SA (Stack Overflow; version depends on post date)",
        "source_file": "data/corpus_raw/variables_hard_2.json",
        "url": "https://stackoverflow.com/questions/10851906/how-can-i-fix-unboundlocalerror-local-variable-referenced-before-assignment"
      },
      "title": "Why UnboundLocalError happens: assignment makes a name local (and how to fix it safely)",
      "type": "tutorial"
    }
  ]
}