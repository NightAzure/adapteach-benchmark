{
  "ai_generated": false,
  "concept_tags": [
    "branching",
    "conditionals",
    "data-shapes",
    "guards",
    "match",
    "pattern-matching"
  ],
  "content": "Hard conditional logic often shows up when branching depends on the **shape** of data (tuples, dicts, nested structures). Python\u2019s `match` statement supports *structural pattern matching*, which can replace long `if/elif` chains.\n\n---\n## 1) A basic match example\n\n```python\ndef http_status(code):\n    match code:\n        case 200:\n            return \"OK\"\n        case 404:\n            return \"Not Found\"\n        case 500:\n            return \"Server Error\"\n        case _:\n            return \"Unknown\"\n\nprint(http_status(200))\nprint(http_status(123))\n```python\n\n`case _:` is a wildcard \u201cdefault.\u201d\n\n---\n## 2) Matching sequences (tuples/lists)\n\n```python\ndef describe_point(p):\n    match p:\n        case (0, 0):\n            return \"origin\"\n        case (0, y):\n            return f\"on y-axis at {y}\"\n        case (x, 0):\n            return f\"on x-axis at {x}\"\n        case (x, y):\n            return f\"point {x},{y}\"\n        case _:\n            return \"not a point\"\n\nprint(describe_point((0, 5)))\nprint(describe_point((3, 0)))\nprint(describe_point((2, 9)))\n```python\n\n---\n## 3) Matching with guards (extra conditions)\nGuards let you add an `if` to a `case`.\n\n```python\ndef classify(n):\n    match n:\n        case x if x < 0:\n            return \"negative\"\n        case 0:\n            return \"zero\"\n        case x if x % 2 == 0:\n            return \"positive even\"\n        case _:\n            return \"positive odd\"\n\nfor v in [-3, 0, 2, 5]:\n    print(v, classify(v))\n```python\n\n---\n## 4) Matching dictionaries (structured input)\n\n```python\ndef handle_event(evt):\n    match evt:\n        case {\"type\": \"login\", \"user\": user}:\n            return f\"login {user}\"\n        case {\"type\": \"score\", \"user\": user, \"value\": v} if isinstance(v, int):\n            return f\"score {user}={v}\"\n        case {\"type\": t}:\n            return f\"unknown event type {t}\"\n        case _:\n            return \"invalid\"\n\nprint(handle_event({\"type\": \"login\", \"user\": \"ana\"}))\nprint(handle_event({\"type\": \"score\", \"user\": \"ana\", \"value\": 10}))\nprint(handle_event({\"type\": \"score\", \"user\": \"ana\", \"value\": \"x\"}))\n```python\n\n---\n## 5) When match helps\n- When data has multiple possible shapes.\n- When nested if/elif becomes hard to read.\n- When you want to capture parts of the data as variables.",
  "difficulty": "hard",
  "doc_id": "doc-structural-pattern-matching-match-case-for-complex-branching-and-data-shaped-conditions-8b7b091601",
  "provenance": {
    "author": "",
    "date": "",
    "license": "Public domain (PEP text)",
    "source_file": "data/corpus_raw/conditionals_hard_2.json",
    "url": "https://peps.python.org/pep-0634/"
  },
  "title": "Structural pattern matching: match/case for complex branching and data-shaped conditions",
  "type": "reference"
}