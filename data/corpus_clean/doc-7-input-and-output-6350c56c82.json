{
  "ai_generated": false,
  "concept_tags": [
    "file_io",
    "formatting",
    "strings"
  ],
  "content": "# 7.Input and Output\u00c2\u00b6\n\nThere are several ways to present the output of a program; data can be printed\nin a human-readable form, or written to a file for future use. This chapter will\ndiscuss some of the possibilities.\n\n## 7.1.Fancier Output Formatting\u00c2\u00b6\n\nSo far we\u00e2\u0080\u0099ve encountered two ways of writing values: expression statements and\nthe print() function.  (A third way is using the write() method\nof file objects; the standard output file can be referenced as sys.stdout .\nSee the Library Reference for more information on this.)\n\nOften you\u00e2\u0080\u0099ll want more control over the formatting of your output than simply\nprinting space-separated values. There are several ways to format output.\n\n- To use formatted string literals , begin a string\nwith f or F before the opening quotation mark or triple quotation mark.\nInside this string, you can write a Python expression between { and } characters that can refer to variables or literal values. >>> year = 2016 >>> event = 'Referendum' >>> f 'Results of the { year } { event } ' 'Results of the 2016 Referendum'\n- The str.format() method of strings requires more manual\neffort.  You\u00e2\u0080\u0099ll still use { and } to mark where a variable\nwill be substituted and can provide detailed formatting directives,\nbut you\u00e2\u0080\u0099ll also need to provide the information to be formatted. In the following code\nblock there are two examples of how to format variables: >>> yes_votes = 42_572_654 >>> total_votes = 85_705_149 >>> percentage = yes_votes / total_votes >>> ' {:-9} YES votes {:2.2%} ' . format ( yes_votes , percentage ) ' 42572654 YES votes  49.67%' Notice how the yes_votes are padded with spaces and a negative sign only for negative numbers.\nThe example also prints percentage multiplied by 100, with 2 decimal\nplaces and followed by a percent sign (see Format Specification Mini-Language for details).\n- Finally, you can do all the string handling yourself by using string slicing and\nconcatenation operations to create any layout you can imagine.  The\nstring type has some methods that perform useful operations for padding\nstrings to a given column width.\n\nWhen you don\u00e2\u0080\u0099t need fancy output but just want a quick display of some\nvariables for debugging purposes, you can convert any value to a string with\nthe repr() or str() functions.\n\nThe str() function is meant to return representations of values which are\nfairly human-readable, while repr() is meant to generate representations\nwhich can be read by the interpreter (or will force a SyntaxError if\nthere is no equivalent syntax).  For objects which don\u00e2\u0080\u0099t have a particular\nrepresentation for human consumption, str() will return the same value as repr() .  Many values, such as numbers or structures like lists and\ndictionaries, have the same representation using either function.  Strings, in\nparticular, have two distinct representations.\n\nSome examples:\n\n```python\n>>> s = 'Hello, world.'\n>>> str(s)\n'Hello, world.'\n>>> repr(s)\n\"'Hello, world.'\"\n>>> str(1/7)\n'0.14285714285714285'\n>>> x = 10 * 3.25\n>>> y = 200 * 200\n>>> s = 'The value of x is ' + repr(x) + ', and y is ' + repr(y) + '...'\n>>> print(s)\nThe value of x is 32.5, and y is 40000...\n>>> # The repr() of a string adds string quotes and backslashes:\n>>> hello = 'hello, world\\n'\n>>> hellos = repr(hello)\n>>> print(hellos)\n'hello, world\\n'\n>>> # The argument to repr() may be any Python object:\n>>> repr((x, y, ('spam', 'eggs')))\n\"(32.5, 40000, ('spam', 'eggs'))\"\n```python\n\nThe string module contains support for a simple templating approach\nbased upon regular expressions, via string.Template .\nThis offers yet another way to substitute values into strings,\nusing placeholders like $x and replacing them with values from a dictionary.\nThis syntax is easy to use, although it offers much less control for formatting.\n\n### 7.1.1.Formatted String Literals\u00c2\u00b6\n\nFormatted string literals (also called f-strings for\nshort) let you include the value of Python expressions inside a string by\nprefixing the string with f or F and writing expressions as {expression} .\n\nAn optional format specifier can follow the expression. This allows greater\ncontrol over how the value is formatted. The following example rounds pi to\nthree places after the decimal:\n\n```python\n>>> import math\n>>> print(f'The value of pi is approximately {math.pi:.3f}.')\nThe value of pi is approximately 3.142.\n```python\n\nPassing an integer after the ':' will cause that field to be a minimum\nnumber of characters wide.  This is useful for making columns line up.\n\n```python\n>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}\n>>> for name, phone in table.items():\n...     print(f'{name:10} ==> {phone:10d}')\n...\nSjoerd     ==>       4127\nJack       ==>       4098\nDcab       ==>       7678\n```python\n\nOther modifiers can be used to convert the value before it is formatted. '!a' applies ascii() , '!s' applies str() , and '!r' applies repr() :\n\n```python\n>>> animals = 'eels'\n>>> print(f'My hovercraft is full of {animals}.')\nMy hovercraft is full of eels.\n>>> print(f'My hovercraft is full of {animals!r}.')\nMy hovercraft is full of 'eels'.\n```python\n\nThe = specifier can be used to expand an expression to the text of the\nexpression, an equal sign, then the representation of the evaluated expression:\n\n```python\n>>> bugs = 'roaches'\n>>> count = 13\n>>> area = 'living room'\n>>> print(f'Debugging {bugs=} {count=} {area=}')\nDebugging bugs='roaches' count=13 area='living room'\n```python\n\nSee self-documenting expressions for more information\non the = specifier. For a reference on these format specifications, see\nthe reference guide for the Format Specification Mini-Language .\n\n### 7.1.2.The String format() Method\u00c2\u00b6\n\nBasic usage of the str.format() method looks like this:\n\n```python\n>>> print('We are the {} who say \"{}!\"'.format('knights', 'Ni'))\nWe are the knights who say \"Ni!\"\n```python\n\nThe brackets and characters within them (called format fields) are replaced with\nthe objects passed into the str.format() method.  A number in the\nbrackets can be used to refer to the position of the object passed into the str.format() method.\n\n```python\n>>> print('{0} and {1}'.format('spam', 'eggs'))\nspam and eggs\n>>> print('{1} and {0}'.format('spam', 'eggs'))\neggs and spam\n```python\n\nIf keyword arguments are used in the str.format() method, their values\nare referred to by using the name of the argument.\n\n```python\n>>> print('This {food} is {adjective}.'.format(\n...       food='spam', adjective='absolutely horrible'))\nThis spam is absolutely horrible.\n```python\n\nPositional and keyword arguments can be arbitrarily combined:\n\n```python\n>>> print('The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred',\n...                                                    other='Georg'))\nThe story of Bill, Manfred, and Georg.\n```python\n\nIf you have a really long format string that you don\u00e2\u0080\u0099t want to split up, it\nwould be nice if you could reference the variables to be formatted by name\ninstead of by position.  This can be done by simply passing the dict and using\nsquare brackets '[]' to access the keys.\n\n```python\n>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}\n>>> print('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; '\n...       'Dcab: {0[Dcab]:d}'.format(table))\nJack: 4098; Sjoerd: 4127; Dcab: 8637678\n```python\n\nThis could also be done by passing the table dictionary as keyword arguments with the ** notation.\n\n```python\n>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}\n>>> print('Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: {Dcab:d}'.format(**table))\nJack: 4098; Sjoerd: 4127; Dcab: 8637678\n```python\n\nThis is particularly useful in combination with the built-in function vars() , which returns a dictionary containing all local variables:\n\n```python\n>>> table = {k: str(v) for k, v in vars().items()}\n>>> message = \" \".join([f'{k}: ' + '{' + k +'};' for k in table.keys()])\n>>> print(message.format(**table))\n__name__: __main__; __doc__: None; __package__: None; __loader__: ...\n```python\n\nAs an example, the following lines produce a tidily aligned\nset of columns giving integers and their squares and cubes:\n\n```python\n>>> for x in range(1, 11):\n...     print('{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x))\n...\n 1   1    1\n 2   4    8\n 3   9   27\n 4  16   64\n 5  25  125\n 6  36  216\n 7  49  343\n 8  64  512\n 9  81  729\n10 100 1000\n```python\n\nFor a complete overview of string formatting with str.format() , see Format String Syntax .\n\n### 7.1.3.Manual String Formatting\u00c2\u00b6\n\nHere\u00e2\u0080\u0099s the same table of squares and cubes, formatted manually:\n\n```python\n>>> for x in range(1, 11):\n...     print(repr(x).rjust(2), repr(x*x).rjust(3), end=' ')\n...     # Note use of 'end' on previous line\n...     print(repr(x*x*x).rjust(4))\n...\n 1   1    1\n 2   4    8\n 3   9   27\n 4  16   64\n 5  25  125\n 6  36  216\n 7  49  343\n 8  64  512\n 9  81  729\n10 100 1000\n```python\n\n(Note that the one space between each column was added by the\nway print() works: it always adds spaces between its arguments.)\n\nThe str.rjust() method of string objects right-justifies a string in a\nfield of a given width by padding it with spaces on the left. There are\nsimilar methods str.ljust() and str.center() . These methods do\nnot write anything, they just return a new string. If the input string is too\nlong, they don\u00e2\u0080\u0099t truncate it, but return it unchanged; this will mess up your\ncolumn lay-out but that\u00e2\u0080\u0099s usually better than the alternative, which would be\nlying about a value. (If you really want truncation you can always add a\nslice operation, as in x.ljust(n)[:n] .)\n\nThere is another method, str.zfill() , which pads a numeric string on the\nleft with zeros.  It understands about plus and minus signs:\n\n```python\n>>> '12'.zfill(5)\n'00012'\n>>> '-3.14'.zfill(7)\n'-003.14'\n>>> '3.14159265359'.zfill(5)\n'3.14159265359'\n```python\n\n### 7.1.4.Old string formatting\u00c2\u00b6\n\nThe % operator (modulo) can also be used for string formatting.\nGiven format % values (where format is a string), % conversion specifications in format are replaced with\nzero or more elements of values .\nThis operation is commonly known as string\ninterpolation. For example:\n\n```python\n>>> import math\n>>> print('The value of pi is approximately %5.3f.' % math.pi)\nThe value of pi is approximately 3.142.\n```python\n\nMore information can be found in the printf-style String Formatting section.\n\n## 7.2.Reading and Writing Files\u00c2\u00b6\n\nopen() returns a file object , and is most commonly used with\ntwo positional arguments and one keyword argument: open(filename, mode, encoding=None)\n\n```python\n>>> f = open('workfile', 'w', encoding=\"utf-8\")\n```python\n\nThe first argument is a string containing the filename.  The second argument is\nanother string containing a few characters describing the way in which the file\nwill be used. mode can be 'r' when the file will only be read, 'w' for only writing (an existing file with the same name will be erased), and 'a' opens the file for appending; any data written to the file is\nautomatically added to the end. 'r+' opens the file for both reading and\nwriting. The mode argument is optional; 'r' will be assumed if it\u00e2\u0080\u0099s\nomitted.\n\nNormally, files are opened in text mode , that means, you read and write\nstrings from and to the file, which are encoded in a specific encoding .\nIf encoding is not specified, the default is platform dependent\n(see open() ).\nBecause UTF-8 is the modern de-facto standard, encoding=\"utf-8\" is\nrecommended unless you know that you need to use a different encoding.\nAppending a 'b' to the mode opens the file in binary mode .\nBinary mode data is read and written as bytes objects.\nYou can not specify encoding when opening file in binary mode.\n\nIn text mode, the default when reading is to convert platform-specific line\nendings ( \\n on Unix, \\r\\n on Windows) to just \\n .  When writing in\ntext mode, the default is to convert occurrences of \\n back to\nplatform-specific line endings.  This behind-the-scenes modification\nto file data is fine for text files, but will corrupt binary data like that in JPEG or EXE files.  Be very careful to use binary mode when\nreading and writing such files.\n\nIt is good practice to use the with keyword when dealing\nwith file objects.  The advantage is that the file is properly closed\nafter its suite finishes, even if an exception is raised at some\npoint.  Using with is also much shorter than writing\nequivalent try - finally blocks:\n\n```python\n>>> with open('workfile', encoding=\"utf-8\") as f:\n...     read_data = f.read()\n\n>>> # We can check that the file has been automatically closed.\n>>> f.closed\nTrue\n```python\n\nIf you\u00e2\u0080\u0099re not using the with keyword, then you should call f.close() to close the file and immediately free up any system\nresources used by it.\n\nWarning\n\nCalling f.write() without using the with keyword or calling f.close() might result in the arguments\nof f.write() not being completely written to the disk, even if the\nprogram exits successfully.\n\nAfter a file object is closed, either by a with statement\nor by calling f.close() , attempts to use the file object will\nautomatically fail.\n\n```python\n>>> f.close()\n>>> f.read()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: I/O operation on closed file.\n```python\n\n### 7.2.1.Methods of File Objects\u00c2\u00b6\n\nThe rest of the examples in this section will assume that a file object called f has already been created.\n\nTo read a file\u00e2\u0080\u0099s contents, call f.read(size) , which reads some quantity of\ndata and returns it as a string (in text mode) or bytes object (in binary mode). size is an optional numeric argument.  When size is omitted or negative, the\nentire contents of the file will be read and returned; it\u00e2\u0080\u0099s your problem if the\nfile is twice as large as your machine\u00e2\u0080\u0099s memory. Otherwise, at most size characters (in text mode) or size bytes (in binary mode) are read and returned.\nIf the end of the file has been reached, f.read() will return an empty\nstring ( '' ).\n\n```python\n>>> f.read()\n'This is the entire file.\\n'\n>>> f.read()\n''\n```python\n\nf.readline() reads a single line from the file; a newline character ( \\n )\nis left at the end of the string, and is only omitted on the last line of the\nfile if the file doesn\u00e2\u0080\u0099t end in a newline.  This makes the return value\nunambiguous; if f.readline() returns an empty string, the end of the file\nhas been reached, while a blank line is represented by '\\n' , a string\ncontaining only a single newline.\n\n```python\n>>> f.readline()\n'This is the first line of the file.\\n'\n>>> f.readline()\n'Second line of the file\\n'\n>>> f.readline()\n''\n```python\n\nFor reading lines from a file, you can loop over the file object. This is memory\nefficient, fast, and leads to simple code:\n\n```python\n>>> for line in f:\n...     print(line, end='')\n...\nThis is the first line of the file.\nSecond line of the file\n```python\n\nIf you want to read all the lines of a file in a list you can also use list(f) or f.readlines() .\n\nf.write(string) writes the contents of string to the file, returning\nthe number of characters written.\n\n```python\n>>> f.write('This is a test\\n')\n15\n```python\n\nOther types of objects need to be converted \u00e2\u0080\u0093 either to a string (in text mode)\nor a bytes object (in binary mode) \u00e2\u0080\u0093 before writing them:\n\n```python\n>>> value = ('the answer', 42)\n>>> s = str(value)  # convert the tuple to string\n>>> f.write(s)\n18\n```python\n\nf.tell() returns an integer giving the file object\u00e2\u0080\u0099s current position in the file\nrepresented as number of bytes from the beginning of the file when in binary mode and\nan opaque number when in text mode.\n\nTo change the file object\u00e2\u0080\u0099s position, use f.seek(offset, whence) .  The position is computed\nfrom adding offset to a reference point; the reference point is selected by\nthe whence argument.  A whence value of 0 measures from the beginning\nof the file, 1 uses the current file position, and 2 uses the end of the file as\nthe reference point. whence can be omitted and defaults to 0, using the\nbeginning of the file as the reference point.\n\n```python\n>>> f = open('workfile', 'rb+')\n>>> f.write(b'0123456789abcdef')\n16\n>>> f.seek(5)      # Go to the 6th byte in the file\n5\n>>> f.read(1)\nb'5'\n>>> f.seek(-3, 2)  # Go to the 3rd byte before the end\n13\n>>> f.read(1)\nb'd'\n```python\n\nIn text files (those opened without a b in the mode string), only seeks\nrelative to the beginning of the file are allowed (the exception being seeking\nto the very file end with seek(0, 2) ) and the only valid offset values are\nthose returned from the f.tell() , or zero. Any other offset value produces\nundefined behaviour.\n\nFile objects have some additional methods, such as isatty() and truncate() which are less frequently used; consult the Library\nReference for a complete guide to file objects.\n\n### 7.2.2.Saving structured data withjson\u00c2\u00b6\n\nStrings can easily be written to and read from a file.  Numbers take a bit more\neffort, since the read() method only returns strings, which will have to\nbe passed to a function like int() , which takes a string like '123' and returns its numeric value 123.  When you want to save more complex data\ntypes like nested lists and dictionaries, parsing and serializing by hand\nbecomes complicated.\n\nRather than having users constantly writing and debugging code to save\ncomplicated data types to files, Python allows you to use the popular data\ninterchange format called JSON (JavaScript Object Notation) .  The standard module called json can take Python\ndata hierarchies, and convert them to string representations; this process is\ncalled serializing .  Reconstructing the data from the string representation\nis called deserializing .  Between serializing and deserializing, the\nstring representing the object may have been stored in a file or data, or\nsent over a network connection to some distant machine.\n\nNote\n\nThe JSON format is commonly used by modern applications to allow for data\nexchange.  Many programmers are already familiar with it, which makes\nit a good choice for interoperability.\n\nIf you have an object x , you can view its JSON string representation with a\nsimple line of code:\n\n```python\n>>> import json\n>>> x = [1, 'simple', 'list']\n>>> json.dumps(x)\n'[1, \"simple\", \"list\"]'\n```python\n\nAnother variant of the dumps() function, called dump() ,\nsimply serializes the object to a text file .  So if f is a text file object opened for writing, we can do this:\n\n```python\njson.dump(x, f)\n```python\n\nTo decode the object again, if f is a binary file or text file object which has been opened for reading:\n\n```python\nx = json.load(f)\n```python\n\nNote\n\nJSON files must be encoded in UTF-8. Use encoding=\"utf-8\" when opening\nJSON file as a text file for both of reading and writing.\n\nThis simple serialization technique can handle lists and dictionaries, but\nserializing arbitrary class instances in JSON requires a bit of extra effort.\nThe reference for the json module contains an explanation of this.\n\nSee also\n\npickle - the pickle module\n\nContrary to JSON , pickle is a protocol which allows\nthe serialization of arbitrarily complex Python objects.  As such, it is\nspecific to Python and cannot be used to communicate with applications\nwritten in other languages.  It is also insecure by default:\ndeserializing pickle data coming from an untrusted source can execute\narbitrary code, if the data was crafted by a skilled attacker.",
  "difficulty": "intro",
  "doc_id": "doc-7-input-and-output-6350c56c82",
  "provenance": {
    "author": "",
    "date": "",
    "license": "PSF Documentation License",
    "source_file": "data/corpus_raw/scraped/3_tutorial_inputoutput_html_d3ac38.json",
    "url": "https://docs.python.org/3/tutorial/inputoutput.html"
  },
  "title": "7.Input and Output\u00c2\u00b6",
  "type": "tutorial"
}