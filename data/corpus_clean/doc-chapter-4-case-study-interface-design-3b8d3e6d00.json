{
  "ai_generated": false,
  "concept_tags": [
    "functions",
    "recursion",
    "return_values",
    "scope"
  ],
  "content": "Buy this book at Amazon.com Chapter\u00a04\u00a0\u00a0Case study: interface design This chapter presents a case study that demonstrates a process for\ndesigning functions that work together. It introduces the turtle module, which allows you to\ncreate images using turtle graphics. The turtle module is\nincluded in most Python installations, but if you are running Python\nusing PythonAnywhere, you won\u2019t be able to run the turtle examples (at\nleast you couldn\u2019t when I wrote this). If you have already installed Python on your computer, you should\nbe able to run the examples. Otherwise, now is a good time\nto install. I have posted instructions at http://tinyurl.com/thinkpython2e . Code examples from this chapter are available from https://thinkpython.com/code/polygon.py . 4.1\u00a0\u00a0The turtle module To check whether you have the turtle module, open the Python\ninterpreter and type >>> import turtle\n>>> bob = turtle.Turtle() When you run this code, it should create a new window\nwith small arrow that represents the turtle. Close the window. Create a file named mypolygon.py and type in the following\ncode: import turtle\nbob = turtle.Turtle()\nprint(bob)\nturtle.mainloop() The turtle module (with a lowercase \u2019t\u2019) provides a function\ncalled Turtle (with an uppercase \u2019T\u2019) that creates a Turtle\nobject, which we assign to a variable named bob .\nPrinting bob displays something like: <turtle.Turtle object at 0xb7bfbf4c> This means that bob refers to an object with type Turtle as defined in module turtle . mainloop tells the window to wait for the user\nto do something, although in this case there\u2019s not much for\nthe user to do except close the window. Once you create a Turtle, you can call a method to move it\naround the window. A method is similar to a function, but it\nuses slightly different syntax. For example, to move the turtle\nforward: bob.fd(100) The method, fd , is associated with the turtle\nobject we\u2019re calling bob .\nCalling a method is like making a request: you are asking bob to move forward. The argument of fd is a distance in pixels, so the actual\nsize depends on your display. Other methods you can call on a Turtle are bk to move\nbackward, lt for left turn, and rt right turn. The\nargument for lt and rt is an angle in degrees. Also, each Turtle is holding a pen, which is\neither down or up; if the pen is down, the Turtle leaves\na trail when it moves. The methods pu and pd stand for \u201cpen up\u201d and \u201cpen down\u201d. To draw a right angle, add these lines to the program\n(after creating bob and before calling mainloop ): bob.fd(100)\nbob.lt(90)\nbob.fd(100) When you run this program, you should see bob move east and then\nnorth, leaving two line segments behind. Now modify the program to draw a square. Don\u2019t go on until\nyou\u2019ve got it working! 4.2\u00a0\u00a0Simple repetition Chances are you wrote something like this: bob.fd(100)\nbob.lt(90)\n\nbob.fd(100)\nbob.lt(90)\n\nbob.fd(100)\nbob.lt(90)\n\nbob.fd(100) We can do the same thing more concisely with a for statement.\nAdd this example to mypolygon.py and run it again: for i in range(4):\n    print('Hello!') You should see something like this: Hello!\nHello!\nHello!\nHello! This is the simplest use of the for statement; we will see\nmore later. But that should be enough to let you rewrite your\nsquare-drawing program. Don\u2019t go on until you do. Here is a for statement that draws a square: for i in range(4):\n    bob.fd(100)\n    bob.lt(90) The syntax of a for statement is similar to a function\ndefinition. It has a header that ends with a colon and an indented\nbody. The body can contain any number of statements. A for statement is also called a loop because\nthe flow of execution runs through the body and then loops back\nto the top. In this case, it runs the body four times. This version is actually a little different from the previous\nsquare-drawing code because it makes another turn after\ndrawing the last side of the square. The extra turn takes\nmore time, but it simplifies the code if we do the same thing\nevery time through the loop. This version also has the effect\nof leaving the turtle back in the starting position, facing in\nthe starting direction. 4.3\u00a0\u00a0Exercises The following is a series of exercises using the turtle module. They\nare meant to be fun, but they have a point, too. While you are\nworking on them, think about what the point is. The following sections have solutions to the exercises, so\ndon\u2019t look until you have finished (or at least tried). Write a function called square that takes a parameter\nnamed t , which is a turtle. It should use the turtle to draw\na square. Write a function call that passes bob as an argument to square , and then run the program again. Add another parameter, named length , to square .\nModify the body so length of the sides is length , and then\nmodify the function call to provide a second argument. Run the\nprogram again. Test your program with a range of values for length . Make a copy of square and change the name to polygon . Add another parameter named n and modify the body\nso it draws an n-sided regular polygon. Hint: The exterior angles\nof an n-sided regular polygon are 360/ n degrees. Write a function called circle that takes a turtle, t , and radius, r , as parameters and that draws an\napproximate circle by calling polygon with an appropriate\nlength and number of sides. Test your function with a range of values\nof r . Hint: figure out the circumference of the circle and make sure that length * n = circumference . Make a more general version of circle called arc that takes an additional parameter angle , which determines\nwhat fraction of a circle to draw. angle is in units of\ndegrees, so when angle=360 , arc should draw a complete\ncircle. 4.4\u00a0\u00a0Encapsulation The first exercise asks you to put your square-drawing code\ninto a function definition and then call the function, passing\nthe turtle as a parameter. Here is a solution: def square(t):\n    for i in range(4):\n        t.fd(100)\n        t.lt(90)\n\nsquare(bob) The innermost statements, fd and lt are indented twice to\nshow that they are inside the for loop, which is inside the\nfunction definition. The next line, square(bob) , is flush with\nthe left margin, which indicates the end of both the for loop\nand the function definition. Inside the function, t refers to the same turtle bob , so t.lt(90) has the same effect as bob.lt(90) . In that\ncase, why not\ncall the parameter bob ? The idea is that t can be any\nturtle, not just bob , so you could create a second turtle and\npass it as an argument to square : alice = turtle.Turtle()\nsquare(alice) Wrapping a piece of code up in a function is called encapsulation . One of the benefits of encapsulation is that it\nattaches a name to the code, which serves as a kind of documentation.\nAnother advantage is that if you re-use the code, it is more concise\nto call a function twice than to copy and paste the body! 4.5\u00a0\u00a0Generalization The next step is to add a length parameter to square .\nHere is a solution: def square(t, length):\n    for i in range(4):\n        t.fd(length)\n        t.lt(90)\n\nsquare(bob, 100) Adding a parameter to a function is called generalization because it makes the function more general: in the previous\nversion, the square is always the same size; in this version\nit can be any size. The next step is also a generalization. Instead of drawing\nsquares, polygon draws regular polygons with any number of\nsides. Here is a solution: def polygon(t, n, length):\n    angle = 360 / n\n    for i in range(n):\n        t.fd(length)\n        t.lt(angle)\n\npolygon(bob, 7, 70) This example draws a 7-sided polygon with side length 70. If you are using Python 2, the value of angle might be off\nbecause of integer division. A simple solution is to compute angle = 360.0 / n . Because the numerator is a floating-point\nnumber, the result is floating point. When a function has more than a few numeric arguments, it is easy to\nforget what they are, or what order they should be in. In that case\nit is often a good idea to include the names of the parameters in the\nargument list: polygon(bob, n=7, length=70) These are called keyword arguments because they include\nthe parameter names as \u201ckeywords\u201d (not to be confused with\nPython keywords like while and def ). This syntax makes the program more readable. It is also a reminder\nabout how arguments and parameters work: when you call a function, the\narguments are assigned to the parameters. 4.6\u00a0\u00a0Interface design The next step is to write circle , which takes a radius, r , as a parameter. Here is a simple solution that uses polygon to draw a 50-sided polygon: import math\n\ndef circle(t, r):\n    circumference = 2 * math.pi * r\n    n = 50\n    length = circumference / n\n    polygon(t, n, length) The first line computes the circumference of a circle with radius r using the formula 2 \u03c0 r . Since we use math.pi , we\nhave to import math . By convention, import statements\nare usually at the beginning of the script. n is the number of line segments in our approximation of a circle,\nso length is the length of each segment. Thus, polygon draws a 50-sided polygon that approximates a circle with radius r . One limitation of this solution is that n is a constant, which\nmeans that for very big circles, the line segments are too long, and\nfor small circles, we waste time drawing very small segments. One\nsolution would be to generalize the function by taking n as\na parameter. This would give the user (whoever calls circle )\nmore control, but the interface would be less clean. The interface of a function is a summary of how it is used: what\nare the parameters? What does the function do? And what is the return\nvalue? An interface is \u201cclean\u201d if it allows the caller to do\nwhat they want without dealing with unnecessary details. In this example, r belongs in the interface because it\nspecifies the circle to be drawn. n is less appropriate\nbecause it pertains to the details of how the circle should\nbe rendered. Rather than clutter up the interface, it is better\nto choose an appropriate value of n depending on circumference : def circle(t, r):\n    circumference = 2 * math.pi * r\n    n = int(circumference / 3) + 3\n    length = circumference / n\n    polygon(t, n, length) Now the number of segments is an integer near circumference/3 ,\nso the length of each segment is approximately 3, which is small\nenough that the circles look good, but big enough to be efficient,\nand acceptable for any size circle. Adding 3 to n guarantees that the polygon has at least 3 sides. 4.7\u00a0\u00a0Refactoring When I wrote circle , I was able to re-use polygon because a many-sided polygon is a good approximation of a circle.\nBut arc is not as cooperative; we can\u2019t use polygon or circle to draw an arc. One alternative is to start with a copy\nof polygon and transform it into arc . The result\nmight look like this: def arc(t, r, angle):\n    arc_length = 2 * math.pi * r * angle / 360\n    n = int(arc_length / 3) + 1\n    step_length = arc_length / n\n    step_angle = angle / n\n\n    for i in range(n):\n        t.fd(step_length)\n        t.lt(step_angle) The second half of this function looks like polygon , but we\ncan\u2019t re-use polygon without changing the interface. We could\ngeneralize polygon to take an angle as a third argument,\nbut then polygon would no longer be an appropriate name!\nInstead, let\u2019s call the more general function polyline : def polyline(t, n, length, angle):\n    for i in range(n):\n        t.fd(length)\n        t.lt(angle) Now we can rewrite polygon and arc to use polyline : def polygon(t, n, length):\n    angle = 360.0 / n\n    polyline(t, n, length, angle)\n\ndef arc(t, r, angle):\n    arc_length = 2 * math.pi * r * angle / 360\n    n = int(arc_length / 3) + 1\n    step_length = arc_length / n\n    step_angle = float(angle) / n\n    polyline(t, n, step_length, step_angle) Finally, we can rewrite circle to use arc : def circle(t, r):\n    arc(t, r, 360) This process\u2014rearranging a program to improve\ninterfaces and facilitate code re-use\u2014is called refactoring .\nIn this case, we noticed that there was similar code in arc and polygon , so we \u201cfactored it out\u201d into polyline . If we had planned ahead, we might have written polyline first\nand avoided refactoring, but often you don\u2019t know enough at the\nbeginning of a project to design all the interfaces. Once you start\ncoding, you understand the problem better. Sometimes refactoring is a\nsign that you have learned something. 4.8\u00a0\u00a0A development plan A development plan is a process for writing programs. The\nprocess we used in this case study is \u201cencapsulation and\ngeneralization\u201d. The steps of this process are: Start by writing a small program with no function definitions. Once you get the program working, identify a coherent piece of\nit, encapsulate the piece in a function and give it a name. Generalize the function by adding appropriate parameters. Repeat steps 1\u20133 until you have a set of working functions.\nCopy and paste working code to avoid retyping (and re-debugging). Look for opportunities to improve the program by refactoring.\nFor example, if you have similar code in several places, consider\nfactoring it into an appropriately general function. This process has some drawbacks\u2014we will see alternatives later\u2014but\nit can be useful if you don\u2019t know ahead of time how to divide the\nprogram into functions. This approach lets you design as you go\nalong. 4.9\u00a0\u00a0docstring A docstring is a string at the beginning of a function that\nexplains the interface (\u201cdoc\u201d is short for \u201cdocumentation\u201d). Here\nis an example: def polyline(t, n, length, angle):\n    \"\"\"Draws n line segments with the given length and\n    angle (in degrees) between them.  t is a turtle.\n    \"\"\"\n    for i in range(n):\n        t.fd(length)\n        t.lt(angle) By convention, all docstrings are triple-quoted strings, also known\nas multiline strings because the triple quotes allow the string\nto span more than one line. It is terse, but it contains the essential information\nsomeone would need to use this function. It explains concisely what\nthe function does (without getting into the details of how it does\nit). It explains what effect each parameter has on the behavior of\nthe function and what type each parameter should be (if it is not\nobvious). Writing this kind of documentation is an important part of interface\ndesign. A well-designed interface should be simple to explain;\nif you have a hard time explaining one of your functions,\nmaybe the interface could be improved. 4.10\u00a0\u00a0Debugging An interface is like a contract between a function and a caller.\nThe caller agrees to provide certain parameters and the function\nagrees to do certain work. For example, polyline requires four arguments: t has to be\na Turtle; n has to be an\ninteger; length should be a positive number; and angle has to be a number, which is understood to be in degrees. These requirements are called preconditions because they\nare supposed to be true before the function starts executing.\nConversely, conditions at the end of the function are postconditions . Postconditions include the intended\neffect of the function (like drawing line segments) and any\nside effects (like moving the Turtle or making other changes). Preconditions are the responsibility of the caller. If the caller\nviolates a (properly documented!) precondition and the function\ndoesn\u2019t work correctly, the bug is in the caller, not the function. If the preconditions are satisfied and the postconditions are\nnot, the bug is in the function. If your pre- and postconditions\nare clear, they can help with debugging. 4.11\u00a0\u00a0Glossary method: A function that is associated with an object and called\nusing dot notation. loop: A part of a program that can run repeatedly. encapsulation: The process of transforming a sequence of\nstatements into a function definition. generalization: The process of replacing something\nunnecessarily specific (like a number) with something appropriately\ngeneral (like a variable or parameter). keyword argument: An argument that includes the name of\nthe parameter as a \u201ckeyword\u201d. interface: A description of how to use a function, including\nthe name and descriptions of the arguments and return value. refactoring: The process of modifying a working program to\nimprove function interfaces and other qualities of the code. development plan: A process for writing programs. docstring: A string that appears at the top of a function\ndefinition to document the function\u2019s interface. precondition: A requirement that should be satisfied by\nthe caller before a function starts. postcondition: A requirement that should be satisfied by\nthe function before it ends. 4.12\u00a0\u00a0Exercises Exercise\u00a01 Download the code in this chapter from https://thinkpython.com/code/polygon.py . Draw a stack diagram that shows the state of the program\nwhile executing circle(bob, radius) . You can do the\narithmetic by hand or add print statements to the code. The version of arc in Section 4.7 is not\nvery accurate because the linear approximation of the\ncircle is always outside the true circle. As a result,\nthe Turtle ends up a few pixels away from the correct\ndestination. My solution shows a way to reduce\nthe effect of this error. Read the code and see if it makes\nsense to you. If you draw a diagram, you might see how it works. Figure 4.1: Turtle flowers. Exercise\u00a02 Write an appropriately general set of functions that\ncan draw flowers as in Figure 4.1 . Solution: https://thinkpython.com/code/flower.py ,\nalso requires https://thinkpython.com/code/polygon.py . Figure 4.2: Turtle pies. Exercise\u00a03 Write an appropriately general set of functions that\ncan draw shapes as in Figure 4.2 . Solution: https://thinkpython.com/code/pie.py . Exercise\u00a04 The letters of the alphabet can be constructed from a moderate number\nof basic elements, like vertical and horizontal lines and a few\ncurves. Design an alphabet that can be drawn with a minimal\nnumber of basic elements and then write functions that draw the letters. You should write one function for each letter, with names draw_a , draw_b , etc., and put your functions\nin a file named letters.py . You can download a\n\u201cturtle typewriter\u201d from https://thinkpython.com/code/typewriter.py to help you test your code. You can get a solution from https://thinkpython.com/code/letters.py ;\nit also requires https://thinkpython.com/code/polygon.py . Exercise\u00a05 Read about spirals at http://en.wikipedia.org/wiki/Spiral ; then\nwrite a program that draws an Archimedian spiral (or one of the other\nkinds). Solution: https://thinkpython.com/code/spiral.py . Buy this book at Amazon.com\n\n#### Contribute\n\nIf you would like to make a contribution to support my books,\nyou can use the button below and pay with PayPal.  Thank you!\nPay what you want:\nSmall $1.00 USD\nMedium $5.00 USD\nLarge $10.00 USD\nX-Large $20.00 USD\nXX-Large $50.00 USD\nAre you using one of our books in a class? We'd like to know\nabout it.  Please consider filling out this short survey . Think DSP Think Java Think Bayes Think Python 2e Think Stats 2e Think Complexity",
  "difficulty": "intro",
  "doc_id": "doc-chapter-4-case-study-interface-design-3b8d3e6d00",
  "provenance": {
    "author": "",
    "date": "",
    "license": "CC BY-NC 3.0",
    "source_file": "data/corpus_raw/thinkpython2_html_thinkpython2005_html_82fc01.json",
    "url": "https://greenteapress.com/thinkpython2/html/thinkpython2005.html"
  },
  "title": "Chapter\u00a04\u00a0\u00a0Case study: interface design",
  "type": "tutorial"
}