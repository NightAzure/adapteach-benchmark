{
  "ai_generated": false,
  "concept_tags": [
    "data_types",
    "numbers",
    "operators",
    "strings",
    "variables"
  ],
  "content": "## 1PYTHON BASICS\n\nThe Python programming language has a wide range of syntactical constructions, standard library functions, and interactive development environment features. Fortunately, you can ignore most of that; you just need to learn enough to write some handy little programs.\n\nYou will, however, have to learn some basic programming concepts before you can do anything. Like a wizard in training, you might think these concepts seem arcane and tedious, but with some knowledge and practice, you\u2019ll be able to command your computer like a magic wand and perform incredible feats.\n\nThis chapter has a few examples that encourage you to type into the interactive shell , also called the REPL (Read-Evaluate-Print Loop), which lets you run (or execute ) Python instructions one at a time and instantly shows you the results. Using the interactive shell is great for learning what basic Python instructions do, so give it a try as you follow along. You\u2019ll remember the things you do much better than the things you only read.\n\n### Entering Expressions into the Interactive Shell\n\nYou can run the interactive shell by launching the Mu editor, which you should have downloaded when going through the setup instructions in the Preface. On Windows, open the Start menu, type \u201cMu,\u201d and open the Mu app. On macOS, open your Applications folder and double-click Mu . Click the New button and save an empty file as blank.py . When you run this blank file by clicking the Run button or pressing F5 , it will open the interactive shell, which will open as a new pane that opens at the bottom of the Mu editor\u2019s window. You should see a >>> prompt in the interactive shell.\n\nEnter 2 + 2 at the prompt to have Python do some simple math. The Mu window should now look like this:\n\n>>> 2 + 2 4 >>>\n\nIn Python, 2 + 2 is called an expression , which is the most basic kind of programming instruction in the language. Expressions consist of values (such as 2 ) and operators (such as + ), and they can always evaluate (that is, reduce) down to a single value. That means you can use expressions anywhere in Python code that you could also use a value.\n\nIn the previous example, 2 + 2 is evaluated down to a single value, 4 . A single value with no operators is also considered an expression, though it evaluates only to itself, as shown here:\n\n>>> 2 2\n\nERRORS ARE OKAY!\n\nPrograms will crash if they contain code the computer can\u2019t understand, which will cause Python to show an error message. An error message won\u2019t break your computer, though, so don\u2019t be afraid to make mistakes. A crash just means the program stopped running unexpectedly.\n\nIf you want to know more about an error, you can search for the exact error message text online for more information. You can also check out the resources at https://nostarch.com/automatestuff2/ to see a list of common Python error messages and their meanings.\n\nYou can use plenty of other operators in Python expressions, too. For example, Table 1-1 lists all the math operators in Python.\n\nTable 1-1: Math Operators from Highest to Lowest Precedence\n\nOperator\n\nOperation\n\nExample\n\nEvaluates to . . .\n\n**\n\nExponent\n\n2 ** 3\n\n8\n\n%\n\nModulus/remainder\n\n22 % 8\n\n6\n\n//\n\nInteger division/floored quotient\n\n22 // 8\n\n2\n\n/\n\nDivision\n\n22 / 8\n\n2.75\n\n*\n\nMultiplication\n\n3 * 5\n\n15\n\n-\n\nSubtraction\n\n5 - 2\n\n3\n\n+\n\nAddition\n\n2 + 2\n\n4\n\nThe order of operations (also called precedence ) of Python math operators is similar to that of mathematics. The ** operator is evaluated first; the * , / , // , and % operators are evaluated next, from left to right; and the + and - operators are evaluated last (also from left to right). You can use parentheses to override the usual precedence if you need to. Whitespace in between the operators and values doesn\u2019t matter for Python (except for the indentation at the beginning of the line), but a single space is convention. Enter the following expressions into the interactive shell:\n\n>>> 2 + 3 * 6 20 >>> (2 + 3) * 6 30 >>> 48565878 * 578453 28093077826734 >>> 2 ** 8 256 >>> 23 / 7 3.2857142857142856 >>> 23 // 7 3 >>> 23 % 7 2 >>> 2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02 4 >>> (5 - 1) * ((7 + 1) / (3 - 1)) 16.0\n\nIn each case, you as the programmer must enter the expression, but Python does the hard part of evaluating it down to a single value. Python will keep evaluating parts of the expression until it becomes a single value, as shown here:\n\nThese rules for putting operators and values together to form expressions are a fundamental part of Python as a programming language, just like the grammar rules that help us communicate. Here\u2019s an example:\n\nThis is a grammatically correct English sentence.\n\nThis grammatically is sentence not English correct a.\n\nThe second line is difficult to parse because it doesn\u2019t follow the rules of English. Similarly, if you enter a bad Python instruction, Python won\u2019t be able to understand it and will display a SyntaxError error message, as shown here:\n\n>>> 5 + File \"<stdin>\", line 1 5 + ^ SyntaxError: invalid syntax >>> 42 + 5 + * 2 File \"<stdin>\", line 1 42 + 5 + * 2 ^ SyntaxError: invalid syntax\n\nYou can always test to see whether an instruction works by entering it into the interactive shell. Don\u2019t worry about breaking the computer: the worst that could happen is that Python responds with an error message. Professional software developers get error messages while writing code all the time.\n\n### The Integer, Floating-Point, and String Data Types\n\nRemember that expressions are just values combined with operators, and they always evaluate down to a single value. A data type is a category for values, and every value belongs to exactly one data type. The most common data types in Python are listed in Table 1-2. The values -2 and 30 , for example, are said to be integer values. The integer (or int ) data type indicates values that are whole numbers. Numbers with a decimal point, such as 3.14 , are called floating-point numbers (or floats ). Note that even though the value 42 is an integer, the value 42.0 would be a floating-point number.\n\nTable 1-2: Common Data Types\n\nData type\n\nExamples\n\nIntegers\n\n-2 , -1 , 0 , 1 , 2 , 3 , 4 , 5\n\nFloating-point numbers\n\n-1.25 , -1.0 , -0.5 , 0.0 , 0.5 , 1.0 , 1.25\n\nStrings\n\n'a' , 'aa' , 'aaa' , 'Hello!' , '11 cats'\n\nPython programs can also have text values called strings , or strs (pronounced \u201cstirs\u201d). Always surround your string in single quote ( ' ) characters (as in 'Hello' or 'Goodbye cruel world!' ) so Python knows where the string begins and ends. You can even have a string with no characters in it, '' , called a blank string or an empty string . Strings are explained in greater detail in Chapter 4.\n\nIf you ever see the error message SyntaxError: EOL while scanning string literal , you probably forgot the final single quote character at the end of the string, such as in this example:\n\n>>> 'Hello, world! SyntaxError: EOL while scanning string literal\n\n### String Concatenation and Replication\n\nThe meaning of an operator may change based on the data types of the values next to it. For example, + is the addition operator when it operates on two integers or floating-point values. However, when + is used on two string values, it joins the strings as the string concatenation operator. Enter the following into the interactive shell:\n\n>>> 'Alice' + 'Bob' 'AliceBob'\n\nThe expression evaluates down to a single, new string value that combines the text of the two strings. However, if you try to use the + operator on a string and an integer value, Python will not know how to handle this, and it will display an error message.\n\n>>> 'Alice' + 42 Traceback (most recent call last): File \"<pyshell#0>\", line 1, in <module> 'Alice' + 42 TypeError: can only concatenate str (not \"int\") to str\n\nThe error message can only concatenate str (not \"int\") to str means that Python thought you were trying to concatenate an integer to the string 'Alice' . Your code will have to explicitly convert the integer to a string because Python cannot do this automatically. (Converting data types will be explained in \u201cDissecting Your Program\u201d on page 13 when we talk about the str() , int() , and float() functions.)\n\nThe * operator multiplies two integer or floating-point values. But when the * operator is used on one string value and one integer value, it becomes the string replication operator. Enter a string multiplied by a number into the interactive shell to see this in action.\n\n>>> 'Alice' * 5 'AliceAliceAliceAliceAlice'\n\nThe expression evaluates down to a single string value that repeats the original string a number of times equal to the integer value. String replication is a useful trick, but it\u2019s not used as often as string concatenation.\n\nThe * operator can be used with only two numeric values (for multiplication), or one string value and one integer value (for string replication). Otherwise, Python will just display an error message, like the following:\n\n>>> 'Alice' * 'Bob' Traceback (most recent call last): File \"<pyshell#32>\", line 1, in <module> 'Alice' * 'Bob' TypeError: can't multiply sequence by non-int of type 'str' >>> 'Alice' * 5.0 Traceback (most recent call last): File \"<pyshell#33>\", line 1, in <module> 'Alice' * 5.0 TypeError: can't multiply sequence by non-int of type 'float'\n\nIt makes sense that Python wouldn\u2019t understand these expressions: you can\u2019t multiply two words, and it\u2019s hard to replicate an arbitrary string a fractional number of times.\n\n### Storing Values in Variables\n\nA variable is like a box in the computer\u2019s memory where you can store a single value. If you want to use the result of an evaluated expression later in your program, you can save it inside a variable.\n\n#### Assignment Statements\n\nYou\u2019ll store values in variables with an assignment statement . An assignment statement consists of a variable name, an equal sign (called the assignment operator ), and the value to be stored. If you enter the assignment statement spam = 42 , then a variable named spam will have the integer value 42 stored in it.\n\nThink of a variable as a labeled box that a value is placed in, as in Figure 1-1.\n\nFigure 1-1: spam = 42 is like telling the program, \u201cThe variable spam now has the integer value 42 in it.\u201d\n\nFor example, enter the following into the interactive shell:\n\n\u278a >>> spam = 40 >>> spam 40 >>> eggs = 2 \u278b >>> spam + eggs 42 >>> spam + eggs + spam 82 \u278c >>> spam = spam + 2 >>> spam 42\n\nA variable is initialized (or created) the first time a value is stored in it \u278a . After that, you can use it in expressions with other variables and values \u278b . When a variable is assigned a new value \u278c , the old value is forgotten, which is why spam evaluated to 42 instead of 40 at the end of the example. This is called overwriting the variable. Enter the following code into the interactive shell to try overwriting a string:\n\n>>> spam = 'Hello' >>> spam 'Hello' >>> spam = 'Goodbye' >>> spam 'Goodbye'\n\nJust like the box in Figure 1-2, the spam variable in this example stores 'Hello' until you replace the string with 'Goodbye' .\n\nFigure 1-2: When a new value is assigned to a variable, the old one is forgotten.\n\n#### Variable Names\n\nA good variable name describes the data it contains. Imagine that you moved to a new house and labeled all of your moving boxes as Stuff . You\u2019d never find anything! Most of this book\u2019s examples (and Python\u2019s documentation) use generic variable names like spam , eggs , and bacon , which come from the Monty Python \u201cSpam\u201d sketch. But in your programs, a descriptive name will help make your code more readable.\n\nThough you can name your variables almost anything, Python does have some naming restrictions. Table 1-3 has examples of legal variable names. You can name a variable anything as long as it obeys the following three rules:\n\n- It can be only one word with no spaces.\n- It can use only letters, numbers, and the underscore ( _ ) character.\n- It can\u2019t begin with a number.\n\nTable 1-3: Valid and Invalid Variable Names\n\nValid variable names\n\nInvalid variable names\n\ncurrent_balance\n\ncurrent-balance (hyphens are not allowed)\n\ncurrentBalance\n\ncurrent balance (spaces are not allowed)\n\naccount4\n\n4account (can\u2019t begin with a number)\n\n_42\n\n42 (can\u2019t begin with a number)\n\nTOTAL_SUM\n\nTOTAL_$UM (special characters like $ are not allowed)\n\nhello\n\n'hello' (special characters like ' are not allowed)\n\nVariable names are case-sensitive, meaning that spam , SPAM , Spam , and sPaM are four different variables. Though Spam is a valid variable you can use in a program, it is a Python convention to start your variables with a lowercase letter.\n\nThis book uses camelcase for variable names instead of underscores; that is, variables lookLikeThis instead of looking_like_this . Some experienced programmers may point out that the official Python code style, PEP 8, says that underscores should be used. I unapologetically prefer camelcase and point to the \u201cA Foolish Consistency Is the Hobgoblin of Little Minds\u201d section in PEP 8 itself:\n\nConsistency with the style guide is important. But most importantly: know when to be inconsistent\u2014sometimes the style guide just doesn\u2019t apply. When in doubt, use your best judgment.\n\n### Your First Program\n\nWhile the interactive shell is good for running Python instructions one at a time, to write entire Python programs, you\u2019ll type the instructions into the file editor. The file editor is similar to text editors such as Notepad or TextMate, but it has some features specifically for entering source code. To open a new file in Mu, click the New button on the top row.\n\nThe window that appears should contain a cursor awaiting your input, but it\u2019s different from the interactive shell, which runs Python instructions as soon as you press ENTER . The file editor lets you type in many instructions, save the file, and run the program. Here\u2019s how you can tell the difference between the two:\n\n- The interactive shell window will always be the one with the >>> prompt.\n- The file editor window will not have the >>> prompt.\n\nNow it\u2019s time to create your first program! When the file editor window opens, enter the following into it:\n\n\u278a # This program says hello and asks for my name. \u278b print('Hello, world!') print('What is your name?')\u00a0\u00a0\u00a0\u00a0# ask for their name \u278c myName = input() \u278d print('It is good to meet you, ' + myName) \u278e print('The length of your name is:') print(len(myName)) \u278f print('What is your age?')\u00a0\u00a0\u00a0\u00a0# ask for their age myAge = input() print('You will be ' + str(int(myAge) + 1) + ' in a year.')\n\nOnce you\u2019ve entered your source code, save it so that you won\u2019t have to retype it each time you start Mu. Click the Save button, enter hello.py in the File Name field, and then click Save .\n\nYou should save your programs every once in a while as you type them. That way, if the computer crashes or you accidentally exit Mu, you won\u2019t lose the code. As a shortcut, you can press CTRL -S on Windows and Linux or -S on macOS to save your file.\n\nOnce you\u2019ve saved, let\u2019s run our program. Press the F5 key. Your program should run in the interactive shell window. Remember, you have to press F5 from the file editor window, not the interactive shell window. Enter your name when your program asks for it. The program\u2019s output in the interactive shell should look something like this:\n\nWhen there are no more lines of code to execute, the Python program terminates ; that is, it stops running. (You can also say that the Python program exits .)\n\nYou can close the file editor by clicking the X at the top of the window. To reload a saved program, select File \u25b8 Open... from the menu. Do that now, and in the window that appears, choose hello.py and click the Open button. Your previously saved hello.py program should open in the file editor window.\n\nYou can view the execution of a program using the Python Tutor visualization tool at http://pythontutor.com/ . You can see the execution of this particular program at https://autbor.com/hellopy/ . Click the forward button to move through each step of the program\u2019s execution. You\u2019ll be able to see how the variables\u2019 values and the output change.\n\n### Dissecting Your Program\n\nWith your new program open in the file editor, let\u2019s take a quick tour of the Python instructions it uses by looking at what each line of code does.\n\n#### Comments\n\nThe following line is called a comment .\n\n\u278a # This program says hello and asks for my name.\n\nPython ignores comments, and you can use them to write notes or remind yourself what the code is trying to do. Any text for the rest of the line following a hash mark ( # ) is part of a comment.\n\nSometimes, programmers will put a # in front of a line of code to temporarily remove it while testing a program. This is called commenting out code, and it can be useful when you\u2019re trying to figure out why a program isn\u2019t working. You can remove the # later when you are ready to put the line back in.\n\nPython also ignores the blank line after the comment. You can add as many blank lines to your program as you want. This can make your code easier to read, like paragraphs in a book.\n\n#### The print() Function\n\nThe print() function displays the string value inside its parentheses on the screen.\n\n\u278b print('Hello, world!') print('What is your name?') # ask for their name\n\nThe line print('Hello, world!') means \u201cPrint out the text in the string 'Hello, world!' .\u201d When Python executes this line, you say that Python is calling the print() function and the string value is being passed to the function. A value that is passed to a function call is an argument . Notice that the quotes are not printed to the screen. They just mark where the string begins and ends; they are not part of the string value.\n\nNOTE\n\nYou can also use this function to put a blank line on the screen; just call print() with nothing in between the parentheses.\n\nWhen you write a function name, the opening and closing parentheses at the end identify it as the name of a function. This is why in this book, you\u2019ll see print() rather than print . Chapter 3 describes functions in more detail.\n\n#### The input() Function\n\nThe input() function waits for the user to type some text on the keyboard and press ENTER .\n\n\u278c myName = input()\n\nThis function call evaluates to a string equal to the user\u2019s text, and the line of code assigns the myName variable to this string value.\n\nYou can think of the input() function call as an expression that evaluates to whatever string the user typed in. If the user entered 'Al' , then the expression would evaluate to myName = 'Al' .\n\nIf you call input() and see an error message, like NameError: name 'Al' is not defined , the problem is that you\u2019re running the code with Python 2 instead of Python 3.\n\n#### Printing the User\u2019s Name\n\nThe following call to print() actually contains the expression 'It is good to meet you, ' + myName between the parentheses.\n\n\u278d print('It is good to meet you, ' + myName)\n\nRemember that expressions can always evaluate to a single value. If 'Al' is the value stored in myName on line \u278c , then this expression evaluates to 'It is good to meet you, Al' . This single string value is then passed to print() , which prints it on the screen.\n\n#### The len() Function\n\nYou can pass the len() function a string value (or a variable containing a string), and the function evaluates to the integer value of the number of characters in that string.\n\n\u278e print('The length of your name is:') print(len(myName))\n\nEnter the following into the interactive shell to try this:\n\n>>> len('hello') 5 >>> len('My very energetic monster just scarfed nachos.') 46 >>> len('') 0\n\nJust like those examples, len(myName) evaluates to an integer. It is then passed to print() to be displayed on the screen. The print() function allows you to pass it either integer values or string values, but notice the error that shows up when you type the following into the interactive shell:\n\n>>> print('I am ' + 29 + ' years old.') Traceback (most recent call last): File \"<pyshell#6>\", line 1, in <module> print('I am ' + 29 + ' years old.') TypeError: can only concatenate str (not \"int\") to str\n\nThe print() function isn\u2019t causing that error, but rather it\u2019s the expression you tried to pass to print() . You get the same error message if you type the expression into the interactive shell on its own.\n\n>>> 'I am ' + 29 + ' years old.' Traceback (most recent call last): File \"<pyshell#7>\", line 1, in <module> 'I am ' + 29 + ' years old.' TypeError: can only concatenate str (not \"int\") to str\n\nPython gives an error because the + operator can only be used to add two integers together or concatenate two strings. You can\u2019t add an integer to a string, because this is ungrammatical in Python. You can fix this by using a string version of the integer instead, as explained in the next section.\n\n#### The str(), int(), and float() Functions\n\nIf you want to concatenate an integer such as 29 with a string to pass to print() , you\u2019ll need to get the value '29' , which is the string form of 29 . The str() function can be passed an integer value and will evaluate to a string value version of the integer, as follows:\n\n>>> str(29) '29' >>> print('I am ' + str(29) + ' years old.') I am 29 years old.\n\nBecause str(29) evaluates to '29' , the expression 'I am ' + str(29) + ' years old.' evaluates to 'I am ' + '29' + ' years old.' , which in turn evaluates to 'I am 29 years old.' . This is the value that is passed to the print() function.\n\nThe str() , int() , and float() functions will evaluate to the string, integer, and floating-point forms of the value you pass, respectively. Try converting some values in the interactive shell with these functions and watch what happens.\n\n>>> str(0) '0' >>> str(-3.14) '-3.14' >>> int('42') 42 >>> int('-99') -99 >>> int(1.25) 1 >>> int(1.99) 1 >>> float('3.14') 3.14 >>> float(10) 10.0\n\nThe previous examples call the str() , int() , and float() functions and pass them values of the other data types to obtain a string, integer, or floating-point form of those values.\n\nThe str() function is handy when you have an integer or float that you want to concatenate to a string. The int() function is also helpful if you have a number as a string value that you want to use in some mathematics. For example, the input() function always returns a string, even if the user enters a number. Enter spam = input() into the interactive shell and enter 101 when it waits for your text.\n\n>>> spam = input() 101 >>> spam '101'\n\nThe value stored inside spam isn\u2019t the integer 101 but the string '101' . If you want to do math using the value in spam , use the int() function to get the integer form of spam and then store this as the new value in spam .\n\n>>> spam = int(spam) >>> spam 101\n\nNow you should be able to treat the spam variable as an integer instead of a string.\n\n>>> spam * 10 / 5 202.0\n\nNote that if you pass a value to int() that it cannot evaluate as an integer, Python will display an error message.\n\n>>> int('99.99') Traceback (most recent call last): File \"<pyshell#18>\", line 1, in <module> int('99.99') ValueError: invalid literal for int() with base 10: '99.99' >>> int('twelve') Traceback (most recent call last): File \"<pyshell#19>\", line 1, in <module> int('twelve') ValueError: invalid literal for int() with base 10: 'twelve'\n\nThe int() function is also useful if you need to round a floating-point number down.\n\n>>> int(7.7) 7 >>> int(7.7) + 1 8\n\nYou used the int() and str() functions in the last three lines of your program to get a value of the appropriate data type for the code.\n\n\u278f print('What is your age?') # ask for their age myAge = input() print('You will be ' + str(int(myAge) + 1) + ' in a year.')\n\nTEXT AND NUMBER EQUIVALENCE\n\nAlthough the string value of a number is considered a completely different value from the integer or floating-point version, an integer can be equal to a floating point.\n\n>>> 42 == '42' False >>> 42 == 42.0 True >>> 42.0 == 0042.000 True\n\nPython makes this distinction because strings are text, while integers and floats are both numbers.\n\nThe myAge variable contains the value returned from input() . Because the input() function always returns a string (even if the user typed in a number), you can use the int(myAge) code to return an integer value of the string in myAge . This integer value is then added to 1 in the expression int(myAge) + 1 .\n\nThe result of this addition is passed to the str() function: str(int(myAge) + 1) . The string value returned is then concatenated with the strings 'You will be ' and ' in a year.' to evaluate to one large string value. This large string is finally passed to print() to be displayed on the screen.\n\nLet\u2019s say the user enters the string '4' for myAge . The string '4' is converted to an integer, so you can add one to it. The result is 5 . The str() function converts the result back to a string, so you can concatenate it with the second string, 'in a year.' , to create the final message. These evaluation steps would look something like the following:\n\n### Summary\n\nYou can compute expressions with a calculator or enter string concatenations with a word processor. You can even do string replication easily by copying and pasting text. But expressions, and their component values\u2014operators, variables, and function calls\u2014are the basic building blocks that make programs. Once you know how to handle these elements, you will be able to instruct Python to operate on large amounts of data for you.\n\nIt is good to remember the different types of operators ( + , - , * , / , // , % , and ** for math operations, and + and * for string operations) and the three data types (integers, floating-point numbers, and strings) introduced in this chapter.\n\nI introduced a few different functions as well. The print() and input() functions handle simple text output (to the screen) and input (from the keyboard). The len() function takes a string and evaluates to an int of the number of characters in the string. The str() , int() , and float() functions will evaluate to the string, integer, or floating-point number form of the value they are passed.\n\nIn the next chapter, you\u2019ll learn how to tell Python to make intelligent decisions about what code to run, what code to skip, and what code to repeat based on the values it has. This is known as flow control , and it allows you to write programs that make intelligent decisions.\n\n### Practice Questions\n\n1. Which of the following are operators, and which are values?\n\n* 'hello' -88.8 - / + 5\n\n2. Which of the following is a variable, and which is a string?\n\nspam 'spam'\n\n3. Name three data types.\n\n4. What is an expression made up of? What do all expressions do?\n\n5. This chapter introduced assignment statements, like spam = 10 . What is the difference between an expression and a statement?\n\n6. What does the variable bacon contain after the following code runs?\n\nbacon = 20 bacon + 1\n\n7. What should the following two expressions evaluate to?\n\n'spam' + 'spamspam' 'spam' * 3\n\n8. Why is eggs a valid variable name while 100 is invalid?\n\n9. What three functions can be used to get the integer, floating-point number, or string version of a value?\n\n10. Why does this expression cause an error? How can you fix it?\n\n'I have eaten ' + 99 + ' burritos.'\n\nExtra credit: Search online for the Python documentation for the len() function. It will be on a web page titled \u201cBuilt-in Functions.\u201d Skim the list of other functions Python has, look up what the round() function does, and experiment with it in the interactive shell.",
  "difficulty": "intro",
  "doc_id": "doc-1python-basics-c6c24cef47",
  "provenance": {
    "author": "",
    "date": "",
    "license": "CC BY-NC-SA 3.0",
    "source_file": "data/corpus_raw/2e_chapter1_6e73d7.json",
    "url": "https://automatetheboringstuff.com/2e/chapter1/"
  },
  "title": "1PYTHON BASICS",
  "type": "tutorial"
}