{
  "ai_generated": false,
  "concept_tags": [
    "cache",
    "decorators",
    "functions",
    "functools",
    "lru_cache",
    "memoization",
    "partial",
    "wraps"
  ],
  "content": "Hard-level function work often means building function wrappers (decorators), caching results, or creating specialized callables. The `functools` module supports these patterns.\n\n---\n## 1) functools.wraps: preserve metadata when wrapping\nWithout care, wrappers hide the original function\u2019s name/docstring.\n\n```python\ndef deco(func):\n    def wrapper(*args, **kwargs):\n        return func(*args, **kwargs)\n    return wrapper\n\n@deco\ndef f():\n    \"\"\"example doc\"\"\"\n    return 1\n\nprint(f.__name__)  # wrapper\nprint(f.__doc__)   # None\n```python\n\nUsing `functools.wraps` fixes that:\n\n```python\nimport functools\n\ndef deco(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        return func(*args, **kwargs)\n    return wrapper\n\n@deco\ndef f():\n    \"\"\"example doc\"\"\"\n    return 1\n\nprint(f.__name__)  # f\nprint(f.__doc__)   # example doc\n```python\n\n---\n## 2) lru_cache/cache: memoize function results\nCaching is useful when the function is pure-ish and called repeatedly with the same inputs.\n\n```python\nimport functools\n\n@functools.lru_cache(maxsize=128)\ndef fib(n):\n    if n < 2:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\nprint(fib(30))\nprint(fib.cache_info())\n```python\n\nUnbounded caching is available via `cache` (or `lru_cache(maxsize=None)`):\n\n```python\nimport functools\n\n@functools.cache\ndef f(n):\n    return n * n\n\nprint(f(10))\n```python\n\n---\n## 3) partial: create specialized callables\n`partial` pre-fills arguments.\n\n```python\nimport functools\n\ndef power(base, exp):\n    return base ** exp\n\nsquare = functools.partial(power, exp=2)\ncube = functools.partial(power, exp=3)\n\nprint(square(10))\nprint(cube(10))\n```python\n\n---\n## 4) A larger example: decorator + wraps + caching together\n\n```python\nimport functools\n\ndef log_calls(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        print(\"call\", func.__name__, args, kwargs)\n        return func(*args, **kwargs)\n    return wrapper\n\n@log_calls\n@functools.lru_cache(maxsize=64)\ndef compute(x, y):\n    return (x * x) + (y * y)\n\nprint(compute(3, 4))\nprint(compute(3, 4))  # cached\n```",
  "difficulty": "hard",
  "doc_id": "doc-higher-order-function-tools-hard-functools-wraps-lru-cache-cache-and-partial-7b6a338369",
  "provenance": {
    "author": "",
    "date": "",
    "license": "PSF Documentation License (Python docs)",
    "source_file": "data/corpus_raw/functions_hard_2.json",
    "url": "https://docs.python.org/3/library/functools.html"
  },
  "title": "Higher-order function tools (hard): functools.wraps, lru_cache/cache, and partial",
  "type": "reference"
}