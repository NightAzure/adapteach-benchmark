{
  "ai_generated": false,
  "concept_tags": [
    "algorithms",
    "recursion",
    "searching",
    "sorting"
  ],
  "content": "Buy this book at Amazon.com Chapter\u00a015\u00a0\u00a0Classes and objects At this point you know how to use\nfunctions to organize code and\nbuilt-in types to organize data. The next step is to learn\n\u201cobject-oriented programming\u201d, which uses programmer-defined types\nto organize both code and data. Object-oriented programming is\na big topic; it will take a few chapters to get there. Code examples from this chapter are available from https://thinkpython.com/code/Point1.py ; solutions\nto the exercises are available from https://thinkpython.com/code/Point1_soln.py . 15.1\u00a0\u00a0Programmer-defined types We have used many of Python\u2019s built-in types; now we are going\nto define a new type. As an example, we will create a type\ncalled Point that represents a point in two-dimensional\nspace. In mathematical notation, points are often written in\nparentheses with a comma separating the coordinates. For example,\n(0,0) represents the origin, and ( x , y ) represents the\npoint x units to the right and y units up from the origin. There are several ways we might represent points in Python: We could store the coordinates separately in two\nvariables, x and y . We could store the coordinates as elements in a list\nor tuple. We could create a new type to represent points as\nobjects. Creating a new type\nis more complicated than the other options, but\nit has advantages that will be apparent soon. A programmer-defined type is also called a class .\nA class definition looks like this: class Point:\n    \"\"\"Represents a point in 2-D space.\"\"\" The header indicates that the new class is called Point .\nThe body is a docstring that explains what the class is for.\nYou can define variables and methods inside a class definition,\nbut we will get back to that later. Defining a class named Point creates a class object . >>> Point\n<class '__main__.Point'> Because Point is defined at the top level, its \u201cfull\nname\u201d is __main__.Point . The class object is like a factory for creating objects. To create a\nPoint, you call Point as if it were a function. >>> blank = Point()\n>>> blank\n<__main__.Point object at 0xb7e9d3ac> The return value is a reference to a Point object, which we\nassign to blank . Creating a new object is called instantiation , and the object is an instance of\nthe class. When you print an instance, Python tells you what class it\nbelongs to and where it is stored in memory (the prefix 0x means that the following number is in hexadecimal). Every object is an instance of some class, so \u201cobject\u201d and\n\u201cinstance\u201d are interchangeable. But in this chapter I use\n\u201cinstance\u201d to indicate that I am talking about a programmer-defined\ntype. 15.2\u00a0\u00a0Attributes You can assign values to an instance using dot notation: >>> blank.x = 3.0\n>>> blank.y = 4.0 This syntax is similar to the syntax for selecting a variable from a\nmodule, such as math.pi or string.whitespace . In this case,\nthough, we are assigning values to named elements of an object.\nThese elements are called attributes . As a noun, \u201cAT-trib-ute\u201d is pronounced with emphasis on the first\nsyllable, as opposed to \u201ca-TRIB-ute\u201d, which is a verb. Figure 15.1 is a state diagram that shows the result of these assignments.\nA state diagram that shows an object and its attributes is\ncalled an object diagram . Figure 15.1: Object diagram. The variable blank refers to a Point object, which\ncontains two attributes. Each attribute refers to a\nfloating-point number. You can read the value of an attribute using the same syntax: >>> blank.y\n4.0\n>>> x = blank.x\n>>> x\n3.0 The expression blank.x means, \u201cGo to the object blank refers to and get the value of x .\u201d In the example, we assign that\nvalue to a variable named x . There is no conflict between\nthe variable x and the attribute x . You can use dot notation as part of any expression. For example: >>> '(%g, %g)' % (blank.x, blank.y)\n'(3.0, 4.0)'\n>>> distance = math.sqrt(blank.x**2 + blank.y**2)\n>>> distance\n5.0 You can pass an instance as an argument in the usual way.\nFor example: def print_point(p):\n    print('(%g, %g)' % (p.x, p.y)) print_point takes a point as an argument and displays it in\nmathematical notation. To invoke it, you can pass blank as\nan argument: >>> print_point(blank)\n(3.0, 4.0) Inside the function, p is an alias for blank , so if\nthe function modifies p , blank changes. As an exercise, write a function called distance_between_points that takes two Points as arguments and returns the distance between\nthem. 15.3\u00a0\u00a0Rectangles Sometimes it is obvious what the attributes of an object should be,\nbut other times you have to make decisions. For example, imagine you\nare designing a class to represent rectangles. What attributes would\nyou use to specify the location and size of a rectangle? You can\nignore angle; to keep things simple, assume that the rectangle is\neither vertical or horizontal. There are at least two possibilities: You could specify one corner of the rectangle\n(or the center), the width, and the height. You could specify two opposing corners. At this point it is hard to say whether either is better than\nthe other, so we\u2019ll implement the first one, just as an example. Here is the class definition: class Rectangle:\n    \"\"\"Represents a rectangle.\n\n    attributes: width, height, corner.\n    \"\"\" The docstring lists the attributes: width and height are numbers; corner is a Point object that\nspecifies the lower-left corner. To represent a rectangle, you have to instantiate a Rectangle\nobject and assign values to the attributes: box = Rectangle()\nbox.width = 100.0\nbox.height = 200.0\nbox.corner = Point()\nbox.corner.x = 0.0\nbox.corner.y = 0.0 The expression box.corner.x means,\n\u201cGo to the object box refers to and select the attribute named corner ; then go to that object and select the attribute named x .\u201d Figure 15.2: Object diagram. Figure 15.2 shows the state of this object.\nAn object that is an attribute of another object is embedded . 15.4\u00a0\u00a0Instances as return values Functions can return instances. For example, find_center takes a Rectangle as an argument and returns a Point that contains the coordinates of the center of the Rectangle : def find_center(rect):\n    p = Point()\n    p.x = rect.corner.x + rect.width/2\n    p.y = rect.corner.y + rect.height/2\n    return p Here is an example that passes box as an argument and assigns\nthe resulting Point to center : >>> center = find_center(box)\n>>> print_point(center)\n(50, 100) 15.5\u00a0\u00a0Objects are mutable You can change the state of an object by making an assignment to one of\nits attributes. For example, to change the size of a rectangle\nwithout changing its position, you can modify the values of width and height : box.width = box.width + 50\nbox.height = box.height + 100 You can also write functions that modify objects. For example, grow_rectangle takes a Rectangle object and two numbers, dwidth and dheight , and adds the numbers to the\nwidth and height of the rectangle: def grow_rectangle(rect, dwidth, dheight):\n    rect.width += dwidth\n    rect.height += dheight Here is an example that demonstrates the effect: >>> box.width, box.height\n(150.0, 300.0)\n>>> grow_rectangle(box, 50, 100)\n>>> box.width, box.height\n(200.0, 400.0) Inside the function, rect is an\nalias for box , so when the function modifies rect , box changes. As an exercise, write a function named move_rectangle that takes\na Rectangle and two numbers named dx and dy . It\nshould change the location of the rectangle by adding dx to the x coordinate of corner and adding dy to the y coordinate of corner . 15.6\u00a0\u00a0Copying Aliasing can make a program difficult to read because changes\nin one place might have unexpected effects in another place.\nIt is hard to keep track of all the variables that might refer\nto a given object. Copying an object is often an alternative to aliasing.\nThe copy module contains a function called copy that\ncan duplicate any object: >>> p1 = Point()\n>>> p1.x = 3.0\n>>> p1.y = 4.0\n\n>>> import copy\n>>> p2 = copy.copy(p1) p1 and p2 contain the same data, but they are\nnot the same Point. >>> print_point(p1)\n(3, 4)\n>>> print_point(p2)\n(3, 4)\n>>> p1 is p2\nFalse\n>>> p1 == p2\nFalse The is operator indicates that p1 and p2 are not the\nsame object, which is what we expected. But you might have expected == to yield True because these points contain the same\ndata. In that case, you will be disappointed to learn that for\ninstances, the default behavior of the == operator is the same\nas the is operator; it checks object identity, not object\nequivalence. That\u2019s because for programmer-defined types, Python doesn\u2019t\nknow what should be considered equivalent. At least, not yet. If you use copy.copy to duplicate a Rectangle, you will find\nthat it copies the Rectangle object but not the embedded Point. >>> box2 = copy.copy(box)\n>>> box2 is box\nFalse\n>>> box2.corner is box.corner\nTrue Figure 15.3: Object diagram. Figure 15.3 shows what the object diagram looks like. This operation is called a shallow copy because it copies the\nobject and any references it contains, but not the embedded objects. For most applications, this is not what you want. In this example,\ninvoking grow_rectangle on one of the Rectangles would not\naffect the other, but invoking move_rectangle on either would\naffect both! This behavior is confusing and error-prone. Fortunately, the copy module provides a method named deepcopy that copies not only the object but also\nthe objects it refers to, and the objects they refer to,\nand so on.\nYou will not be surprised to learn that this operation is\ncalled a deep copy . >>> box3 = copy.deepcopy(box)\n>>> box3 is box\nFalse\n>>> box3.corner is box.corner\nFalse box3 and box are completely separate objects. As an exercise, write a version of move_rectangle that creates and\nreturns a new Rectangle instead of modifying the old one. 15.7\u00a0\u00a0Debugging When you start working with objects, you are likely to encounter\nsome new exceptions. If you try to access an attribute\nthat doesn\u2019t exist, you get an AttributeError : >>> p = Point()\n>>> p.x = 3\n>>> p.y = 4\n>>> p.z\nAttributeError: Point instance has no attribute 'z' If you are not sure what type an object is, you can ask: >>> type(p)\n<class '__main__.Point'> You can also use isinstance to check whether an object\nis an instance of a class: >>> isinstance(p, Point)\nTrue If you are not sure whether an object has a particular attribute,\nyou can use the built-in function hasattr : >>> hasattr(p, 'x')\nTrue\n>>> hasattr(p, 'z')\nFalse The first argument can be any object; the second argument is a string that contains the name of the attribute. You can also use a try statement to see if the object has the\nattributes you need: try:\n    x = p.x\nexcept AttributeError:\n    x = 0 This approach can make it easier to write functions that work with\ndifferent types; more on that topic is\ncoming up in Section 17.9 . 15.8\u00a0\u00a0Glossary class: A programmer-defined type. A class definition creates a new\nclass object. class object: An object that contains information about a\nprogrammer-defined type. The class object can be used to create instances\nof the type. instance: An object that belongs to a class. instantiate: To create a new object. attribute: One of the named values associated with an object. embedded object: An object that is stored as an attribute\nof another object. shallow copy: To copy the contents of an object, including\nany references to embedded objects;\nimplemented by the copy function in the copy module. deep copy: To copy the contents of an object as well as any\nembedded objects, and any objects embedded in them, and so on;\nimplemented by the deepcopy function in the copy module. object diagram: A diagram that shows objects, their\nattributes, and the values of the attributes. 15.9\u00a0\u00a0Exercises Exercise\u00a01 Write a definition for a class named Circle with attributes center and radius , where center is a Point object\nand radius is a number. Instantiate a Circle object that represents a circle with its center\nat (150, 100) and radius 75. Write a function named point_in_circle that takes a Circle and\na Point and returns True if the Point lies in or on the boundary of\nthe circle. Write a function named rect_in_circle that takes a Circle and a\nRectangle and returns True if the Rectangle lies entirely in or on the boundary\nof the circle. Write a function named rect_circle_overlap that takes a Circle\nand a Rectangle and returns True if any of the corners of the Rectangle fall\ninside the Circle. Or as a more challenging version, return True if\nany part of the Rectangle falls inside the Circle. Solution: https://thinkpython.com/code/Circle.py . Exercise\u00a02 Write a function called draw_rect that takes a Turtle object\nand a Rectangle and uses the Turtle to draw the Rectangle. See\nChapter 4 for examples using Turtle objects. Write a function called draw_circle that takes a Turtle and\na Circle and draws the Circle. Solution: https://thinkpython.com/code/draw.py . Buy this book at Amazon.com\n\n#### Contribute\n\nIf you would like to make a contribution to support my books,\nyou can use the button below and pay with PayPal.  Thank you!\nPay what you want:\nSmall $1.00 USD\nMedium $5.00 USD\nLarge $10.00 USD\nX-Large $20.00 USD\nXX-Large $50.00 USD\nAre you using one of our books in a class? We'd like to know\nabout it.  Please consider filling out this short survey . Think DSP Think Java Think Bayes Think Python 2e Think Stats 2e Think Complexity",
  "difficulty": "intermediate",
  "doc_id": "doc-chapter-15-classes-and-objects-9467cf0dec",
  "provenance": {
    "author": "",
    "date": "",
    "license": "CC BY-NC 3.0",
    "source_file": "data/corpus_raw/thinkpython2_html_thinkpython2016_html_bb1d60.json",
    "url": "https://greenteapress.com/thinkpython2/html/thinkpython2016.html"
  },
  "title": "Chapter\u00a015\u00a0\u00a0Classes and objects",
  "type": "tutorial"
}