{
  "ai_generated": true,
  "concept_tags": [
    "break",
    "continue",
    "counting",
    "for",
    "loop-else",
    "loops",
    "parsing",
    "unpacking"
  ],
  "content": "Looping over lines is a common real-world use of `for`. This example stays moderate: it mixes parsing, counters, and early exit, but remains readable.\n\n---\n## 1) Basic line iteration (list of lines)\n\n```python\nlines = [\n    \"INFO start\\n\",\n    \"WARN low disk\\n\",\n    \"INFO running\\n\",\n    \"ERROR crashed\\n\",\n]\n\nfor line in lines:\n    print(line.strip())\n```python\n\n---\n## 2) Counting types of lines\n\n```python\ncounts = {\"INFO\": 0, \"WARN\": 0, \"ERROR\": 0}\n\nfor line in lines:\n    text = line.strip()\n    level, *rest = text.split(\" \")\n    if level in counts:\n        counts[level] += 1\n\nprint(counts)\n```python\n\n---\n## 3) Stop when a condition is met (early exit)\n\n```python\nfor line in lines:\n    if line.startswith(\"ERROR\"):\n        print(\"first error:\", line.strip())\n        break\nelse:\n    print(\"no errors\")\n```python\n\n---\n## 4) Practice-style block: extract messages after WARN\n\n```python\nwarn_msgs = []\nfor line in lines:\n    if not line.startswith(\"WARN\"):\n        continue\n    warn_msgs.append(line.strip())\n\nprint(warn_msgs)\n```",
  "difficulty": "moderate",
  "doc_id": "doc-looping-over-text-lines-clean-parsing-counters-and-early-exit-patterns-ce462c5d5f",
  "provenance": {
    "author": "",
    "date": "",
    "license": "",
    "source_file": "data/corpus_raw/loops_moderate_4.json",
    "url": ""
  },
  "title": "Looping over text lines: clean parsing, counters, and early-exit patterns",
  "type": "tutorial"
}