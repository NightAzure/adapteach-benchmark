{
  "ai_generated": false,
  "concept_tags": [
    "debugging",
    "error_handling",
    "exceptions"
  ],
  "content": "Buy this book at Amazon.com Chapter\u00a016\u00a0\u00a0Classes and functions Now that we know how to create new types, the next\nstep is to write functions that take programmer-defined objects\nas parameters and return them as results. In this chapter I\nalso present \u201cfunctional programming style\u201d and two new\nprogram development plans. Code examples from this chapter are available from https://thinkpython.com/code/Time1.py .\nSolutions to the exercises are at https://thinkpython.com/code/Time1_soln.py . 16.1\u00a0\u00a0Time As another example of a programmer-defined type, we\u2019ll define a class\ncalled Time that records the time of day. The class definition\nlooks like this: class Time:\n    \"\"\"Represents the time of day.\n\n    attributes: hour, minute, second\n    \"\"\" We can create a new Time object and assign\nattributes for hours, minutes, and seconds: time = Time()\ntime.hour = 11\ntime.minute = 59\ntime.second = 30 The state diagram for the Time object looks like Figure 16.1 . As an exercise, write a function called print_time that takes a\nTime object and prints it in the form hour:minute:second .\nHint: the format sequence '%.2d' prints an integer using\nat least two digits, including a leading zero if necessary. Write a boolean function called is_after that\ntakes two Time objects, t1 and t2 , and\nreturns True if t1 follows t2 chronologically and False otherwise. Challenge: don\u2019t use an if statement. Figure 16.1: Object diagram. 16.2\u00a0\u00a0Pure functions In the next few sections, we\u2019ll write two functions that add time\nvalues. They demonstrate two kinds of functions: pure functions and\nmodifiers. They also demonstrate a development plan I\u2019ll call prototype and patch , which is a way of tackling a complex problem\nby starting with a simple prototype and incrementally dealing with the\ncomplications. Here is a simple prototype of add_time : def add_time(t1, t2):\n    sum = Time()\n    sum.hour = t1.hour + t2.hour\n    sum.minute = t1.minute + t2.minute\n    sum.second = t1.second + t2.second\n    return sum The function creates a new Time object, initializes its\nattributes, and returns a reference to the new object. This is called\na pure function because it does not modify any of the objects\npassed to it as arguments and it has no effect,\nlike displaying a value or getting user input,\nother than returning a value. To test this function, I\u2019ll create two Time objects: start contains the start time of a movie, like Monty Python and the\nHoly Grail , and duration contains the run time of the movie,\nwhich is one hour 35 minutes. add_time figures out when the movie will be done. >>> start = Time()\n>>> start.hour = 9\n>>> start.minute = 45\n>>> start.second =  0\n\n>>> duration = Time()\n>>> duration.hour = 1\n>>> duration.minute = 35\n>>> duration.second = 0\n\n>>> done = add_time(start, duration)\n>>> print_time(done)\n10:80:00 The result, 10:80:00 might not be what you were hoping\nfor. The problem is that this function does not deal with cases where the\nnumber of seconds or minutes adds up to more than sixty. When that\nhappens, we have to \u201ccarry\u201d the extra seconds into the minute column\nor the extra minutes into the hour column. Here\u2019s an improved version: def add_time(t1, t2):\n    sum = Time()\n    sum.hour = t1.hour + t2.hour\n    sum.minute = t1.minute + t2.minute\n    sum.second = t1.second + t2.second\n\n    if sum.second >= 60:\n        sum.second -= 60\n        sum.minute += 1\n\n    if sum.minute >= 60:\n        sum.minute -= 60\n        sum.hour += 1\n\n    return sum Although this function is correct, it is starting to get big.\nWe will see a shorter alternative later. 16.3\u00a0\u00a0Modifiers Sometimes it is useful for a function to modify the objects it gets as\nparameters. In that case, the changes are visible to the caller.\nFunctions that work this way are called modifiers . increment , which adds a given number of seconds to a Time object, can be written naturally as a\nmodifier. Here is a rough draft: def increment(time, seconds):\n    time.second += seconds\n\n    if time.second >= 60:\n        time.second -= 60\n        time.minute += 1\n\n    if time.minute >= 60:\n        time.minute -= 60\n        time.hour += 1 The first line performs the basic operation; the remainder deals\nwith the special cases we saw before. Is this function correct? What happens if seconds is much greater than sixty? In that case, it is not enough to carry once; we have to keep doing it\nuntil time.second is less than sixty. One solution is to\nreplace the if statements with while statements. That\nwould make the function correct, but not very efficient. As an\nexercise, write a correct version of increment that doesn\u2019t\ncontain any loops. Anything that can be done with modifiers can also be done with pure\nfunctions. In fact, some programming languages only allow pure\nfunctions. There is some evidence that programs that use pure\nfunctions are faster to develop and less error-prone than programs\nthat use modifiers. But modifiers are convenient at times,\nand functional programs tend to be less efficient. In general, I recommend that you write pure functions whenever it is\nreasonable and resort to modifiers only if there is a compelling\nadvantage. This approach might be called a functional\nprogramming style . As an exercise, write a \u201cpure\u201d version of increment that\ncreates and returns a new Time object rather than modifying the\nparameter. 16.4\u00a0\u00a0Prototyping versus planning The development plan I am demonstrating is called \u201cprototype and\npatch\u201d. For each function, I wrote a prototype that performed the\nbasic calculation and then tested it, patching errors along the\nway. This approach can be effective, especially if you don\u2019t yet have a\ndeep understanding of the problem. But incremental corrections can\ngenerate code that is unnecessarily complicated\u2014since it deals with\nmany special cases\u2014and unreliable\u2014since it is hard to know if you\nhave found all the errors. An alternative is designed development , in which high-level\ninsight into the problem can make the programming much easier. In\nthis case, the insight is that a Time object is really a three-digit\nnumber in base 60 (see http://en.wikipedia.org/wiki/Sexagesimal ). The second attribute is the \u201cones column\u201d, the minute attribute is the \u201csixties column\u201d, and the hour attribute is\nthe \u201cthirty-six hundreds column\u201d. When we wrote add_time and increment , we were effectively\ndoing addition in base 60, which is why we had to carry from one\ncolumn to the next. This observation suggests another approach to the whole problem\u2014we\ncan convert Time objects to integers and take advantage of the fact\nthat the computer knows how to do integer arithmetic. Here is a function that converts Times to integers: def time_to_int(time):\n    minutes = time.hour * 60 + time.minute\n    seconds = minutes * 60 + time.second\n    return seconds And here is a function that converts an integer to a Time\n(recall that divmod divides the first argument by the second\nand returns the quotient and remainder as a tuple). def int_to_time(seconds):\n    time = Time()\n    minutes, time.second = divmod(seconds, 60)\n    time.hour, time.minute = divmod(minutes, 60)\n    return time You might have to think a bit, and run some tests, to convince\nyourself that these functions are correct. One way to test them is to\ncheck that time_to_int(int_to_time(x)) == x for many values of x . This is an example of a consistency check. Once you are convinced they are correct, you can use them to\nrewrite add_time : def add_time(t1, t2):\n    seconds = time_to_int(t1) + time_to_int(t2)\n    return int_to_time(seconds) This version is shorter than the original, and easier to verify. As\nan exercise, rewrite increment using time_to_int and int_to_time . In some ways, converting from base 60 to base 10 and back is harder\nthan just dealing with times. Base conversion is more abstract; our\nintuition for dealing with time values is better. But if we have the insight to treat times as base 60 numbers and make\nthe investment of writing the conversion functions ( time_to_int and int_to_time ), we get a program that is shorter, easier to\nread and debug, and more reliable. It is also easier to add features later. For example, imagine\nsubtracting two Times to find the duration between them. The\nnaive approach would be to implement subtraction with borrowing.\nUsing the conversion functions would be easier and more likely to be\ncorrect. Ironically, sometimes making a problem harder (or more general) makes it\neasier (because there are fewer special cases and fewer opportunities\nfor error). 16.5\u00a0\u00a0Debugging A Time object is well-formed if the values of minute and second are between 0 and 60 (including 0 but not 60) and if hour is positive. hour and minute should be\ninteger values, but we might allow second to have a\nfraction part. Requirements like these are called invariants because\nthey should always be true. To put it a different way, if they\nare not true, something has gone wrong. Writing code to check invariants can help detect errors\nand find their causes. For example, you might have a function\nlike valid_time that takes a Time object and returns False if it violates an invariant: def valid_time(time):\n    if time.hour < 0 or time.minute < 0 or time.second < 0:\n        return False\n    if time.minute >= 60 or time.second >= 60:\n        return False\n    return True At the beginning of each function you could check the\narguments to make sure they are valid: def add_time(t1, t2):\n    if not valid_time(t1) or not valid_time(t2):\n        raise ValueError('invalid Time object in add_time')\n    seconds = time_to_int(t1) + time_to_int(t2)\n    return int_to_time(seconds) Or you could use an assert statement , which checks a given invariant\nand raises an exception if it fails: def add_time(t1, t2):\n    assert valid_time(t1) and valid_time(t2)\n    seconds = time_to_int(t1) + time_to_int(t2)\n    return int_to_time(seconds) assert statements are useful because they distinguish\ncode that deals with normal conditions from code\nthat checks for errors. 16.6\u00a0\u00a0Glossary prototype and patch: A development plan that involves\nwriting a rough draft of a program, testing, and correcting errors as\nthey are found. designed development: A development plan that involves\nhigh-level insight into the problem and more planning than incremental\ndevelopment or prototype development. pure function: A function that does not modify any of the objects it\nreceives as arguments. Most pure functions are fruitful. modifier: A function that changes one or more of the objects it\nreceives as arguments. Most modifiers are void; that is, they\nreturn None . functional programming style: A style of program design in which the\nmajority of functions are pure. invariant: A condition that should always be true during the\nexecution of a program. assert statement: A statement that checks a condition and raises\nan exception if it fails. 16.7\u00a0\u00a0Exercises Code examples from this chapter are available from https://thinkpython.com/code/Time1.py ; solutions to the\nexercises are available from https://thinkpython.com/code/Time1_soln.py . Exercise\u00a01 Write a function called mul_time that takes a Time object\nand a number and returns a new Time object that contains\nthe product of the original Time and the number. Then use mul_time to write a function that takes a Time\nobject that represents the finishing time in a race, and a number\nthat represents the distance, and returns a Time object that represents\nthe average pace (time per mile). Exercise\u00a02 The datetime module provides time objects\nthat are similar to the Time objects in this chapter, but\nthey provide a rich set of methods and operators. Read the\ndocumentation at http://docs.python.org/3/library/datetime.html . Use the datetime module to write a program that gets the\ncurrent date and prints the day of the week. Write a program that takes a birthday as input and prints the\nuser\u2019s age and the number of days, hours, minutes and seconds until\ntheir next birthday. For two people born on different days, there is a day when one\nis twice as old as the other. That\u2019s their Double Day. Write a\nprogram that takes two birth dates and computes their Double Day. For a little more challenge, write the more general version that\ncomputes the day when one person is n times older than the other. Solution: https://thinkpython.com/code/double.py Buy this book at Amazon.com\n\n#### Contribute\n\nIf you would like to make a contribution to support my books,\nyou can use the button below and pay with PayPal.  Thank you!\nPay what you want:\nSmall $1.00 USD\nMedium $5.00 USD\nLarge $10.00 USD\nX-Large $20.00 USD\nXX-Large $50.00 USD\nAre you using one of our books in a class? We'd like to know\nabout it.  Please consider filling out this short survey . Think DSP Think Java Think Bayes Think Python 2e Think Stats 2e Think Complexity",
  "difficulty": "intro",
  "doc_id": "doc-chapter-16-classes-and-functions-130c309393",
  "provenance": {
    "author": "",
    "date": "",
    "license": "CC BY-NC 3.0",
    "source_file": "data/corpus_raw/thinkpython2_html_thinkpython2017_html_8b1699.json",
    "url": "https://greenteapress.com/thinkpython2/html/thinkpython2017.html"
  },
  "title": "Chapter\u00a016\u00a0\u00a0Classes and functions",
  "type": "tutorial"
}