{
  "ai_generated": false,
  "concept_tags": [
    "OOP",
    "data_types",
    "functions",
    "scope",
    "variables"
  ],
  "content": "# Glossary\u00c2\u00b6\n\n`>>>`\n\u00c2\u00b6\nThe default Python prompt of the interactive shell.  Often\nseen for code examples which can be executed interactively in the\ninterpreter.\n\n`...`\n\u00c2\u00b6\nCan refer to:\n\n- The default Python prompt of the interactive shell when entering the\ncode for an indented code block, when within a pair of matching left and\nright delimiters (parentheses, square brackets, curly braces or triple\nquotes), or after specifying a decorator.\n\n- The three dots form of the Ellipsis object.\n\nabstract base class\n\u00c2\u00b6\nAbstract base classes complement duck-typing by\nproviding a way to define interfaces when other techniques like hasattr() would be clumsy or subtly wrong (for example with magic methods ).  ABCs introduce virtual\nsubclasses, which are classes that don\u00e2\u0080\u0099t inherit from a class but are\nstill recognized by isinstance() and issubclass() ; see the abc module documentation.  Python comes with many built-in ABCs for\ndata structures (in the collections.abc module), numbers (in the numbers module), streams (in the io module), import finders\nand loaders (in the importlib.abc module).  You can create your own\nABCs with the abc module.\n\nannotate function\n\u00c2\u00b6\nA function that can be called to retrieve the annotations of an object. This function is accessible as the __annotate__ attribute of functions, classes, and modules. Annotate functions are a\nsubset of evaluate functions .\n\nannotation\n\u00c2\u00b6\nA label associated with a variable, a class\nattribute or a function parameter or return value,\nused by convention as a type hint .\n\nAnnotations of local variables cannot be accessed at runtime, but\nannotations of global variables, class attributes, and functions\ncan be retrieved by calling annotationlib.get_annotations() on modules, classes, and functions, respectively.\n\nSee variable annotation , function annotation , PEP 484 , PEP 526 , and PEP 649 , which describe this functionality.\nAlso see Annotations Best Practices for best practices on working with annotations.\n\nargument\n\u00c2\u00b6\nA value passed to a function (or method ) when calling the\nfunction.  There are two kinds of argument:\n\n- keyword argument : an argument preceded by an identifier (e.g. name= ) in a function call or passed as a value in a dictionary\npreceded by ** .  For example, 3 and 5 are both keyword\narguments in the following calls to complex() : complex ( real = 3 , imag = 5 ) complex ( ** { 'real' : 3 , 'imag' : 5 })\n- positional argument : an argument that is not a keyword argument.\nPositional arguments can appear at the beginning of an argument list\nand/or be passed as elements of an iterable preceded by * .\nFor example, 3 and 5 are both positional arguments in the\nfollowing calls: complex ( 3 , 5 ) complex ( * ( 3 , 5 ))\n\nArguments are assigned to the named local variables in a function body.\nSee the Calls section for the rules governing this assignment.\nSyntactically, any expression can be used to represent an argument; the\nevaluated value is assigned to the local variable.\n\nSee also the parameter glossary entry, the FAQ question on the difference between arguments and parameters , and PEP 362 .\n\nasynchronous context manager\n\u00c2\u00b6\nAn object which controls the environment seen in an async with statement by defining __aenter__() and __aexit__() methods.  Introduced by PEP 492 .\n\nasynchronous generator\n\u00c2\u00b6\nA function which returns an asynchronous generator iterator .  It\nlooks like a coroutine function defined with async def except\nthat it contains yield expressions for producing a series of\nvalues usable in an async for loop.\n\nUsually refers to an asynchronous generator function, but may refer to an asynchronous generator iterator in some contexts.  In cases where the\nintended meaning isn\u00e2\u0080\u0099t clear, using the full terms avoids ambiguity.\n\nAn asynchronous generator function may contain await expressions as well as async for , and async with statements.\n\nasynchronous generator iterator\n\u00c2\u00b6\nAn object created by an asynchronous generator function.\n\nThis is an asynchronous iterator which when called using the __anext__() method returns an awaitable object which will execute\nthe body of the asynchronous generator function until the next yield expression.\n\nEach yield temporarily suspends processing, remembering the\nexecution state (including local variables and pending\ntry-statements).  When the asynchronous generator iterator effectively\nresumes with another awaitable returned by __anext__() , it\npicks up where it left off.  See PEP 492 and PEP 525 .\n\nasynchronous iterable\n\u00c2\u00b6\nAn object, that can be used in an async for statement.\nMust return an asynchronous iterator from its __aiter__() method.  Introduced by PEP 492 .\n\nasynchronous iterator\n\u00c2\u00b6\nAn object that implements the __aiter__() and __anext__() methods. __anext__() must return an awaitable object. async for resolves the awaitables returned by an asynchronous\niterator\u00e2\u0080\u0099s __anext__() method until it raises a StopAsyncIteration exception.  Introduced by PEP 492 .\n\natomic operation\n\u00c2\u00b6\nAn operation that appears to execute as a single, indivisible step: no\nother thread can observe it half-done, and its effects become visible all\nat once.  Python does not guarantee that high-level statements are atomic\n(for example, x += 1 performs multiple bytecode operations and is not\natomic).  Atomicity is only guaranteed where explicitly documented.  See\nalso race condition and data race .\n\nattached thread state\n\u00c2\u00b6\nA thread state that is active for the current OS thread.\n\nWhen a thread state is attached, the OS thread has\naccess to the full Python C API and can safely invoke the\nbytecode interpreter.\n\nUnless a function explicitly notes otherwise, attempting to call\nthe C API without an attached thread state will result in a fatal\nerror or undefined behavior.  A thread state can be attached and detached\nexplicitly by the user through the C API, or implicitly by the runtime,\nincluding during blocking C calls and by the bytecode interpreter in between\ncalls.\n\nOn most builds of Python, having an attached thread state implies that the\ncaller holds the GIL for the current interpreter, so only\none OS thread can have an attached thread state at a given moment. In free-threaded builds of Python, threads can\nconcurrently hold an attached thread state, allowing for true parallelism of\nthe bytecode interpreter.\n\nattribute\n\u00c2\u00b6\nA value associated with an object which is usually referenced by name\nusing dotted expressions.\nFor example, if an object o has an attribute a it would be referenced as o.a .\n\nIt is possible to give an object an attribute whose name is not an\nidentifier as defined by Names (identifiers and keywords) , for example using setattr() , if the object allows it.\nSuch an attribute will not be accessible using a dotted expression,\nand would instead need to be retrieved with getattr() .\n\nawaitable\n\u00c2\u00b6\nAn object that can be used in an await expression.  Can be\na coroutine or an object with an __await__() method.\nSee also PEP 492 .\n\nBDFL\n\u00c2\u00b6\nBenevolent Dictator For Life, a.k.a. Guido van Rossum , Python\u00e2\u0080\u0099s creator.\n\nbinary file\n\u00c2\u00b6\nA file object able to read and write bytes-like objects .\nExamples of binary files are files opened in binary mode ( 'rb' , 'wb' or 'rb+' ), sys.stdin.buffer , sys.stdout.buffer , and instances of io.BytesIO and gzip.GzipFile .\n\nSee also text file for a file object able to read and write str objects.\n\nborrowed reference\n\u00c2\u00b6\nIn Python\u00e2\u0080\u0099s C API, a borrowed reference is a reference to an object,\nwhere the code using the object does not own the reference.\nIt becomes a dangling\npointer if the object is destroyed. For example, a garbage collection can\nremove the last strong reference to the object and so destroy it.\n\nCalling Py_INCREF() on the borrowed reference is\nrecommended to convert it to a strong reference in-place, except\nwhen the object cannot be destroyed before the last usage of the borrowed\nreference. The Py_NewRef() function can be used to create a new strong reference .\n\nbytes-like object\n\u00c2\u00b6\nAn object that supports the Buffer Protocol and can\nexport a C- contiguous buffer. This includes all bytes , bytearray , and array.array objects, as well as many\ncommon memoryview objects.  Bytes-like objects can\nbe used for various operations that work with binary data; these include\ncompression, saving to a binary file, and sending over a socket.\n\nSome operations need the binary data to be mutable.  The documentation\noften refers to these as \u00e2\u0080\u009cread-write bytes-like objects\u00e2\u0080\u009d.  Example\nmutable buffer objects include bytearray and a memoryview of a bytearray .\nOther operations require the binary data to be stored in\nimmutable objects (\u00e2\u0080\u009cread-only bytes-like objects\u00e2\u0080\u009d); examples\nof these include bytes and a memoryview of a bytes object.\n\nbytecode\n\u00c2\u00b6\nPython source code is compiled into bytecode, the internal representation\nof a Python program in the CPython interpreter.  The bytecode is also\ncached in .pyc files so that executing the same file is\nfaster the second time (recompilation from source to bytecode can be\navoided).  This \u00e2\u0080\u009cintermediate language\u00e2\u0080\u009d is said to run on a virtual machine that executes the machine code corresponding to\neach bytecode. Do note that bytecodes are not expected to work between\ndifferent Python virtual machines, nor to be stable between Python\nreleases.\n\nA list of bytecode instructions can be found in the documentation for the dis module .\n\ncallable\n\u00c2\u00b6\nA callable is an object that can be called, possibly with a set\nof arguments (see argument ), with the following syntax:\n\n```python\ncallable(argument1, argument2, argumentN)\n```python\n\nA function , and by extension a method , is a callable.\nAn instance of a class that implements the __call__() method is also a callable.\n\ncallback\n\u00c2\u00b6\nA subroutine function which is passed as an argument to be executed at\nsome point in the future.\n\nclass\n\u00c2\u00b6\nA template for creating user-defined objects. Class definitions\nnormally contain method definitions which operate on instances of the\nclass.\n\nclass variable\n\u00c2\u00b6\nA variable defined in a class and intended to be modified only at\nclass level (i.e., not in an instance of the class).\n\nclosure variable\n\u00c2\u00b6\nA free variable referenced from a nested scope that is defined in an outer\nscope rather than being resolved at runtime from the globals or builtin namespaces.\nMay be explicitly defined with the nonlocal keyword to allow write access,\nor implicitly defined if the variable is only being read.\n\nFor example, in the inner function in the following code, both x and print are free variables , but only x is a closure variable :\n\n```python\ndef outer():\n    x = 0\n    def inner():\n        nonlocal x\n        x += 1\n        print(x)\n    return inner\n```python\n\nDue to the codeobject.co_freevars attribute (which, despite its name, only\nincludes the names of closure variables rather than listing all referenced free\nvariables), the more general free variable term is sometimes used even\nwhen the intended meaning is to refer specifically to closure variables.\n\ncomplex number\n\u00c2\u00b6\nAn extension of the familiar real number system in which all numbers are\nexpressed as a sum of a real part and an imaginary part.  Imaginary\nnumbers are real multiples of the imaginary unit (the square root of -1 ), often written i in mathematics or j in\nengineering.  Python has built-in support for complex numbers, which are\nwritten with this latter notation; the imaginary part is written with a j suffix, e.g., 3+1j .  To get access to complex equivalents of the math module, use cmath .  Use of complex numbers is a fairly\nadvanced mathematical feature.  If you\u00e2\u0080\u0099re not aware of a need for them,\nit\u00e2\u0080\u0099s almost certain you can safely ignore them.\n\nconcurrency\n\u00c2\u00b6\nThe ability of a computer program to perform multiple tasks at the same\ntime.  Python provides libraries for writing programs that make use of\ndifferent forms of concurrency. asyncio is a library for dealing\nwith asynchronous tasks and coroutines. threading provides\naccess to operating system threads and multiprocessing to\noperating system processes. Multi-core processors can execute threads and\nprocesses on different CPU cores at the same time (see parallelism ).\n\nconcurrent modification\n\u00c2\u00b6\nWhen multiple threads modify shared data at the same time.  Concurrent\nmodification without proper synchronization can cause race conditions , and might also trigger a data race , data corruption, or both.\n\ncontext\n\u00c2\u00b6\nThis term has different meanings depending on where and how it is used.\nSome common meanings:\n\n- The temporary state or environment established by a context\nmanager via a with statement.\n- The collection of key\u00c2\u00advalue bindings associated with a particular contextvars.Context object and accessed via ContextVar objects.  Also see context\nvariable .\n- A contextvars.Context object.  Also see current\ncontext .\n\ncontext management protocol\n\u00c2\u00b6\nThe __enter__() and __exit__() methods called\nby the with statement.  See PEP 343 .\n\ncontext manager\n\u00c2\u00b6\nAn object which implements the context management protocol and\ncontrols the environment seen in a with statement.  See PEP 343 .\n\ncontext variable\n\u00c2\u00b6\nA variable whose value depends on which context is the current\ncontext .  Values are accessed via contextvars.ContextVar objects.  Context variables are primarily used to isolate state between\nconcurrent asynchronous tasks.\n\ncontiguous\n\u00c2\u00b6\nA buffer is considered contiguous exactly if it is either C-contiguous or Fortran contiguous .  Zero-dimensional buffers are\nC and Fortran contiguous.  In one-dimensional arrays, the items\nmust be laid out in memory next to each other, in order of\nincreasing indexes starting from zero.  In multidimensional\nC-contiguous arrays, the last index varies the fastest when\nvisiting items in order of memory address.  However, in\nFortran contiguous arrays, the first index varies the fastest.\n\ncoroutine\n\u00c2\u00b6\nCoroutines are a more generalized form of subroutines. Subroutines are\nentered at one point and exited at another point.  Coroutines can be\nentered, exited, and resumed at many different points.  They can be\nimplemented with the async def statement.  See also PEP 492 .\n\ncoroutine function\n\u00c2\u00b6\nA function which returns a coroutine object.  A coroutine\nfunction may be defined with the async def statement,\nand may contain await , async for , and async with keywords.  These were introduced\nby PEP 492 .\n\nCPython\n\u00c2\u00b6\nThe canonical implementation of the Python programming language, as\ndistributed on python.org .  The term \u00e2\u0080\u009cCPython\u00e2\u0080\u009d\nis used when necessary to distinguish this implementation from others\nsuch as Jython or IronPython.\n\ncurrent context\n\u00c2\u00b6\nThe context ( contextvars.Context object) that is\ncurrently used by ContextVar objects to access (get\nor set) the values of context variables .  Each\nthread has its own current context.  Frameworks for executing asynchronous\ntasks (see asyncio ) associate each task with a context which\nbecomes the current context whenever the task starts or resumes execution.\n\ncyclic isolate\n\u00c2\u00b6\nA subgroup of one or more objects that reference each other in a reference\ncycle, but are not referenced by objects outside the group.  The goal of\nthe cyclic garbage collector is to identify these groups and break the reference\ncycles so that the memory can be reclaimed.\n\ndata race\n\u00c2\u00b6\nA situation where multiple threads access the same memory location\nconcurrently, at least one of the accesses is a write, and the threads\ndo not use any synchronization to control their access.  Data races\nlead to non-deterministic behavior and can cause data corruption.\nProper use of locks and other synchronization primitives prevents data races.  Note that data races\ncan only happen in native code, but that native code might be\nexposed in a Python API.  See also race condition and thread-safe .\n\ndeadlock\n\u00c2\u00b6\nA situation in which two or more tasks (threads, processes, or coroutines)\nwait indefinitely for each other to release resources or complete actions,\npreventing any from making progress.  For example, if thread A holds lock\n1 and waits for lock 2, while thread B holds lock 2 and waits for lock 1,\nboth threads will wait indefinitely.  In Python this often arises from\nacquiring multiple locks in conflicting orders or from circular\njoin/await dependencies.  Deadlocks can be avoided by always acquiring\nmultiple locks in a consistent order.  See also lock and reentrant .\n\ndecorator\n\u00c2\u00b6\nA function returning another function, usually applied as a function\ntransformation using the @wrapper syntax.  Common examples for\ndecorators are classmethod() and staticmethod() .\n\nThe decorator syntax is merely syntactic sugar, the following two\nfunction definitions are semantically equivalent:\n\n```python\ndef f(arg):\n    ...\nf = staticmethod(f)\n\n@staticmethod\ndef f(arg):\n    ...\n```python\n\nThe same concept exists for classes, but is less commonly used there.  See\nthe documentation for function definitions and class definitions for more about decorators.\n\ndescriptor\n\u00c2\u00b6\nAny object which defines the methods __get__() , __set__() , or __delete__() .\nWhen a class attribute is a descriptor, its special\nbinding behavior is triggered upon attribute lookup.  Normally, using a.b to get, set or delete an attribute looks up the object named b in\nthe class dictionary for a , but if b is a descriptor, the respective\ndescriptor method gets called.  Understanding descriptors is a key to a\ndeep understanding of Python because they are the basis for many features\nincluding functions, methods, properties, class methods, static methods,\nand reference to super classes.\n\nFor more information about descriptors\u00e2\u0080\u0099 methods, see Implementing Descriptors or the Descriptor How To Guide .\n\ndictionary\n\u00c2\u00b6\nAn associative array, where arbitrary keys are mapped to values.  The\nkeys can be any object with __hash__() and __eq__() methods.\nCalled a hash in Perl.\n\ndictionary comprehension\n\u00c2\u00b6\nA compact way to process all or part of the elements in an iterable and\nreturn a dictionary with the results. results = {n: n ** 2 for n in range(10)} generates a dictionary containing key n mapped to\nvalue n ** 2 . See Displays for lists, sets and dictionaries .\n\ndictionary view\n\u00c2\u00b6\nThe objects returned from dict.keys() , dict.values() , and dict.items() are called dictionary views. They provide a dynamic\nview on the dictionary\u00e2\u0080\u0099s entries, which means that when the dictionary\nchanges, the view reflects these changes. To force the\ndictionary view to become a full list use list(dictview) .  See Dictionary view objects .\n\ndocstring\n\u00c2\u00b6\nA string literal which appears as the first expression in a class,\nfunction or module.  While ignored when the suite is executed, it is\nrecognized by the compiler and put into the __doc__ attribute\nof the enclosing class, function or module.  Since it is available via\nintrospection, it is the canonical place for documentation of the\nobject.\n\nduck-typing\n\u00c2\u00b6\nA programming style which does not look at an object\u00e2\u0080\u0099s type to determine\nif it has the right interface; instead, the method or attribute is simply\ncalled or used (\u00e2\u0080\u009cIf it looks like a duck and quacks like a duck, it\nmust be a duck.\u00e2\u0080\u009d)  By emphasizing interfaces rather than specific types,\nwell-designed code improves its flexibility by allowing polymorphic\nsubstitution.  Duck-typing avoids tests using type() or isinstance() .  (Note, however, that duck-typing can be complemented\nwith abstract base classes .)  Instead, it\ntypically employs hasattr() tests or EAFP programming.\n\ndunder\n\u00c2\u00b6\nAn informal short-hand for \u00e2\u0080\u009cdouble underscore\u00e2\u0080\u009d, used when talking about a special method . For example, __init__ is often pronounced\n\u00e2\u0080\u009cdunder init\u00e2\u0080\u009d.\n\nEAFP\n\u00c2\u00b6\nEasier to ask for forgiveness than permission.  This common Python coding\nstyle assumes the existence of valid keys or attributes and catches\nexceptions if the assumption proves false.  This clean and fast style is\ncharacterized by the presence of many try and except statements.  The technique contrasts with the LBYL style\ncommon to many other languages such as C.\n\nevaluate function\n\u00c2\u00b6\nA function that can be called to evaluate a lazily evaluated attribute\nof an object, such as the value of type aliases created with the type statement.\n\nexpression\n\u00c2\u00b6\nA piece of syntax which can be evaluated to some value.  In other words,\nan expression is an accumulation of expression elements like literals,\nnames, attribute access, operators or function calls which all return a\nvalue.  In contrast to many other languages, not all language constructs\nare expressions.  There are also statement s which cannot be used\nas expressions, such as while .  Assignments are also statements,\nnot expressions.\n\nextension module\n\u00c2\u00b6\nA module written in C or C++, using Python\u00e2\u0080\u0099s C API to interact with the\ncore and with user code.\n\nf-string\n\u00c2\u00b6\nf-strings\n\u00c2\u00b6\nString literals prefixed with f or F are commonly called\n\u00e2\u0080\u009cf-strings\u00e2\u0080\u009d which is short for formatted string literals .  See also PEP 498 .\n\nfile object\n\u00c2\u00b6\nAn object exposing a file-oriented API (with methods such as read() or write() ) to an underlying resource.  Depending\non the way it was created, a file object can mediate access to a real\non-disk file or to another type of storage or communication device\n(for example standard input/output, in-memory buffers, sockets, pipes,\netc.).  File objects are also called file-like objects or streams .\n\nThere are actually three categories of file objects: raw binary files , buffered binary files and text files .\nTheir interfaces are defined in the io module.  The canonical\nway to create a file object is by using the open() function.\n\nfile-like object\n\u00c2\u00b6\nA synonym for file object .\n\nfilesystem encoding and error handler\n\u00c2\u00b6\nEncoding and error handler used by Python to decode bytes from the\noperating system and encode Unicode to the operating system.\n\nThe filesystem encoding must guarantee to successfully decode all bytes\nbelow 128. If the file system encoding fails to provide this guarantee,\nAPI functions can raise UnicodeError .\n\nThe sys.getfilesystemencoding() and sys.getfilesystemencodeerrors() functions can be used to get the\nfilesystem encoding and error handler.\n\nThe filesystem encoding and error handler are configured at\nPython startup by the PyConfig_Read() function: see filesystem_encoding and filesystem_errors members of PyConfig .\n\nSee also the locale encoding .\n\nfinder\n\u00c2\u00b6\nAn object that tries to find the loader for a module that is\nbeing imported.\n\nThere are two types of finder: meta path finders for use with sys.meta_path , and path\nentry finders for use with sys.path_hooks .\n\nSee Finders and loaders and importlib for much more detail.\n\nfloor division\n\u00c2\u00b6\nMathematical division that rounds down to nearest integer.  The floor\ndivision operator is // .  For example, the expression 11 // 4 evaluates to 2 in contrast to the 2.75 returned by float true\ndivision.  Note that (-11) // 4 is -3 because that is -2.75 rounded downward . See PEP 238 .\n\nfree threading\n\u00c2\u00b6\nA threading model where multiple threads can run Python bytecode\nsimultaneously within the same interpreter.  This is in contrast to\nthe global interpreter lock which allows only one thread to\nexecute Python bytecode at a time.  See PEP 703 .\n\nfree-threaded build\n\u00c2\u00b6\nA build of CPython that supports free threading ,\nconfigured using the --disable-gil option before compilation.\n\nSee Python support for free threading .\n\nfree variable\n\u00c2\u00b6\nFormally, as defined in the language execution model , a free\nvariable is any variable used in a namespace which is not a local variable in that\nnamespace. See closure variable for an example.\nPragmatically, due to the name of the codeobject.co_freevars attribute,\nthe term is also sometimes used as a synonym for closure variable .\n\nfunction\n\u00c2\u00b6\nA series of statements which returns some value to a caller. It can also\nbe passed zero or more arguments which may be used in\nthe execution of the body. See also parameter , method ,\nand the Function definitions section.\n\nfunction annotation\n\u00c2\u00b6\nAn annotation of a function parameter or return value.\n\nFunction annotations are usually used for type hints : for example, this function is expected to take two int arguments and is also expected to have an int return value:\n\n```python\ndef sum_two_numbers(a: int, b: int) -> int:\n   return a + b\n```python\n\nFunction annotation syntax is explained in section Function definitions .\n\nSee variable annotation and PEP 484 ,\nwhich describe this functionality.\nAlso see Annotations Best Practices for best practices on working with annotations.\n\n__future__\n\u00c2\u00b6\nA future statement , from __future__ import <feature> ,\ndirects the compiler to compile the current module using syntax or\nsemantics that will become standard in a future release of Python.\nThe __future__ module documents the possible values of feature .  By importing this module and evaluating its variables,\nyou can see when a new feature was first added to the language and\nwhen it will (or did) become the default:\n\n```python\n>>> import __future__\n>>> __future__.division\n_Feature((2, 2, 0, 'alpha', 2), (3, 0, 0, 'alpha', 0), 8192)\n```python\n\ngarbage collection\n\u00c2\u00b6\nThe process of freeing memory when it is not used anymore.  Python\nperforms garbage collection via reference counting and a cyclic garbage\ncollector that is able to detect and break reference cycles.  The\ngarbage collector can be controlled using the gc module.\n\ngenerator\n\u00c2\u00b6\nA function which returns a generator iterator .  It looks like a\nnormal function except that it contains yield expressions\nfor producing a series of values usable in a for-loop or that can be\nretrieved one at a time with the next() function.\n\nUsually refers to a generator function, but may refer to a generator iterator in some contexts.  In cases where the intended\nmeaning isn\u00e2\u0080\u0099t clear, using the full terms avoids ambiguity.\n\ngenerator iterator\n\u00c2\u00b6\nAn object created by a generator function.\n\nEach yield temporarily suspends processing, remembering the\nexecution state (including local variables and pending\ntry-statements).  When the generator iterator resumes, it picks up where\nit left off (in contrast to functions which start fresh on every\ninvocation).\n\ngenerator expression\n\u00c2\u00b6\nAn expression that returns an iterator .  It looks like a normal expression\nfollowed by a for clause defining a loop variable, range,\nand an optional if clause.  The combined expression\ngenerates values for an enclosing function:\n\n```python\n>>> sum(i*i for i in range(10))         # sum of squares 0, 1, 4, ... 81\n285\n```python\n\ngeneric function\n\u00c2\u00b6\nA function composed of multiple functions implementing the same operation\nfor different types. Which implementation should be used during a call is\ndetermined by the dispatch algorithm.\n\nSee also the single dispatch glossary entry, the functools.singledispatch() decorator, and PEP 443 .\n\ngeneric type\n\u00c2\u00b6\nA type that can be parameterized; typically a container class such as list or dict . Used for type hints and annotations .\n\nFor more details, see generic alias types , PEP 483 , PEP 484 , PEP 585 , and the typing module.\n\nGIL\n\u00c2\u00b6\nSee global interpreter lock .\n\nglobal interpreter lock\n\u00c2\u00b6\nThe mechanism used by the CPython interpreter to assure that\nonly one thread executes Python bytecode at a time.\nThis simplifies the CPython implementation by making the object model\n(including critical built-in types such as dict ) implicitly\nsafe against concurrent access.  Locking the entire interpreter\nmakes it easier for the interpreter to be multi-threaded, at the\nexpense of much of the parallelism afforded by multi-processor\nmachines.\n\nHowever, some extension modules, either standard or third-party,\nare designed so as to release the GIL when doing computationally intensive\ntasks such as compression or hashing.  Also, the GIL is always released\nwhen doing I/O.\n\nAs of Python 3.13, the GIL can be disabled using the --disable-gil build configuration. After building Python with this option, code must be\nrun with -X gil=0 or after setting the PYTHON_GIL=0 environment variable. This feature enables improved performance for\nmulti-threaded applications and makes it easier to use multi-core CPUs\nefficiently. For more details, see PEP 703 .\n\nIn prior versions of Python\u00e2\u0080\u0099s C API, a function might declare that it\nrequires the GIL to be held in order to use it. This refers to having an attached thread state .\n\nglobal state\n\u00c2\u00b6\nData that is accessible throughout a program, such as module-level\nvariables, class variables, or C static variables in extension modules .  In multi-threaded programs, global state shared\nbetween threads typically requires synchronization to avoid race conditions and data races .\n\nhash-based pyc\n\u00c2\u00b6\nA bytecode cache file that uses the hash rather than the last-modified\ntime of the corresponding source file to determine its validity. See Cached bytecode invalidation .\n\nhashable\n\u00c2\u00b6\nAn object is hashable if it has a hash value which never changes during\nits lifetime (it needs a __hash__() method), and can be\ncompared to other objects (it needs an __eq__() method).\nHashable objects which\ncompare equal must have the same hash value.\n\nHashability makes an object usable as a dictionary key and a set member,\nbecause these data structures use the hash value internally.\n\nMost of Python\u00e2\u0080\u0099s immutable built-in objects are hashable; mutable\ncontainers (such as lists or dictionaries) are not; immutable\ncontainers (such as tuples and frozensets) are only hashable if\ntheir elements are hashable.  Objects which are\ninstances of user-defined classes are hashable by default.  They all\ncompare unequal (except with themselves), and their hash value is derived\nfrom their id() .\n\nIDLE\n\u00c2\u00b6\nAn Integrated Development and Learning Environment for Python. IDLE \u00e2\u0080\u0094 Python editor and shell is a basic editor and interpreter environment\nwhich ships with the standard distribution of Python.\n\nimmortal\n\u00c2\u00b6\nImmortal objects are a CPython implementation detail introduced\nin PEP 683 .\n\nIf an object is immortal, its reference count is never modified,\nand therefore it is never deallocated while the interpreter is running.\nFor example, True and None are immortal in CPython.\n\nImmortal objects can be identified via sys._is_immortal() , or\nvia PyUnstable_IsImmortal() in the C API.\n\nimmutable\n\u00c2\u00b6\nAn object with a fixed value.  Immutable objects include numbers, strings and\ntuples.  Such an object cannot be altered.  A new object has to\nbe created if a different value has to be stored.  They play an important\nrole in places where a constant hash value is needed, for example as a key\nin a dictionary.  Immutable objects are inherently thread-safe because their state cannot be modified after creation, eliminating concerns\nabout improperly synchronized concurrent modification .\n\nimport path\n\u00c2\u00b6\nA list of locations (or path entries ) that are\nsearched by the path based finder for modules to import. During\nimport, this list of locations usually comes from sys.path , but\nfor subpackages it may also come from the parent package\u00e2\u0080\u0099s __path__ attribute.\n\nimporting\n\u00c2\u00b6\nThe process by which Python code in one module is made available to\nPython code in another module.\n\nimporter\n\u00c2\u00b6\nAn object that both finds and loads a module; both a finder and loader object.\n\nindex\n\u00c2\u00b6\nA numeric value that represents the position of an element in\na sequence .\n\nIn Python, indexing starts at zero.\nFor example, things[0] names the first element of things ; things[1] names the second one.\n\nIn some contexts, Python allows negative indexes for counting from the\nend of a sequence, and indexing using slices .\n\nSee also subscript .\n\ninteractive\n\u00c2\u00b6\nPython has an interactive interpreter which means you can enter\nstatements and expressions at the interpreter prompt, immediately\nexecute them and see their results.  Just launch python with no\narguments (possibly by selecting it from your computer\u00e2\u0080\u0099s main\nmenu). It is a very powerful way to test out new ideas or inspect\nmodules and packages (remember help(x) ). For more on interactive\nmode, see Interactive Mode .\n\ninterpreted\n\u00c2\u00b6\nPython is an interpreted language, as opposed to a compiled one,\nthough the distinction can be blurry because of the presence of the\nbytecode compiler.  This means that source files can be run directly\nwithout explicitly creating an executable which is then run.\nInterpreted languages typically have a shorter development/debug cycle\nthan compiled ones, though their programs generally also run more\nslowly.  See also interactive .\n\ninterpreter shutdown\n\u00c2\u00b6\nWhen asked to shut down, the Python interpreter enters a special phase\nwhere it gradually releases all allocated resources, such as modules\nand various critical internal structures.  It also makes several calls\nto the garbage collector . This can trigger\nthe execution of code in user-defined destructors or weakref callbacks.\nCode executed during the shutdown phase can encounter various\nexceptions as the resources it relies on may not function anymore\n(common examples are library modules or the warnings machinery).\n\nThe main reason for interpreter shutdown is that the __main__ module\nor the script being run has finished executing.\n\niterable\n\u00c2\u00b6\nAn object capable of returning its members one at a time. Examples of\niterables include all sequence types (such as list , str ,\nand tuple ) and some non-sequence types like dict , file objects , and objects of any classes you define\nwith an __iter__() method or with a __getitem__() method\nthat implements sequence semantics.\n\nIterables can be\nused in a for loop and in many other places where a sequence is\nneeded ( zip() , map() , \u00e2\u0080\u00a6).  When an iterable object is passed\nas an argument to the built-in function iter() , it returns an\niterator for the object.  This iterator is good for one pass over the set\nof values.  When using iterables, it is usually not necessary to call iter() or deal with iterator objects yourself.  The for statement does that automatically for you, creating a temporary unnamed\nvariable to hold the iterator for the duration of the loop.  See also iterator , sequence , and generator .\n\niterator\n\u00c2\u00b6\nAn object representing a stream of data.  Repeated calls to the iterator\u00e2\u0080\u0099s __next__() method (or passing it to the built-in function next() ) return successive items in the stream.  When no more data\nare available a StopIteration exception is raised instead.  At this\npoint, the iterator object is exhausted and any further calls to its __next__() method just raise StopIteration again.  Iterators\nare required to have an __iter__() method that returns the iterator\nobject itself so every iterator is also iterable and may be used in most\nplaces where other iterables are accepted.  One notable exception is code\nwhich attempts multiple iteration passes.  A container object (such as a list ) produces a fresh new iterator each time you pass it to the iter() function or use it in a for loop.  Attempting this\nwith an iterator will just return the same exhausted iterator object used\nin the previous iteration pass, making it appear like an empty container.\n\nMore information can be found in Iterator Types .\n\nCPython implementation detail: CPython does not consistently apply the requirement that an iterator\ndefine __iter__() .\nAnd also please note that free-threaded CPython does not guarantee thread-safe behavior of iterator\noperations.\n\nkey\n\u00c2\u00b6\nA value that identifies an entry in a mapping .\nSee also subscript .\n\nkey function\n\u00c2\u00b6\nA key function or collation function is a callable that returns a value\nused for sorting or ordering.  For example, locale.strxfrm() is\nused to produce a sort key that is aware of locale specific sort\nconventions.\n\nA number of tools in Python accept key functions to control how elements\nare ordered or grouped.  They include min() , max() , sorted() , list.sort() , heapq.merge() , heapq.nsmallest() , heapq.nlargest() , and itertools.groupby() .\n\nThere are several ways to create a key function.  For example. the str.casefold() method can serve as a key function for case insensitive\nsorts.  Alternatively, a key function can be built from a lambda expression such as lambda r: (r[0], r[2]) .  Also, operator.attrgetter() , operator.itemgetter() , and operator.methodcaller() are three key function constructors.  See the Sorting HOW TO for examples of how to create and use key functions.\n\nkeyword argument\n\u00c2\u00b6\nSee argument .\n\nlambda\n\u00c2\u00b6\nAn anonymous inline function consisting of a single expression which is evaluated when the function is called.  The syntax to create\na lambda function is lambda [parameters]: expression\n\nLBYL\n\u00c2\u00b6\nLook before you leap.  This coding style explicitly tests for\npre-conditions before making calls or lookups.  This style contrasts with\nthe EAFP approach and is characterized by the presence of many if statements.\n\nIn a multi-threaded environment, the LBYL approach can risk introducing a race condition between \u00e2\u0080\u009cthe looking\u00e2\u0080\u009d and \u00e2\u0080\u009cthe leaping\u00e2\u0080\u009d.  For example,\nthe code, if key in mapping: return mapping[key] can fail if another\nthread removes key from mapping after the test, but before the lookup.\nThis issue can be solved with locks or by using the EAFP approach.  See also thread-safe .\n\nlexical analyzer\n\u00c2\u00b6\nFormal name for the tokenizer ; see token .\n\nlist\n\u00c2\u00b6\nA built-in Python sequence .  Despite its name it is more akin\nto an array in other languages than to a linked list since access to\nelements is O (1).\n\nlist comprehension\n\u00c2\u00b6\nA compact way to process all or part of the elements in a sequence and\nreturn a list with the results. result = ['{:#04x}'.format(x) for x in range(256) if x % 2 == 0] generates a list of strings containing\neven hex numbers (0x..) in the range from 0 to 255. The if clause is optional.  If omitted, all elements in range(256) are\nprocessed.\n\nlock\n\u00c2\u00b6\nA synchronization primitive that allows only one thread at a\ntime to access a shared resource.  A thread must acquire a lock before\naccessing the protected resource and release it afterward.  If a thread\nattempts to acquire a lock that is already held by another thread, it\nwill block until the lock becomes available.  Python\u00e2\u0080\u0099s threading module provides Lock (a basic lock) and RLock (a reentrant lock).  Locks are used\nto prevent race conditions and ensure thread-safe access to shared data.  Alternative design patterns\nto locks exist such as queues, producer/consumer patterns, and\nthread-local state. See also deadlock , and reentrant .\n\nlock-free\n\u00c2\u00b6\nAn operation that does not acquire any lock and uses atomic CPU\ninstructions to ensure correctness. Lock-free operations can execute\nconcurrently without blocking each other and cannot be blocked by\noperations that hold locks. In free-threaded Python, built-in types like dict and list provide\nlock-free read operations, which means other threads may observe\nintermediate states during multi-step modifications even when those\nmodifications hold the per-object lock .\n\nloader\n\u00c2\u00b6\nAn object that loads a module.\nIt must define the exec_module() and create_module() methods\nto implement the Loader interface.\nA loader is typically returned by a finder .\nSee also:\n\n- Finders and loaders\n- importlib.abc.Loader\n- PEP 302\n\nlocale encoding\n\u00c2\u00b6\nOn Unix, it is the encoding of the LC_CTYPE locale. It can be set with locale.setlocale(locale.LC_CTYPE, new_locale) .\n\nOn Windows, it is the ANSI code page (ex: \"cp1252\" ).\n\nOn Android and VxWorks, Python uses \"utf-8\" as the locale encoding.\n\nlocale.getencoding() can be used to get the locale encoding.\n\nSee also the filesystem encoding and error handler .\n\nmagic method\n\u00c2\u00b6\nAn informal synonym for special method .\n\nmapping\n\u00c2\u00b6\nA container object that supports arbitrary key lookups and implements the\nmethods specified in the collections.abc.Mapping or collections.abc.MutableMapping abstract base classes .  Examples\ninclude dict , collections.defaultdict , collections.OrderedDict and collections.Counter .\n\nmeta path finder\n\u00c2\u00b6\nA finder returned by a search of sys.meta_path .  Meta path\nfinders are related to, but different from path entry finders .\n\nSee importlib.abc.MetaPathFinder for the methods that meta path\nfinders implement.\n\nmetaclass\n\u00c2\u00b6\nThe class of a class.  Class definitions create a class name, a class\ndictionary, and a list of base classes.  The metaclass is responsible for\ntaking those three arguments and creating the class.  Most object oriented\nprogramming languages provide a default implementation.  What makes Python\nspecial is that it is possible to create custom metaclasses.  Most users\nnever need this tool, but when the need arises, metaclasses can provide\npowerful, elegant solutions.  They have been used for logging attribute\naccess, adding thread-safety, tracking object creation, implementing\nsingletons, and many other tasks.\n\nMore information can be found in Metaclasses .\n\nmethod\n\u00c2\u00b6\nA function which is defined inside a class body.  If called as an attribute\nof an instance of that class, the method will get the instance object as\nits first argument (which is usually called self ).\nSee function and nested scope .\n\nmethod resolution order\n\u00c2\u00b6\nMethod Resolution Order is the order in which base classes are searched\nfor a member during lookup. See The Python 2.3 Method Resolution Order for details of the\nalgorithm used by the Python interpreter since the 2.3 release.\n\nmodule\n\u00c2\u00b6\nAn object that serves as an organizational unit of Python code.  Modules\nhave a namespace containing arbitrary Python objects.  Modules are loaded\ninto Python by the process of importing .\n\nSee also package .\n\nmodule spec\n\u00c2\u00b6\nA namespace containing the import-related information used to load a\nmodule. An instance of importlib.machinery.ModuleSpec .\n\nSee also Module specs .\n\nMRO\n\u00c2\u00b6\nSee method resolution order .\n\nmutable\n\u00c2\u00b6\nAn object with state that is allowed to change during the course\nof the program.  In multi-threaded programs, mutable objects that are\nshared between threads require careful synchronization to avoid race conditions .  See also immutable , thread-safe , and concurrent modification .\n\nnamed tuple\n\u00c2\u00b6\nThe term \u00e2\u0080\u009cnamed tuple\u00e2\u0080\u009d applies to any type or class that inherits from\ntuple and whose indexable elements are also accessible using named\nattributes.  The type or class may have other features as well.\n\nSeveral built-in types are named tuples, including the values returned\nby time.localtime() and os.stat() .  Another example is sys.float_info :\n\n```python\n>>> sys.float_info[1]                   # indexed access\n1024\n>>> sys.float_info.max_exp              # named field access\n1024\n>>> isinstance(sys.float_info, tuple)   # kind of tuple\nTrue\n```python\n\nSome named tuples are built-in types (such as the above examples).\nAlternatively, a named tuple can be created from a regular class\ndefinition that inherits from tuple and that defines named\nfields.  Such a class can be written by hand, or it can be created by\ninheriting typing.NamedTuple , or with the factory function collections.namedtuple() .  The latter techniques also add some\nextra methods that may not be found in hand-written or built-in named\ntuples.\n\nnamespace\n\u00c2\u00b6\nThe place where a variable is stored.  Namespaces are implemented as\ndictionaries.  There are the local, global and built-in namespaces as well\nas nested namespaces in objects (in methods).  Namespaces support\nmodularity by preventing naming conflicts.  For instance, the functions builtins.open and os.open() are distinguished by\ntheir namespaces.  Namespaces also aid readability and maintainability by\nmaking it clear which module implements a function.  For instance, writing random.seed() or itertools.islice() makes it clear that those\nfunctions are implemented by the random and itertools modules, respectively.\n\nnamespace package\n\u00c2\u00b6\nA package which serves only as a container for subpackages.\nNamespace packages may have no physical representation,\nand specifically are not like a regular package because they\nhave no __init__.py file.\n\nNamespace packages allow several individually installable packages to have a common parent package.\nOtherwise, it is recommended to use a regular package .\n\nFor more information, see PEP 420 and Namespace packages .\n\nSee also module .\n\nnative code\n\u00c2\u00b6\nCode that is compiled to machine instructions and runs directly on the\nprocessor, as opposed to code that is interpreted or runs in a virtual\nmachine.  In the context of Python, native code typically refers to\nC, C++, Rust or Fortran code in extension modules that can be called from Python.  See also extension module .\n\nnested scope\n\u00c2\u00b6\nThe ability to refer to a variable in an enclosing definition.  For\ninstance, a function defined inside another function can refer to\nvariables in the outer function.  Note that nested scopes by default work\nonly for reference and not for assignment.  Local variables both read and\nwrite in the innermost scope.  Likewise, global variables read and write\nto the global namespace.  The nonlocal allows writing to outer\nscopes.\n\nnew-style class\n\u00c2\u00b6\nOld name for the flavor of classes now used for all class objects.  In\nearlier Python versions, only new-style classes could use Python\u00e2\u0080\u0099s newer,\nversatile features like __slots__ , descriptors,\nproperties, __getattribute__() , class methods, and static\nmethods.\n\nnon-deterministic\n\u00c2\u00b6\nBehavior where the outcome of a program can vary between executions with\nthe same inputs.  In multi-threaded programs, non-deterministic behavior\noften results from race conditions where the\nrelative timing or interleaving of threads affects the result.\nProper synchronization using locks and other synchronization primitives helps\nensure deterministic behavior.\n\nobject\n\u00c2\u00b6\nAny data with state (attributes or value) and defined behavior\n(methods).  Also the ultimate base class of any new-style\nclass .\n\noptimized scope\n\u00c2\u00b6\nA scope where target local variable names are reliably known to the\ncompiler when the code is compiled, allowing optimization of read and\nwrite access to these names. The local namespaces for functions,\ngenerators, coroutines, comprehensions, and generator expressions are\noptimized in this fashion. Note: most interpreter optimizations are\napplied to all scopes, only those relying on a known set of local\nand nonlocal variable names are restricted to optimized scopes.\n\noptional module\n\u00c2\u00b6\nAn extension module that is part of the standard library ,\nbut may be absent in some builds of CPython ,\nusually due to missing third-party libraries or because the module\nis not available for a given platform.\n\nSee Requirements for optional modules for a list of optional modules\nthat require third-party libraries.\n\npackage\n\u00c2\u00b6\nA Python module which can contain submodules or recursively,\nsubpackages.  Technically, a package is a Python module with a __path__ attribute.\n\nSee also regular package and namespace package .\n\nparallelism\n\u00c2\u00b6\nExecuting multiple operations at the same time (e.g. on multiple CPU\ncores).  In Python builds with the global interpreter lock (GIL) , only one\nthread runs Python bytecode at a time, so taking advantage of multiple\nCPU cores typically involves multiple processes\n(e.g. multiprocessing ) or native extensions that release the GIL.\nIn free-threaded Python, multiple Python threads\ncan run Python code simultaneously on different cores.\n\nparameter\n\u00c2\u00b6\nA named entity in a function (or method) definition that\nspecifies an argument (or in some cases, arguments) that the\nfunction can accept.  There are five kinds of parameter:\n\n- positional-or-keyword : specifies an argument that can be passed\neither positionally or as a keyword argument .  This is the default kind of parameter, for example foo and bar in the following: def func ( foo , bar = None ): ...\n\n- positional-only : specifies an argument that can be supplied only\nby position. Positional-only parameters can be defined by including a / character in the parameter list of the function definition after\nthem, for example posonly1 and posonly2 in the following: def func ( posonly1 , posonly2 , / , positional_or_keyword ): ...\n\n- keyword-only : specifies an argument that can be supplied only\nby keyword.  Keyword-only parameters can be defined by including a\nsingle var-positional parameter or bare * in the parameter list\nof the function definition before them, for example kw_only1 and kw_only2 in the following: def func ( arg , * , kw_only1 , kw_only2 ): ...\n- var-positional : specifies that an arbitrary sequence of\npositional arguments can be provided (in addition to any positional\narguments already accepted by other parameters).  Such a parameter can\nbe defined by prepending the parameter name with * , for example args in the following: def func ( * args , ** kwargs ): ...\n- var-keyword : specifies that arbitrarily many keyword arguments\ncan be provided (in addition to any keyword arguments already accepted\nby other parameters).  Such a parameter can be defined by prepending\nthe parameter name with ** , for example kwargs in the example\nabove.\n\nParameters can specify both optional and required arguments, as well as\ndefault values for some optional arguments.\n\nSee also the argument glossary entry, the FAQ question on the difference between arguments and parameters , the inspect.Parameter class, the Function definitions section, and PEP 362 .\n\nper-object lock\n\u00c2\u00b6\nA lock associated with an individual object instance rather than\na global lock shared across all objects. In free-threaded Python, built-in types like dict and list use per-object locks to allow concurrent operations on\ndifferent objects while serializing operations on the same object.\nOperations that hold the per-object lock prevent other locking operations\non the same object from proceeding, but do not block lock-free operations.\n\npath entry\n\u00c2\u00b6\nA single location on the import path which the path\nbased finder consults to find modules for importing.\n\npath entry finder\n\u00c2\u00b6\nA finder returned by a callable on sys.path_hooks (i.e. a path entry hook ) which knows how to locate modules given\na path entry .\n\nSee importlib.abc.PathEntryFinder for the methods that path entry\nfinders implement.\n\npath entry hook\n\u00c2\u00b6\nA callable on the sys.path_hooks list which returns a path\nentry finder if it knows how to find modules on a specific path\nentry .\n\npath based finder\n\u00c2\u00b6\nOne of the default meta path finders which\nsearches an import path for modules.\n\npath-like object\n\u00c2\u00b6\nAn object representing a file system path. A path-like object is either\na str or bytes object representing a path, or an object\nimplementing the os.PathLike protocol. An object that supports\nthe os.PathLike protocol can be converted to a str or bytes file system path by calling the os.fspath() function; os.fsdecode() and os.fsencode() can be used to guarantee a str or bytes result instead, respectively. Introduced\nby PEP 519 .\n\nPEP\n\u00c2\u00b6\nPython Enhancement Proposal. A PEP is a design document\nproviding information to the Python community, or describing a new\nfeature for Python or its processes or environment. PEPs should\nprovide a concise technical specification and a rationale for proposed\nfeatures.\n\nPEPs are intended to be the primary mechanisms for proposing major new\nfeatures, for collecting community input on an issue, and for documenting\nthe design decisions that have gone into Python. The PEP author is\nresponsible for building consensus within the community and documenting\ndissenting opinions.\n\nSee PEP 1 .\n\nportion\n\u00c2\u00b6\nA set of files in a single directory (possibly stored in a zip file)\nthat contribute to a namespace package, as defined in PEP 420 .\n\npositional argument\n\u00c2\u00b6\nSee argument .\n\nprovisional API\n\u00c2\u00b6\nA provisional API is one which has been deliberately excluded from\nthe standard library\u00e2\u0080\u0099s backwards compatibility guarantees.  While major\nchanges to such interfaces are not expected, as long as they are marked\nprovisional, backwards incompatible changes (up to and including removal\nof the interface) may occur if deemed necessary by core developers.  Such\nchanges will not be made gratuitously \u00e2\u0080\u0093 they will occur only if serious\nfundamental flaws are uncovered that were missed prior to the inclusion\nof the API.\n\nEven for provisional APIs, backwards incompatible changes are seen as\na \u00e2\u0080\u009csolution of last resort\u00e2\u0080\u009d - every attempt will still be made to find\na backwards compatible resolution to any identified problems.\n\nThis process allows the standard library to continue to evolve over\ntime, without locking in problematic design errors for extended periods\nof time.  See PEP 411 for more details.\n\nprovisional package\n\u00c2\u00b6\nSee provisional API .\n\nPython 3000\n\u00c2\u00b6\nNickname for the Python 3.x release line (coined long ago when the\nrelease of version 3 was something in the distant future.)  This is also\nabbreviated \u00e2\u0080\u009cPy3k\u00e2\u0080\u009d.\n\nPythonic\n\u00c2\u00b6\nAn idea or piece of code which closely follows the most common idioms\nof the Python language, rather than implementing code using concepts\ncommon to other languages.  For example, a common idiom in Python is\nto loop over all elements of an iterable using a for statement.  Many other languages don\u00e2\u0080\u0099t have this type of construct, so\npeople unfamiliar with Python sometimes use a numerical counter instead:\n\n```python\nfor i in range(len(food)):\n    print(food[i])\n```python\n\nAs opposed to the cleaner, Pythonic method:\n\n```python\nfor piece in food:\n    print(piece)\n```python\n\nqualified name\n\u00c2\u00b6\nA dotted name showing the \u00e2\u0080\u009cpath\u00e2\u0080\u009d from a module\u00e2\u0080\u0099s global scope to a\nclass, function or method defined in that module, as defined in PEP 3155 .  For top-level functions and classes, the qualified name\nis the same as the object\u00e2\u0080\u0099s name:\n\n```python\n>>> class C:\n...     class D:\n...         def meth(self):\n...             pass\n...\n>>> C.__qualname__\n'C'\n>>> C.D.__qualname__\n'C.D'\n>>> C.D.meth.__qualname__\n'C.D.meth'\n```python\n\nWhen used to refer to modules, the fully qualified name means the\nentire dotted path to the module, including any parent packages,\ne.g. email.mime.text :\n\n```python\n>>> import email.mime.text\n>>> email.mime.text.__name__\n'email.mime.text'\n```python\n\nrace condition\n\u00c2\u00b6\nA condition of a program where the behavior\ndepends on the relative timing or ordering of events, particularly in\nmulti-threaded programs.  Race conditions can lead to non-deterministic behavior and bugs that are difficult to\nreproduce.  A data race is a specific type of race condition\ninvolving unsynchronized access to shared memory.  The LBYL coding style is particularly susceptible to race conditions in\nmulti-threaded code.  Using locks and other synchronization primitives helps prevent race conditions.\n\nreference count\n\u00c2\u00b6\nThe number of references to an object.  When the reference count of an\nobject drops to zero, it is deallocated.  Some objects are immortal and have reference counts that are never modified, and\ntherefore the objects are never deallocated.  Reference counting is\ngenerally not visible to Python code, but it is a key element of the CPython implementation.  Programmers can call the sys.getrefcount() function to return the\nreference count for a particular object.\n\nIn CPython , reference counts are not considered to be stable\nor well-defined values; the number of references to an object, and how\nthat number is affected by Python code, may be different between\nversions.\n\nregular package\n\u00c2\u00b6\nA traditional package , such as a directory containing an __init__.py file.\n\nSee also namespace package .\n\nreentrant\n\u00c2\u00b6\nA property of a function or lock that allows it to be called or\nacquired multiple times by the same thread without causing errors or a deadlock .\n\nFor functions, reentrancy means the function can be safely called again\nbefore a previous invocation has completed, which is important when\nfunctions may be called recursively or from signal handlers. Thread-unsafe\nfunctions may be non-deterministic if they\u00e2\u0080\u0099re called reentrantly in a\nmultithreaded program.\n\nFor locks, Python\u00e2\u0080\u0099s threading.RLock (reentrant lock) is\nreentrant, meaning a thread that already holds the lock can acquire it\nagain without blocking.  In contrast, threading.Lock is not\nreentrant - attempting to acquire it twice from the same thread will cause\na deadlock.\n\nSee also lock and deadlock .\n\nREPL\n\u00c2\u00b6\nAn acronym for the \u00e2\u0080\u009cread\u00e2\u0080\u0093eval\u00e2\u0080\u0093print loop\u00e2\u0080\u009d, another name for the interactive interpreter shell.\n\n__slots__\n\u00c2\u00b6\nA declaration inside a class that saves memory by pre-declaring space for\ninstance attributes and eliminating instance dictionaries.  Though\npopular, the technique is somewhat tricky to get right and is best\nreserved for rare cases where there are large numbers of instances in a\nmemory-critical application.\n\nsequence\n\u00c2\u00b6\nAn iterable which supports efficient element access using integer\nindices via the __getitem__() special method and defines a __len__() method that returns the length of the sequence.\nSome built-in sequence types are list , str , tuple , and bytes . Note that dict also\nsupports __getitem__() and __len__() , but is considered a\nmapping rather than a sequence because the lookups use arbitrary hashable keys rather than integers.\n\nThe collections.abc.Sequence abstract base class\ndefines a much richer interface that goes beyond just __getitem__() and __len__() , adding count() , index() , __contains__() , and __reversed__() .\nTypes that implement this expanded\ninterface can be registered explicitly using register() . For more documentation on sequence\nmethods generally, see Common Sequence Operations .\n\nset comprehension\n\u00c2\u00b6\nA compact way to process all or part of the elements in an iterable and\nreturn a set with the results. results = {c for c in 'abracadabra' if c not in 'abc'} generates the set of strings {'r', 'd'} .  See Displays for lists, sets and dictionaries .\n\nsingle dispatch\n\u00c2\u00b6\nA form of generic function dispatch where the implementation is\nchosen based on the type of a single argument.\n\nslice\n\u00c2\u00b6\nAn object of type slice , used to describe a portion of\na sequence .\nA slice object is created when using the slicing form\nof subscript notation , with colons inside square\nbrackets, such as in variable_name[1:3:5] .\n\nsoft deprecated\n\u00c2\u00b6\nA soft deprecated API should not be used in new code,\nbut it is safe for already existing code to use it.\nThe API remains documented and tested, but will not be enhanced further.\n\nSoft deprecation, unlike normal deprecation, does not plan on removing the API\nand will not emit warnings.\n\nSee PEP 387: Soft Deprecation .\n\nspecial method\n\u00c2\u00b6\nA method that is called implicitly by Python to execute a certain\noperation on a type, such as addition.  Such methods have names starting\nand ending with double underscores.  Special methods are documented in Special method names .\n\nstandard library\n\u00c2\u00b6\nThe collection of packages , modules and extension modules distributed as a part\nof the official Python interpreter package.  The exact membership of the\ncollection may vary based on platform, available system libraries, or\nother criteria.  Documentation can be found at The Python Standard Library .\n\nSee also sys.stdlib_module_names for a list of all possible\nstandard library module names.\n\nstatement\n\u00c2\u00b6\nA statement is part of a suite (a \u00e2\u0080\u009cblock\u00e2\u0080\u009d of code).  A statement is either\nan expression or one of several constructs with a keyword, such\nas if , while or for .\n\nstatic type checker\n\u00c2\u00b6\nAn external tool that reads Python code and analyzes it, looking for\nissues such as incorrect types. See also type hints and the typing module.\n\nstdlib\n\u00c2\u00b6\nAn abbreviation of standard library .\n\nstrong reference\n\u00c2\u00b6\nIn Python\u00e2\u0080\u0099s C API, a strong reference is a reference to an object\nwhich is owned by the code holding the reference.  The strong\nreference is taken by calling Py_INCREF() when the\nreference is created and released with Py_DECREF() when the reference is deleted.\n\nThe Py_NewRef() function can be used to create a strong reference\nto an object. Usually, the Py_DECREF() function must be called on\nthe strong reference before exiting the scope of the strong reference, to\navoid leaking one reference.\n\nSee also borrowed reference .\n\nsubscript\n\u00c2\u00b6\nThe expression in square brackets of a subscription expression , for example,\nthe 3 in items[3] .\nUsually used to select an element of a container.\nAlso called a key when subscripting a mapping ,\nor an index when subscripting a sequence .\n\nsynchronization primitive\n\u00c2\u00b6\nA basic building block for coordinating (synchronizing) the execution of\nmultiple threads to ensure thread-safe access to shared resources.\nPython\u00e2\u0080\u0099s threading module provides several synchronization primitives\nincluding Lock , RLock , Semaphore , Condition , Event , and Barrier .  Additionally,\nthe queue module provides multi-producer, multi-consumer queues\nthat are especially useful in multithreaded programs. These\nprimitives help prevent race conditions and\ncoordinate thread execution.  See also lock .\n\nt-string\n\u00c2\u00b6\nt-strings\n\u00c2\u00b6\nString literals prefixed with t or T are commonly called\n\u00e2\u0080\u009ct-strings\u00e2\u0080\u009d which is short for template string literals .\n\ntext encoding\n\u00c2\u00b6\nA string in Python is a sequence of Unicode code points (in range U+0000 \u00e2\u0080\u0093 U+10FFFF ). To store or transfer a string, it needs to be\nserialized as a sequence of bytes.\n\nSerializing a string into a sequence of bytes is known as \u00e2\u0080\u009cencoding\u00e2\u0080\u009d, and\nrecreating the string from the sequence of bytes is known as \u00e2\u0080\u009cdecoding\u00e2\u0080\u009d.\n\nThere are a variety of different text serialization codecs , which are collectively referred to as\n\u00e2\u0080\u009ctext encodings\u00e2\u0080\u009d.\n\ntext file\n\u00c2\u00b6\nA file object able to read and write str objects.\nOften, a text file actually accesses a byte-oriented datastream\nand handles the text encoding automatically.\nExamples of text files are files opened in text mode ( 'r' or 'w' ), sys.stdin , sys.stdout , and instances of io.StringIO .\n\nSee also binary file for a file object able to read and write bytes-like objects .\n\nthread state\n\u00c2\u00b6\nThe information used by the CPython runtime to run in an OS thread.\nFor example, this includes the current exception, if any, and the\nstate of the bytecode interpreter.\n\nEach thread state is bound to a single OS thread, but threads may have\nmany thread states available.  At most, one of them may be attached at once.\n\nAn attached thread state is required to call most\nof Python\u00e2\u0080\u0099s C API, unless a function explicitly documents otherwise.\nThe bytecode interpreter only runs under an attached thread state.\n\nEach thread state belongs to a single interpreter, but each interpreter\nmay have many thread states, including multiple for the same OS thread.\nThread states from multiple interpreters may be bound to the same\nthread, but only one can be attached in\nthat thread at any given moment.\n\nSee Thread State and the Global Interpreter Lock for more\ninformation.\n\nthread-safe\n\u00c2\u00b6\nA module, function, or class that behaves correctly when used by multiple\nthreads concurrently.  Thread-safe code uses appropriate synchronization primitives like locks to protect shared mutable state, or is designed\nto avoid shared mutable state entirely.  In the free-threaded build, built-in types like dict , list , and set use internal locking\nto make many operations thread-safe, although thread safety is not\nnecessarily guaranteed.  Code that is not thread-safe may experience race conditions and data races when used in multi-threaded programs.\n\ntoken\n\u00c2\u00b6\nA small unit of source code, generated by the lexical analyzer (also called the tokenizer ).\nNames, numbers, strings, operators,\nnewlines and similar are represented by tokens.\n\nThe tokenize module exposes Python\u00e2\u0080\u0099s lexical analyzer.\nThe token module contains information on the various types\nof tokens.\n\ntriple-quoted string\n\u00c2\u00b6\nA string which is bound by three instances of either a quotation mark\n(\u00e2\u0080\u009d) or an apostrophe (\u00e2\u0080\u0098).  While they don\u00e2\u0080\u0099t provide any functionality\nnot available with single-quoted strings, they are useful for a number\nof reasons.  They allow you to include unescaped single and double\nquotes within a string and they can span multiple lines without the\nuse of the continuation character, making them especially useful when\nwriting docstrings.\n\ntype\n\u00c2\u00b6\nThe type of a Python object determines what kind of object it is; every\nobject has a type.  An object\u00e2\u0080\u0099s type is accessible as its __class__ attribute or can be retrieved with type(obj) .\n\ntype alias\n\u00c2\u00b6\nA synonym for a type, created by assigning the type to an identifier.\n\nType aliases are useful for simplifying type hints .\nFor example:\n\n```python\ndef remove_gray_shades(\n        colors: list[tuple[int, int, int]]) -> list[tuple[int, int, int]]:\n    pass\n```python\n\ncould be made more readable like this:\n\n```python\nColor = tuple[int, int, int]\n\ndef remove_gray_shades(colors: list[Color]) -> list[Color]:\n    pass\n```python\n\nSee typing and PEP 484 , which describe this functionality.\n\ntype hint\n\u00c2\u00b6\nAn annotation that specifies the expected type for a variable, a class\nattribute, or a function parameter or return value.\n\nType hints are optional and are not enforced by Python but\nthey are useful to static type checkers .\nThey can also aid IDEs with code completion and refactoring.\n\nType hints of global variables, class attributes, and functions,\nbut not local variables, can be accessed using typing.get_type_hints() .\n\nSee typing and PEP 484 , which describe this functionality.\n\nuniversal newlines\n\u00c2\u00b6\nA manner of interpreting text streams in which all of the following are\nrecognized as ending a line: the Unix end-of-line convention '\\n' ,\nthe Windows convention '\\r\\n' , and the old Macintosh convention '\\r' .  See PEP 278 and PEP 3116 , as well as bytes.splitlines() for an additional use.\n\nvariable annotation\n\u00c2\u00b6\nAn annotation of a variable or a class attribute.\n\nWhen annotating a variable or a class attribute, assignment is optional:\n\n```python\nclass C:\n    field: 'annotation'\n```python\n\nVariable annotations are usually used for type hints : for example this variable is expected to take int values:\n\n```python\ncount: int = 0\n```python\n\nVariable annotation syntax is explained in section Annotated assignment statements .\n\nSee function annotation , PEP 484 and PEP 526 , which describe this functionality.\nAlso see Annotations Best Practices for best practices on working with annotations.\n\nvirtual environment\n\u00c2\u00b6\nA cooperatively isolated runtime environment that allows Python users\nand applications to install and upgrade Python distribution packages\nwithout interfering with the behaviour of other Python applications\nrunning on the same system.\n\nSee also venv .\n\nvirtual machine\n\u00c2\u00b6\nA computer defined entirely in software.  Python\u00e2\u0080\u0099s virtual machine\nexecutes the bytecode emitted by the bytecode compiler.\n\nwalrus operator\n\u00c2\u00b6\nA light-hearted way to refer to the assignment expression operator := because it looks a bit like a\nwalrus if you turn your head.\n\nZen of Python\n\u00c2\u00b6\nListing of Python design principles and philosophies that are helpful in\nunderstanding and using the language.  The listing can be found by typing\n\u00e2\u0080\u009c import this \u00e2\u0080\u009d at the interactive prompt.",
  "difficulty": "intro",
  "doc_id": "doc-glossary-4e4a714c7f",
  "provenance": {
    "author": "",
    "date": "",
    "license": "PSF Documentation License",
    "source_file": "data/corpus_raw/scraped/3_glossary_html_d0d1f2.json",
    "url": "https://docs.python.org/3/glossary.html"
  },
  "title": "Glossary\u00c2\u00b6",
  "type": "tutorial"
}