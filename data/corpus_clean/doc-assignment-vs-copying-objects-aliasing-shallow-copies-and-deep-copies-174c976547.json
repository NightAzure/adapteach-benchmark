{
  "ai_generated": false,
  "concept_tags": [
    "aliasing",
    "assignment",
    "copy",
    "deepcopy",
    "dicts",
    "lists",
    "mutability",
    "shallow-copy",
    "variables"
  ],
  "content": "A moderate jump in understanding variables is realizing that **assignment does not copy objects**. It creates a binding (a reference) from a name to an object.\n\n---\n## 1) Aliasing: two names, one object\n\n```python\noriginal = {\"k\": 1}\nalias = original\n\nalias[\"k\"] = 999\nprint(original)  # {'k': 999}\nprint(alias)     # {'k': 999}\n```python\n\nBoth names refer to the same dictionary, so changing it via one name is visible through the other.\n\n---\n## 2) Shallow copy: new outer object, shared inner objects\nA shallow copy duplicates the outer container but keeps references to nested objects.\n\n```python\nouter1 = {\"nums\": [1, 2, 3], \"tag\": \"A\"}\nouter2 = outer1.copy()  # dict shallow copy\n\nouter2[\"tag\"] = \"B\"          # changes only outer2\nouter2[\"nums\"].append(4)      # changes the shared inner list\n\nprint(outer1)  # nums changed!\nprint(outer2)\n```python\n\nThis can surprise people: the dict itself is copied, but the list inside is still shared.\n\n---\n## 3) Shallow copying techniques you\u2019ll see often\n\n```python\nlst1 = [1, 2, 3]\nlst2 = lst1.copy()   # or lst1[:] or list(lst1)\n\nlst2.append(999)\nprint(lst1)  # [1, 2, 3]\nprint(lst2)  # [1, 2, 3, 999]\n```python\n\nFor nested lists, shallow copying the outer list isn\u2019t enough:\n\n```python\ngrid1 = [[0, 0], [0, 0]]\ngrid2 = grid1.copy()  # shallow\n\ngrid2[0].append(1)\nprint(grid1)  # inner list mutated (shared)\nprint(grid2)\n```python\n\n---\n## 4) Deep copy: recursively copies nested objects\nWhen you need an independent copy of a nested structure, use `copy.deepcopy`.\n\n```python\nimport copy\n\ngrid1 = [[0, 0], [0, 0]]\ngrid3 = copy.deepcopy(grid1)\n\ngrid3[0].append(1)\nprint(grid1)  # unchanged\nprint(grid3)  # changed\n```python\n\n---\n## 5) A practical mini checklist\n- If you only need a separate outer container and you are fine sharing nested objects \u2192 shallow copy is fine.\n- If you need nested objects to be independent too \u2192 deep copy.\n- If the object is immutable (like an int or string), aliasing is usually not a problem.\n\n---\n## 6) Short \u201cspot the aliasing\u201d practice block\n\n```python\nimport copy\n\na = {\"x\": [1, 2]}\nb = a\nc = a.copy()\nd = copy.deepcopy(a)\n\nb[\"x\"].append(3)\nprint(a)  # affects a\nprint(c)  # shallow copy shares inner list\nprint(d)  # deep copy independent\n```",
  "difficulty": "moderate",
  "doc_id": "doc-assignment-vs-copying-objects-aliasing-shallow-copies-and-deep-copies-174c976547",
  "provenance": {
    "author": "",
    "date": "",
    "license": "PSF Documentation License (Python docs)",
    "source_file": "data/corpus_raw/variables_moderate_2.json",
    "url": "https://docs.python.org/3/library/copy.html"
  },
  "title": "Assignment vs copying objects: aliasing, shallow copies, and deep copies",
  "type": "tutorial"
}