{
  "ai_generated": false,
  "concept_tags": [
    "file_io",
    "modules",
    "standard_library"
  ],
  "content": "# 10.Brief Tour of the Standard Library\u00c2\u00b6\n\n## 10.1.Operating System Interface\u00c2\u00b6\n\nThe os module provides dozens of functions for interacting with the\noperating system:\n\n```python\n>>> import os\n>>> os.getcwd()      # Return the current working directory\n'C:\\\\Python314'\n>>> os.chdir('/server/accesslogs')   # Change current working directory\n>>> os.system('mkdir today')   # Run the command mkdir in the system shell\n0\n```python\n\nBe sure to use the import os style instead of from os import * .  This\nwill keep os.open() from shadowing the built-in open() function which\noperates much differently.\n\nThe built-in dir() and help() functions are useful as interactive\naids for working with large modules like os :\n\n```python\n>>> import os\n>>> dir(os)\n<returns a list of all module functions>\n>>> help(os)\n<returns an extensive manual page created from the module's docstrings>\n```python\n\nFor daily file and directory management tasks, the shutil module provides\na higher level interface that is easier to use:\n\n```python\n>>> import shutil\n>>> shutil.copyfile('data.db', 'archive.db')\n'archive.db'\n>>> shutil.move('/build/executables', 'installdir')\n'installdir'\n```python\n\n## 10.2.File Wildcards\u00c2\u00b6\n\nThe glob module provides a function for making file lists from directory\nwildcard searches:\n\n```python\n>>> import glob\n>>> glob.glob('*.py')\n['primes.py', 'random.py', 'quote.py']\n```python\n\n## 10.3.Command Line Arguments\u00c2\u00b6\n\nCommon utility scripts often need to process command line arguments. These\narguments are stored in the sys module\u00e2\u0080\u0099s argv attribute as a list.  For\ninstance, let\u00e2\u0080\u0099s take the following demo.py file:\n\n```python\n# File demo.py\nimport sys\nprint(sys.argv)\n```python\n\nHere is the output from running python demo.py one two three at the command\nline:\n\n```python\n['demo.py', 'one', 'two', 'three']\n```python\n\nThe argparse module provides a more sophisticated mechanism to process\ncommand line arguments.  The following script extracts one or more filenames\nand an optional number of lines to be displayed:\n\n```python\nimport argparse\n\nparser = argparse.ArgumentParser(\n    prog='top',\n    description='Show top lines from each file')\nparser.add_argument('filenames', nargs='+')\nparser.add_argument('-l', '--lines', type=int, default=10)\nargs = parser.parse_args()\nprint(args)\n```python\n\nWhen run at the command line with python top.py --lines=5 alpha.txt beta.txt , the script sets args.lines to 5 and args.filenames to ['alpha.txt', 'beta.txt'] .\n\n## 10.4.Error Output Redirection and Program Termination\u00c2\u00b6\n\nThe sys module also has attributes for stdin , stdout , and stderr .\nThe latter is useful for emitting warnings and error messages to make them\nvisible even when stdout has been redirected:\n\n```python\n>>> sys.stderr.write('Warning, log file not found starting a new one\\n')\nWarning, log file not found starting a new one\n```python\n\nThe most direct way to terminate a script is to use sys.exit() .\n\n## 10.5.String Pattern Matching\u00c2\u00b6\n\nThe re module provides regular expression tools for advanced string\nprocessing. For complex matching and manipulation, regular expressions offer\nsuccinct, optimized solutions:\n\n```python\n>>> import re\n>>> re.findall(r'\\bf[a-z]*', 'which foot or hand fell fastest')\n['foot', 'fell', 'fastest']\n>>> re.sub(r'(\\b[a-z]+) \\1', r'\\1', 'cat in the the hat')\n'cat in the hat'\n```python\n\nWhen only simple capabilities are needed, string methods are preferred because\nthey are easier to read and debug:\n\n```python\n>>> 'tea for too'.replace('too', 'two')\n'tea for two'\n```python\n\n## 10.6.Mathematics\u00c2\u00b6\n\nThe math module gives access to the underlying C library functions for\nfloating-point math:\n\n```python\n>>> import math\n>>> math.cos(math.pi / 4)\n0.70710678118654757\n>>> math.log(1024, 2)\n10.0\n```python\n\nThe random module provides tools for making random selections:\n\n```python\n>>> import random\n>>> random.choice(['apple', 'pear', 'banana'])\n'apple'\n>>> random.sample(range(100), 10)   # sampling without replacement\n[30, 83, 16, 4, 8, 81, 41, 50, 18, 33]\n>>> random.random()    # random float from the interval [0.0, 1.0)\n0.17970987693706186\n>>> random.randrange(6)    # random integer chosen from range(6)\n4\n```python\n\nThe statistics module calculates basic statistical properties\n(the mean, median, variance, etc.) of numeric data:\n\n```python\n>>> import statistics\n>>> data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]\n>>> statistics.mean(data)\n1.6071428571428572\n>>> statistics.median(data)\n1.25\n>>> statistics.variance(data)\n1.3720238095238095\n```python\n\nThe SciPy project < https://scipy.org > has many other modules for numerical\ncomputations.\n\n## 10.7.Internet Access\u00c2\u00b6\n\nThere are a number of modules for accessing the internet and processing internet\nprotocols. Two of the simplest are urllib.request for retrieving data\nfrom URLs and smtplib for sending mail:\n\n```python\n>>> from urllib.request import urlopen\n>>> with urlopen('https://docs.python.org/3/') as response:\n...     for line in response:\n...         line = line.decode()             # Convert bytes to a str\n...         if 'updated' in line:\n...             print(line.rstrip())         # Remove trailing newline\n...\n      Last updated on Nov 11, 2025 (20:11 UTC).\n\n>>> import smtplib\n>>> server = smtplib.SMTP('localhost')\n>>> server.sendmail('soothsayer@example.org', 'jcaesar@example.org',\n... \"\"\"To: jcaesar@example.org\n... From: soothsayer@example.org\n...\n... Beware the Ides of March.\n... \"\"\")\n>>> server.quit()\n```python\n\n(Note that the second example needs a mailserver running on localhost.)\n\n## 10.8.Dates and Times\u00c2\u00b6\n\nThe datetime module supplies classes for manipulating dates and times in\nboth simple and complex ways. While date and time arithmetic is supported, the\nfocus of the implementation is on efficient member extraction for output\nformatting and manipulation.  The module also supports objects that are timezone\naware.\n\n```python\n>>> # dates are easily constructed and formatted\n>>> from datetime import date\n>>> now = date.today()\n>>> now\ndatetime.date(2003, 12, 2)\n>>> now.strftime(\"%m-%d-%y. %d %b %Y is a %A on the %d day of %B.\")\n'12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.'\n\n>>> # dates support calendar arithmetic\n>>> birthday = date(1964, 7, 31)\n>>> age = now - birthday\n>>> age.days\n14368\n```python\n\n## 10.9.Data Compression\u00c2\u00b6\n\nCommon data archiving and compression formats are directly supported by modules\nincluding: zlib , gzip , bz2 , lzma , zipfile and tarfile .\n\n```python\n>>> import zlib\n>>> s = b'witch which has which witches wrist watch'\n>>> len(s)\n41\n>>> t = zlib.compress(s)\n>>> len(t)\n37\n>>> zlib.decompress(t)\nb'witch which has which witches wrist watch'\n>>> zlib.crc32(s)\n226805979\n```python\n\n## 10.10.Performance Measurement\u00c2\u00b6\n\nSome Python users develop a deep interest in knowing the relative performance of\ndifferent approaches to the same problem. Python provides a measurement tool\nthat answers those questions immediately.\n\nFor example, it may be tempting to use the tuple packing and unpacking feature\ninstead of the traditional approach to swapping arguments. The timeit module quickly demonstrates a modest performance advantage:\n\n```python\n>>> from timeit import Timer\n>>> Timer('t=a; a=b; b=t', 'a=1; b=2').timeit()\n0.57535828626024577\n>>> Timer('a,b = b,a', 'a=1; b=2').timeit()\n0.54962537085770791\n```python\n\nIn contrast to timeit \u00e2\u0080\u0099s fine level of granularity, the profile and pstats modules provide tools for identifying time critical sections in\nlarger blocks of code.\n\n## 10.11.Quality Control\u00c2\u00b6\n\nOne approach for developing high quality software is to write tests for each\nfunction as it is developed and to run those tests frequently during the\ndevelopment process.\n\nThe doctest module provides a tool for scanning a module and validating\ntests embedded in a program\u00e2\u0080\u0099s docstrings.  Test construction is as simple as\ncutting-and-pasting a typical call along with its results into the docstring.\nThis improves the documentation by providing the user with an example and it\nallows the doctest module to make sure the code remains true to the\ndocumentation:\n\n```python\ndef average(values):\n    \"\"\"Computes the arithmetic mean of a list of numbers.\n\n    >>> print(average([20, 30, 70]))\n    40.0\n    \"\"\"\n    return sum(values) / len(values)\n\nimport doctest\ndoctest.testmod()   # automatically validate the embedded tests\n```python\n\nThe unittest module is not as effortless as the doctest module,\nbut it allows a more comprehensive set of tests to be maintained in a separate\nfile:\n\n```python\nimport unittest\n\nclass TestStatisticalFunctions(unittest.TestCase):\n\n    def test_average(self):\n        self.assertEqual(average([20, 30, 70]), 40.0)\n        self.assertEqual(round(average([1, 5, 7]), 1), 4.3)\n        with self.assertRaises(ZeroDivisionError):\n            average([])\n        with self.assertRaises(TypeError):\n            average(20, 30, 70)\n\nunittest.main()  # Calling from the command line invokes all tests\n```python\n\n## 10.12.Batteries Included\u00c2\u00b6\n\nPython has a \u00e2\u0080\u009cbatteries included\u00e2\u0080\u009d philosophy.  This is best seen through the\nsophisticated and robust capabilities of its larger packages. For example:\n\n- The xmlrpc.client and xmlrpc.server modules make implementing\nremote procedure calls into an almost trivial task.  Despite the modules\u00e2\u0080\u0099\nnames, no direct knowledge or handling of XML is needed.\n- The email package is a library for managing email messages, including\nMIME and other RFC 5322 -based message documents. Unlike smtplib and poplib which actually send and receive messages, the email package has\na complete toolset for building or decoding complex message structures\n(including attachments) and for implementing internet encoding and header\nprotocols.\n- The json package provides robust support for parsing this\npopular data interchange format.  The csv module supports\ndirect reading and writing of files in Comma-Separated Value format,\ncommonly supported by databases and spreadsheets.  XML processing is\nsupported by the xml.etree.ElementTree , xml.dom and xml.sax packages. Together, these modules and packages\ngreatly simplify data interchange between Python applications and\nother tools.\n- The sqlite3 module is a wrapper for the SQLite database\nlibrary, providing a persistent database that can be updated and\naccessed using slightly nonstandard SQL syntax.\n- Internationalization is supported by a number of modules including gettext , locale , and the codecs package.",
  "difficulty": "intro",
  "doc_id": "doc-10-brief-tour-of-the-standard-library-28f2830678",
  "provenance": {
    "author": "",
    "date": "",
    "license": "PSF Documentation License",
    "source_file": "data/corpus_raw/scraped/3_tutorial_stdlib_html_0b886b.json",
    "url": "https://docs.python.org/3/tutorial/stdlib.html"
  },
  "title": "10.Brief Tour of the Standard Library\u00c2\u00b6",
  "type": "tutorial"
}