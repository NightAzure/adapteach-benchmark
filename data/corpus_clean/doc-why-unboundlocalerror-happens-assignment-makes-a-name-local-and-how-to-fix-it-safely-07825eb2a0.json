{
  "ai_generated": false,
  "concept_tags": [
    "binding",
    "debugging",
    "global",
    "scope",
    "unboundlocalerror",
    "variables"
  ],
  "content": "A frequent hard-level error is:\n\n> `UnboundLocalError: local variable 'x' referenced before assignment`\n\nThis happens because Python decides whether a name is **local** by scanning the function body for **any binding** to that name. If the name is assigned anywhere in the function, it is treated as local throughout that function (unless declared `global` or `nonlocal`).\n\n---\n## 1) Minimal example\n\n```python\nx = 10\n\ndef f():\n    print(x)  # Python thinks x is local here\n    x = 3     # because of this assignment\n\n# f() would raise UnboundLocalError\n```python\n\nWhy? Because `x = 3` makes `x` local to `f()`, so `print(x)` tries to read the local `x` before it has a value.\n\n---\n## 2) Fix pattern A: rename the local variable (best default)\nIf you didn\u2019t intend to modify the global `x`, use a different name.\n\n```python\nx = 10\n\ndef f():\n    print(x)      # reads global x\n    x_local = 3\n    return x_local\n\nprint(f())\nprint(x)          # still 10\n```python\n\n---\n## 3) Fix pattern B: pass input as arguments and return results (pure function style)\n\n```python\ndef f(x):\n    print(x)\n    x = 3\n    return x\n\nprint(f(10))\n```python\n\n---\n## 4) Fix pattern C: global (only if you truly mean shared module state)\n\n```python\nx = 10\n\ndef f():\n    global x\n    print(x)\n    x = 3\n\nf()\nprint(x)  # 3\n```python\n\n---\n## 5) A more realistic \u201cbranch\u201d example\nEven if the assignment happens only in one branch, it still makes the name local for the whole function.\n\n```python\nflag = False\nx = 100\n\ndef g():\n    if flag:\n        x = 5   # assignment exists \u2192 x is local in g\n    return x\n\n# g() would error if flag is False (it tries to return local x before assignment)\n```python\n\nA safe refactor is to always assign before use:\n\n```python\nflag = False\nx = 100\n\ndef g():\n    local_x = x\n    if flag:\n        local_x = 5\n    return local_x\n\nprint(g())\n```python\n\n---\n## 6) Related: comprehension variables can also create bindings\nSome confusing cases happen when a name becomes local because of a binding inside an expression (e.g., comprehensions).\n\n```python\ndef h():\n    # If you bind a name inside the function body, it can change locality expectations.\n    data = [1, 2, 3]\n    out = [v for v in data]\n    return out\n\nprint(h())\n```",
  "difficulty": "hard",
  "doc_id": "doc-why-unboundlocalerror-happens-assignment-makes-a-name-local-and-how-to-fix-it-safely-07825eb2a0",
  "provenance": {
    "author": "",
    "date": "",
    "license": "CC BY-SA (Stack Overflow; version depends on post date)",
    "source_file": "data/corpus_raw/variables_hard_2.json",
    "url": "https://stackoverflow.com/questions/10851906/how-can-i-fix-unboundlocalerror-local-variable-referenced-before-assignment"
  },
  "title": "Why UnboundLocalError happens: assignment makes a name local (and how to fix it safely)",
  "type": "tutorial"
}