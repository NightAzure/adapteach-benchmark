{
  "ai_generated": false,
  "concept_tags": [
    "classmethod",
    "decorators",
    "functions",
    "methods",
    "pep-318",
    "stacking",
    "staticmethod",
    "wrapping"
  ],
  "content": "Decorators are a way to transform a function (or method) at definition time. The `@decorator` syntax makes transformations explicit and keeps them close to the function they affect.\n\n---\n## 1) Mental model: @decorator rewrites the function binding\nConceptually, this:\n\n```python\n@decorator\ndef f(x):\n    return x + 1\n```python\n\nis like:\n\n```python\ndef f(x):\n    return x + 1\n\nf = decorator(f)\n```python\n\nThis \u201crebinding\u201d happens when the function definition is executed.\n\n---\n## 2) A simple decorator: log calls\n\n```python\ndef log_calls(func):\n    def wrapper(*args, **kwargs):\n        print(\"calling\", func.__name__, args, kwargs)\n        result = func(*args, **kwargs)\n        print(\"returned\", result)\n        return result\n    return wrapper\n\n@log_calls\ndef add(a, b):\n    return a + b\n\nprint(add(2, 3))\n```python\n\n---\n## 3) Stacking decorators (order matters)\n\n```python\ndef d1(func):\n    def w(*a, **k):\n        print(\"d1 before\")\n        r = func(*a, **k)\n        print(\"d1 after\")\n        return r\n    return w\n\ndef d2(func):\n    def w(*a, **k):\n        print(\"d2 before\")\n        r = func(*a, **k)\n        print(\"d2 after\")\n        return r\n    return w\n\n@d1\n@d2\ndef work():\n    print(\"work\")\n\nwork()\n```python\n\nThink of it as:\n\n```python\n# roughly\nwork = d1(d2(work))\n```python\n\n---\n## 4) Decorators are common for method transformations\nA classic motivation is avoiding \u201cwrap then assign\u201d patterns for things like `staticmethod` / `classmethod`.\n\n```python\nclass C:\n    @staticmethod\n    def f(x):\n        return x * 2\n\nprint(C.f(10))\n```python\n\n---\n## 5) A bigger example: permission check decorator\n\n```python\ndef require_admin(func):\n    def wrapper(user, *args, **kwargs):\n        if user.get(\"role\") != \"admin\":\n            raise PermissionError(\"admin only\")\n        return func(user, *args, **kwargs)\n    return wrapper\n\n@require_admin\ndef delete_post(user, post_id):\n    return f\"deleted {post_id}\"\n\nadmin = {\"role\": \"admin\"}\nguest = {\"role\": \"guest\"}\n\nprint(delete_post(admin, 123))\n# delete_post(guest, 123) would raise PermissionError\n```",
  "difficulty": "hard",
  "doc_id": "doc-decorators-hard-what-decorator-means-stacking-decorators-and-readable-function-transformations-7abd2d614e",
  "provenance": {
    "author": "",
    "date": "",
    "license": "Public domain (PEP text)",
    "source_file": "data/corpus_raw/functions_hard_1.json",
    "url": "https://peps.python.org/pep-0318/"
  },
  "title": "Decorators (hard): what @decorator means, stacking decorators, and readable function transformations",
  "type": "reference"
}