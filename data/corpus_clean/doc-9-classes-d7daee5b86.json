{
  "ai_generated": false,
  "concept_tags": [
    "OOP",
    "classes",
    "inheritance",
    "objects",
    "scope"
  ],
  "content": "# 9.Classes\u00c2\u00b6\n\nClasses provide a means of bundling data and functionality together.  Creating\na new class creates a new type of object, allowing new instances of that\ntype to be made.  Each class instance can have attributes attached to it for\nmaintaining its state.  Class instances can also have methods (defined by its\nclass) for modifying its state.\n\nCompared with other programming languages, Python\u00e2\u0080\u0099s class mechanism adds classes\nwith a minimum of new syntax and semantics.  It is a mixture of the class\nmechanisms found in C++ and Modula-3.  Python classes provide all the standard\nfeatures of Object Oriented Programming: the class inheritance mechanism allows\nmultiple base classes, a derived class can override any methods of its base\nclass or classes, and a method can call the method of a base class with the same\nname.  Objects can contain arbitrary amounts and kinds of data.  As is true for\nmodules, classes partake of the dynamic nature of Python: they are created at\nruntime, and can be modified further after creation.\n\nIn C++ terminology, normally class members (including the data members) are public (except see below Private Variables ), and all member functions are virtual .  As in Modula-3, there are no shorthands for referencing the object\u00e2\u0080\u0099s\nmembers from its methods: the method function is declared with an explicit first\nargument representing the object, which is provided implicitly by the call.  As\nin Smalltalk, classes themselves are objects.  This provides semantics for\nimporting and renaming.  Unlike C++ and Modula-3, built-in types can be used as\nbase classes for extension by the user.  Also, like in C++, most built-in\noperators with special syntax (arithmetic operators, subscripting etc.) can be\nredefined for class instances.\n\n(Lacking universally accepted terminology to talk about classes, I will make\noccasional use of Smalltalk and C++ terms.  I would use Modula-3 terms, since\nits object-oriented semantics are closer to those of Python than C++, but I\nexpect that few readers have heard of it.)\n\n## 9.1.A Word About Names and Objects\u00c2\u00b6\n\nObjects have individuality, and multiple names (in multiple scopes) can be bound\nto the same object.  This is known as aliasing in other languages.  This is\nusually not appreciated on a first glance at Python, and can be safely ignored\nwhen dealing with immutable basic types (numbers, strings, tuples).  However,\naliasing has a possibly surprising effect on the semantics of Python code\ninvolving mutable objects such as lists, dictionaries, and most other types.\nThis is usually used to the benefit of the program, since aliases behave like\npointers in some respects.  For example, passing an object is cheap since only a\npointer is passed by the implementation; and if a function modifies an object\npassed as an argument, the caller will see the change \u00e2\u0080\u0094 this eliminates the\nneed for two different argument passing mechanisms as in Pascal.\n\n## 9.2.Python Scopes and Namespaces\u00c2\u00b6\n\nBefore introducing classes, I first have to tell you something about Python\u00e2\u0080\u0099s\nscope rules.  Class definitions play some neat tricks with namespaces, and you\nneed to know how scopes and namespaces work to fully understand what\u00e2\u0080\u0099s going on.\nIncidentally, knowledge about this subject is useful for any advanced Python\nprogrammer.\n\nLet\u00e2\u0080\u0099s begin with some definitions.\n\nA namespace is a mapping from names to objects.  Most namespaces are currently\nimplemented as Python dictionaries, but that\u00e2\u0080\u0099s normally not noticeable in any\nway (except for performance), and it may change in the future.  Examples of\nnamespaces are: the set of built-in names (containing functions such as abs() , and\nbuilt-in exception names); the global names in a module; and the local names in\na function invocation.  In a sense the set of attributes of an object also form\na namespace.  The important thing to know about namespaces is that there is\nabsolutely no relation between names in different namespaces; for instance, two\ndifferent modules may both define a function maximize without confusion \u00e2\u0080\u0094\nusers of the modules must prefix it with the module name.\n\nBy the way, I use the word attribute for any name following a dot \u00e2\u0080\u0094 for\nexample, in the expression z.real , real is an attribute of the object z .  Strictly speaking, references to names in modules are attribute\nreferences: in the expression modname.funcname , modname is a module\nobject and funcname is an attribute of it.  In this case there happens to be\na straightforward mapping between the module\u00e2\u0080\u0099s attributes and the global names\ndefined in the module: they share the same namespace! [ 1 ]\n\nAttributes may be read-only or writable.  In the latter case, assignment to\nattributes is possible.  Module attributes are writable: you can write modname.the_answer = 42 .  Writable attributes may also be deleted with the del statement.  For example, del modname.the_answer will remove\nthe attribute the_answer from the object named by modname .\n\nNamespaces are created at different moments and have different lifetimes.  The\nnamespace containing the built-in names is created when the Python interpreter\nstarts up, and is never deleted.  The global namespace for a module is created\nwhen the module definition is read in; normally, module namespaces also last\nuntil the interpreter quits.  The statements executed by the top-level\ninvocation of the interpreter, either read from a script file or interactively,\nare considered part of a module called __main__ , so they have their own\nglobal namespace.  (The built-in names actually also live in a module; this is\ncalled builtins .)\n\nThe local namespace for a function is created when the function is called, and\ndeleted when the function returns or raises an exception that is not handled\nwithin the function.  (Actually, forgetting would be a better way to describe\nwhat actually happens.)  Of course, recursive invocations each have their own\nlocal namespace.\n\nA scope is a textual region of a Python program where a namespace is directly\naccessible.  \u00e2\u0080\u009cDirectly accessible\u00e2\u0080\u009d here means that an unqualified reference to a\nname attempts to find the name in the namespace.\n\nAlthough scopes are determined statically, they are used dynamically. At any\ntime during execution, there are 3 or 4 nested scopes whose namespaces are\ndirectly accessible:\n\n- the innermost scope, which is searched first, contains the local names\n- the scopes of any enclosing functions, which are searched starting with the\nnearest enclosing scope, contain non-local, but also non-global names\n- the next-to-last scope contains the current module\u00e2\u0080\u0099s global names\n- the outermost scope (searched last) is the namespace containing built-in names\n\nIf a name is declared global, then all references and assignments go directly to\nthe next-to-last scope containing the module\u00e2\u0080\u0099s global names.  To rebind variables\nfound outside of the innermost scope, the nonlocal statement can be\nused; if not declared nonlocal, those variables are read-only (an attempt to\nwrite to such a variable will simply create a new local variable in the\ninnermost scope, leaving the identically named outer variable unchanged).\n\nUsually, the local scope references the local names of the (textually) current\nfunction.  Outside functions, the local scope references the same namespace as\nthe global scope: the module\u00e2\u0080\u0099s namespace. Class definitions place yet another\nnamespace in the local scope.\n\nIt is important to realize that scopes are determined textually: the global\nscope of a function defined in a module is that module\u00e2\u0080\u0099s namespace, no matter\nfrom where or by what alias the function is called.  On the other hand, the\nactual search for names is done dynamically, at run time \u00e2\u0080\u0094 however, the\nlanguage definition is evolving towards static name resolution, at \u00e2\u0080\u009ccompile\u00e2\u0080\u009d\ntime, so don\u00e2\u0080\u0099t rely on dynamic name resolution!  (In fact, local variables are\nalready determined statically.)\n\nA special quirk of Python is that \u00e2\u0080\u0093 if no global or nonlocal statement is in effect \u00e2\u0080\u0093 assignments to names always go into the innermost scope.\nAssignments do not copy data \u00e2\u0080\u0094 they just bind names to objects.  The same is true\nfor deletions: the statement del x removes the binding of x from the\nnamespace referenced by the local scope.  In fact, all operations that introduce\nnew names use the local scope: in particular, import statements and\nfunction definitions bind the module or function name in the local scope.\n\nThe global statement can be used to indicate that particular\nvariables live in the global scope and should be rebound there; the nonlocal statement indicates that particular variables live in\nan enclosing scope and should be rebound there.\n\n### 9.2.1.Scopes and Namespaces Example\u00c2\u00b6\n\nThis is an example demonstrating how to reference the different scopes and\nnamespaces, and how global and nonlocal affect variable\nbinding:\n\n```python\ndef scope_test():\n    def do_local():\n        spam = \"local spam\"\n\n    def do_nonlocal():\n        nonlocal spam\n        spam = \"nonlocal spam\"\n\n    def do_global():\n        global spam\n        spam = \"global spam\"\n\n    spam = \"test spam\"\n    do_local()\n    print(\"After local assignment:\", spam)\n    do_nonlocal()\n    print(\"After nonlocal assignment:\", spam)\n    do_global()\n    print(\"After global assignment:\", spam)\n\nscope_test()\nprint(\"In global scope:\", spam)\n```python\n\nThe output of the example code is:\n\n```python\nAfter local assignment: test spam\nAfter nonlocal assignment: nonlocal spam\nAfter global assignment: nonlocal spam\nIn global scope: global spam\n```python\n\nNote how the local assignment (which is default) didn\u00e2\u0080\u0099t change scope_test 's\nbinding of spam .  The nonlocal assignment changed scope_test 's\nbinding of spam , and the global assignment changed the module-level\nbinding.\n\nYou can also see that there was no previous binding for spam before the global assignment.\n\n## 9.3.A First Look at Classes\u00c2\u00b6\n\nClasses introduce a little bit of new syntax, three new object types, and some\nnew semantics.\n\n### 9.3.1.Class Definition Syntax\u00c2\u00b6\n\nThe simplest form of class definition looks like this:\n\n```python\nclass ClassName:\n    <statement-1>\n    .\n    .\n    .\n    <statement-N>\n```python\n\nClass definitions, like function definitions ( def statements) must be\nexecuted before they have any effect.  (You could conceivably place a class\ndefinition in a branch of an if statement, or inside a function.)\n\nIn practice, the statements inside a class definition will usually be function\ndefinitions, but other statements are allowed, and sometimes useful \u00e2\u0080\u0094 we\u00e2\u0080\u0099ll\ncome back to this later.  The function definitions inside a class normally have\na peculiar form of argument list, dictated by the calling conventions for\nmethods \u00e2\u0080\u0094 again, this is explained later.\n\nWhen a class definition is entered, a new namespace is created, and used as the\nlocal scope \u00e2\u0080\u0094 thus, all assignments to local variables go into this new\nnamespace.  In particular, function definitions bind the name of the new\nfunction here.\n\nWhen a class definition is left normally (via the end), a class object is\ncreated.  This is basically a wrapper around the contents of the namespace\ncreated by the class definition; we\u00e2\u0080\u0099ll learn more about class objects in the\nnext section.  The original local scope (the one in effect just before the class\ndefinition was entered) is reinstated, and the class object is bound here to the\nclass name given in the class definition header ( ClassName in the\nexample).\n\n### 9.3.2.Class Objects\u00c2\u00b6\n\nClass objects support two kinds of operations: attribute references and\ninstantiation.\n\nAttribute references use the standard syntax used for all attribute references\nin Python: obj.name .  Valid attribute names are all the names that were in\nthe class\u00e2\u0080\u0099s namespace when the class object was created.  So, if the class\ndefinition looked like this:\n\n```python\nclass MyClass:\n    \"\"\"A simple example class\"\"\"\n    i = 12345\n\n    def f(self):\n        return 'hello world'\n```python\n\nthen MyClass.i and MyClass.f are valid attribute references, returning\nan integer and a function object, respectively. Class attributes can also be\nassigned to, so you can change the value of MyClass.i by assignment. __doc__ is also a valid attribute, returning the docstring\nbelonging to the class: \"A simple example class\" .\n\nClass instantiation uses function notation.  Just pretend that the class\nobject is a parameterless function that returns a new instance of the class.\nFor example (assuming the above class):\n\n```python\nx = MyClass()\n```python\n\ncreates a new instance of the class and assigns this object to the local\nvariable x .\n\nThe instantiation operation (\u00e2\u0080\u009ccalling\u00e2\u0080\u009d a class object) creates an empty object.\nMany classes like to create objects with instances customized to a specific\ninitial state. Therefore a class may define a special method named __init__() , like this:\n\n```python\ndef __init__(self):\n    self.data = []\n```python\n\nWhen a class defines an __init__() method, class instantiation\nautomatically invokes __init__() for the newly created class instance.  So\nin this example, a new, initialized instance can be obtained by:\n\n```python\nx = MyClass()\n```python\n\nOf course, the __init__() method may have arguments for greater\nflexibility.  In that case, arguments given to the class instantiation operator\nare passed on to __init__() .  For example,\n\n```python\n>>> class Complex:\n...     def __init__(self, realpart, imagpart):\n...         self.r = realpart\n...         self.i = imagpart\n...\n>>> x = Complex(3.0, -4.5)\n>>> x.r, x.i\n(3.0, -4.5)\n```python\n\n### 9.3.3.Instance Objects\u00c2\u00b6\n\nNow what can we do with instance objects?  The only operations understood by\ninstance objects are attribute references.  There are two kinds of valid\nattribute names: data attributes and methods.\n\nData attributes correspond to \u00e2\u0080\u009cinstance variables\u00e2\u0080\u009d in Smalltalk, and to \u00e2\u0080\u009cdata\nmembers\u00e2\u0080\u009d in C++.  Data attributes need not be declared; like local variables,\nthey spring into existence when they are first assigned to.  For example, if x is the instance of MyClass created above, the following piece of\ncode will print the value 16 , without leaving a trace:\n\n```python\nx.counter = 1\nwhile x.counter < 10:\n    x.counter = x.counter * 2\nprint(x.counter)\ndel x.counter\n```python\n\nThe other kind of instance attribute reference is a method . A method is a\nfunction that \u00e2\u0080\u009cbelongs to\u00e2\u0080\u009d an object.\n\nValid method names of an instance object depend on its class.  By definition,\nall attributes of a class that are function  objects define corresponding\nmethods of its instances.  So in our example, x.f is a valid method\nreference, since MyClass.f is a function, but x.i is not, since MyClass.i is not.  But x.f is not the same thing as MyClass.f \u00e2\u0080\u0094 it\nis a method object , not a function object.\n\n### 9.3.4.Method Objects\u00c2\u00b6\n\nUsually, a method is called right after it is bound:\n\n```python\nx.f()\n```python\n\nIf x = MyClass() , as above, this will return the string 'hello world' .\nHowever, it is not necessary to call a method right away: x.f is a method\nobject, and can be stored away and called at a later time.  For example:\n\n```python\nxf = x.f\nwhile True:\n    print(xf())\n```python\n\nwill continue to print hello world until the end of time.\n\nWhat exactly happens when a method is called?  You may have noticed that x.f() was called without an argument above, even though the function\ndefinition for f() specified an argument.  What happened to the argument?\nSurely Python raises an exception when a function that requires an argument is\ncalled without any \u00e2\u0080\u0094 even if the argument isn\u00e2\u0080\u0099t actually used\u00e2\u0080\u00a6\n\nActually, you may have guessed the answer: the special thing about methods is\nthat the instance object is passed as the first argument of the function.  In our\nexample, the call x.f() is exactly equivalent to MyClass.f(x) .  In\ngeneral, calling a method with a list of n arguments is equivalent to calling\nthe corresponding function with an argument list that is created by inserting\nthe method\u00e2\u0080\u0099s instance object before the first argument.\n\nIn general, methods work as follows.  When a non-data attribute\nof an instance is referenced, the instance\u00e2\u0080\u0099s class is searched.\nIf the name denotes a valid class attribute that is a function object,\nreferences to both the instance object and the function object\nare packed into a method object.  When the method object is called\nwith an argument list, a new argument list is constructed from the instance\nobject and the argument list, and the function object is called with this new\nargument list.\n\n### 9.3.5.Class and Instance Variables\u00c2\u00b6\n\nGenerally speaking, instance variables are for data unique to each instance\nand class variables are for attributes and methods shared by all instances\nof the class:\n\n```python\nclass Dog:\n\n    kind = 'canine'         # class variable shared by all instances\n\n    def __init__(self, name):\n        self.name = name    # instance variable unique to each instance\n\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.kind                  # shared by all dogs\n'canine'\n>>> e.kind                  # shared by all dogs\n'canine'\n>>> d.name                  # unique to d\n'Fido'\n>>> e.name                  # unique to e\n'Buddy'\n```python\n\nAs discussed in A Word About Names and Objects , shared data can have possibly surprising\neffects involving mutable objects such as lists and dictionaries.\nFor example, the tricks list in the following code should not be used as a\nclass variable because just a single list would be shared by all Dog instances:\n\n```python\nclass Dog:\n\n    tricks = []             # mistaken use of a class variable\n\n    def __init__(self, name):\n        self.name = name\n\n    def add_trick(self, trick):\n        self.tricks.append(trick)\n\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.add_trick('roll over')\n>>> e.add_trick('play dead')\n>>> d.tricks                # unexpectedly shared by all dogs\n['roll over', 'play dead']\n```python\n\nCorrect design of the class should use an instance variable instead:\n\n```python\nclass Dog:\n\n    def __init__(self, name):\n        self.name = name\n        self.tricks = []    # creates a new empty list for each dog\n\n    def add_trick(self, trick):\n        self.tricks.append(trick)\n\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.add_trick('roll over')\n>>> e.add_trick('play dead')\n>>> d.tricks\n['roll over']\n>>> e.tricks\n['play dead']\n```python\n\n## 9.4.Random Remarks\u00c2\u00b6\n\nIf the same attribute name occurs in both an instance and in a class,\nthen attribute lookup prioritizes the instance:\n\n```python\n>>> class Warehouse:\n...    purpose = 'storage'\n...    region = 'west'\n...\n>>> w1 = Warehouse()\n>>> print(w1.purpose, w1.region)\nstorage west\n>>> w2 = Warehouse()\n>>> w2.region = 'east'\n>>> print(w2.purpose, w2.region)\nstorage east\n```python\n\nData attributes may be referenced by methods as well as by ordinary users\n(\u00e2\u0080\u009cclients\u00e2\u0080\u009d) of an object.  In other words, classes are not usable to implement\npure abstract data types.  In fact, nothing in Python makes it possible to\nenforce data hiding \u00e2\u0080\u0094 it is all based upon convention.  (On the other hand,\nthe Python implementation, written in C, can completely hide implementation\ndetails and control access to an object if necessary; this can be used by\nextensions to Python written in C.)\n\nClients should use data attributes with care \u00e2\u0080\u0094 clients may mess up invariants\nmaintained by the methods by stamping on their data attributes.  Note that\nclients may add data attributes of their own to an instance object without\naffecting the validity of the methods, as long as name conflicts are avoided \u00e2\u0080\u0094\nagain, a naming convention can save a lot of headaches here.\n\nThere is no shorthand for referencing data attributes (or other methods!) from\nwithin methods.  I find that this actually increases the readability of methods:\nthere is no chance of confusing local variables and instance variables when\nglancing through a method.\n\nOften, the first argument of a method is called self .  This is nothing more\nthan a convention: the name self has absolutely no special meaning to\nPython.  Note, however, that by not following the convention your code may be\nless readable to other Python programmers, and it is also conceivable that a class browser program might be written that relies upon such a convention.\n\nAny function object that is a class attribute defines a method for instances of\nthat class.  It is not necessary that the function definition is textually\nenclosed in the class definition: assigning a function object to a local\nvariable in the class is also ok.  For example:\n\n```python\n# Function defined outside the class\ndef f1(self, x, y):\n    return min(x, x+y)\n\nclass C:\n    f = f1\n\n    def g(self):\n        return 'hello world'\n\n    h = g\n```python\n\nNow f , g and h are all attributes of class C that refer to\nfunction objects, and consequently they are all methods of instances of C \u00e2\u0080\u0094 h being exactly equivalent to g .  Note that this practice\nusually only serves to confuse the reader of a program.\n\nMethods may call other methods by using method attributes of the self argument:\n\n```python\nclass Bag:\n    def __init__(self):\n        self.data = []\n\n    def add(self, x):\n        self.data.append(x)\n\n    def addtwice(self, x):\n        self.add(x)\n        self.add(x)\n```python\n\nMethods may reference global names in the same way as ordinary functions.  The\nglobal scope associated with a method is the module containing its\ndefinition.  (A class is never used as a global scope.)  While one\nrarely encounters a good reason for using global data in a method, there are\nmany legitimate uses of the global scope: for one thing, functions and modules\nimported into the global scope can be used by methods, as well as functions and\nclasses defined in it.  Usually, the class containing the method is itself\ndefined in this global scope, and in the next section we\u00e2\u0080\u0099ll find some good\nreasons why a method would want to reference its own class.\n\nEach value is an object, and therefore has a class (also called its type ).\nIt is stored as object.__class__ .\n\n## 9.5.Inheritance\u00c2\u00b6\n\nOf course, a language feature would not be worthy of the name \u00e2\u0080\u009cclass\u00e2\u0080\u009d without\nsupporting inheritance.  The syntax for a derived class definition looks like\nthis:\n\n```python\nclass DerivedClassName(BaseClassName):\n    <statement-1>\n    .\n    .\n    .\n    <statement-N>\n```python\n\nThe name BaseClassName must be defined in a\nnamespace accessible from the scope containing the\nderived class definition.  In place of a base class name, other arbitrary\nexpressions are also allowed.  This can be useful, for example, when the base\nclass is defined in another module:\n\n```python\nclass DerivedClassName(modname.BaseClassName):\n```python\n\nExecution of a derived class definition proceeds the same as for a base class.\nWhen the class object is constructed, the base class is remembered.  This is\nused for resolving attribute references: if a requested attribute is not found\nin the class, the search proceeds to look in the base class.  This rule is\napplied recursively if the base class itself is derived from some other class.\n\nThere\u00e2\u0080\u0099s nothing special about instantiation of derived classes: DerivedClassName() creates a new instance of the class.  Method references\nare resolved as follows: the corresponding class attribute is searched,\ndescending down the chain of base classes if necessary, and the method reference\nis valid if this yields a function object.\n\nDerived classes may override methods of their base classes.  Because methods\nhave no special privileges when calling other methods of the same object, a\nmethod of a base class that calls another method defined in the same base class\nmay end up calling a method of a derived class that overrides it.  (For C++\nprogrammers: all methods in Python are effectively virtual .)\n\nAn overriding method in a derived class may in fact want to extend rather than\nsimply replace the base class method of the same name. There is a simple way to\ncall the base class method directly: just call BaseClassName.methodname(self, arguments) .  This is occasionally useful to clients as well.  (Note that this\nonly works if the base class is accessible as BaseClassName in the global\nscope.)\n\nPython has two built-in functions that work with inheritance:\n\n- Use isinstance() to check an instance\u00e2\u0080\u0099s type: isinstance(obj, int) will be True only if obj.__class__ is int or some class\nderived from int .\n- Use issubclass() to check class inheritance: issubclass(bool, int) is True since bool is a subclass of int .  However, issubclass(float, int) is False since float is not a\nsubclass of int .\n\n### 9.5.1.Multiple Inheritance\u00c2\u00b6\n\nPython supports a form of multiple inheritance as well.  A class definition with\nmultiple base classes looks like this:\n\n```python\nclass DerivedClassName(Base1, Base2, Base3):\n    <statement-1>\n    .\n    .\n    .\n    <statement-N>\n```python\n\nFor most purposes, in the simplest cases, you can think of the search for\nattributes inherited from a parent class as depth-first, left-to-right, not\nsearching twice in the same class where there is an overlap in the hierarchy.\nThus, if an attribute is not found in DerivedClassName , it is searched\nfor in Base1 , then (recursively) in the base classes of Base1 ,\nand if it was not found there, it was searched for in Base2 , and so on.\n\nIn fact, it is slightly more complex than that; the method resolution order\nchanges dynamically to support cooperative calls to super() .  This\napproach is known in some other multiple-inheritance languages as\ncall-next-method and is more powerful than the super call found in\nsingle-inheritance languages.\n\nDynamic ordering is necessary because all cases of multiple inheritance exhibit\none or more diamond relationships (where at least one of the parent classes\ncan be accessed through multiple paths from the bottommost class).  For example,\nall classes inherit from object , so any case of multiple inheritance\nprovides more than one path to reach object .  To keep the base classes\nfrom being accessed more than once, the dynamic algorithm linearizes the search\norder in a way that preserves the left-to-right ordering specified in each\nclass, that calls each parent only once, and that is monotonic (meaning that a\nclass can be subclassed without affecting the precedence order of its parents).\nTaken together, these properties make it possible to design reliable and\nextensible classes with multiple inheritance.  For more detail, see The Python 2.3 Method Resolution Order .\n\n## 9.6.Private Variables\u00c2\u00b6\n\n\u00e2\u0080\u009cPrivate\u00e2\u0080\u009d instance variables that cannot be accessed except from inside an\nobject don\u00e2\u0080\u0099t exist in Python.  However, there is a convention that is followed\nby most Python code: a name prefixed with an underscore (e.g. _spam ) should\nbe treated as a non-public part of the API (whether it is a function, a method\nor a data member).  It should be considered an implementation detail and subject\nto change without notice.\n\nSince there is a valid use-case for class-private members (namely to avoid name\nclashes of names with names defined by subclasses), there is limited support for\nsuch a mechanism, called name mangling .  Any identifier of the form __spam (at least two leading underscores, at most one trailing underscore)\nis textually replaced with _classname__spam , where classname is the\ncurrent class name with leading underscore(s) stripped.  This mangling is done\nwithout regard to the syntactic position of the identifier, as long as it\noccurs within the definition of a class.\n\nSee also\n\nThe private name mangling specifications for details and special cases.\n\nName mangling is helpful for letting subclasses override methods without\nbreaking intraclass method calls.  For example:\n\n```python\nclass Mapping:\n    def __init__(self, iterable):\n        self.items_list = []\n        self.__update(iterable)\n\n    def update(self, iterable):\n        for item in iterable:\n            self.items_list.append(item)\n\n    __update = update   # private copy of original update() method\n\nclass MappingSubclass(Mapping):\n\n    def update(self, keys, values):\n        # provides new signature for update()\n        # but does not break __init__()\n        for item in zip(keys, values):\n            self.items_list.append(item)\n```python\n\nThe above example would work even if MappingSubclass were to introduce a __update identifier since it is replaced with _Mapping__update in the Mapping class  and _MappingSubclass__update in the MappingSubclass class respectively.\n\nNote that the mangling rules are designed mostly to avoid accidents; it still is\npossible to access or modify a variable that is considered private.  This can\neven be useful in special circumstances, such as in the debugger.\n\nNotice that code passed to exec() or eval() does not consider the\nclassname of the invoking class to be the current class; this is similar to the\neffect of the global statement, the effect of which is likewise restricted\nto code that is byte-compiled together.  The same restriction applies to getattr() , setattr() and delattr() , as well as when referencing __dict__ directly.\n\n## 9.7.Odds and Ends\u00c2\u00b6\n\nSometimes it is useful to have a data type similar to the Pascal \u00e2\u0080\u009crecord\u00e2\u0080\u009d or C\n\u00e2\u0080\u009cstruct\u00e2\u0080\u009d, bundling together a few named data items. The idiomatic approach\nis to use dataclasses for this purpose:\n\n```python\nfrom dataclasses import dataclass\n\n@dataclass\nclass Employee:\n    name: str\n    dept: str\n    salary: int\n```python\n\n```python\n>>> john = Employee('john', 'computer lab', 1000)\n>>> john.dept\n'computer lab'\n>>> john.salary\n1000\n```python\n\nA piece of Python code that expects a particular abstract data type can often be\npassed a class that emulates the methods of that data type instead.  For\ninstance, if you have a function that formats some data from a file object, you\ncan define a class with methods read() and readline() that get the\ndata from a string buffer instead, and pass it as an argument.\n\nInstance method objects have attributes, too: m.__self__ is the instance\nobject with the method m() , and m.__func__ is\nthe function object corresponding to the method.\n\n## 9.8.Iterators\u00c2\u00b6\n\nBy now you have probably noticed that most container objects can be looped over\nusing a for statement:\n\n```python\nfor element in [1, 2, 3]:\n    print(element)\nfor element in (1, 2, 3):\n    print(element)\nfor key in {'one':1, 'two':2}:\n    print(key)\nfor char in \"123\":\n    print(char)\nfor line in open(\"myfile.txt\"):\n    print(line, end='')\n```python\n\nThis style of access is clear, concise, and convenient.  The use of iterators\npervades and unifies Python.  Behind the scenes, the for statement\ncalls iter() on the container object.  The function returns an iterator\nobject that defines the method __next__() which accesses\nelements in the container one at a time.  When there are no more elements, __next__() raises a StopIteration exception which tells the for loop to terminate.  You can call the __next__() method\nusing the next() built-in function; this example shows how it all works:\n\n```python\n>>> s = 'abc'\n>>> it = iter(s)\n>>> it\n<str_iterator object at 0x10c90e650>\n>>> next(it)\n'a'\n>>> next(it)\n'b'\n>>> next(it)\n'c'\n>>> next(it)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n    next(it)\nStopIteration\n```python\n\nHaving seen the mechanics behind the iterator protocol, it is easy to add\niterator behavior to your classes.  Define an __iter__() method which\nreturns an object with a __next__() method.  If the class\ndefines __next__() , then __iter__() can just return self :\n\n```python\nclass Reverse:\n    \"\"\"Iterator for looping over a sequence backwards.\"\"\"\n    def __init__(self, data):\n        self.data = data\n        self.index = len(data)\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.index == 0:\n            raise StopIteration\n        self.index = self.index - 1\n        return self.data[self.index]\n```python\n\n```python\n>>> rev = Reverse('spam')\n>>> iter(rev)\n<__main__.Reverse object at 0x00A1DB50>\n>>> for char in rev:\n...     print(char)\n...\nm\na\np\ns\n```python\n\n## 9.9.Generators\u00c2\u00b6\n\nGenerators are a simple and powerful tool for creating iterators.  They\nare written like regular functions but use the yield statement\nwhenever they want to return data.  Each time next() is called on it, the\ngenerator resumes where it left off (it remembers all the data values and which\nstatement was last executed).  An example shows that generators can be trivially\neasy to create:\n\n```python\ndef reverse(data):\n    for index in range(len(data)-1, -1, -1):\n        yield data[index]\n```python\n\n```python\n>>> for char in reverse('golf'):\n...     print(char)\n...\nf\nl\no\ng\n```python\n\nAnything that can be done with generators can also be done with class-based\niterators as described in the previous section.  What makes generators so\ncompact is that the __iter__() and __next__() methods\nare created automatically.\n\nAnother key feature is that the local variables and execution state are\nautomatically saved between calls.  This made the function easier to write and\nmuch more clear than an approach using instance variables like self.index and self.data .\n\nIn addition to automatic method creation and saving program state, when\ngenerators terminate, they automatically raise StopIteration . In\ncombination, these features make it easy to create iterators with no more effort\nthan writing a regular function.\n\n## 9.10.Generator Expressions\u00c2\u00b6\n\nSome simple generators can be coded succinctly as expressions using a syntax\nsimilar to list comprehensions but with parentheses instead of square brackets.\nThese expressions are designed for situations where the generator is used right\naway by an enclosing function.  Generator expressions are more compact but less\nversatile than full generator definitions and tend to be more memory friendly\nthan equivalent list comprehensions.\n\nExamples:\n\n```python\n>>> sum(i*i for i in range(10))                 # sum of squares\n285\n\n>>> xvec = [10, 20, 30]\n>>> yvec = [7, 5, 3]\n>>> sum(x*y for x,y in zip(xvec, yvec))         # dot product\n260\n\n>>> unique_words = set(word for line in page  for word in line.split())\n\n>>> valedictorian = max((student.gpa, student.name) for student in graduates)\n\n>>> data = 'golf'\n>>> list(data[i] for i in range(len(data)-1, -1, -1))\n['f', 'l', 'o', 'g']\n```python\n\nFootnotes",
  "difficulty": "intermediate",
  "doc_id": "doc-9-classes-d7daee5b86",
  "provenance": {
    "author": "",
    "date": "",
    "license": "PSF Documentation License",
    "source_file": "data/corpus_raw/scraped/3_tutorial_classes_html_bd3d0c.json",
    "url": "https://docs.python.org/3/tutorial/classes.html"
  },
  "title": "9.Classes\u00c2\u00b6",
  "type": "tutorial"
}