{
  "ai_generated": false,
  "concept_tags": [
    "debugging",
    "error_handling",
    "exceptions"
  ],
  "content": "# Built-in Exceptions\u00c2\u00b6\n\nIn Python, all exceptions must be instances of a class that derives from BaseException .  In a try statement with an except clause that mentions a particular class, that clause also handles any exception\nclasses derived from that class (but not exception classes from which it is\nderived).  Two exception classes that are not related via subclassing are never\nequivalent, even if they have the same name.\n\nThe built-in exceptions listed in this chapter can be generated by the interpreter or\nbuilt-in functions.  Except where mentioned, they have an \u00e2\u0080\u009cassociated value\u00e2\u0080\u009d\nindicating the detailed cause of the error.  This may be a string or a tuple of\nseveral items of information (e.g., an error code and a string explaining the\ncode).  The associated value is usually passed as arguments to the exception\nclass\u00e2\u0080\u0099s constructor.\n\nUser code can raise built-in exceptions.  This can be used to test an exception\nhandler or to report an error condition \u00e2\u0080\u009cjust like\u00e2\u0080\u009d the situation in which the\ninterpreter raises the same exception; but beware that there is nothing to\nprevent user code from raising an inappropriate error.\n\nThe built-in exception classes can be subclassed to define new exceptions;\nprogrammers are encouraged to derive new exceptions from the Exception class or one of its subclasses, and not from BaseException .  More\ninformation on defining exceptions is available in the Python Tutorial under User-defined Exceptions .\n\n## Exception context\u00c2\u00b6\n\nThree attributes on exception objects provide information about the context in\nwhich the exception was raised:\n\nBaseException.\n__context__\n\u00c2\u00b6\nBaseException.\n__cause__\n\u00c2\u00b6\nBaseException.\n__suppress_context__\n\u00c2\u00b6\nWhen raising a new exception while another exception\nis already being handled, the new exception\u00e2\u0080\u0099s __context__ attribute is automatically set to the handled\nexception.  An exception may be handled when an except or finally clause, or a with statement, is used.\n\nThis implicit exception context can be\nsupplemented with an explicit cause by using from with raise :\n\n```python\nraise new_exc from original_exc\n```python\n\nThe expression following from must be an exception or None . It\nwill be set as __cause__ on the raised exception. Setting __cause__ also implicitly sets the __suppress_context__ attribute to True , so that using raise new_exc from None effectively replaces the old exception with the new one for display\npurposes (e.g. converting KeyError to AttributeError ), while\nleaving the old exception available in __context__ for introspection\nwhen debugging.\n\nThe default traceback display code shows these chained exceptions in\naddition to the traceback for the exception itself. An explicitly chained\nexception in __cause__ is always shown when present. An implicitly\nchained exception in __context__ is shown only if __cause__ is None and __suppress_context__ is false.\n\nIn either case, the exception itself is always shown after any chained\nexceptions so that the final line of the traceback always shows the last\nexception that was raised.\n\n## Inheriting from built-in exceptions\u00c2\u00b6\n\nUser code can create subclasses that inherit from an exception type.\nIt\u00e2\u0080\u0099s recommended to only subclass one exception type at a time to avoid\nany possible conflicts between how the bases handle the args attribute, as well as due to possible memory layout incompatibilities.\n\nCPython implementation detail: Most built-in exceptions are implemented in C for efficiency, see: Objects/exceptions.c .  Some have custom memory layouts\nwhich makes it impossible to create a subclass that inherits from\nmultiple exception types. The memory layout of a type is an implementation\ndetail and might change between Python versions, leading to new\nconflicts in the future.  Therefore, it\u00e2\u0080\u0099s recommended to avoid\nsubclassing multiple exception types altogether.\n\n## Base classes\u00c2\u00b6\n\nThe following exceptions are used mostly as base classes for other exceptions.\n\nexception\nBaseException\n\u00c2\u00b6\nThe base class for all built-in exceptions.  It is not meant to be directly\ninherited by user-defined classes (for that, use Exception ).  If str() is called on an instance of this class, the representation of\nthe argument(s) to the instance are returned, or the empty string when\nthere were no arguments.\n\nargs\n\u00c2\u00b6\nThe tuple of arguments given to the exception constructor.  Some built-in\nexceptions (like OSError ) expect a certain number of arguments and\nassign a special meaning to the elements of this tuple, while others are\nusually called only with a single string giving an error message.\n\nwith_traceback\n(\ntb\n)\n\u00c2\u00b6\nThis method sets tb as the new traceback for the exception and returns\nthe exception object.  It was more commonly used before the exception\nchaining features of PEP 3134 became available.  The following example\nshows how we can convert an instance of SomeException into an\ninstance of OtherException while preserving the traceback.  Once\nraised, the current frame is pushed onto the traceback of the OtherException , as would have happened to the traceback of the\noriginal SomeException had we allowed it to propagate to the caller.\n\n```python\ntry:\n    ...\nexcept SomeException:\n    tb = sys.exception().__traceback__\n    raise OtherException(...).with_traceback(tb)\n```python\n\n__traceback__\n\u00c2\u00b6\nA writable field that holds the traceback object associated with this\nexception. See also: The raise statement .\n\nadd_note\n(\nnote\n)\n\u00c2\u00b6\nAdd the string note to the exception\u00e2\u0080\u0099s notes which appear in the standard\ntraceback after the exception string. A TypeError is raised if note is not a string.\n\nAdded in version 3.11.\n\n__notes__\n\u00c2\u00b6\nA list of the notes of this exception, which were added with add_note() .\nThis attribute is created when add_note() is called.\n\nAdded in version 3.11.\n\nexception\nException\n\u00c2\u00b6\nAll built-in, non-system-exiting exceptions are derived from this class.  All\nuser-defined exceptions should also be derived from this class.\n\nexception\nArithmeticError\n\u00c2\u00b6\nThe base class for those built-in exceptions that are raised for various\narithmetic errors: OverflowError , ZeroDivisionError , FloatingPointError .\n\nexception\nBufferError\n\u00c2\u00b6\nRaised when a buffer related operation cannot be\nperformed.\n\nexception\nLookupError\n\u00c2\u00b6\nThe base class for the exceptions that are raised when a key or index used on\na mapping or sequence is invalid: IndexError , KeyError .  This\ncan be raised directly by codecs.lookup() .\n\n## Concrete exceptions\u00c2\u00b6\n\nThe following exceptions are the exceptions that are usually raised.\n\nexception\nAssertionError\n\u00c2\u00b6\nRaised when an assert statement fails.\n\nexception\nAttributeError\n\u00c2\u00b6\nRaised when an attribute reference (see Attribute references ) or\nassignment fails.  (When an object does not support attribute references or\nattribute assignments at all, TypeError is raised.)\n\nThe optional name and obj keyword-only arguments\nset the corresponding attributes:\n\nname\n\u00c2\u00b6\nThe name of the attribute that was attempted to be accessed.\n\nobj\n\u00c2\u00b6\nThe object that was accessed for the named attribute.\n\nChanged in version 3.10: Added the name and obj attributes.\n\nexception\nEOFError\n\u00c2\u00b6\nRaised when the input() function hits an end-of-file condition (EOF)\nwithout reading any data. (Note: the io.IOBase.read() and io.IOBase.readline() methods return an empty string when they hit EOF.)\n\nexception\nFloatingPointError\n\u00c2\u00b6\nNot currently used.\n\nexception\nGeneratorExit\n\u00c2\u00b6\nRaised when a generator or coroutine is closed;\nsee generator.close() and coroutine.close() .  It\ndirectly inherits from BaseException instead of Exception since\nit is technically not an error.\n\nexception\nImportError\n\u00c2\u00b6\nRaised when the import statement has troubles trying to\nload a module.  Also raised when the \u00e2\u0080\u009cfrom list\u00e2\u0080\u009d in from ... import has a name that cannot be found.\n\nThe optional name and path keyword-only arguments\nset the corresponding attributes:\n\nname\n\u00c2\u00b6\nThe name of the module that was attempted to be imported.\n\npath\n\u00c2\u00b6\nThe path to any file which triggered the exception.\n\nChanged in version 3.3: Added the name and path attributes.\n\nexception\nModuleNotFoundError\n\u00c2\u00b6\nA subclass of ImportError which is raised by import when a module could not be located.  It is also raised when None is found in sys.modules .\n\nAdded in version 3.6.\n\nexception\nIndexError\n\u00c2\u00b6\nRaised when a sequence subscript is out of range.  (Slice indices are\nsilently truncated to fall in the allowed range; if an index is not an\ninteger, TypeError is raised.)\n\nexception\nKeyError\n\u00c2\u00b6\nRaised when a mapping (dictionary) key is not found in the set of existing keys.\n\nexception\nKeyboardInterrupt\n\u00c2\u00b6\nRaised when the user hits the interrupt key (normally Control - C or Delete ).  During execution, a check for interrupts is made\nregularly. The exception inherits from BaseException so as to not be\naccidentally caught by code that catches Exception and thus prevent\nthe interpreter from exiting.\n\nNote\n\nCatching a KeyboardInterrupt requires special consideration.\nBecause it can be raised at unpredictable points, it may, in some\ncircumstances, leave the running program in an inconsistent state. It is\ngenerally best to allow KeyboardInterrupt to end the program as\nquickly as possible or avoid raising it entirely. (See Note on Signal Handlers and Exceptions .)\n\nexception\nMemoryError\n\u00c2\u00b6\nRaised when an operation runs out of memory but the situation may still be\nrescued (by deleting some objects).  The associated value is a string indicating\nwhat kind of (internal) operation ran out of memory. Note that because of the\nunderlying memory management architecture (C\u00e2\u0080\u0099s malloc() function), the\ninterpreter may not always be able to completely recover from this situation; it\nnevertheless raises an exception so that a stack traceback can be printed, in\ncase a run-away program was the cause.\n\nexception\nNameError\n\u00c2\u00b6\nRaised when a local or global name is not found.  This applies only to\nunqualified names.  The associated value is an error message that includes the\nname that could not be found.\n\nThe optional name keyword-only argument sets the attribute:\n\nname\n\u00c2\u00b6\nThe name of the variable that was attempted to be accessed.\n\nChanged in version 3.10: Added the name attribute.\n\nexception\nNotImplementedError\n\u00c2\u00b6\nThis exception is derived from RuntimeError .  In user defined base\nclasses, abstract methods should raise this exception when they require\nderived classes to override the method, or while the class is being\ndeveloped to indicate that the real implementation still needs to be added.\n\nNote\n\nIt should not be used to indicate that an operator or method is not\nmeant to be supported at all \u00e2\u0080\u0093 in that case either leave the operator /\nmethod undefined or, if a subclass, set it to None .\n\nCaution\n\nNotImplementedError and NotImplemented are not\ninterchangeable. This exception should only be used as described\nabove; see NotImplemented for details on correct usage of\nthe built-in constant.\n\nexception\nOSError\n(\n[\narg\n]\n)\n\u00c2\u00b6\nexception\nOSError\n(\nerrno\n,\nstrerror\n[\n,\nfilename\n[\n,\nwinerror\n[\n,\nfilename2\n]\n]\n]\n)\nThis exception is raised when a system function returns a system-related\nerror, including I/O failures such as \u00e2\u0080\u009cfile not found\u00e2\u0080\u009d or \u00e2\u0080\u009cdisk full\u00e2\u0080\u009d\n(not for illegal argument types or other incidental errors).\n\nThe second form of the constructor sets the corresponding attributes,\ndescribed below.  The attributes default to None if not\nspecified.  For backwards compatibility, if three arguments are passed,\nthe args attribute contains only a 2-tuple\nof the first two constructor arguments.\n\nThe constructor often actually returns a subclass of OSError , as\ndescribed in OS exceptions below.  The particular subclass depends on\nthe final errno value.  This behaviour only occurs when\nconstructing OSError directly or via an alias, and is not\ninherited when subclassing.\n\nerrno\n\u00c2\u00b6\nA numeric error code from the C variable errno .\n\nwinerror\n\u00c2\u00b6\nUnder Windows, this gives you the native\nWindows error code.  The errno attribute is then an approximate\ntranslation, in POSIX terms, of that native error code.\n\nUnder Windows, if the winerror constructor argument is an integer,\nthe errno attribute is determined from the Windows error code,\nand the errno argument is ignored.  On other platforms, the winerror argument is ignored, and the winerror attribute\ndoes not exist.\n\nstrerror\n\u00c2\u00b6\nThe corresponding error message, as provided by\nthe operating system.  It is formatted by the C\nfunctions perror() under POSIX, and FormatMessage() under Windows.\n\nfilename\n\u00c2\u00b6\nfilename2\n\u00c2\u00b6\nFor exceptions that involve a file system path (such as open() or os.unlink() ), filename is the file name passed to the function.\nFor functions that involve two file system paths (such as os.rename() ), filename2 corresponds to the second\nfile name passed to the function.\n\nChanged in version 3.3: EnvironmentError , IOError , WindowsError , socket.error , select.error and mmap.error have been merged into OSError , and the\nconstructor may return a subclass.\n\nChanged in version 3.4: The filename attribute is now the original file name passed to\nthe function, instead of the name encoded to or decoded from the filesystem encoding and error handler . Also, the filename2 constructor argument and attribute was added.\n\nexception\nOverflowError\n\u00c2\u00b6\nRaised when the result of an arithmetic operation is too large to be\nrepresented.  This cannot occur for integers (which would rather raise MemoryError than give up).  However, for historical reasons,\nOverflowError is sometimes raised for integers that are outside a required\nrange.   Because of the lack of standardization of floating-point exception\nhandling in C, most floating-point operations are not checked.\n\nexception\nPythonFinalizationError\n\u00c2\u00b6\nThis exception is derived from RuntimeError .  It is raised when\nan operation is blocked during interpreter shutdown also known as Python finalization .\n\nExamples of operations which can be blocked with a PythonFinalizationError during the Python finalization:\n\n- Creating a new Python thread.\n- Joining a running daemon thread.\n- os.fork() .\n\nSee also the sys.is_finalizing() function.\n\nAdded in version 3.13: Previously, a plain RuntimeError was raised.\n\nChanged in version 3.14: threading.Thread.join() can now raise this exception.\n\nexception\nRecursionError\n\u00c2\u00b6\nThis exception is derived from RuntimeError .  It is raised when the\ninterpreter detects that the maximum recursion depth (see sys.getrecursionlimit() ) is exceeded.\n\nAdded in version 3.5: Previously, a plain RuntimeError was raised.\n\nexception\nReferenceError\n\u00c2\u00b6\nThis exception is raised when a weak reference proxy, created by the weakref.proxy() function, is used to access an attribute of the referent\nafter it has been garbage collected. For more information on weak references,\nsee the weakref module.\n\nexception\nRuntimeError\n\u00c2\u00b6\nRaised when an error is detected that doesn\u00e2\u0080\u0099t fall in any of the other\ncategories.  The associated value is a string indicating what precisely went\nwrong.\n\nexception\nStopIteration\n\u00c2\u00b6\nRaised by built-in function next() and an iterator 's __next__() method to signal that there are no further\nitems produced by the iterator.\n\nvalue\n\u00c2\u00b6\nThe exception object has a single attribute value , which is\ngiven as an argument when constructing the exception, and defaults\nto None .\n\nWhen a generator or coroutine function\nreturns, a new StopIteration instance is\nraised, and the value returned by the function is used as the value parameter to the constructor of the exception.\n\nIf a generator code directly or indirectly raises StopIteration ,\nit is converted into a RuntimeError (retaining the StopIteration as the new exception\u00e2\u0080\u0099s cause).\n\nChanged in version 3.3: Added value attribute and the ability for generator functions to\nuse it to return a value.\n\nChanged in version 3.5: Introduced the RuntimeError transformation via from __future__ import generator_stop , see PEP 479 .\n\nChanged in version 3.7: Enable PEP 479 for all code by default: a StopIteration error raised in a generator is transformed into a RuntimeError .\n\nexception\nStopAsyncIteration\n\u00c2\u00b6\nMust be raised by __anext__() method of an asynchronous iterator object to stop the iteration.\n\nAdded in version 3.5.\n\nexception\nSyntaxError\n(\nmessage\n,\ndetails\n)\n\u00c2\u00b6\nRaised when the parser encounters a syntax error.  This may occur in an import statement, in a call to the built-in functions compile() , exec() ,\nor eval() , or when reading the initial script or standard input\n(also interactively).\n\nThe str() of the exception instance returns only the error message.\nDetails is a tuple whose members are also available as separate attributes.\n\nfilename\n\u00c2\u00b6\nThe name of the file the syntax error occurred in.\n\nlineno\n\u00c2\u00b6\nWhich line number in the file the error occurred in. This is\n1-indexed: the first line in the file has a lineno of 1.\n\noffset\n\u00c2\u00b6\nThe column in the line where the error occurred. This is\n1-indexed: the first character in the line has an offset of 1.\n\ntext\n\u00c2\u00b6\nThe source code text involved in the error.\n\nend_lineno\n\u00c2\u00b6\nWhich line number in the file the error occurred ends in. This is\n1-indexed: the first line in the file has a lineno of 1.\n\nend_offset\n\u00c2\u00b6\nThe column in the end line where the error occurred finishes. This is\n1-indexed: the first character in the line has an offset of 1.\n\nFor errors in f-string fields, the message is prefixed by \u00e2\u0080\u009cf-string: \u00e2\u0080\u009d\nand the offsets are offsets in a text constructed from the replacement\nexpression.  For example, compiling f\u00e2\u0080\u0099Bad {a b} field\u00e2\u0080\u0099 results in this\nargs attribute: (\u00e2\u0080\u0098f-string: \u00e2\u0080\u00a6\u00e2\u0080\u0099, (\u00e2\u0080\u0098\u00e2\u0080\u0099, 1, 2, \u00e2\u0080\u0098(a b)n\u00e2\u0080\u0099, 1, 5)).\n\nChanged in version 3.10: Added the end_lineno and end_offset attributes.\n\nexception\nIndentationError\n\u00c2\u00b6\nBase class for syntax errors related to incorrect indentation.  This is a\nsubclass of SyntaxError .\n\nexception\nTabError\n\u00c2\u00b6\nRaised when indentation contains an inconsistent use of tabs and spaces.\nThis is a subclass of IndentationError .\n\nexception\nSystemError\n\u00c2\u00b6\nRaised when the interpreter finds an internal error, but the situation does not\nlook so serious to cause it to abandon all hope. The associated value is a\nstring indicating what went wrong (in low-level terms). In CPython ,\nthis could be raised by incorrectly using Python\u00e2\u0080\u0099s C API, such as returning\na NULL value without an exception set.\n\nIf you\u00e2\u0080\u0099re confident that this exception wasn\u00e2\u0080\u0099t your fault, or the fault of\na package you\u00e2\u0080\u0099re using, you should report this to the author or maintainer\nof your Python interpreter.\nBe sure to report the version of the Python interpreter ( sys.version ; it is\nalso printed at the start of an interactive Python session), the exact error\nmessage (the exception\u00e2\u0080\u0099s associated value) and if possible the source of the\nprogram that triggered the error.\n\nexception\nSystemExit\n\u00c2\u00b6\nThis exception is raised by the sys.exit() function.  It inherits from BaseException instead of Exception so that it is not accidentally\ncaught by code that catches Exception .  This allows the exception to\nproperly propagate up and cause the interpreter to exit.  When it is not\nhandled, the Python interpreter exits; no stack traceback is printed.  The\nconstructor accepts the same optional argument passed to sys.exit() .\nIf the value is an integer, it specifies the system exit status (passed to\nC\u00e2\u0080\u0099s exit() function); if it is None , the exit status is zero; if\nit has another type (such as a string), the object\u00e2\u0080\u0099s value is printed and\nthe exit status is one.\n\nA call to sys.exit() is translated into an exception so that clean-up\nhandlers ( finally clauses of try statements) can be\nexecuted, and so that a debugger can execute a script without running the risk\nof losing control.  The os._exit() function can be used if it is\nabsolutely positively necessary to exit immediately (for example, in the child\nprocess after a call to os.fork() ).\n\ncode\n\u00c2\u00b6\nThe exit status or error message that is passed to the constructor.\n(Defaults to None .)\n\nexception\nTypeError\n\u00c2\u00b6\nRaised when an operation or function is applied to an object of inappropriate\ntype.  The associated value is a string giving details about the type mismatch.\n\nThis exception may be raised by user code to indicate that an attempted\noperation on an object is not supported, and is not meant to be. If an object\nis meant to support a given operation but has not yet provided an\nimplementation, NotImplementedError is the proper exception to raise.\n\nPassing arguments of the wrong type (e.g. passing a list when an int is expected) should result in a TypeError , but passing\narguments with the wrong value (e.g. a number outside expected boundaries)\nshould result in a ValueError .\n\nexception\nUnboundLocalError\n\u00c2\u00b6\nRaised when a reference is made to a local variable in a function or method, but\nno value has been bound to that variable.  This is a subclass of NameError .\n\nexception\nUnicodeError\n\u00c2\u00b6\nRaised when a Unicode-related encoding or decoding error occurs.  It is a\nsubclass of ValueError .\n\nUnicodeError has attributes that describe the encoding or decoding\nerror.  For example, err.object[err.start:err.end] gives the particular\ninvalid input that the codec failed on.\n\nencoding\n\u00c2\u00b6\nThe name of the encoding that raised the error.\n\nreason\n\u00c2\u00b6\nA string describing the specific codec error.\n\nobject\n\u00c2\u00b6\nThe object the codec was attempting to encode or decode.\n\nstart\n\u00c2\u00b6\nThe first index of invalid data in object .\n\nThis value should not be negative as it is interpreted as an\nabsolute offset but this constraint is not enforced at runtime.\n\nend\n\u00c2\u00b6\nThe index after the last invalid data in object .\n\nThis value should not be negative as it is interpreted as an\nabsolute offset but this constraint is not enforced at runtime.\n\nexception\nUnicodeEncodeError\n\u00c2\u00b6\nRaised when a Unicode-related error occurs during encoding.  It is a subclass of UnicodeError .\n\nexception\nUnicodeDecodeError\n\u00c2\u00b6\nRaised when a Unicode-related error occurs during decoding.  It is a subclass of UnicodeError .\n\nexception\nUnicodeTranslateError\n\u00c2\u00b6\nRaised when a Unicode-related error occurs during translating.  It is a subclass\nof UnicodeError .\n\nexception\nValueError\n\u00c2\u00b6\nRaised when an operation or function receives an argument that has the\nright type but an inappropriate value, and the situation is not described by a\nmore precise exception such as IndexError .\n\nexception\nZeroDivisionError\n\u00c2\u00b6\nRaised when the second argument of a division or modulo operation is zero.  The\nassociated value is a string indicating the type of the operands and the\noperation.\n\nThe following exceptions are kept for compatibility with previous versions;\nstarting from Python 3.3, they are aliases of OSError .\n\nexception\nEnvironmentError\n\u00c2\u00b6\nexception\nIOError\n\u00c2\u00b6\nexception\nWindowsError\n\u00c2\u00b6\nOnly available on Windows.\n\n### OS exceptions\u00c2\u00b6\n\nThe following exceptions are subclasses of OSError , they get raised\ndepending on the system error code.\n\nexception\nBlockingIOError\n\u00c2\u00b6\nRaised when an operation would block on an object (e.g. socket) set\nfor non-blocking operation.\nCorresponds to errno EAGAIN , EALREADY , EWOULDBLOCK and EINPROGRESS .\n\nIn addition to those of OSError , BlockingIOError can have\none more attribute:\n\ncharacters_written\n\u00c2\u00b6\nAn integer containing the number of bytes written to the stream\nbefore it blocked. This attribute is available when using the\nbuffered I/O classes from the io module.\n\nexception\nChildProcessError\n\u00c2\u00b6\nRaised when an operation on a child process failed.\nCorresponds to errno ECHILD .\n\nexception\nConnectionError\n\u00c2\u00b6\nA base class for connection-related issues.\n\nSubclasses are BrokenPipeError , ConnectionAbortedError , ConnectionRefusedError and ConnectionResetError .\n\nexception\nBrokenPipeError\n\u00c2\u00b6\nA subclass of ConnectionError , raised when trying to write on a\npipe while the other end has been closed, or trying to write on a socket\nwhich has been shutdown for writing.\nCorresponds to errno EPIPE and ESHUTDOWN .\n\nexception\nConnectionAbortedError\n\u00c2\u00b6\nA subclass of ConnectionError , raised when a connection attempt\nis aborted by the peer.\nCorresponds to errno ECONNABORTED .\n\nexception\nConnectionRefusedError\n\u00c2\u00b6\nA subclass of ConnectionError , raised when a connection attempt\nis refused by the peer.\nCorresponds to errno ECONNREFUSED .\n\nexception\nConnectionResetError\n\u00c2\u00b6\nA subclass of ConnectionError , raised when a connection is\nreset by the peer.\nCorresponds to errno ECONNRESET .\n\nexception\nFileExistsError\n\u00c2\u00b6\nRaised when trying to create a file or directory which already exists.\nCorresponds to errno EEXIST .\n\nexception\nFileNotFoundError\n\u00c2\u00b6\nRaised when a file or directory is requested but doesn\u00e2\u0080\u0099t exist.\nCorresponds to errno ENOENT .\n\nexception\nInterruptedError\n\u00c2\u00b6\nRaised when a system call is interrupted by an incoming signal.\nCorresponds to errno EINTR .\n\nChanged in version 3.5: Python now retries system calls when a syscall is interrupted by a\nsignal, except if the signal handler raises an exception (see PEP 475 for the rationale), instead of raising InterruptedError .\n\nexception\nIsADirectoryError\n\u00c2\u00b6\nRaised when a file operation (such as os.remove() ) is requested\non a directory.\nCorresponds to errno EISDIR .\n\nexception\nNotADirectoryError\n\u00c2\u00b6\nRaised when a directory operation (such as os.listdir() ) is requested on\nsomething which is not a directory.  On most POSIX platforms, it may also be\nraised if an operation attempts to open or traverse a non-directory file as if\nit were a directory.\nCorresponds to errno ENOTDIR .\n\nexception\nPermissionError\n\u00c2\u00b6\nRaised when trying to run an operation without the adequate access\nrights - for example filesystem permissions.\nCorresponds to errno EACCES , EPERM , and ENOTCAPABLE .\n\nChanged in version 3.11.1: WASI\u00e2\u0080\u0099s ENOTCAPABLE is now mapped to PermissionError .\n\nexception\nProcessLookupError\n\u00c2\u00b6\nRaised when a given process doesn\u00e2\u0080\u0099t exist.\nCorresponds to errno ESRCH .\n\nexception\nTimeoutError\n\u00c2\u00b6\nRaised when a system function timed out at the system level.\nCorresponds to errno ETIMEDOUT .\n\nAdded in version 3.3: All the above OSError subclasses were added.\n\nSee also\n\nPEP 3151 - Reworking the OS and IO exception hierarchy\n\n## Warnings\u00c2\u00b6\n\nThe following exceptions are used as warning categories; see the Warning Categories documentation for more details.\n\nexception\nWarning\n\u00c2\u00b6\nBase class for warning categories.\n\nexception\nUserWarning\n\u00c2\u00b6\nBase class for warnings generated by user code.\n\nexception\nDeprecationWarning\n\u00c2\u00b6\nBase class for warnings about deprecated features when those warnings are\nintended for other Python developers.\n\nIgnored by the default warning filters, except in the __main__ module\n( PEP 565 ). Enabling the Python Development Mode shows\nthis warning.\n\nThe deprecation policy is described in PEP 387 .\n\nexception\nPendingDeprecationWarning\n\u00c2\u00b6\nBase class for warnings about features which are obsolete and\nexpected to be deprecated in the future, but are not deprecated\nat the moment.\n\nThis class is rarely used as emitting a warning about a possible\nupcoming deprecation is unusual, and DeprecationWarning is preferred for already active deprecations.\n\nIgnored by the default warning filters. Enabling the Python\nDevelopment Mode shows this warning.\n\nThe deprecation policy is described in PEP 387 .\n\nexception\nSyntaxWarning\n\u00c2\u00b6\nBase class for warnings about dubious syntax.\n\nThis warning is typically emitted when compiling Python source code, and usually won\u00e2\u0080\u0099t be reported\nwhen running already compiled code.\n\nexception\nRuntimeWarning\n\u00c2\u00b6\nBase class for warnings about dubious runtime behavior.\n\nexception\nFutureWarning\n\u00c2\u00b6\nBase class for warnings about deprecated features when those warnings are\nintended for end users of applications that are written in Python.\n\nexception\nImportWarning\n\u00c2\u00b6\nBase class for warnings about probable mistakes in module imports.\n\nIgnored by the default warning filters. Enabling the Python\nDevelopment Mode shows this warning.\n\nexception\nUnicodeWarning\n\u00c2\u00b6\nBase class for warnings related to Unicode.\n\nexception\nEncodingWarning\n\u00c2\u00b6\nBase class for warnings related to encodings.\n\nSee Opt-in EncodingWarning for details.\n\nAdded in version 3.10.\n\nexception\nBytesWarning\n\u00c2\u00b6\nBase class for warnings related to bytes and bytearray .\n\nexception\nResourceWarning\n\u00c2\u00b6\nBase class for warnings related to resource usage.\n\nIgnored by the default warning filters. Enabling the Python\nDevelopment Mode shows this warning.\n\nAdded in version 3.2.\n\n## Exception groups\u00c2\u00b6\n\nThe following are used when it is necessary to raise multiple unrelated\nexceptions. They are part of the exception hierarchy so they can be\nhandled with except like all other exceptions. In addition,\nthey are recognised by except* , which matches\ntheir subgroups based on the types of the contained exceptions.\n\nexception\nExceptionGroup\n(\nmsg\n,\nexcs\n)\n\u00c2\u00b6\nexception\nBaseExceptionGroup\n(\nmsg\n,\nexcs\n)\n\u00c2\u00b6\nBoth of these exception types wrap the exceptions in the sequence excs .\nThe msg parameter must be a string. The difference between the two\nclasses is that BaseExceptionGroup extends BaseException and\nit can wrap any exception, while ExceptionGroup extends Exception and it can only wrap subclasses of Exception . This design is so that except Exception catches an ExceptionGroup but not BaseExceptionGroup .\n\nThe BaseExceptionGroup constructor returns an ExceptionGroup rather than a BaseExceptionGroup if all contained exceptions are Exception instances, so it can be used to make the selection\nautomatic. The ExceptionGroup constructor, on the other hand,\nraises a TypeError if any contained exception is not an Exception subclass.\n\nmessage\n\u00c2\u00b6\nThe msg argument to the constructor. This is a read-only attribute.\n\nexceptions\n\u00c2\u00b6\nA tuple of the exceptions in the excs sequence given to the\nconstructor. This is a read-only attribute.\n\nsubgroup\n(\ncondition\n)\n\u00c2\u00b6\nReturns an exception group that contains only the exceptions from the\ncurrent group that match condition , or None if the result is empty.\n\nThe condition can be an exception type or tuple of exception types, in which\ncase each exception is checked for a match using the same check that is used\nin an except clause.  The condition can also be a callable (other than\na type object) that accepts an exception as its single argument and returns\ntrue for the exceptions that should be in the subgroup.\n\nThe nesting structure of the current exception is preserved in the result,\nas are the values of its message , __traceback__ , __cause__ , __context__ and __notes__ fields.\nEmpty nested groups are omitted from the result.\n\nThe condition is checked for all exceptions in the nested exception group,\nincluding the top-level and any nested exception groups. If the condition is\ntrue for such an exception group, it is included in the result in full.\n\nAdded in version 3.13: condition can be any callable which is not a type object.\n\nsplit\n(\ncondition\n)\n\u00c2\u00b6\nLike subgroup() , but returns the pair (match, rest) where match is subgroup(condition) and rest is the remaining non-matching\npart.\n\nderive\n(\nexcs\n)\n\u00c2\u00b6\nReturns an exception group with the same message , but which\nwraps the exceptions in excs .\n\nThis method is used by subgroup() and split() , which\nare used in various contexts to break up an exception group. A\nsubclass needs to override it in order to make subgroup() and split() return instances of the subclass rather\nthan ExceptionGroup .\n\nsubgroup() and split() copy the __traceback__ , __cause__ , __context__ and __notes__ fields from\nthe original exception group to the one returned by derive() , so\nthese fields do not need to be updated by derive() .\n\n```python\n>>> class MyGroup(ExceptionGroup):\n...     def derive(self, excs):\n...         return MyGroup(self.message, excs)\n...\n>>> e = MyGroup(\"eg\", [ValueError(1), TypeError(2)])\n>>> e.add_note(\"a note\")\n>>> e.__context__ = Exception(\"context\")\n>>> e.__cause__ = Exception(\"cause\")\n>>> try:\n...    raise e\n... except Exception as e:\n...    exc = e\n...\n>>> match, rest = exc.split(ValueError)\n>>> exc, exc.__context__, exc.__cause__, exc.__notes__\n(MyGroup('eg', [ValueError(1), TypeError(2)]), Exception('context'), Exception('cause'), ['a note'])\n>>> match, match.__context__, match.__cause__, match.__notes__\n(MyGroup('eg', [ValueError(1)]), Exception('context'), Exception('cause'), ['a note'])\n>>> rest, rest.__context__, rest.__cause__, rest.__notes__\n(MyGroup('eg', [TypeError(2)]), Exception('context'), Exception('cause'), ['a note'])\n>>> exc.__traceback__ is match.__traceback__ is rest.__traceback__\nTrue\n```python\n\nNote that BaseExceptionGroup defines __new__() , so\nsubclasses that need a different constructor signature need to\noverride that rather than __init__() . For example, the following\ndefines an exception group subclass which accepts an exit_code and\nconstructs the group\u00e2\u0080\u0099s message from it.\n\n```python\nclass Errors(ExceptionGroup):\n   def __new__(cls, errors, exit_code):\n      self = super().__new__(Errors, f\"exit code: {exit_code}\", errors)\n      self.exit_code = exit_code\n      return self\n\n   def derive(self, excs):\n      return Errors(excs, self.exit_code)\n```python\n\nLike ExceptionGroup , any subclass of BaseExceptionGroup which\nis also a subclass of Exception can only wrap instances of Exception .\n\nAdded in version 3.11.\n\n## Exception hierarchy\u00c2\u00b6\n\nThe class hierarchy for built-in exceptions is:\n\n```python\nBaseException\n \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 BaseExceptionGroup\n \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 GeneratorExit\n \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 KeyboardInterrupt\n \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 SystemExit\n \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 Exception\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 ArithmeticError\n      \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 FloatingPointError\n      \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 OverflowError\n      \u00e2\u0094\u0082    \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 ZeroDivisionError\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 AssertionError\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 AttributeError\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 BufferError\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 EOFError\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 ExceptionGroup [BaseExceptionGroup]\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 ImportError\n      \u00e2\u0094\u0082    \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 ModuleNotFoundError\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 LookupError\n      \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 IndexError\n      \u00e2\u0094\u0082    \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 KeyError\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 MemoryError\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 NameError\n      \u00e2\u0094\u0082    \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 UnboundLocalError\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 OSError\n      \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 BlockingIOError\n      \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 ChildProcessError\n      \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 ConnectionError\n      \u00e2\u0094\u0082    \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 BrokenPipeError\n      \u00e2\u0094\u0082    \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 ConnectionAbortedError\n      \u00e2\u0094\u0082    \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 ConnectionRefusedError\n      \u00e2\u0094\u0082    \u00e2\u0094\u0082    \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 ConnectionResetError\n      \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 FileExistsError\n      \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 FileNotFoundError\n      \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 InterruptedError\n      \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 IsADirectoryError\n      \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 NotADirectoryError\n      \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 PermissionError\n      \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 ProcessLookupError\n      \u00e2\u0094\u0082    \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 TimeoutError\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 ReferenceError\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 RuntimeError\n      \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 NotImplementedError\n      \u00e2\u0094\u0082    \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 PythonFinalizationError\n      \u00e2\u0094\u0082    \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 RecursionError\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 StopAsyncIteration\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 StopIteration\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 SyntaxError\n      \u00e2\u0094\u0082    \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 IndentationError\n      \u00e2\u0094\u0082         \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 TabError\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 SystemError\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 TypeError\n      \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 ValueError\n      \u00e2\u0094\u0082    \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 UnicodeError\n      \u00e2\u0094\u0082         \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 UnicodeDecodeError\n      \u00e2\u0094\u0082         \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 UnicodeEncodeError\n      \u00e2\u0094\u0082         \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 UnicodeTranslateError\n      \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 Warning\n           \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 BytesWarning\n           \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 DeprecationWarning\n           \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 EncodingWarning\n           \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 FutureWarning\n           \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 ImportWarning\n           \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 PendingDeprecationWarning\n           \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 ResourceWarning\n           \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 RuntimeWarning\n           \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 SyntaxWarning\n           \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 UnicodeWarning\n           \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 UserWarning\n```",
  "difficulty": "intro",
  "doc_id": "doc-built-in-exceptions-2d19674db7",
  "provenance": {
    "author": "",
    "date": "",
    "license": "PSF Documentation License",
    "source_file": "data/corpus_raw/3_library_exceptions_html_ad80a0.json",
    "url": "https://docs.python.org/3/library/exceptions.html"
  },
  "title": "Built-in Exceptions\u00c2\u00b6",
  "type": "tutorial"
}