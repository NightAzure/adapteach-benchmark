{
  "ai_generated": false,
  "concept_tags": [
    "assignment-expression",
    "conditionals",
    "parsing",
    "readability",
    "walrus",
    "while"
  ],
  "content": "Hard-level conditional code often tries to balance readability with avoiding repeated work. Python\u2019s **assignment expression** operator `:=` (sometimes called the \u201cwalrus operator\u201d) helps when you want to compute a value once and use it immediately in an `if` or `while`.\n\n---\n## 1) The basic idea\nInstead of computing something twice:\n\n```python\ns = \" 42 \"\nif s.strip().isdigit():\n    n = int(s.strip())\n    print(n)\n```python\n\nYou can compute once and reuse:\n\n```python\ns = \" 42 \"\nif (t := s.strip()).isdigit():\n    n = int(t)\n    print(n)\n```python\n\n---\n## 2) While loops with assignment expressions (read/process pattern)\nA classic use is reading items until a sentinel.\n\n```python\n# conceptually similar to: line = input(); while line != \"\": ...; line = input()\nlines = [\"a\", \"bb\", \"\", \"ccc\"]\ni = 0\n\nwhile (line := lines[i]) != \"\":\n    print(\"got\", line)\n    i += 1\n```python\n\n---\n## 3) Avoid repeated expensive work\n\n```python\nimport time\n\ndef expensive(x):\n    time.sleep(0.05)\n    return x * 2\n\nx = 10\n\n# without := you'd likely call expensive(x) twice if you need the value\nif (y := expensive(x)) > 10:\n    print(\"big\", y)\nelse:\n    print(\"small\", y)\n```python\n\n---\n## 4) Parsing with := in a readable way\n\n```python\ntext = \"key=value\"\nif (parts := text.split(\"=\", 1)) and len(parts) == 2:\n    k, v = parts\n    print(k, v)\n```python\n\n---\n## 5) A larger example: parse numeric tokens with a single pass\n\n```python\ndata = [\"10\", \"x\", \"5\", \"-\", \"7\", \" 3 \"]\nnums = []\n\nfor raw in data:\n    if (t := raw.strip()).isdigit():\n        nums.append(int(t))\n\nprint(nums)\nprint(\"sum\", sum(nums))\nprint(\"max\", max(nums) if nums else None)\n```python\n\n---\n## 6) Practical guidance\n- Use `:=` when it **removes repetition** and stays readable.\n- If it makes the condition too dense, compute the value on a separate line.",
  "difficulty": "hard",
  "doc_id": "doc-assignment-expressions-in-conditionals-compact-patterns-without-losing-clarity-2c1f405af6",
  "provenance": {
    "author": "",
    "date": "",
    "license": "Public domain (PEP text)",
    "source_file": "data/corpus_raw/conditionals_hard_1.json",
    "url": "https://peps.python.org/pep-0572/"
  },
  "title": "Assignment expressions (:=) in conditionals: compact patterns without losing clarity",
  "type": "reference"
}